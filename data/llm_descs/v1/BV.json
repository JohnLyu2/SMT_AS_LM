[
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_15.smt2",
    "description": "The file encodes a quantified bit‑vector linear‑arithmetic formula over three 32‑bit variables ( x1, y2, y3 ). It contains four alternating quantifier blocks (∀ y3 … ∧ ∃ y2 ∀ y3 … ∧ ∃ y2 …) whose bodies are conjunctions of linear equalities and inequalities built from constants, additions, and multiplications by constants, together with a few Boolean combinations. The overall check asks whether there exists a value for x1 (and the existential witnesses) such that all universally quantified constraints hold, i.e., it is a satisfiability/emptiness test for a non‑convex polyhedral region expressed in BV arithmetic, featuring a relatively deep term structure (depth 13) and multiple quantifier alternations that make it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_13.smt2",
    "description": "This instance asks whether a quantified Boolean‑combination of linear 32‑bit signed‑integer constraints is satisfiable.  The formula consists of several nested `forall/exists` blocks that relate the free variable `x1` with quantified variables (`y3…y6`) through many affine expressions built with `bvadd`, `bvmul`, and comparisons such as `bvsle`, `bvsge`, `bvsgt` and `bvslt`.  It thus encodes a SAT problem over a non‑convex polyhedral region expressed in bit‑vector arithmetic, and its difficulty stems from the deep term structure (depth ≈ 20) and multiple quantifier alternations (four nested `forall`/`exists` levels) together with a large number of arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_16.smt2",
    "description": "The file encodes a single quantified bit‑vector formula over 32‑bit variables (one free variable x1 and six declared y‑variables) that consists of a large disjunction of conjunctive blocks, each containing several alternating ∀/∃ quantifiers. Inside the quantifier scopes the constraints are linear signed inequalities and equalities built from constant‑multiplied sums (e.g., bvadd, bvmul, bvneg) such as bvslt(bvadd(bvmul(c₁, ?yₖ), …, bvmul(c₂, x1)), c₃), so the problem amounts to checking whether there exists an assignment to the free variables (and the quantified ones) satisfying this non‑convex system of linear constraints. The instance is deliberately hard: it features many quantifier alternations (35 ∀, 19 ∃), a high term‑depth (24), and a large number of arithmetic operations (≈ 278 multiplications), making it a strenuous benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_30.smt2",
    "description": "The benchmark asks whether there exists a 32‑bit value x₁ such that, for every choice of a 32‑bit y₁, there are 32‑bit witnesses y₂ and y₃ (and further alternating ∀/∃ blocks) satisfying a large conjunction of signed linear inequalities, disequalities and equalities built from bvadd, bvmul with constant coefficients and the comparators bvslt, bvsle, bvsge, bvsgt.  All constraints are pure linear bit‑vector arithmetic, but the formula contains several quantifier alternations, deep term nesting (depth 18) and hundreds of arithmetic terms, making it a difficult quantified‑BV verification‑style instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_24.smt2",
    "description": "The file asserts a single quantified formula over four 32‑bit bit‑vectors (x1, y1, y2, y3) that combines hundreds of linear bit‑vector constraints (addition, multiplication, signed comparisons) with deep nesting of existential and universal quantifiers (up to three alternating levels) and a maximal term depth of 20. The problem is to decide the satisfiability of this heavily quantified, arithmetic‑rich BV formula, which originates from encoding redundancy checks for non‑convex polyhedral representations and is therefore a challenging quantified‑BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_6.smt2",
    "description": "The file encodes a single quantified bit‑vector satisfiability query over 32‑bit words.  It asks whether there exists a value for the free variable `x1` (and the other declared constants `y1…y6`) such that a massive Boolean combination of linear constraints – built from `bvadd`, `bvmul` with constant coefficients and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) – holds under a pattern of alternating quantifiers (`∃…∀…∃…`).  The formula represents a highly non‑convex, quantified linear‑arithmetic problem, typical of benchmarks used to stress SMT solvers’ handling of quantified BV arithmetic and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_14.smt2",
    "description": "The file encodes a single quantified satisfiability query over 32‑bit bit‑vectors that models a non‑convex polyhedron described by a large set of linear constraints (scaled by constants via `bvmul` and combined with `bvadd`). The top‑level assertion is a Boolean combination of inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) under ten universal quantifiers and seven existential quantifiers, together with several auxiliary equalities, thus checking whether there exists an assignment to the free variables `x1`, `y1`, `y3`, `y4` that satisfies all those quantified linear conditions. The heavy use of nested quantifiers, deep term nesting (depth 18), and many arithmetic literals makes the instance a difficult QF_BV‑with‑quantifiers benchmark aimed at testing redundancy detection and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_25.smt2",
    "description": "The instance asks whether the 32‑bit variables x1, y1…y6 can satisfy a single, highly nested quantified formula that consists of many linear bit‑vector constraints (signed additions, constant multiplications, and comparisons). It mixes alternating ∃ and ∀ blocks (22 ∀ and 23 ∃ quantifiers) with deep term nesting (depth 24) and a large number of linear terms, effectively encoding a non‑convex polyhedral feasibility problem in the BV logic. The heavy use of quantifier alternations and dozens of linear inequalities makes the satisfiability check challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_23.smt2",
    "description": "The benchmark encodes a quantified bit‑vector problem over 32‑bit signed integers that consists of a large conjunction of affine equalities and inequalities (linear combinations built with constant multiplications, additions and signed comparisons). It asks whether there exist three auxiliary vectors ( ?y1, ?y2, ?y3 ) such that, for all values of a fourth vector ( ?y3 ) and under a further existential choice of another ?y3, all of the listed constraints involving the declared constants x1, y1, y2, y3 are simultaneously satisfied. This results in a highly constrained Σ₂‑type formula with deep term nesting (depth 19) and many linear‑BV operations, representative of the redundancy‑removal task for non‑convex polyhedral representations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_4.smt2",
    "description": "The instance encodes a quantified bit‑vector satisfiability problem that models a set of linear constraints (multiplications by constants, additions, and comparisons) over a single free variable `x1` and several universally‑ and existentially‑quantified auxiliary variables (`?y1`, `?y2`, `?y3`).  It asks whether there exists an assignment to `x1` such that a complex Boolean combination of inequalities (signed less‑than, less‑or‑equal, greater‑or‑equal) and equalities holds for all/there‑exists choices of the quantified variables.  The formula features multiple quantifier alternations and deep nested arithmetic terms (depth 13), making it a challenging benchmark for BV solvers’ quantifier‑instantiation and interpolation capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_2.smt2",
    "description": "The file encodes a quantified satisfiability problem over 32‑bit bit‑vectors, consisting of a single massive conjunction of linear (affine) inequalities and equalities built from additions, multiplications by constant coefficients, and negations. It mixes many alternating blocks of existential and universal quantifiers (13 ∃, 11 ∀) and deep term nesting (depth 15), thereby testing a solver’s ability to handle quantified bit‑vector arithmetic—originally derived from a reduction of redundant linear‑constraint detection in non‑convex polyhedra. The goal is to decide whether there exists a valuation for the free constants x1, y1…y4 that satisfies all the quantified constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_1.smt2",
    "description": "The instance asks whether there exists a 32‑bit value x₁ such that a large disjunction of quantified linear bit‑vector constraints is satisfied. The first disjunct contains an ∃y₁ ∀y₂ ∀y₃ pattern with signed‑less‑than/greater‑than inequalities and an equality built from constant‑coefficient multiplications and additions; the second disjunct mixes ∀y₂ and several ∃y‑quantifiers with similar linear (in)equalities and equalities. Thus the problem is a quantified BV‑SAT/check of a non‑convex polyhedral description encoded as bit‑vector arithmetic. Its difficulty stems from multiple quantifier alternations (∃∀∀ and interleaved ∀/∃), a relatively deep term structure (depth 13), and a high density of constant‑scaled multiplications, making it a challenging case for interpolation‑based or quantifier‑instantiation solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_21.smt2",
    "description": "The file encodes a quantified bit‑vector formula that models a system of signed‑linear constraints over 32‑bit variables (the declared constants y1…y6 and x1).  The single top‑level assertion is an ∃/∀ alternation of the form “there exist values for some variables such that, for all choices of the remaining variables, a large conjunction of linear inequalities (bvsge, bvsle, bvsgt, bvslt) and disequalities holds”, i.e. a feasibility/emptiness check for a non‑convex polyhedral representation.  The instance is hard for solvers because it contains many quantified alternations (74 ∃ and 54 ∀), a high number of arithmetic terms (≈ 900 multiplications, 680 additions) and a maximal term depth of 24, leading to deep nesting of linear expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_11.smt2",
    "description": "This instance encodes a quantified bit‑vector formula that represents a system of linear (affine) inequalities over 32‑bit variables x1, y1…y4.  It mixes existential and universal quantifiers (16 ∃, 17 ∀) to express that a certain non‑convex polyhedral region (defined by many coefficient‑weighted sums, multiplications and comparisons) is non‑empty, and the solver must decide SAT/UNSAT for the free variable x1.  The benchmark is challenging due to numerous quantifier alternations, deep term nesting (depth 18), and a high density of bvmul/bvadd operations (over 150 multiplications), which together stress both quantifier handling and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_26.smt2",
    "description": "This benchmark encodes a quantified linear‑arithmetic property over 32‑bit vectors that originates from the “redundant‑constraint detection in non‑convex polyhedra’’ setting: it asks whether there exists a concrete assignment to the main variable x1 (and some auxiliary y‑variables) such that a large collection of linear inequalities (built from bvadd, bvmul, bvneg and signed comparisons) holds for all possible values of the quantified y‑variables, with several alternating ∀/∃ blocks. The formula is a single SAT‑check of a deep (term‑depth 26) quantified BV expression, featuring 796 multiplications, many quantifier alternations (50 ∀, 32 ∃) and a dense mix of conjunctions, disjunctions and inequalities, making it a demanding test of a solver’s ability to handle quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_22.smt2",
    "description": "The instance encodes a single massive quantified constraint over five 32‑bit signed variables (x1, y1…y4). It consists of a tangled mix of existential and universal quantifiers that assert dozens of linear (in)equalities and equalities built from constant‑scaled additions and subtractions (bvmul with literals, bvadd, bvneg) – essentially a non‑convex polyhedral feasibility problem expressed in bit‑vector arithmetic. The formula features deep term nesting (depth 21), a high count of arithmetic operators (≈ 500 multiplications, 300 additions) and multiple quantifier alternations (26 ∃, 22 ∀), making it a difficult SAT/SMT challenge that tests a solver’s ability to handle quantified linear arithmetic on 32‑bit bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_36.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that encodes a large system of linear constraints (constant‑multiplications, additions, and signed inequalities) over seven 32‑bit variables x1, y1…y6. It asks whether there exists an assignment to these variables such that a complex mix of universally and existentially quantified conditions—representing the feasibility of a non‑convex polyhedral region—holds, i.e., whether the quantified BV formula is SAT. The formula features deep term nesting (depth 27) and many quantifier alternations (66 ∀, 62 ∃), making it a challenging QBV‑SAT instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_19.smt2",
    "description": "The file encodes a single quantified bit‑vector formula over seven 32‑bit variables ( x1, y1…y6 ) that consists of a large conjunction of linear arithmetic constraints: each clause is a (in)equation built from constant‑multiples of the variables added together and compared with other constant‑multiples using signed ≤, ≥, <, > or equality, and the clauses are combined with nested Boolean disjunctions.  The formula features many alternating quantifiers (23 ∃‑blocks and 19 ∀‑blocks), deep arithmetic terms (max depth 22) and a high count of elementary operations (≈ 280 bvmul, 224 bvadd), making it a stress test for solvers’ quantifier handling and interpolation on quantified linear‑integer (bit‑vector) constraints.  It originates from a reduction of redundant‑constraint detection in non‑convex polyhedra, but here is used as a random benchmark for the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_23.smt2",
    "description": "The file encodes a quantified bit‑vector verification problem: it asserts that for every 32‑bit value y₃ there must exist a 32‑bit value y₄ (with a free 32‑bit constant x₁) such that a huge disjunction of signed linear inequalities/equalities—each built from constant‑multiplied terms, additions and negations—is satisfied. The formula features a single ∀ y₃ ∃ y₄ quantifier alternation, a deep term nesting (depth 17), and over 200 bvmul occurrences, turning the check into a challenging instance of quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_28.smt2",
    "description": "The instance asks the solver to decide the satisfiability of a single, highly quantified bit‑vector formula that mixes many existential and universal quantifiers over 32‑bit variables (y1…y6, x1) and a large conjunction of linear arithmetic constraints (inequalities, equalities, and non‑zero tests) built from `bvadd`, `bvmul`, and `bvneg`.  In effect it encodes a feasibility check for a system of linear constraints that model a non‑convex polyhedral region, a typical task in redundancy‑removal and Craig‑interpolation research.  The problem is difficult because it contains numerous quantifier alternations, deep term nesting (depth ≈ 26), and hundreds of arithmetic operations, leading to a very large and combinatorial search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_14.smt2",
    "description": "The instance is a quantified bit‑vector formula that asks whether there exists a 32‑bit value `x1` together with unconstrained 32‑bit parameters `y1…y6` such that a large collection of linear (multiply‑by‑constant, add, compare) constraints holds for all possible choices of the universally‑quantified `y` variables.  The constraints consist of mixed equalities and strict/non‑strict inequalities, forming a non‑convex polyhedral region expressed in BV arithmetic; the problem therefore amounts to checking the satisfiability of a quantified linear‑arithmetic conjunction.  The formula features many alternating ∀/∃ blocks (≈ 3 quantifier alternations), deep term nesting (depth 21) and a high count of multiplication and addition terms, making it a challenging benchmark for solvers that handle quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_40.smt2",
    "description": "The file encodes a single, highly quantified bit‑vector formula that asks whether there exist 32‑bit values for the variables x₁, y₁,…, y₆ such that a huge conjunction of linear inequalities ( bvsge, bvsle, bvslt, bvsgt ) and equalities involving many constant‑scaled multiplications ( bvmul ) holds.  Structurally it is a ∀∃∀∃… chain of quantifiers (about four alternations) with deep term nesting (depth 27) and thousands of arithmetic terms, representing a satisfiability/verification problem derived from the redundant‑constraint removal benchmark for non‑convex polyhedra.  The instance therefore tests a solver’s ability to handle large, alternating‑quantifier BV arithmetic and to decide the existence of a solution to this intricate system of linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_30.smt2",
    "description": "The instance is a quantified satisfiability query over 32‑bit bit‑vectors.  Six free variables (`x1`, `y2`, `y3`, `y4`, `y5`, `y6`) appear inside a single massive assertion that combines many universally‑ and existentially‑quantified sub‑formulas.  Each sub‑formula is a linear arithmetic constraint of the form  \n`c1·?v1 + c2·?v2 + … + c·x1  ⪯  c0` (or equality), where the coefficients are small integer constants encoded as bit‑vectors.  The overall formula is a deep Boolean combination of `or`, `and`, and `not` over these linear constraints, with alternating blocks of `forall` and `exists` (21 universal, 24 existential quantifiers) and a maximum term depth of 22.  \n\nThus the problem is a pure‑BV quantifier‑alternation SAT check that tests the solver’s ability to handle large numbers of linear bit‑vector constraints, many quantifier alternations, and high term depth.  It is a typical “random” benchmark used to evaluate detection of redundant linear constraints and the scalability of quantifier reasoning in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_12.smt2",
    "description": "The file encodes a single quantified bit‑vector formula in the BV logic, asking whether there exist 32‑bit values for the free constants x1, y1, y2, y3 that satisfy a large conjunction of linear (constant‑multiplied) inequalities and equalities, together with several alternating ∃/∀ sub‑formulas.  The constraints are purely linear (multiplication only by concrete constants) but are heavily nested, featuring eight universal quantifiers and twelve existential quantifiers, a maximal term depth of 15, and more than a hundred arithmetic operations, which makes the satisfiability problem challenging for quantifier‑handling procedures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_13.smt2",
    "description": "The instance encodes a quantified bit‑vector feasibility problem: four 32‑bit variables ( y1, y2, y3, x1 ) are constrained by a large conjunction of linear (affine) equalities and signed inequalities, all expressed with `bvadd`, `bvmul` by constant coefficients and signed comparisons (`bvsle`, `bvsge`, `bvsgt`, `bvslt`). The formula has a quantifier pattern ∃y1 ∃y2 ( ∀y3 … ∧ … ∧ ∃y3 …) and thus mixes existential and universal quantifiers over the same numeric domain, creating a non‑convex polyhedral region that must be checked for satisfiability. The problem is challenging for solvers because of the deep term nesting (depth 15), a high number of constant multiplications (57) and the need to reason about quantified linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_15.smt2",
    "description": "The file encodes a single quantified satisfiability query in the BV logic: it asks whether there exists a 32‑bit value for the free variable `x1` such that a large conjunction of linear bit‑vector constraints (built from `bvadd`, `bvmul`, and `bvneg`) holds for many alternations of existentially‑ and universally‑quantified auxiliary variables (`y1` … `y6`). The constraints are simple inequalities/equalities (≤, ≥, <, >, =), but they are deeply nested (up to depth 21) and involve 18 ∃‑quantifiers and 14 ∀‑quantifiers, leading to a highly quantified, combinatorial search space. Consequently the instance tests the solver’s ability to handle quantified linear arithmetic over 32‑bit bit‑vectors with multiple quantifier alternations and a large number of arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_24.smt2",
    "description": "The instance asks whether there exist 32‑bit values for the free variables x1, y1, y3 and y4 that satisfy a huge conjunction of linear bit‑vector constraints built from additions, multiplications by constant coefficients and signed inequalities, all wrapped inside several alternating ∀/∃ quantifiers and nested let‑expressions.  In other words, it is a quantified satisfiability problem over the theory of bit‑vectors that encodes a dense system of linear (in)equalities – a random‑generated but highly tangled example of checking consistency of non‑convex polyhedral constraints.  The presence of many quantifier alternations, deep term nesting (depth 20) and over three hundred multiplications makes the formula particularly challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_8.smt2",
    "description": "The file encodes a single quantified bit‑vector formula over 32‑bit signed integers. It asserts the existence of witnesses for the variables y₂,…,y₆ (and x₁) that satisfy a conjunction of linear equalities and signed (in)equalities built from additions, multiplications by constant coefficients and negations, with three nested alternating blocks of ∀‑∃ quantifiers. The problem is a pure satisfiability check (SAT/UNSAT) for a highly non‑trivial quantified linear arithmetic fragment, featuring deep term nesting (depth 17) and a total of five quantifier alternations, which makes it a demanding benchmark for solvers that rely on quantifier instantiation or interpolation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_33.smt2",
    "description": "This benchmark encodes a highly quantified, quantifier‑alternating satisfiability problem over 32‑bit bit‑vectors.  It consists of a single large assertion that combines many universally‑ and existentially‑quantified variables with linear (affine) constraints built from constant multiplications, additions, and comparisons (≠, ≤, <, ≥, >) on the bit‑vectors, forming a dense system of linear inequalities and equalities.  The instance tests a solver’s ability to handle deep term nesting (up to depth 25), a large number of arithmetic operations (over 1 200 multiplications and 900 additions) and multiple quantifier alternations, making it a challenging case for quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_1.smt2",
    "description": "The file encodes a quantified satisfiability problem in the 32‑bit bit‑vector logic: a single top‑level formula contains several alternating blocks of existential and universal quantifiers over auxiliary variables (y1…y4) and a free variable x1, together with a large conjunction of linear equalities and inequalities formed with bvadd, bvmul (multiplication by constant coefficients), and signed comparisons. The goal is to decide whether there exists an x1 such that the whole quantified arithmetic condition holds for all choices of the quantified y‑variables, a pattern typical for checking redundancy or invariant properties of non‑convex polyhedral representations. The instance is “random” but structurally dense: it features 57 multiplications, 36 additions, 10 ∃‑quantifiers, 8 ∀‑quantifiers, and a maximum term depth of 17, making quantifier‑instantiation and bit‑vector reasoning the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_3.smt2",
    "description": "The file encodes a quantified bit‑vector arithmetic problem.  Three 32‑bit variables x1, y3 and y4 are declared and a single large formula asserts a conjunction of linear (constant‑coefficient) inequalities and equalities over them, with a quantifier pattern **∀ y3 ∃ y4 … ∨ ∀ y4 …**.  Thus the solver must decide whether there exists a value for x1 such that, for every possible y3, the existential choice of y4 can satisfy one side of a disjunction, while simultaneously another universally quantified condition on y4 (and the same y3) must hold.  The instance is essentially a satisfiability check for a non‑convex polyhedral constraint expressed in bit‑vector arithmetic, featuring a modest number of variables but a relatively deep term structure (depth 12) and an alternation of quantifiers, which makes it challenging for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_12.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that encodes a large system of linear (signed) inequalities over 32‑bit variables.  The formula contains numerous nested existential and universal quantifiers (19 ∀, 17 ∃) over auxiliary variables y₁…y₄ together with a free variable x₁, and the constraints are built from linear combinations of these variables using addition, multiplication by constant bit‑vectors, and relational operators ( bvsge, bvslt, bvsgt, bvsle ).  The heavy alternation of quantifiers, deep term nesting (depth 18) and the sheer number of linear terms (hundreds of bvmul/bvadd) make the problem a challenging benchmark for solvers handling quantified BV arithmetic, typical of redundancy‑removal checks for non‑convex polyhedral representations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_4.smt2",
    "description": "The benchmark encodes a single quantified bit‑vector formula over four 32‑bit variables (y1, y3, y4, x1). It consists of a ∀‑quantified outer variable ( ?y1) with nested ∀‑?y3/∃‑?y4 quantifier alternations, and a conjunction of many linear‑arithmetical constraints formed with constant‑coefficient multiplications, additions, and signed comparisons. The instance models the satisfiability of a non‑convex polyhedral redundancy check, and its difficulty stems from the deep term nesting (depth ≈ 14) together with multiple quantifier alternations and a dense use of bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_10.smt2",
    "description": "The instance asks whether a quantified bit‑vector formula over three 32‑bit variables is satisfiable; it combines universal and existential quantifiers to express a mixture of linear equalities, strict and non‑strict inequalities, and disequalities that arise from a non‑convex polyhedral representation. The constraints are encoded as nested `bvadd`/`bvmul`/`bvneg` arithmetic on bit‑vectors, with a quantifier alternation pattern ∀y₂ ( ∃y₃ ∨ ∀y₃ ∨ ∃y₃ ) that yields several layers of quantifier interaction and a term depth of 12, making the problem non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_23.smt2",
    "description": "The file encodes a quantified bit‑vector property that asks whether, for every 32‑bit value y₃ (and later for y₄, y₅, y₆) there exist witnesses for the remaining variables such that a large conjunction of linear (affine) constraints—built from constant‑multiplications, additions and signed comparisons (≤, <, ≥, >, =)—holds, with a free 32‑bit variable x₁ appearing throughout.  This formulation originates from a reduction of the redundancy‑detection problem for linear constraints in non‑convex polyhedra to a quantified BV formula, and the benchmark is challenging because it features alternating ∀/∃ quantifiers, a deep term nesting (depth 23), and a high count of arithmetic operations (over 400 bvmul and 300 bvadd terms).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_1.smt2",
    "description": "The benchmark encodes a highly quantified 32‑bit bit‑vector problem that consists of a large conjunction of linear equalities and inequalities built from constant‑multiplied variables (e.g. `bvmul` with small constants) and additions. It asks whether there exists a value for the free variable `x1` (and auxiliary existentially‑quantified variables) such that a nested alternation of ∃ and ∀ quantifiers over the remaining variables satisfies all the signed‑comparison constraints, which stem from a translation of redundant linear constraints in a non‑convex polyhedral setting. The formula features deep term nesting (depth 18), 21 quantifier blocks and dozens of linear arithmetic atoms, making quantifier‑instantiation and interpolation the primary sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_20.smt2",
    "description": "The file asserts a single quantified bit‑vector formula over five 32‑bit variables ( x1, y1…y4 ) that encodes a large system of linear inequalities – each inequality is expressed with `bvadd`, `bvmul` and `bvneg` to mimic integer arithmetic.  The top‑level assertion is a disjunction of two quantified blocks: one contains an ∀ y2 ∃ y3 ∀ y4 prefix and the other an ∀ y1 ∃ y3 (and further ∃ y4) prefix, so the problem features three quantifier alternations together with deep (depth 18) nested arithmetic terms (over 123 multiplications).  It therefore represents a non‑convex polyhedral redundancy/check‑implication problem translated to the BV logic, whose difficulty lies in the combination of many linear‑combination constraints, deep term structure, and alternating quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_8.smt2",
    "description": "The instance is a quantified bit‑vector satisfiability query. It asks whether there exists a 32‑bit value for the free variable `x1` such that **either** of two ∀∃‑formulas holds: each formula quantifies universally over a fresh 32‑bit variable (`?y2` or `?y1`) and existentially over another 32‑bit variable (`?y3`), and then imposes a conjunction of signed linear inequalities and equalities that involve only constant‑scaled multiplications, additions and comparisons (`bvsgt`, `bvslt`, `bvsle`).  \n\nThus the problem encodes a disjunction of two universally‑existential quantified linear constraints over signed 32‑bit integers. The difficulty stems from the quantifier alternation (∀∃) and the relatively deep term structure (depth 12), despite the small number of quantified variables and the absence of nonlinear (variable‑variable) multiplication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_29.smt2",
    "description": "The file encodes a single quantified SMT‑LIB formula over 32‑bit bit‑vectors that models a large system of linear (affine) constraints: each constraint is a combination of additions, constant multiplications, and negations, compared with constants using signed ≤, ≥, <, > or equality. The formula contains several alternating quantifier blocks (∃∀∃… and ∀∃…), with up to three‑level nesting, and the arithmetic expressions reach a term depth of 24, involving hundreds of multiplications and additions. The overall task is simply to decide whether the quantifier‑rich conjunction of these linear inequalities is satisfiable, testing a solver’s ability to handle deep quantified linear arithmetic in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_28.smt2",
    "description": "The file encodes a quantified bit‑vector satisfiability problem in the BV logic (32‑bit signed integers).  The single asserted formula consists of a large Boolean combination of linear equalities and inequalities built from constants, additions, multiplications by constants and signed comparisons, with a mixture of ∃‑ and ∀‑quantifiers over three auxiliary variables (y1, y2, y3) together with the free variable x1.  It essentially asks whether the system of non‑convex, linear constraints (originating from a polyhedral redundancy‑removal task) admits a solution, and is made difficult by many quantifier alternations (27 ∃, 17 ∀), a high number of bvmul occurrences (227) and a maximum term depth of 17.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_20.smt2",
    "description": "The benchmark encodes a single quantified bit‑vector formula in the BV logic that mixes linear arithmetic constraints (signed ≤, ≥, <, >) over three 32‑bit variables x₁, y₂, y₃ with a four‑stage quantifier prefix ∀y₂ ∃y₃ ∀y₃ ∃y₃.  All constraints are built from additions, multiplications by constant bit‑vectors and negations, forming a dense system of linear relations that must hold (or be refuted) for every choice of the universally‑quantified variables.  The presence of alternating ∀/∃ blocks together with a deep term structure (depth 14) and many coefficient multiplications makes the instance a challenging case of quantified linear arithmetic verification in the bit‑vector domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_27.smt2",
    "description": "The file asserts the satisfiability of a large quantified bit‑vector formula in the BV logic.  It combines a handful of free 32‑bit variables (x1, y2, y3, y4) with many universally‑ and existentially‑quantified auxiliary variables, and encodes a dense system of linear (affine) constraints built from constant multiplications, additions and signed comparisons ( ≤, ≥, <, >) as well as equalities.  The problem is essentially a quantified safety‑/feasibility check over a non‑convex region, featuring several quantifier alternations, deep terms (depth 20) and hundreds of arithmetic operations, which makes it a challenging benchmark for BV solvers with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_29.smt2",
    "description": "The file encodes a single quantified Boolean‑valued formula over 32‑bit signed bit‑vectors.  It contains two alternating quantifier blocks (∀y₂ ∀y₃ … ∃y₃ …) that compose a large conjunction of linear (constant‑times‑variable) arithmetic constraints – a mixture of signed inequalities ( ≥, ≤, <, >) and equalities, heavily nested with or/and and a few let‑bindings.  The problem is to decide satisfiability of this non‑convex set of linear constraints; the difficulty stems from the deep term nesting (depth 17), the presence of several quantified variables and many linear inequalities, which together make quantifier instantiation and interpolation challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_7.smt2",
    "description": "The instance asks whether there exist 32‑bit signed variables y₁, y₂, y₃ (and a free x₁) such that a conjunction of linear inequalities—written as bit‑vector additions, multiplications and negations—holds, while for all possible values of the quantified y‑variables additional opposite‑signed inequalities must also be satisfied.  In other words, it encodes the satisfiability of a system of signed linear constraints (a non‑convex polyhedral description) after translation to 32‑bit bit‑vectors.  The formula features three quantifier alternations (∃ … ∃ … ∀ … ∀ … ∃ … ∃), deep arithmetic terms (depth 13) and many bvmul/bvadd operations, making it a demanding benchmark for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_9.smt2",
    "description": "The benchmark asks whether there exist 32‑bit vectors x₁ and y₁…y₆ such that a large conjunction of signed linear inequalities (built from bvadd, bvmul by constant coefficients and bvneg) holds, while simultaneously satisfying numerous universally quantified conditions on additional fresh bit‑vector variables. It encodes the verification of redundancy among linear constraints that describe a non‑convex polyhedron, using only bit‑vector arithmetic and signed comparisons. The formula features many alternating ∃/∀ quantifiers (16 existentials and 11 universals) and deep nested terms (maximum depth 21), yielding a highly quantified and combinatorially challenging BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_9.smt2",
    "description": "This instance encodes a quantified bit‑vector satisfiability problem that models a set of linear arithmetic constraints over 32‑bit variables (x1 together with auxiliary witnesses y1, y2, y3). The single top‑level assertion is a large Boolean combination of existential and universal quantifiers that express upper‑ and lower‑bound inequalities (using `bvslt`, `bvsle`, `bvsge`, `bvsgt`) together with equalities, all involving only constant‑multiplication and addition, mirroring the redundancy‑removal checks for non‑convex polyhedral descriptions described in the source paper. The formula contains several alternations of `exists`/`forall` (7 existentials, 5 universals) and a maximal term depth of 13, making it a challenging benchmark for solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_18.smt2",
    "description": "The formula asserts the satisfiability of a quantified bit‑vector condition over four 32‑bit variables x1, y1, y2, y3. It consists of a disjunction of two ∀∃ blocks, each requiring that for every value of a universally‑quantified variable (y2 or y1) there exists a value of another variable (y3) such that a large conjunction of signed linear inequalities, disequalities and equalities—written as constant‑multiplied bvadd and bvmul terms—is satisfied. This encodes a non‑convex polyhedral feasibility check and is challenging because of the alternating quantifiers, the many linear‑arithmetic‑like constraints, and a term depth of 14 despite involving only four variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_27.smt2",
    "description": "The file encodes a large conjunction of quantified linear constraints over 32‑bit signed bit‑vectors.  Six integer variables ( x1, y2, y3, y4, y5, y6 ) appear in many inequalities of the form bvadd/bvmul combined with signed (in)equalities, and the constraints are organized in alternating ∀/∃ blocks (e.g., ∀y3 ∀y5 ∃y6 … ∧ ∃y2 ∀y3 ∃y4 …), resulting in a dense, deeply nested quantified formula.  The problem therefore asks whether a non‑convex polyhedral system, represented as these bit‑vector linear inequalities, is satisfiable—i.e., whether the set of constraints (intended to model redundancy detection in linear systems) admits a model—while presenting a challenging solving task due to the many quantified alternations, high term depth (≈22), and thousands of arithmetic literals.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_2.smt2",
    "description": "The benchmark is a single quantified bit‑vector formula that encodes a large system of linear constraints over 32‑bit variables x1 and y1…y6. It combines many nested ∀ and ∃ quantifiers with linear expressions built from addition, multiplication by constants, and signed comparisons (≤, <, ≥, >) to ask whether the whole conjunction is satisfiable. The instance has deep term nesting (depth 18), a high count of arithmetic operations and roughly five alternations of quantifiers, making it a challenging SAT/SMT problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_36.smt2",
    "description": "The file asserts a single quantified formula over four 32‑bit variables x₁…x₄ of the shape  \n\n ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ . φ(x₁,x₂,x₃,x₄),\n\nwhere φ is a massive Boolean combination of linear bit‑vector constraints built from constant‑multiplications, additions and signed (in)equalities (≈ 250 bvmul, 190 bvadd, many or/and).  Thus the benchmark tests the satisfiability of a non‑convex polyhedral relation encoded in bit‑vectors, stressing a solver’s ability to handle alternating quantifiers, deep term nesting (depth 20) and a large number of arithmetic literals.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_59.smt2",
    "description": "This instance encodes a three‑variable quantified bit‑vector problem of the form  \n  ∃ x₁ ∀ x₂ ∃ x₃ · Φ, where Φ is a massive conjunction of linear equalities and (in)equalities built from constant‑scaled products (bvmul) and sums (bvadd) of the three 32‑bit variables. The formula represents a highly non‑convex polyhedral constraint system (as in the cited work on redundant linear constraints) and is used to test a solver’s ability to handle quantifier alternation (∃∀∃) together with a large number of arithmetic terms (≈ 350 multiplications, 300 additions) and deep nesting (term depth 21). The main difficulty lies in the sheer volume of linear constraints and the need to reason about them under the alternating quantifiers, rather than in a large number of distinct variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_58.smt2",
    "description": "This benchmark encodes a three‑alternation quantified formula over 32‑bit bit‑vectors: ∃ x₁ ∀ x₂ ∃ x₃ such that a large conjunction of signed linear constraints (equalities, ≤, <, ≥, >) built from constant‑scaled multiplications (bvmul) and additions (bvadd) is satisfied. The constraints form a dense, randomly generated system of linear inequalities with many disjunctions, leading to a deep term‑depth (≈18) and a heavy quantifier alternation pattern that stresses a solver’s ability to handle quantified bit‑vector arithmetic and large numbers of arithmetic literals.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_46.smt2",
    "description": "This benchmark encodes a quantified bit‑vector feasibility problem that originates from the reduction of redundant‑constraint detection in non‑convex polyhedra. It asks whether there exist 32‑bit vectors x₁, x₂, x₃ such that a massive conjunction of affine inequalities and equalities (each built from constant‑multiplications, additions and signed comparisons) holds under an ∃ x₁ ∀ x₂ ∃ x₃ quantifier pattern. The instance is hard for solvers because it features many linear‑arithmetic‑like BV terms (over 120 multiplications), a deep term nesting depth of 18, and alternating quantifiers, creating a dense, highly coupled constraint network.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_31.smt2",
    "description": "The file encodes a quantified bit‑vector formula that asks whether a “strategy” exists for the alternating choices of four 32‑bit variables.  Formally it asserts  \n\n\\[\n\\forall x_1\\;\\exists x_2\\;\\forall x_3\\;\\exists x_4\\;.\\; \\Phi(x_1,x_2,x_3,x_4)\n\\]\n\nwhere Φ is a large Boolean combination of signed linear inequalities built from additions, constant multiplications ( bvmul ) and comparisons ( bvslt, bvsle, bvsge, bvsgt ).  The constraints originate from the redundancy‑removal encoding for non‑convex polyhedra described in the cited paper, so the instance tests the satisfiability of a non‑convex polyhedral condition under a two‑round quantifier alternation.  The problem is challenging because of the many linear terms (≈200 multiplications, 158 additions) and the depth‑20 term structure combined with the forall/exists alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_54.smt2",
    "description": "This instance checks a quantified linear‑arithmetic property over three 32‑bit variables x₁, x₂ and x₃: it asks whether there exists a value for x₁ such that for every possible x₂ there is some x₃ making a huge conjunction of signed inequalities and equalities (all built from pre‑computed multiples of the variables) true. The formula features a single ∃ x₁ ∀ x₂ ∃ x₃ quantifier prefix, about 425 bvmul and 426 bvadd operations, and a maximum term depth of 21, creating a dense, highly coupled set of linear constraints that makes the problem challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_12.smt2",
    "description": "The instance encodes a quantified bit‑vector satisfiability problem with the prefix ∃?x₁ ∀?x₂ ∃?x₃ over 32‑bit vectors, where the three global constants x₁, x₂, x₃ are unconstrained. Inside the quantifiers a large conjunction of linear (affine) constraints—equalities, strict and non‑strict inequalities, and disequalities—built from constant‑multiplied variables (using bvmul, bvadd, bvneg) is asserted; these constraints represent a non‑convex polyhedral region translated to BV arithmetic. The benchmark tests a solver’s ability to handle alternating quantifiers and many intertwined linear bit‑vector constraints (≈64 multiplications, depth 16), typical of redundancy‑removal/invariant‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_66.smt2",
    "description": "This instance checks the satisfiability of a quantified bit‑vector formula that encodes a large system of linear (affine) inequalities over four 32‑bit variables, derived from the redundancy‑removal problem for non‑convex polyhedra (Scholl et al., SAT‑Mod‑Theories 2008). It features a ∀∃∀∃ quantifier alternation with dozens of constant‑scaled multiplications and additions, resulting in deep term nesting (depth 30) and thousands of arithmetic constraints (e.g., bvadd, bvmul, bvslt/​bvsle/​bvsge). The main challenge for an SMT solver is handling the high quantifier alternation and the massive number of linear‑integer‑like constraints expressed in bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_5.smt2",
    "description": "The file encodes a quantified bit‑vector satisfiability query in which three 32‑bit variables (x1, x2, x3) are related by a large conjunction of linear‑looking equalities and signed inequalities built from constant‑multiplied terms, additions, and negations. The formula has an ∃ ?x1 ∀ ?x2 ∃ ?x3 quantifier prefix, creating a three‑alternation pattern that forces the solver to reason about a universally quantified intermediate variable within a non‑convex polyhedral‑style region defined by many small‑coefficient linear constraints. The combination of deep term nesting (depth 15), numerous bvmul/bvadd operations, and the alternating quantifiers makes the instance a challenging benchmark for BV solvers handling quantified linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_35.smt2",
    "description": "The file encodes a quantified bit‑vector decision problem over four 32‑bit variables x₁…x₄.  It has the prefix **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄** followed by a huge conjunction of linear integer (bit‑vector) constraints built from constant‑scaled multiplications, additions, and order comparisons ( bvslt, bvsle, bvsgt, bvsge ) together with several equalities and disequalities.  The solver is asked to determine whether, for every value of the first variable, a suitable choice of the second, third, and fourth variables can satisfy all these constraints – a typical emptiness/validity check for a non‑convex polyhedral region, made difficult by deep term nesting (depth 20) and a large number of quantified linear inequalities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_37.smt2",
    "description": "The file encodes a quantified bit‑vector problem that asks whether, for every 32‑bit value of ?x1, there exists a 32‑bit ?x2 such that for all 32‑bit ?x3 there exists a 32‑bit ?x4 satisfying a large conjunction of linear inequalities and equalities (bvslt, bvsle, bvsge, bvsgt, =), each built from constant‑multiplied variables (bvmul) and additions.  This essentially represents a two‑player game (∀∃∀∃) over a system of linear constraints that model a non‑convex polyhedral region, and the solver must decide the satisfiability of this alternating‑quantifier formula.  The instance is challenging due to the depth of nested arithmetic expressions (term depth 19), many multiplied constants, and a dense mix of Boolean combinations (∧/∨/¬) across four quantified bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_43.smt2",
    "description": "The file encodes a single quantified BV‑satisfiability query that asks whether there exists a 32‑bit value for ?x1 such that for every 32‑bit value of ?x2 one can choose a 32‑bit value for ?x3 making a large conjunction of linear (constant‑multiplied) inequalities hold.  All constraints are expressed with bvmul, bvadd and signed comparisons, and the formula contains an ∃ ?x1 ∀ ?x2 ∃ ?x3 quantifier alternation together with deep (depth 16) Boolean nesting (≈80 multiplications, 24 disjunctions, 15 conjunctions).  This kind of pattern arises from checking redundancy / implication of linear constraints in a non‑convex polyhedral representation, and its quantified, heavily mixed arithmetic structure makes it a hard instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_57.smt2",
    "description": "The file encodes a quantified linear‑arithmetic problem over 32‑bit bit‑vectors.  It asserts a single formula of the form  \n\n\\[\n\\forall x_1.\\;\\exists x_2.\\;\\forall x_3.\\;\\exists x_4.\\; \\bigwedge_{i} \\text{(signed linear inequality or equality built from }c\\cdot x_j\\text{ and }c\\text{)} ,\n\\]\n\nwhere the conjuncts are dozens of signed ≤, ≥, <, > and = relations involving constant‑coefficient multiplications (e.g. \\(75·x_3\\), \\(-36·x_1\\)) and additions.  The instance comes from a benchmark on detecting redundant linear constraints in non‑convex polyhedra, and its difficulty stems from the four‑alternation quantifier prefix together with a large number of arithmetic terms (over 400 bvmul, 380 bvadd) and a term‑depth of 22.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_54.smt2",
    "description": "This benchmark asserts a single quantified formula of the shape ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ Φ, where Φ is a massive Boolean combination of linear bit‑vector constraints (additions, constant‑multiplications, negations) over four 32‑bit variables. The constraints originate from a translation of non‑convex polyhedral inequalities (used in a redundancy‑removal / Craig‑interpolation study) into bit‑vector arithmetic, producing hundreds of bvadd, bvmul, bvsgt, bvslt, bvsge, bvsle, = and logical connectives. Solving this instance therefore requires handling a deep ∀∃∀∃ quantifier alternation together with a large set of shallow linear arithmetic literals, making it a challenging case for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_53.smt2",
    "description": "The instance asks whether there exists a 32‑bit value x₁ such that, for every 32‑bit value x₂, one can find a 32‑bit value x₃ satisfying a massive disjunction of conjunctions of linear bit‑vector constraints (each built from constant‑scaled multiplications, additions, and signed comparisons).  It therefore encodes a quantified linear‑arithmetic reasoning problem (∃ x₁ ∀ x₂ ∃ x₃ φ) over bit‑vectors, typical of invariant‑synthesis or redundancy‑checking tasks.  The formula is dense (over 200 arithmetic operations, depth 19, and many nested Boolean connectives), which makes the satisfiability check challenging despite the small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_26.smt2",
    "description": "The instance encodes a three‑alternation quantified problem (∃ ?x₁ ∀ ?x₂ ∃ ?x₃) over 32‑bit signed bit‑vectors, asking whether there exist values that satisfy a large conjunction of linear equalities and inequalities built from constant multiplications, additions and negations. All constraints are of the form “c₁·?x₁ + c₂·?x₂ + c₃·?x₃ ⊙ k” (with ⊙ ∈ {≤, ≥, <, =}), so the formula represents a non‑convex polyhedral region translated into BV arithmetic. The presence of nested quantifiers, many linear terms (≈ 40 multiplications) and a term‑depth of 16 makes the check‑satisfiability task challenging for quantified‑BV solvers, which must handle quantifier alternation and large coefficient ranges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_27.smt2",
    "description": "The formula is a quantified bit‑vector decision problem over four 32‑bit variables x1…x4. It contains a ∀ x1 ∃ x2 ∀ x3 ∃ x4 prefix followed by a large conjunction of linear arithmetic constraints built from constant‑scaled multiplications, additions and signed comparisons (≈ 50 bvmul and 38 bvadd occurrences, nesting depth 17). The solver must determine whether there exists a strategy for the existential variables that satisfies all the signed inequality and equality clauses for every choice of the universal variables, a task made challenging by the alternating quantifier blocks and the dense, highly interconnected linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_60.smt2",
    "description": "This instance asks whether there exists a 32‑bit value ?x1 such that for every 32‑bit ?x2 one can find a 32‑bit ?x3 satisfying a massive conjunction of signed linear constraints built from constant‑multiplications of the three quantified variables (e.g. 16·?x1, ‑75·?x2, 84·?x3, …).  The formula is an ∃ ∀ ∃ quantifier prefix over bit‑vectors, encoding a redundancy‑checking property of non‑convex polyhedral representations (as described in the cited paper), and its difficulty stems from the huge number of bvmul, bvadd, and comparison atoms (over 500 multiplications, >600 additions) and a nesting depth of 22.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_2.smt2",
    "description": "The file encodes the satisfiability of a quantified linear bit‑vector formula in the BV logic.  It asks whether there exists a 32‑bit value ?x₁ such that for every 32‑bit value ?x₂ there exists a 32‑bit value ?x₃ making a large conjunction of linear inequalities ( bvsge, bvsle, bvslt, bvsgt ) and equalities hold, together with several disjunctions and negated equalities.  Although only three symbolic variables appear, the alternating ∃ ∀ ∃ quantifier prefix and a maximal term depth of 14 (many constant‑multiplied terms) create a non‑trivial quantified‑BV decision problem that stresses solvers’ ability to handle quantifier instantiation and linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_52.smt2",
    "description": "This instance asks whether there exist 32‑bit values ?x1, ?x2 and ?x3 such that a huge conjunction of linear‑arithmetic constraints (equalities, signed‑greater/less‑than and signed‑greater/less‑or‑equal) over constant‑scaled multiples of the three variables holds, under an outer ∃ ?x1 ∀ ?x2 ∃ ?x3 quantifier pattern.  All constraints are expressed with bvadd, bvmul by concrete constants and bvneg, forming a dense system of signed inequalities that is essentially a non‑convex polyhedral feasibility problem encoded in bit‑vector logic.  The formula is deliberately dense (576 additions, 480 multiplications, 410 negations) with a maximum term depth of 22, making it a challenging benchmark for solvers handling quantified BV formulas and large‑scale linear reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_44.smt2",
    "description": "The file encodes a quantified bit‑vector formula that asks whether there exists a 32‑bit value x₁ such that for **all** 32‑bit values x₂ there **exists** a 32‑bit value x₃ satisfying a large conjunction of linear (constant‑multiplied) equalities and signed inequalities.  The constraints are essentially a BV‑translation of a system of linear inequalities used in the paper on detecting redundant constraints in non‑convex polyhedra; they involve many constant multiplications, additions, and signed comparisons combined with deep nested Boolean operators (depth 19, ~200 bvmul occurrences).  The alternating ∃ ∀ ∃ quantifier pattern together with the huge disjunction/conjunction structure makes the instance a hard benchmark for quantified‑BV solving and interpolation‑based redundancy checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_16.smt2",
    "description": "The file encodes a quantified bit‑vector decision problem that corresponds to a system of linear (affine) inequalities over 32‑bit signed integers.  It has a prenex prefix **∀ ?x1 ∃ ?x2 ∀ ?x3 ∃ ?x4** and a large Boolean combination (conjunctions, disjunctions, negations) of constraints built from `bvadd`, `bvmul`, and `bvneg`, i.e. linear arithmetic expressed in the BV theory.  The solver must decide whether the formula is satisfiable, which is hard because of the alternating quantifiers, the high number of multiplication terms (78 `bvmul`s), deep term nesting (depth 18), and the intricate mixture of inequalities, making it a challenging quantified‑BV satisfiability instance derived from redundancy detection in non‑convex polyhedra.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_53.smt2",
    "description": "The file encodes a quantified linear‑arithmetic problem over four signed 32‑bit variables x₁…x₄, written as a ∀x₁ ∃x₂ ∀x₃ ∃x₄‑formula whose matrix is a massive conjunction of linear (constant‑multiplication) inequalities and equalities (bvslt, bvsle, bvsge, bvsgt, =).  It asks whether the existential player can always choose x₂ and x₄ to satisfy all the listed constraints no matter how the universal player picks x₁ and x₃, i.e. a Σ₂²‑style safety/strategy‑existence check.  The instance is challenging because of the alternating quantifiers, a high term‑depth (21), and the sheer number of multiplied terms (≈300 bvmul, 250 bvadd) that blow up the search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_62.smt2",
    "description": "This instance encodes a quantified bit‑vector arithmetic problem that models the detection of redundant linear constraints in a non‑convex polyhedron: it asks whether for every 32‑bit value x₁ there exists an x₂ such that for every x₃ there exists an x₄ making a massive conjunction of signed inequalities (bvslt, bvsle, bvsgt, bvsge, = ) over linear combinations of the variables true. The formula is built from thousands of bvmul and bvadd terms with constant coefficients, nested inside a ∀x₁ ∃x₂ ∀x₃ ∃x₄ quantifier alternation and a term‑depth of 29, resulting in a highly combinatorial search space that challenges SMT solvers both in quantifier handling and in managing the large number of arithmetic sub‑expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_29.smt2",
    "description": "The formula asks whether there exist 32‑bit integers x₁ such that, for every 32‑bit integer x₂, there exists a 32‑bit integer x₃ satisfying a large conjunction of disjunctions of linear (affine) equalities and inequalities, all expressed with constant multiplications, additions, and signed comparisons.  It is a quantified bit‑vector benchmark with the quantifier pattern ∃ x₁ ∀ x₂ ∃ x₃, containing about 100 bvmul occurrences, a term depth of 16, and a dense mixture of `or`/`and` clauses, making it a challenging instance for solvers that must handle three‑alternation quantifiers and heavy arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_33.smt2",
    "description": "The file encodes a quantified bit‑vector arithmetic problem in the BV logic:  \n\n\\[\n\\exists x_1\\;\\forall x_2\\;\\exists x_3\\;.\\;\\Phi(x_1,x_2,x_3)\n\\]\n\nwhere Φ is a large Boolean combination of linear equalities and signed inequalities built from 32‑bit constants, additions and constant multiplications (≈ 50 bvmul occurrences, depth 16).  The formula corresponds to checking the satisfiability of a set of linear constraints that model a (non‑convex) polyhedral region, a typical sub‑task in redundancy‑removal/verification of linear constraints; the alternating quantifiers and heavy use of arithmetic make it a challenging instance for SMT solvers that support quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_20.smt2",
    "description": "This benchmark encodes a quantified word‑level bit‑vector problem: it asks whether there exist a 32‑bit value ?x1 such that for every 32‑bit ?x2 there is a 32‑bit ?x3 satisfying a large conjunction of linear equalities and inequalities built from constant multiplications, additions, and sign‑aware comparisons ( bvsge, bvsgt, bvslt ). The formula features an ∃ ∀ ∃ quantifier alternation, a moderate term depth (14) and dozens of arithmetic operations, making it a challenging instance for solvers that must reason about quantified linear constraints over non‑convex polyhedral regions encoded as bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_55.smt2",
    "description": "This instance is a quantified bit‑vector formula that asks whether, for every 32‑bit value x₁, there exists a 32‑bit value x₂ such that for every 32‑bit value x₃ there exists a 32‑bit value x₄, a large conjunction of linear (multiply‑by‑constant) arithmetic constraints over x₁…x₄ is satisfied.  In other words, it encodes a ∀∃∀∃‑alternation checking the consistency of a massive system of linear inequalities (bvslt, bvsle, bvsge, bvsgt) built from constant‑scaled variables.  The problem is essentially a quantified arithmetic/verification task with deep term nesting (depth 24) and thousands of arithmetic literals, making it a challenging benchmark for SMT solvers handling quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_6.smt2",
    "description": "The formula asks whether there exists a 32‑bit value ?x₁ such that for every 32‑bit value ?x₂ there is a 32‑bit value ?x₃ making a large Boolean combination of signed inequalities ( bvsge, bvslt, bvsle, bvsgt ) and equalities hold on linear expressions built from additions, multiplications and negations of the three variables.  In other words, it is a quantified satisfiability problem (∃ ?x₁ ∀ ?x₂ ∃ ?x₃) over bit‑vector linear arithmetic, featuring a moderate term depth (14) and many arithmetic operations (≈35 multiplications, 20 additions), which creates a non‑trivial search space due to the quantifier alternation and the dense conjunction/disjunction structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_68.smt2",
    "description": "This instance asks whether a quantified Boolean‑valued system of linear arithmetic over 32‑bit bit‑vectors is satisfiable: it contains a single ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ formula whose body is a large conjunction of linear inequalities (bvadd, bvmul with constant coefficients, comparisons such as bvslt, bvsle, bvsgt, bvsge) and Boolean combinations. The problem thus encodes a verification‑style check for the existence of values that satisfy a huge set of linear constraints (originating from redundant‑constraint removal in non‑convex polyhedra), and is challenging because of the alternating quantifiers, deep term nesting (depth 23) and thousands of arithmetic terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_56.smt2",
    "description": "The instance is a quantified decision problem over three 32‑bit integer variables x₁, x₂, x₃, structured as ∃x₁ ∀x₂ ∃x₃ Φ, where Φ is a huge Boolean combination (∧/∨/¬) of linear (signed) inequalities and equalities built from constant‑scaled multiplications (bvmul) and additions (bvadd). It encodes a dense set of linear constraints arising from a non‑convex polyhedral representation (as in the cited work on redundant linear constraints), stressing the solver with many nested arithmetic terms (depth ≈ 22), a large number of Boolean connectives, and a single quantifier alternation block. The main verification task is to determine whether there exists a value for x₁ such that for every x₂ there is some x₃ satisfying all those combined arithmetic conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_10.smt2",
    "description": "This instance asks whether there exist 32‑bit values for ?x1 such that, for every 32‑bit ?x2, there is a 32‑bit ?x3 satisfying a large conjunction of signed linear (in)equality constraints built from constant multiplications, additions and negations.  It originates from a translation of a redundancy‑removal problem for non‑convex polyhedra into the bit‑vector domain and features an ∃∀∃ quantifier prefix, deep (depth 13) arithmetic terms and a dense mix of bvmul, bvadd, bvneg, and relational operators, making quantified BV solving comparatively challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_4.smt2",
    "description": "The instance is a quantified bit‑vector satisfiability problem that encodes a small system of linear (affine) constraints over three 32‑bit signed variables. It asks whether there exists a value for x₁ such that, for every choice of x₂, one can find an x₃ making a conjunction of several constant‑scaled additions, inequalities ( <bvslt>, <bvsge>, <bvsgt> ) and equalities hold. The formula features an ∃ ∀ ∃ quantifier alternation with modest term depth (13) but a non‑trivial mix of linear arithmetic on bit‑vectors, which makes it a challenging benchmark for quantifier‑handling and interpolation‑based solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_9.smt2",
    "description": "The formula asserts the existence of a 32‑bit value ?x1 such that for every 32‑bit ?x2 there exists a 32‑bit ?x3 satisfying a Boolean combination of signed linear bit‑vector constraints (inequalities ≥, ≤, > and equalities) built from constant‑coefficient multiplications, additions and negations. These constraints are nested in disjunctions and conjunctions, forming a single quantified assertion with an ∃∀∃ prefix and a term depth of 13. The instance therefore encodes a non‑trivial quantified BV feasibility problem, characteristic of verification‑style checks on non‑convex polyhedral representations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_52.smt2",
    "description": "This instance encodes a quantified linear‑arithmetic problem over four 32‑bit variables x₁,…,x₄ in the form  \n\n\\[\n\\forall x₁\\;\\exists x₂\\;\\forall x₃\\;\\exists x₄\\;.\\; \\bigwedge_i \\, C_i(x₁,x₂,x₃,x₄),\n\\]  \n\nwhere each conjunct Cᵢ is a simple equality or (in)equality between a constant‑scaled bit‑vector sum (a large collection of bvmul with small integer constants) and a constant.  The formula originates from the reduction of a non‑convex polyhedron redundancy check to bit‑vectors; it therefore tests a solver’s ability to handle a deep alternation of quantifiers (∀∃∀∃), a huge number of linear arithmetic literals (≈ 950 bvadd, 660 bvmul), many let‑bound sub‑terms, and term depth up to 24.  The primary difficulty lies in the combinatorial explosion of quantified linear constraints rather than in any particular domain‑specific property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_39.smt2",
    "description": "The benchmark asserts a quantified bit‑vector property: there must exist a 32‑bit value x₁ such that for every 32‑bit x₂ there exists a 32‑bit x₃ making a huge conjunction of linear (affine) constraints true. All constraints are built from multiplications by concrete constants, signed additions, and comparisons (≤, <, ≥, >) together with several equalities, and they are combined with many Boolean operators (and/or/not) inside a single quantified formula that has an **∃ ∀ ∃** quantifier prefix. Thus the problem is a satisfiability check for a deeply nested, heavily constrained quantified linear arithmetic formula over 32‑bit bit‑vectors, featuring a large number of arithmetic atoms (≈200), high term depth (18) and three quantifier alternations, which makes it a hard case for interpolation‑based or quantifier‑instantiation solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_37.smt2",
    "description": "The file asserts a single quantified formula over three 32‑bit bit‑vectors x1, x2, x3:  \n\n\\[\n\\exists x_1\\;\\forall x_2\\;\\exists x_3\\;.\\; \\bigwedge\\; \\text{(signed linear equalities and inequalities built from constant multiplications, additions and negations)}.\n\\]\n\nThus it asks whether there is a choice of x1 such that, for every x2, one can pick an x3 making a long conjunction of signed‑comparison constraints (bvslt, bvsle, bvsge, bvsgt, =) true.  The constraints stem from a reduction of redundant linear‑constraint detection in non‑convex polyhedra, and the instance features an ∃∀∃ quantifier alternation, 62 constant‑coefficient multiplications, a maximal term depth of 17 and over a hundred arithmetic atoms, making it a dense, quantified bit‑vector linear arithmetic benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_38.smt2",
    "description": "The instance encodes a quantified bit‑vector linear‑arithmetic problem: a single assertion with an alternating quantifier block ∀x₁ ∃x₂ ∀x₃ ∃x₄ over 32‑bit signed bit‑vectors, where each quantified variable appears in a large conjunction of signed inequalities ( bvslt, bvsle, bvsge, bvsgt ) and equalities built from linear expressions of the form c·x plus constants (realised with bvmul and bvadd). The formula checks whether there exists a witness for the inner existential variables such that all the affine constraints—originating from redundant linear constraints in a non‑convex polyhedral representation—are simultaneously satisfied for every outer universal assignment. The problem features a moderate term depth (16) and many constant multiplications, making it a non‑trivial instance for solvers that must handle four‑alternating quantifiers and a dense conjunction of linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_41.smt2",
    "description": "The benchmark encodes a quantified linear‑arithmetic problem over 32‑bit bit‑vectors: two universal variables (x1, x3) and two existential variables (x2, x4) are alternated (∀x1 ∃x2 ∀x3 ∃x4) and must satisfy a large conjunction of equalities and signed (in)equalities in which each term is a constant‑scaled multiplication of one of the variables. All constraints are linear combinations of the four variables with many different coefficients, forming a dense system that tests the solver’s ability to handle deep term nesting (depth ≈ 21) and a four‑alternation quantifier prefix. The instance originates from work on removing redundant linear constraints in non‑convex polyhedra, thus its purpose is to check the satisfiability of a complex quantified polyhedral specification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_12.smt2",
    "description": "The file encodes a quantified verification problem over 32‑bit signed bit‑vectors: it asserts a single ∀ ?x1 ∃ ?x2 ∀ ?x3 ∃ ?x4 formula that is a large Boolean combination of linear (affine) inequalities, disequalities and order predicates, all built from constant‑multiplications, additions and negations. The goal is to decide whether this ∀∃∀∃ property holds, which corresponds to checking an implication (or redundancy) among a set of linear constraints that model a non‑convex polyhedron. The benchmark is challenging for BV solvers because it features two quantifier alternations, deep term nesting (depth 18), and a high density of arithmetic operations (≈80 multiplications and 60 additions) despite a modest number of variables (four).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_50.smt2",
    "description": "The benchmark encodes a quantified linear‑arithmetic reachability check: under the prefix **∃ ?x₁ ∀ ?x₂ ∃ ?x₃** it asks whether there is a 32‑bit signed value for ?x₁ such that for every 32‑bit signed value of ?x₂ there exists a 32‑bit signed value of ?x₃ satisfying a huge disjunction of linear inequalities and equalities (all of the form c·?xᵢ + c′·?xⱼ + c″·?xₖ ⋈ const, with ⋈ ∈ {<,≤,≥,>}=).  \n\nThe constraints arise from the redundancy‑removal step for non‑convex polyhedra, and the instance contains about 200 scalar multiplications, 58 disjunctions and 44 conjunctions, with a maximum term depth of 19, making it a demanding case for solvers because of the alternation of quantifiers and the size of the Boolean combination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_55.smt2",
    "description": "The instance is a quantified bit‑vector satisfiability problem over three 32‑bit variables x1, x2, x3, encoded as ∃x1 ∀x2 ∃x3 ⋀ C, where C is a huge conjunctive block of linear equalities and signed inequalities built from constant‑scaled multiplications (bvmul) and additions (bvadd).  The constraints model a dense system of linear relationships (the original research used them to detect redundant linear constraints in non‑convex polyhedra) and challenge the solver with a deep term hierarchy (depth 23), three quantifier alternations, and hundreds of arithmetic atoms (over 500 bvadd, 470 bvmul, 400 bvneg).  Consequently the benchmark tests a solver’s ability to handle quantified BV arithmetic, quantifier instantiation/interpolation, and large‑scale conjunctive reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_48.smt2",
    "description": "The instance asks whether there exists a 32‑bit value x₁ such that for every 32‑bit value x₂ there is a 32‑bit value x₃ satisfying a massive Boolean combination of linear bit‑vector constraints (equalities, signed ≤/≥, and strict orderings) that involve only additions, constant multiplications and negations.  It features an ∃ ∀ ∃ quantifier alternation, deep term nesting (depth 19) and a very high count of constant‑multiplication terms (over 150 occurrences), making it a stress test for solvers handling quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_16.smt2",
    "description": "The file asserts a single quantified bit‑vector formula over three 32‑bit signed variables: “∃ ?x₁ ∀ ?x₂ ∃ ?x₃ · Φ(?x₁,?x₂,?x₃)”, where Φ is a large Boolean combination of linear constraints of the form **c₁·?x₁ + c₂·?x₂ + c₃·?x₃ ⧏ k** (signed ≤, ≥, <, > or equality), with all coefficients and constants given as bit‑vector literals. The instance therefore asks whether there is a value for ?x₁ such that, for every ?x₂, some ?x₃ can be chosen to satisfy all those signed linear inequalities. It features three quantifier alternations, a maximum term depth of 16, and many constant‑coefficient multiplications (≈60 bvmul nodes), making it a challenging quantitative‑BV satisfiability problem typical of redundancy‑removal benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_51.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem that asks whether there exists a 32‑bit value ?x1 such that for every 32‑bit value ?x2 a suitable 32‑bit value ?x3 can be found making a huge disjunction of linear arithmetic literals (constant‑multiplied variables compared with each other via signed ≤, <, ≥, > and equality) true.  The formula is built from a single quantified (∃ ?x1 ∀ ?x2 ∃ ?x3) prefix followed by an extensive combination of bvadd, bvmul, bvneg and relational operators, yielding over 500 bvadd and nearly 500 bvmul occurrences, a term depth of 20 and many nested and/or structures.  The main difficulty stems from the three‑level quantifier alternation together with the large number of linear constraints, making it a challenging instance for BV‑solvers and interpolation‑based approaches.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_40.smt2",
    "description": "The file encodes a quantified linear‐arithmetic feasibility problem over 32‑bit bit‑vectors: it asserts a single ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ block in which a large conjunction of linear equalities and inequalities (built from many bvmul and bvadd terms with constant coefficients) must hold. The goal is to decide whether the alternating‑quantifier formula is satisfiable, i.e., whether for every choice of x₁ there exists an x₂ such that for every x₃ an x₄ can be found satisfying all those constraints. The instance is hard because it contains deep (depth 20) arithmetic terms, a high count of multiplications (≈ 240) and additions, and four quantifier alternations, creating a dense, non‑convex polyhedral condition in bit‑vector logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_32.smt2",
    "description": "The file encodes a prenex quantified bit‑vector formula of the shape ∀x₁ ∃x₂ ∀x₃ ∃x₄ · Φ, where Φ is a large conjunction of linear (and some non‑linear) inequalities built from 32‑bit multiplications, additions, negations and signed comparisons.  It originates from a study on eliminating redundant linear constraints in non‑convex polyhedra, so the goal is to decide whether there exists a choice of the existential variables that makes all of the many arithmetic constraints true for every choice of the universal variables.  The instance is challenging because it contains a deep term structure (depth ≈ 19), a high count of bvmul/bvadd operations (over 200 multiplications), and two quantifier alternations, which together stress quantifier‑instantiation and non‑linear reasoning in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_50.smt2",
    "description": "The file encodes a quantified bit‑vector SAT problem: **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄** a large conjunction of linear equalities and (in)equalities over 32‑bit vectors, each built from additions, constant multiplications and negations. The constraints form a dense system of arithmetic literals (over 300 bvmul and 260 bvadd terms) with a maximal term depth of 21, so the instance tests a solver’s ability to handle deep, quantified linear arithmetic on bit‑vectors. The alternating quantifier pattern and sheer number of arithmetic atoms make the problem particularly demanding for quantifier‑instantiation and reasoning engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_21.smt2",
    "description": "This instance is a quantified bit‑vector satisfiability problem (∃x₁ ∀x₂ ∃x₃) that encodes a set of linear‑integer (BV) constraints derived from the redundancy‑removal test for non‑convex polyhedra. The body consists of a large Boolean combination of equalities and signed inequalities built from constant‑multiplied variables, additions and negations, resulting in 95 multiplications, 61 additions and a nesting depth of 17. The alternation of three quantifiers, the high term count, and the dense mix of bvslt/bvsle/bvsgt/bvsge predicates make the formula a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_9.smt2",
    "description": "The benchmark is a quantified bit‑vector satisfiability problem that encodes a small system of linear integer constraints (multiplications by constant 32‑bit coefficients, additions, and signed comparisons) with an alternating quantifier pattern ∀x₁ ∃x₂ ∀x₃ ∃x₄.  The single top‑level assertion states that, for every choice of the outer variable, there exists a witness for the next variable such that a disjunction of conjunctions of equalities and inequalities over the four variables holds; essentially it asks whether the quantified linear polyhedron described by the constraints is non‑empty.  The instance’s difficulty stems from the four‑alternation quantifier prefix and the relatively deep (depth 15) arithmetic terms rather than from the number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_30.smt2",
    "description": "The file encodes a quantified bit‑vector feasibility problem: for every 32‑bit value x₁ there must exist an x₂ such that for every x₃ there exists an x₄ satisfying a large conjunction of signed linear (affine) constraints built from constant multiplications, additions and comparisons. It is essentially a non‑convex polyhedral feasibility check expressed in the BV‑logic with two quantifier alternations (∀∃∀∃), a deep term nesting (depth 18) and over a hundred constant‑multiplication terms, which makes it a challenging benchmark for quantifier‑handling and interpolation‑based solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_30.smt2",
    "description": "The benchmark encodes a quantified bit‑vector arithmetic problem: three 32‑bit signed variables x1, x2, x3 are bound by an ∃x1 ∀x2 ∃x3 prefix, and the matrix consists of a large disjunction of linear equalities and inequalities formed with constant multiplications, additions and signed comparisons. Satisfiability asks whether there exists a value for x1 such that, for every x2, some x3 can be chosen to satisfy all these combined polyhedral‑style constraints (originally derived from a non‑convex polyhedron redundancy check). The instance is challenging because of the alternation of quantifiers, deep term nesting (depth 16) and the heavy use of bit‑vector arithmetic operators, which together create a demanding quantified‑BV solving task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_4.smt2",
    "description": "The file encodes a quantified bit‑vector problem with four 32‑bit variables that appear under the quantifier pattern ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄.  The quantified formula is a large Boolean combination of linear signed inequalities (bvslt, bvsgt, bvsge) and equalities, each built from many constant‑scaled additions and multiplications (bvmul, bvadd, bvneg).  Because of the two alternations of ∀/∃, the depth‑15 arithmetic terms, and the dense mixture of conjunctive/disjunctive constraints, the instance is a challenging QBV‑logic benchmark that tests a solver’s ability to handle nested quantifiers over linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_33.smt2",
    "description": "The benchmark encodes a four‑alternation quantified problem over 32‑bit signed bit‑vectors: ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ · Φ, where Φ is a large Boolean combination of linear equalities and (in)equalities (e.g., bvslt, bvsle, bvsge, bvsgt) built from additions, multiplications by constant coefficients and a few let‑bindings.  The instance asks whether, for every choice of x₁, there are values of x₂ and x₄ that can satisfy all of the given linear constraints for all possible x₃, thus testing a solver’s ability to handle alternating quantifiers, deep term nesting (depth 17) and a dense set of linear bit‑vector arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_2.smt2",
    "description": "The benchmark encodes a quantified bit‑vector linear‑arithmetic problem: a formula with the quantifier pattern ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ over 32‑bit signed integers, containing a conjunction of linear inequalities, disequalities and equalities built from constant multiples (e.g., bvmul with concrete constants) and additions. The solver must decide whether the nested ∀∃∧‑constraints are satisfiable, which amounts to checking a Σ₂‑style property (essentially a safety/invariant condition) on a non‑convex polyhedral region. The instance is moderate in size (four quantified variables, term depth 16) but hard for solvers because of the alternating quantifiers and the dense mixture of signed comparisons (bvsge, bvsle, bvslt, bvsgt) and arithmetic expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_59.smt2",
    "description": "This instance is a quantified bit‑vector decision problem that asks whether the alternating quantifier prefix  \n\n  ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄  \n\ncan satisfy a massive conjunction of linear arithmetic constraints over 32‑bit variables.  All constraints are built from additions, constant multiplications (both positive and negative), and relational operators (≤, ≥, <, >, =), yielding a dense system of linear inequalities and equalities reminiscent of a non‑convex polyhedral feasibility check.  The formula features deep term nesting (depth 23), four quantified variables, and hundreds of arithmetic operations, making it a challenging SAT/SMT problem with two quantifier alternations and a large, highly redundant constraint set.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_58.smt2",
    "description": "This instance encodes a quantified bit‑vector problem in the BV logic: a single formula with a ∀∃∀∃ alternation over four 32‑bit variables (x1…x4) that are each multiplied by many constant coefficients and combined with additions and signed comparisons (≤, <, ≥, >) and equalities. The core task is to decide the satisfiability (or validity) of this massive conjunction of linear‑arithmetic‑style constraints, which features deep term nesting (up to depth 20), a large number of arithmetic operations (over 200 multiplications and 180 additions), and numerous Boolean connectives, making it a challenging benchmark for quantifier‑handling and bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_35.smt2",
    "description": "The instance asks whether the quantified bit‑vector sentence  \n\n\\[\n\\exists \\;x_1\\;\\forall \\;x_2\\;\\exists \\;x_3\\;.\\;\\Phi(x_1,x_2,x_3)\n\\]\n\nholds, where Φ is a large conjunction of signed linear constraints built from 32‑bit multiplications by constant coefficients, additions, and inequalities ( bvslt, bvsle, bvsge, bvsgt ).  The formula is a randomly generated, heavily nested benchmark (≈ 150 multiplications, depth 18) that tests SMT solvers’ ability to handle alternating quantifiers and deep arithmetic terms in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_49.smt2",
    "description": "The instance formulates a quantified linear‑arithmetic property over four 32‑bit bit‑vector variables:  \n\\[\n\\forall x_1\\;\\exists x_2\\;\\forall x_3\\;\\exists x_4\\;.\\;\\Phi(x_1,x_2,x_3,x_4)\n\\]  \nwhere \\(Φ\\) is a massive Boolean combination of signed inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`), equalities and constant multiplications (`bvmul`) with depths up to 20.  It essentially asks whether the given set of linear constraints (derived from a non‑convex polyhedral representation) holds for all possible outer assignments, and its difficulty stems from the alternating quantifier pattern together with a high number of arithmetic terms (267 multiplications, 210 additions) and deep nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_34.smt2",
    "description": "The file encodes a quantified bit‑vector satisfiability problem: it asks whether there exist 32‑bit values x₁ such that for all 32‑bit values x₂ there exist 32‑bit values x₃ satisfying a large Boolean combination of linear arithmetic constraints (equalities, signed ≤, ≥, <, >) built from constant‑multiplications, additions and negations.  The formula, originating from a benchmark on redundant linear constraints, contains a single quantifier alternation (∃ ∀ ∃), 130 multiplications and a nesting depth of 17, which together make the instance challenging for BV solvers that must handle deep term structures and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_17.smt2",
    "description": "The instance encodes a quantified feasibility problem over 32‑bit signed bit‑vectors: it asks whether there exists a value for ?x1 such that for every value of ?x2 there is a value of ?x3 satisfying a conjunction of linear (affine) inequalities and equalities built from additions, constant multiplications, and negations. The formula contains a three‑level quantifier alternation (∃ ∀ ∃) and a relatively deep term structure (depth 15) with many constant‑coefficient multiplications, making it a challenging case for BV solvers that must handle both quantifier reasoning and signed arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_42.smt2",
    "description": "The instance encodes a feasibility check for a highly conjoined system of 32‑bit linear constraints that model the redundancy‑removal problem for non‑convex polyhedra.  Boolean variables b17…b24 represent the presence or absence of individual linear inequalities, and the formula combines them with a universal quantifier over a parameter λ and an existential quantifier over λ′, linking the inequalities through affine expressions (e.g., x4 + 60·λ, x3 − λ/20, etc.).  The solver must decide whether there exists an assignment to the Boolean flags and the quantified parameters that satisfies all nested arithmetic bounds, a task made difficult by the deep term nesting (depth ≈ 112) and the large number of Boolean conjunctions/disjunctions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_5.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem that checks a universally quantified parameter λ (32‑bit) against a set of linear constraints derived from the constants x3, x4 and several fixed bounds. For every λ the formula requires either the existence of a witness λ′ satisfying a conjunction of linear inequalities (including range limits on λ′ and bounds on expressions x3 − 3·λ′ and x4 + 20·λ′) or that λ is negative, while additional optional constraints are guarded by Boolean flags bool.b17‑b20. This yields a single ∀∃ quantifier alternation with deep nested arithmetic (term depth 19) and many Boolean‑controlled sub‑terms, making it a challenging industrial‑style bit‑vector satisfiability check used for detecting redundant linear constraints in non‑convex polyhedral models.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_17.smt2",
    "description": "The instance encodes a verification problem for a guarded system of linear integer inequalities translated to 32‑bit bit‑vectors. It asserts that for every value of the variable λ (lambda) either a smaller value λ′ exists satisfying a range of bounded constraints (e.g., 0 ≤ λ′ ≤ λ and several bvsle comparisons against constants like ‑4100, ‑4500, ‑4910, 4820, ‑10) under a conjunction of Boolean condition flags, or λ is negative, or a complex Boolean combination of those flags holds. This universally‑quantified formula, with an inner existential quantifier, deep term nesting (depth 29) and many Boolean‑guarded arithmetic constraints, models the detection of redundant linear constraints in a non‑convex polyhedral representation, making it a challenging industrial BV‑logic instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_15.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem that originates from detecting redundant linear constraints in a non‑convex polyhedral representation. It asserts, for every 32‑bit value λ, either a deep conjunctive condition holds (involving an existentially‑quantified λ′, several linear “affine” expressions such as x4 + 40·λ′, x3 + ½·λ′ and bound checks against constants like ‑30, ‑10, ‑4100, ‑4500, ‑4910) together with a specific Boolean pattern of the flags bool.b22, bool.b7, bool.b5, bool.b6, or else λ is negative; the formula therefore checks whether a certain region of the parameter space can be ruled out as redundant. The problem features a single quantifier alternation (∀λ ∃λ′) with a large conjunction of Boolean and bit‑vector arithmetic literals, a maximal term depth of 19, and multiple multiplication, division and signed‑comparison operators, making it a challenging instance for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_12.smt2",
    "description": "The benchmark encodes a quantified redundancy‑check for a family of linear (bit‑vector) constraints that model a non‑convex polyhedron: for every 32‑bit bound λ it requires either a witness λ′ satisfying a cascade of signed‑inequalities on x3, x4 and x5 (combined with Boolean flags bool.b22, bool.b7, bool.b5, bool.b6), or λ is negative, or the flag combination is inconsistent.  This yields a ∀∃ pattern with deep nested arithmetic (multiplications, additions, and signed comparisons) and many Boolean conjuncts, a typical industrial verification task that is hard because of the single quantifier alternation and the high term depth (≈19).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_67.smt2",
    "description": "The file encodes a feasibility check for a heavily‑parameterised system of linear inequalities that model a non‑convex polyhedron.  The core formula quantifies universally over a 32‑bit “λ” and existentially over a 32‑bit “λ′”, and combines dozens of Boolean selector variables (bool.b*) with bit‑vector additions, multiplications and signed divisions to represent bounds such as bvadd x₃ − λ ≤ 1150, bvadd x₅ + λ′ ≥ ‑10, etc.  The solver must decide whether there exists an assignment to the selector Booleans and to λ′ (within the range 0 ≤ λ′ ≤ λ) that satisfies all of these signed‑inequality constraints; this is essentially a redundancy/consistency check for a set of linear constraints translated to bit‑vectors.  The instance is difficult because it contains a single massive quantified conjunct with deep nesting (max term depth ≈ 54), over 120 ∧/¬ atoms, and both ∀/∃ quantifier alternation, leading to a highly combinatorial search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_9.smt2",
    "description": "The file encodes a quantified bit‑vector verification problem that asks whether, for every 32‑bit value λ, there exists a 32‑bit value λ′ satisfying a collection of linear‑integer‑like constraints (sums, multiplications by constant coefficients, and signed comparisons) together with three Boolean control flags (bool.b17, bool.b18, bool.b19). The core formula is a ∀λ ∃λ′ pattern that combines range restrictions (0 ≤ λ′ ≤ λ) with several conditional inequalities of the form bvadd x3 + c·λ ≤ k and bvadd x4 + c·λ ≤ k, where the constants (e.g., ‑4100, ‑4500, ‑4910) appear in nested negated comparisons. The instance is modest in size (five declared bit‑vectors, one quantified assertion) but features a quantifier alternation and deep term nesting (depth 17), making it a non‑trivial benchmark for bit‑vector solvers handling quantified linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_39.smt2",
    "description": "The instance encodes a single, highly nested SAT‑check over 32‑bit bit‑vectors that originates from a redundancy‑removal problem for non‑convex polyhedra: a universal quantifier over a parameter λ and an existential quantifier over a candidate λ′ are combined with a large Boolean control‑vector (bool.b20 … bool.b24) that selectively activates dozens of linear inequalities (bounds on expressions such as x4 + 60·λ, x3 − 3·λ, etc.).  The formula therefore asks whether there exists a concrete λ′ (within the range 0 ≤ λ′ ≤ λ) satisfying a complex conjunction of signed‑less‑or‑equal constraints whose activation is governed by the Boolean flags, while simultaneously respecting numerous derived consistency conditions expressed by the universal part.  The problem is a pure satisfiability (verification) task with a deep term hierarchy (depth ≈ 142), many Boolean‑to‑arithmetical couplings, and a single quantifier alternation, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_56.smt2",
    "description": "The file encodes a quantifier‑heavy verification query that tests the redundancy of a set of linear (integer) constraints describing a non‑convex polyhedron.  The universally quantified variable λ and the existentially quantified λ′ appear inside a large Boolean combination of 32‑bit bit‑vector inequalities (additions, multiplications, divisions and signed comparisons) together with a handful of Boolean flags (bool.b5, bool.b22, …) that model whether particular constraints are asserted.  The solver must decide whether there exists an assignment to the flags and to λ such that all the nested “≤”, “<” and arithmetic relations hold (or equivalently, whether a supposed redundant constraint can be removed without making the system unsatisfiable), a task made difficult by the deep term nesting (depth 42), many conjuncts/disjuncts and the interplay of universal and existential quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_11.smt2",
    "description": "The instance encodes a quantified verification condition on 32‑bit linear arithmetic that originates from the removal of redundant linear constraints in a non‑convex polyhedral representation.  It asserts that for every value λ (the universally‑quantified bit‑vector) either a witness λ' (existentially quantified and bounded by 0 ≤ λ' ≤ λ) can be found that satisfies a set of linear bound checks involving the constants x₃, x₄ and three Boolean flags (bool.b17‑b19), or λ is negative, or a simple inequality between the two linear expressions fails.  The problem is a single‑alternation quantified bit‑vector SAT query (∀ λ ∃ λ') with moderate term depth (17) and several nested arithmetic operations, making it a typical industrial QBV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_47.smt2",
    "description": "The instance encodes the satisfiability of a quantified set of linear‑inequality constraints over 32‑bit bit‑vectors that model a non‑convex polyhedral region together with a collection of Boolean guard variables. It contains a single universal quantifier over λ and an existential quantifier over λ′, expressing relationships among the variables x3, x4, x5 and the guards (e.g., bounds like bvsle, bvslt, and arithmetic combinations such as bvadd, bvmul, bvsdiv). The formula is a deep (≈22‑level) conjunction of arithmetic and propositional conditions, making it a challenging quantified BV‑satisfiability problem typical of industrial redundancy‑removal / polyhedral verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_52.smt2",
    "description": "The file encodes a satisfiability query that models a verification problem on a non‑convex polyhedral region expressed with signed 32‑bit‑vector linear inequalities. A universally‑quantified variable λ (and an existentially‑quantified λ′) must satisfy a large conjunction of signed‑less‑than/equal constraints that are guarded by a collection of Boolean parameters (bool.b5 … bool.b23); the formula essentially asks whether, for every admissible λ, the guarded constraints admit a λ′ that keeps the whole system consistent—i.e., whether certain linear constraints are redundant or can be simultaneously satisfied. The instance is difficult because it contains a single ∀∃ quantifier alternation, a deep nesting of arithmetic terms (depth 43), and many Boolean combinations (≈70 and, 60 not), making it a challenging industrial BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_26.smt2",
    "description": "The file encodes a quantified bit‑vector feasibility check that originates from the removal of redundant linear constraints in a non‑convex polyhedron: a universally‑quantified 32‑bit variable ?lambda is required to satisfy a complex Boolean combination of signed inequalities involving three parameters (x3, x4, x5) and an existentially‑quantified 32‑bit variable ?lambdaprime that must lie between 0 and ?lambda.  The Boolean flags (bool.b5 … bool.b23) model the presence or absence of individual linear constraints, and the formula essentially asks whether, for every possible λ, there exists a λ′ respecting the bounds such that the selected constraints are simultaneously consistent.  The problem features a single ∀∃ quantifier alternation, a depth‑21 term structure, 12 Boolean variables and several signed arithmetic operations (bvmul, bvadd, bvsdiv, bvsle, bvslt), making it a challenging quantified BV‑SAT instance typical of industrial verification/invariant‑checking workloads.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_31.smt2",
    "description": "The instance encodes a redundancy‑check for a set of linear inequalities that describe a non‑convex polyhedron.  After translating the inequalities into 32‑bit bit‑vector arithmetic, the formula asserts that for **every** integer λ either (i) there exists a λ′ satisfying a conjunction of arithmetic bounds (expressed with `bvmul`, `bvadd`, `bvsle`, etc.) together with a pattern of Boolean guard variables (bool.b5, bool.b6, …), or (ii) λ is negative, or (iii) a particular Boolean combination is false.  Thus the solver must decide the truth of a quantified BV formula with one ∀∃ alternation and a deep nesting of Boolean conjuncts, which stems from the industrial task of detecting and removing redundant linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_22.smt2",
    "description": "The instance encodes a quantified bit‑vector check that corresponds to a redundancy‑detection problem for a set of linear constraints defining a non‑convex polyhedron: a universal variable λ is examined together with an existential witness λ′, while Boolean control variables (bool.b20 … bool.b23) toggle the presence of individual inequality constraints (e.g., bvsle expressions such as λ′·40 + x4 ≤ 45, x3 − 3·λ′ ≤ 20, and global bounds like ≤ 600, ≤ 4820).  The formula asks whether, under all possible λ (or λ < 0), the combination of these guarded constraints can be satisfied, effectively testing if a particular linear bound is redundant.  The problem features a single ∀∃ quantifier alternation, deep nested Boolean structure, and several bit‑vector arithmetic operations, making it a non‑trivial industrial‑style SMT‑BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_36.smt2",
    "description": "This benchmark encodes the redundancy‑checking problem for a set of linear inequalities that define a non‑convex polyhedron. The inequalities are translated to 32‑bit bit‑vector arithmetic (e.g., `bvadd`, `bvmul`, `bvsle`) and are guarded by Boolean selector variables (`bool.b17` … `bool.b24`) that indicate whether each constraint is kept; a universal quantifier over a parameter λ and an existential quantifier over a witness λ′ are used to capture the admissible range of the parameters. The formula is a massive conjunction of Boolean combinations (≈ 500 `and`s, 400 `not`s) with a deep nesting depth (≈ 144), making it an industrial‑scale SAT/SMT instance that tests the solver’s ability to handle quantifier alternation and highly tangled Boolean‑arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_7.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem in which, for every 32‑bit value ?λ, one must either find a 32‑bit witness ?λ′ within the interval [0, ?λ] satisfying several linear inequalities (e.g., x₃ − 3·?λ′ ≤ 45, x₄ + 60·?λ′ ≥ ‑4100, ‑4500, ‑4910) guarded by Boolean flags (bool.b17–bool.b20), or show that ?λ is negative, or falsify a conjunction of related bound constraints.  The formula corresponds to checking redundancy of linear constraints in a non‑convex polyhedral representation, using a combination of universal and existential quantifiers together with nested Boolean combinations of signed‑less‑equal/less‑than relations on 32‑bit arithmetic.  The presence of a single ∀∃ quantifier alternation, deep term nesting (depth 19), and many intertwined Boolean literals makes the problem challenging for SMT solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_37.smt2",
    "description": "The benchmark encodes the feasibility of a guarded system of linear (in)equality constraints that model a non‑convex polyhedron: a 32‑bit quantified variable λ must satisfy dozens of arithmetic bounds (additions, multiplications and signed comparisons) whose activation is controlled by Boolean flags bool.b (i.e. optional constraints).  A single universal quantifier over λ together with an existential quantifier over λ′ expresses the requirement that for every λ in a given interval there exists a λ′ respecting all selected constraints, while the surrounding Boolean network encodes redundancy‑removal conditions from the cited paper.  The formula’s depth (≈137) and the massive conjunction of and/not‑combinations make it a challenging BV‑SAT instance that essentially tests consistency of a heavily conditioned linear‑arithmetic model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_11.smt2",
    "description": "The formula checks the existence of a pair of 32‑bit integers λ and λ′ that satisfy a collection of guarded linear inequalities over the constants x3, x4, x5 and several Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6). It is expressed as a universally‑quantified condition on λ with an inner existential witness λ′, combining simple bit‑vector arithmetic (addition, multiplication by small constants, signed comparisons) and a Boolean conjunctive/disjunctive structure. This encodes a verification task—testing whether the guarded polyhedral constraints (originating from redundant linear constraints in a non‑convex polyhedron) are simultaneously feasible— and is challenging due to the quantifier alternation and the interleaving of arithmetic and Boolean reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_76.smt2",
    "description": "The model encodes a feasibility check for a large system of 32‑bit linear arithmetic constraints that arise from a non‑convex polyhedral representation.  The constraints are expressed as signed‑less‑equalities (bvsle) on linear combinations of the integer variables x3, x4, x5 and the parameters λ and λ′, with many Boolean flags (bool.b*) turning individual inequalities on or off; a universal quantifier ranges over λ and an existential quantifier ranges over λ′, together with bounds linking the two.  The instance is essentially a verification/satisfiability problem for a highly conditioned polyhedral region, whose difficulty stems from the deep term nesting (depth ≈ 77) and the dense combination of negations and conjunctions rather than from a large number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_21.smt2",
    "description": "The formula is a quantified bit‑vector encoding of a redundancy‑check for linear constraints that arise in the representation of a non‑convex polyhedron. It asserts that for every 32‑bit parameter λ there must exist a 32‑bit λ′ (0 ≤ λ′ ≤ λ) satisfying several affine inequalities (e.g., −(x5+λ) ≤ −10, x4+20·λ′ ≤ −4100, x3−3·λ′ ≤ 0) together with a complex Boolean combination of Boolean flags (bool.b5, bool.b22, …) that model the presence or removal of individual constraints. The instance features a single ∀∃ quantifier alternation, deep nesting of let‑bindings (max term depth 25), and many Boolean connectives, making it a challenging verification‑style problem that tests a solver’s ability to handle quantified bit‑vector arithmetic and large Boolean search spaces.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_40.smt2",
    "description": "The file encodes a quantified bit‑vector linear‑arithmetic verification problem that originates from the detection of redundant linear constraints in a non‑convex polyhedral model. It asserts, for every 32‑bit variable λ, a large Boolean conjunction of guarded inequalities over three numeric variables (x3, x4, x5) together with a nested existential quantifier over a second 32‑bit variable λ′; the constraints combine addition, multiplication, division and signed ≤/< comparisons with many Boolean flags (bool.b*). The combination of a ∀∃ quantifier pattern, deep term nesting (depth 26) and a dense mixture of arithmetic and Boolean logic makes the instance a hard industrial‑style SAT/verification benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_25.smt2",
    "description": "The formula encodes the feasibility of a set of 32‑bit linear constraints that arise from a non‑convex polyhedral representation, with a universal‑existential quantifier pattern modelling “for every λ there must exist a λ′ satisfying a subset of the constraints”.  The constraints are expressed as bit‑vector arithmetic (additions, multiplications and divisions by constant coefficients such as 40, 20, 800) together with a collection of Boolean flags (bool.b17 … bool.b23) that turn individual inequalities on or off, and the final check asserts that a certain combination of these inequalities cannot all hold simultaneously.  The benchmark features a single large quantified assertion with deep nesting (term depth 40) and many Boolean auxiliaries, making it a typical industrial redundancy‑detection / verification problem for SMT solvers handling quantifier alternation and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_63.smt2",
    "description": "The file encodes a redundancy‑checking problem for a set of linear (affine) constraints that have been translated to 32‑bit bit‑vector arithmetic.  A single quantified assertion combines a universal quantifier over a parameter λ and an inner existential quantifier over λ′, together with a large Boolean combination of signed‑less‑equal (bvsle), additions, multiplications and divisions that correspond to the original linear inequalities and a collection of Boolean “guard” flags (bool.b17 … bool.b24).  The solver must decide whether the whole conjunction is satisfiable, i.e., whether there exists an assignment to the Boolean guards and the variables (x3, x4) that violates the redundancy property.  The instance is difficult because it features deep nesting (max term depth 91), many let‑bindings, a high count of logical operators (≈300), and both universal and existential quantifiers, creating a complex search space for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_27.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem that models a set of linear (affine) inequalities over 32‑bit variables x3, x4 and x5, guarded by Boolean flags (bool.b5 … bool.b23). It asserts that for every value λ (and for some λ′ with 0 ≤ λ′ ≤ λ) the collection of scaled inequalities (e.g., ‑(x3+λ′) ≤ ‑20, ‑(x4+20·λ′) ≤ ‑4100, ‑(x5+λ′) ≤ ‑10, …) holds according to the chosen combination of Boolean predicates, while also enforcing additional consistency conditions on those predicates. The formula features a single ∀∃ quantifier alternation, deep nesting of conjunctive/disjunctive Boolean structure and several arithmetic terms of depth 20, making it a non‑convex polyhedral redundancy‑checking instance that is challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_3.smt2",
    "description": "The formula asserts that for every 32‑bit integer λ one of three alternatives must hold: (i) there exists a 32‑bit integer λ′ that satisfies a set of linear‑inequality constraints on the expressions x3 − λ′ and x4 + 40·λ′ together with several Boolean flags (bool.b17 … bool.b20); (ii) λ is negative; or (iii) a particular conjunction of those Boolean flags and the same arithmetic bounds is false.  This encodes the verification of redundancy‑removal conditions for linear constraints in a non‑convex polyhedral model, translated into bit‑vector arithmetic.  The problem features a single forall‑exists quantifier alternation, multiple nested let‑bindings, and deep term structure (depth 19), which together contribute to its solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_58.smt2",
    "description": "The formula models a feasibility check for a non‑convex polyhedral region expressed as a large system of linear inequalities over 32‑bit signed bit‑vectors (variables x3, x4, x5, λ, λ′) whose activation is controlled by a collection of Boolean flags (bool.b5, bool.b7, …). It asserts that for every value of λ the guarded arithmetic constraints must hold, while there must exist a λ′ within the same interval satisfying another set of guarded bounds, resulting in a ∀‑∃ quantifier pattern with deeply nested arithmetic (add, mul, div, neg) and many Boolean combinations. The combination of numerous Boolean conditions, mixed arithmetic, a quantifier alternation, and a maximal term depth of 40 makes the instance a hard industrial‑style bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_8.smt2",
    "description": "The file encodes a quantified bit‑vector verification condition: for every 32‑bit value λ it must either be negative, satisfy a complex existential clause (∃ λ′ ∈ [0, λ] that makes a collection of signed‑linear inequalities hold) or violate a conjunction of two bounds involving the parameters x₃, x₄ and three Boolean flags (bool.b17‑b19).  The arithmetic constraints are linear but include multiplications by constants (e.g., 20·λ), a signed division by 20, and several large constant offsets (‑4100, ‑4500, ‑4910, 4820, 30), all expressed as bit‑vector operations.  The instance is an industrial‑style verification problem with a single quantified formula that features nested ∀/∃ quantifiers, a mix of Boolean and arithmetic constraints, and relatively deep term nesting (depth 17), which together make it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_4.smt2",
    "description": "The instance encodes a quantified feasibility check for a small system of signed 32‑bit linear constraints that model a non‑convex polyhedral region.  A universally‑quantified variable `lambda` must either be negative (or a particular Boolean combination of the flags `bool.b22`, `bool.b7`, `bool.b5`, `bool.b6` holds) **or** there must exist an integer `lambdaprime` with `0 ≤ lambdaprime ≤ lambda` satisfying a bundle of arithmetic bounds on the expressions `x3‑lambdaprime`, `x4+60*lambdaprime`, and `x5+λ′` (e.g., `x3‑λ′ ≤ 33`, `x3‑λ′ ≤ 40`, `x5+λ′ ≥ -10`, and several stronger lower‑bound alternatives involving constants –4100, –4500, –4910).  The Boolean flags control which of these alternatives are active.  \n\nThus the problem is a satisfiability/verification query with a single ∀∃ quantifier alternation over bit‑vectors, heavily nested conjunctive/disjunctive Boolean structure and deep arithmetic terms, typical of industrial constraints generated from redundancy‑removal for non‑convex polyhedra.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_55.smt2",
    "description": "This instance formulates a feasibility‑checking problem over 32‑bit integer variables **x3, x4, x5** together with two quantified parameters **lambda** (universally quantified) and **lambdaprime** (existentially quantified). A large Boolean control vector (bool.b5, bool.b6, …) guards a dense network of linear inequalities (bounds such as ≤ 40, ≤ 20, ≤ 30, ≤ 50, ≤ 610, ≤ 1200, etc.) that are expressed with bit‑vector arithmetic (addition, multiplication, negation, division). The formula asks whether for every λ in a certain interval all guarded constraints hold, or equivalently whether there exists a λ′ (with 0 ≤ λ′ ≤ λ) that violates a subset of them, essentially encoding a redundancy‑removal/invariant‑checking condition for a non‑convex polyhedral model. The problem is challenging because it combines deep (≈47) term nesting, many Boolean combinators (≈180 occurrences of and/not), and both universal and existential quantifiers over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_64.smt2",
    "description": "The file encodes a bit‑vector satisfiability check for a large system of linear (affine) inequalities over 32‑bit variables (x3, x4, λ, λ′) together with a collection of Boolean flags (bool.b17 … bool.b24) that represent the activation of individual constraints.  A universal quantifier ranges over λ, requiring a complex conjunction of bounded‑difference constraints (bvadd, bvmul with constant coefficients and divisions) to hold, while an existential quantifier introduces λ′ together with additional lower‑bound conditions; the overall formula is a massive Boolean combination of these arithmetic predicates.  The instance is hard for solvers because it contains a quantifier alternation (∀ λ ∃ λ′), very deep nesting of NOT/AND (term depth ≈ 75), and hundreds of small arithmetic sub‑terms, reflecting the verification of redundant‑constraint removal in a non‑convex polyhedral model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_2.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem that checks the consistency of a set of linear (affine) constraints over 32‑bit integers. A universally‑quantified variable λ is related through an existentially‑quantified λ′ to a collection of inequalities involving the constants x3, x4, x5 and several Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6) that enable or disable individual constraints; the formula asserts that for every λ either a complex conjunction of bounded‑difference constraints holds (or λ is negative). The problem features a single forall‑exists alternation, moderate term depth (≈19) and many nested Boolean combinations, making it a non‑trivial quantified BV instance typical of industrial verification of redundant linear constraint elimination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_35.smt2",
    "description": "The file encodes a quantified bit‑vector verification problem that originates from the redundancy‑removal technique for non‑convex polyhedral representations described in the cited SMT‑08 paper. It asserts that for every 32‑bit integer λ (bounded between 0 and a symbolic limit λ) and for some λ′, a large conjunction of linear inequalities (e.g., x₄ + 40·λ ≤ 4820, x₃ − λ′ ≤ 33, …) together with a set of Boolean selector variables bool.b17 … bool.b24 remain consistent; equivalently, it asks whether any combination of these constraints can be simultaneously satisfied, which corresponds to detecting redundant or contradictory constraints. The formula features one universal and one existential quantifier, ten Boolean constants, and deeply nested Boolean combinations (max term depth 145), making it a challenging industrial‑style quantified BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_59.smt2",
    "description": "The file encodes a feasibility test for a large set of linear (integer) inequalities that arise from a non‑convex polyhedral description, where the inequalities are modeled as 32‑bit bit‑vector arithmetic and are guarded by Boolean flags (bool.b17…bool.b24) that can enable or disable individual constraints. The core formula contains a universal quantifier over a parameter λ and an existential quantifier over λ′, together with a dense nesting of `and`, `or`, and `not` operators and many `bvsle`/`bvslt` comparisons against constant bounds, giving a term‑depth of 90 and over a hundred Boolean sub‑expressions. Consequently the instance is a pure SAT‑check (no additional theory) but its difficulty stems from the deep, highly combinatorial Boolean structure and the alternating quantifiers that force solvers to reason about all possible selections of the guarded constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_38.smt2",
    "description": "The instance encodes a quantified feasibility check for a system of linear (signed‑bit‑vector) inequalities that arise from the redundant‑constraint detection problem for non‑convex polyhedra. It contains a universal 32‑bit variable ?λ, an existential 32‑bit variable ?λ′, a handful of integer parameters (x3, x4, x5) and dozens of Boolean flags that act as selectors, all combined with deep nested conjunctions, disjunctions and signed‑less‑or‑equal comparisons. The solver must decide whether the quantified combination of linear constraints is satisfiable, a task made difficult by the high term depth (36), the alternation of quantifiers, and the large number of Boolean‑conditioned sub‑constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_69.smt2",
    "description": "The instance encodes a feasibility check for a highly guarded system of bounded linear (bit‑vector) inequalities over three 32‑bit variables x3, x4, x5 and two integer parameters λ and λ′. A large Boolean flag vector (bool.b5…bool.b23) selects which of the many linear constraints (expressed with bvadd, bvmul, bvsle, bvsdiv, etc.) are active, and the formula requires that for **all** λ the conjunction of these guarded constraints holds, while there must exist a λ′ (with 0 ≤ λ′ ≤ λ) satisfying a second, similarly guarded set; the outermost disjunction also demands either λ < 0 or a combination of the Boolean flags to be false. The benchmark features a single quantified assertion with one ∀‑quantifier followed by an ∃‑quantifier, deep nesting (term depth 64), and a dense web of ≈130 conjunctions/negations, making it a challenging industrial‑style verification problem in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_38.smt2",
    "description": "This benchmark encodes the satisfiability of a quantified system of 32‑bit linear inequalities that model a non‑convex polyhedron together with a large set of Boolean activation flags (bool.b20 … bool.b24). A universal quantifier over a parameter λ and a subsequent existential quantifier over λ′ are combined with dozens of nested conjunctions, negations and arithmetic constraints (adds, multiplies, divisions and signed‑less‑equal checks), producing a very deep term‑depth (≈139) and a dense Boolean‑logic core (hundreds of and / not). The solver is therefore challenged to reason about mixed Boolean‑arithmetic constraints with quantifier alternation, essentially checking whether the polyhedral description (with optional redundant linear constraints) is feasible.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_10.smt2",
    "description": "The file encodes a quantified bit‑vector verification problem. It asserts that for every 32‑bit value λ, either there exists a non‑negative 32‑bit λ′ ≤ λ satisfying a collection of linear BV constraints involving the free parameters x3, x4 and three Boolean switches (bool.b17, bool.b18, bool.b19), or a simpler linear inequality on λ fails. The constraints are expressed as a conjunction of bounds on affine expressions (e.g., x3 + (−1/20)·λ′, x4 + 60·λ′) together with negated comparisons against constants such as ‑4100, ‑4500, ‑4910, 40 and 33. The instance features a single universal quantifier with a nested existential, a moderate term depth (19), and a handful of Boolean control variables, making it a representative industrial benchmark for quantified BV reasoning and interpolation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_17.smt2",
    "description": "The instance encodes a quantified verification problem over 32‑bit signed integers that models redundancy checking in a non‑convex polyhedral representation.  A universal parameter λ is constrained by two linear signed‑inequality guards (involving the constants x₃, x₄ and the multiplier 30), while a nested existential λ′ (bounded between 0 and λ) together with a collection of Boolean flags (bool.b17…bool.b23) represent the activation of additional linear constraints; the formula asserts that for every λ either such a λ′ exists, λ is negative, or a complex Boolean combination of the flags and the guards holds.  The problem features a single forall/exists alternation, deep term nesting (depth 27) and many Boolean connectives, making it a challenging industrial‑style BV redundancy‑detection benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_3.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem that checks whether, for every 32‑bit value λ, there exists a 32‑bit value λ′ in the interval [0, λ] satisfying a conjunction of linear arithmetic constraints (expressed with additions, multiplications by small constants and signed ≤/< comparisons) together with a fixed Boolean pattern (bool.b22, bool.b7, bool.b5, bool.b6). The formula is a single large‐scale assertion containing a ∀‑λ ∃‑λ′ prefix, numerous nested conjunctions, negations and let‑bindings, and it originates from a translation of redundant‑constraint detection for non‑convex polyhedra into the BV theory. The presence of both universal and existential quantifiers, deep term nesting (depth 19) and several bit‑vector multiplications makes the satisfiability check non‑trivial for current SMT‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_50.smt2",
    "description": "This benchmark encodes the verification of a parametrised, non‑convex polyhedral model where the linear inequalities are guarded by Boolean activation flags (bool.b17 … bool.b24).  Using 32‑bit bit‑vectors, it quantifies universally over a parameter λ (with an inner existential λ′) and asserts a large conjunction of guarded linear bounds (e.g., bvadd x4 + 20·λ ≤ c) together with numerous Boolean combinations that express redundancy‑removal conditions.  The formula features a deep term nesting (depth ≈ 96), many nested let‑bindings, and both ∀/∃ quantifiers, making it a challenging BV‑logic instance of constraint‑consistency/ redundancy checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_33.smt2",
    "description": "The file encodes a quantified bit‑vector formula that models a set of linear inequalities over the 32‑bit variables x3, x4, x5 together with two integer parameters λ and λ′. Boolean constants bool.b* act as switches for individual constraints, and the single asserted clause checks, via a universal quantifier over λ (and an inner existential over λ′), whether the combination of these signed‑comparison constraints can be satisfied—essentially a redundancy‑detection test for a non‑convex polyhedral representation. The problem features deep term nesting (depth 31), a mixture of arithmetic (addition, multiplication, division, negation) and many Boolean combinations, and both ∀ and ∃ quantifiers, which together make the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_49.smt2",
    "description": "The benchmark encodes a consistency/ redundancy check for a non‑convex polyhedral model after it has been translated to 32‑bit signed bit‑vector arithmetic.  A universally quantified parameter λ and an existentially quantified λ′ are constrained by a large collection of linear inequalities (bvsle, bvslt, bvsdiv, bvmul, bvadd) together with Boolean flags bool.b17…bool.b24 that activate or deactivate individual constraints; the formula asks whether there exists an assignment to the Booleans and the numeric variables that satisfies all nested arithmetic conditions (or a simple λ < 0 shortcut).  Because the single assertion contains deep term nesting (depth ≈ 96), many Boolean connectives (≈ 150 not, 140 and) and a quantifier alternation, it represents a heavyweight industrial bit‑vector SAT problem aimed at detecting redundant linear constraints in a non‑convex polyhedral representation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_14.smt2",
    "description": "The instance is a quantified bit‑vector verification problem that models the removal of redundant linear constraints in a non‑convex polyhedral representation. It asserts, for every 32‑bit parameter λ, that either λ is negative, or there exists a witness λ′ in the interval [0, λ] satisfying a set of linear inequalities (e.g., x₃ + ½·λ′ ≥ 0, x₄ + 20·λ′ ≤ 4820) together with Boolean flags bool.b17, bool.b18, bool.b19 that activate three alternative upper‑bound conditions (‑4100, ‑4500, ‑4910). The formula features a single ∀∃ quantifier alternation, moderate term depth (17), and a handful of arithmetic and Boolean operations, making it a typical industrial benchmark for quantifier handling in BV‑SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_1.smt2",
    "description": "The file encodes a quantified bit‑vector verification problem that checks whether a linear inequality on the variables x3 and x4 is implied (or redundant) given a set of other linear constraints guarded by the three Boolean flags bool.b17, bool.b18 and bool.b19.  Formally it asserts that for every 32‑bit integer λ either a witness λ′ in the interval [0, λ] exists making the expression v₀ = −(x4 + 30·λ′) respect the guarded bounds (‑4100, ‑4500, ‑4910), or λ is negative, or the conjunction “x3 ≤ 0 and x4 + 30·λ > 4820” is false.  The instance features a single alternation of quantifiers (∀λ ∃λ′) together with linear bit‑vector arithmetic, a handful of Boolean guards, and a moderate term depth, making it representative of industrial redundancy‑detection tasks for non‑convex polyhedra.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_22.smt2",
    "description": "The file encodes a quantified bit‑vector formulation of a redundancy‑checking problem for a set of linear inequalities that arise from a non‑convex polyhedral model: it asserts that for every 32‑bit parameter λ there must exist a λ′ satisfying a collection of guarded linear bounds (e.g., −(x₅+λ) ≤ −10, −(x₄+40·λ′) ≤ −4100, x₃−3·λ′ ≤ 45, etc.) together with a network of Boolean flags (bool.b5, bool.b22, …) that encode the presence or absence of individual constraints. The formula consists of a single ∀‑∃ quantifier alternation, deep nesting (term depth 25) and many auxiliary Boolean variables, making it a hard industrial‑style verification instance that tests a solver’s ability to handle quantified bit‑vector arithmetic and complex logical combinations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_34.smt2",
    "description": "The file encodes a single, deeply‑nested verification condition for a non‑convex polyhedron expressed in 32‑bit bit‑vector arithmetic.  A universally quantified bit‑vector λ and an existentially quantified λ′ are used together with a set of Boolean flags (bool.b17 … bool.b24) to model a large conjunction of linear inequalities such as  \n`bvsle (bvadd x4 (bvmul 20 λ)) 4820`,  \n`bvsle (bvadd x3 (bvneg λ)) 33`,  \nand several scaled versions of these bounds; the flags capture which of the original linear constraints are assumed to hold.  The solver must decide satisfiability of this massive Boolean‑combination of arithmetic literals, featuring one quantifier alternation, a term depth of 138 and hundreds of nested `and`/`not` expressions, which makes it a challenging industrial‑style redundancy‑removal/verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_5.smt2",
    "description": "The instance encodes a quantified feasibility check for a parameterised system of linear (affine) constraints over 32‑bit integers, modelling the detection of redundant constraints in a non‑convex polyhedral representation. It asserts that for every non‑negative value λ there must exist an intermediate value λ′ (0 ≤ λ′ ≤ λ) satisfying a conjunction of signed‑inequalities involving the constants x3, x4, x5 and several Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6); the outer disjunction also allows the whole formula to hold trivially when λ is negative or when a specific combination of flags is false. The problem features a single ∀∃ quantifier alternation, nested Boolean structure, and deep arithmetic terms (max depth 22), making it a challenging quantified bit‑vector satisfiability instance derived from industrial redundancy‑removal verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_51.smt2",
    "description": "The formula represents a quantified feasibility problem over 32‑bit signed integer variables that model a set of linear inequalities coming from a non‑convex polyhedral representation.  A universal variable ?lambda (and a nested existential ?lambdaprime) are constrained by many derived expressions (sums, constant‑coefficient multiplications and divisions) together with a collection of Boolean flags (bool.b5, bool.b22, …) that encode the presence or removal of individual linear constraints; the overall assertion asks whether there exists a λ (and a λ′ between 0 and λ) satisfying all the signed‑less‑or‑equal bounds such as ≤1150, ≤673, ≥‑10, etc.  The instance therefore checks the consistency of a heavily guarded linear‑constraint system after redundant constraints have been eliminated, featuring a single ∀∃ quantifier pattern, deep let‑nesting (depth 43) and a large number of Boolean conjunctions/disjunctions that make quantifier‑instantiation and bit‑vector reasoning challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_8.smt2",
    "description": "The instance encodes a quantified safety property over 32‑bit integer variables ( λ , λ′ , x₃, x₄, x₅ ) together with a handful of Boolean flags ( bool.b22, bool.b7, bool.b5, bool.b6 ). For every value of λ the formula requires either that a λ′ in the interval [0, λ] satisfies a conjunction of linear bit‑vector constraints (involving additions, multiplications, a signed division and several signed‑less‑or‑equal comparisons with large constants) together with specific Boolean combinations, or that λ is negative, or that the Boolean flags do not simultaneously assume the pattern ¬b22 ∧ ¬b7 ∧ b5 ∧ ¬b6. Thus the problem is a quantified bit‑vector verification task (∀ λ ∃ λ′ …) that checks whether the encoded set of linear constraints is redundant or unsatisfiable under the given Boolean conditions, featuring a single quantifier alternation, moderate term depth (19) and a dense Boolean‑arithmetical structure that makes reasoning challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_62.smt2",
    "description": "The formula encodes a verification condition for a set of linear inequality constraints that have been translated to 32‑bit bit‑vector arithmetic.  It asserts that for every value of the parameter λ (bounded between 0 and λ) the combined numeric bounds on the expressions x₃ + λ·½, x₄ + 20·λ and their linear combinations satisfy a large Boolean combination of “activation” flags (bool.b17…bool.b24); additionally an existential sub‑query over a second parameter λ′ checks that a tighter subset of these bounds can be satisfied.  The instance therefore tests the consistency/redundancy of many guarded linear constraints, featuring a single quantified assertion with deep nesting (term depth ≈ 96), hundreds of Boolean conjuncts, and a mixture of universal and existential quantifiers, which makes it a hard industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_53.smt2",
    "description": "The file encodes a single quantified feasibility test over 32‑bit bit‑vectors: a universally‑quantified variable `λ` must satisfy a large conjunctive system of linear (addition, multiplication by constants, division, and negation) inequalities, while an existentially‑quantified `λ′` is allowed to range between 0 and `λ` and must meet additional guarded constraints. The Boolean constants (`bool.b5`, `bool.b22`, …) act as selector flags that enable or disable particular inequalities, so the formula essentially checks whether a non‑convex polyhedral description—represented as a mixture of linear bounds and conditional predicates—has a feasible point or contains redundant constraints. The instance has a deep term nesting (depth ≈ 50), many nested `let`‑bindings, and both universal and existential quantifiers, making it a challenging industrial‑style verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_33.smt2",
    "description": "This benchmark encodes the redundancy‑checking problem for a non‑convex polyhedron that has been translated into 32‑bit bit‑vector arithmetic.  The Boolean variables b17…b24 serve as selectors for a family of linear inequalities (e.g. x₄ + 30·λ ≤ c, x₃ + 0·λ ≤ 0), while the universally‑quantified λ and the existential λ′ capture the parametric ranges over which the constraints must hold; the formula is a massive Boolean combination of these guarded linear tests.  Because the instance contains a single huge quantified assertion with deep nesting (term depth ≈ 108), thousands of Boolean connectives, and mixed arithmetic, it is a hard industrial‑style verification task that stresses solvers’ handling of quantifiers, bit‑vector arithmetic, and large conjunctive/disjunctive structures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_24.smt2",
    "description": "The instance encodes a quantified bit‑vector feasibility problem that models a collection of linear inequalities over 32‑bit signed integers, guarded by a set of Boolean switches (bool.b5 … bool.b23) which activate or deactivate individual constraints. A universal quantifier over a variable λ and an inner existential quantifier over λ′ express a “for all λ there exists a λ′” condition that must satisfy a conjunction of signed‑less‑equal and signed‑less‑than relations involving expressions such as x4 + 20·λ′, x3 + (−1/5)·λ′, and x5 + λ′, together with numerous Boolean combinations. This yields a single, large conjunctive assertion with deep term nesting (depth 22), a mix of arithmetic and propositional structure, and one quantifier alternation, making it a representative industrial benchmark for BV‑solvers handling quantified linear constraints and Boolean‑controlled redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_44.smt2",
    "description": "The formula checks the consistency of a parametrised system of linear (integer) constraints that arise from a non‑convex polyhedral representation.  It uses 32‑bit bit‑vectors to encode inequalities such as x₃ + λ ≤ 0, x₄ + 40·λ ≤ …, and a collection of Boolean flags (bool.b*) that enable or disable individual constraints; the property is expressed as a ∀ λ ∃ λ′ premise combined with a large Boolean‑arithmetic condition.  The instance features a single quantified block (universal over λ) containing an existential sub‑query, deep term nesting (depth 23) and many conjunctive/disjunctive Boolean combinations, making it a challenging verification‑type problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_60.smt2",
    "description": "The instance encodes a feasibility check for a collection of conditional linear inequalities over 32‑bit integer variables x₃, x₄, x₅ and a parameter λ, where the presence of each inequality is controlled by Boolean flags (bool.b5, bool.b8, …). It combines a universal quantifier over λ with an existential quantifier over a second parameter λ′ that must lie in [0, λ] and satisfy additional bound constraints, forming a single large Boolean‑and/or nesting of bit‑vector arithmetic (addition, multiplication, signed division and comparison). The formula therefore models the verification of redundant‑constraint elimination for a non‑convex polyhedron, stressing the solver with deep term depth, many Boolean combinations, and a mixed quantifier pattern.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_9.smt2",
    "description": "The benchmark encodes a single quantified verification condition that tests whether a universally‑quantified integer λ (represented as a 32‑bit vector) can be related to an existentially‑quantified λ′ and a collection of Boolean flags so that a conjunction of several linear‑type bit‑vector inequalities (bounds on λ′, mixed multiplications, additions and signed comparisons against constants such as –4100, –4500, 30, etc.) holds.  The formula is built from many Boolean “enable/disable” literals (bool.b22, bool.b7, bool.b5, bool.b6) and nests a forall‑exists alternation with deep arithmetic terms (depth ≈19), creating a non‑convex polyhedral region that must be checked for emptiness or redundancy.  This combination of quantifier alternation, numerous Boolean combinations, and bit‑vector arithmetic makes the instance a challenging industrial verification/simplification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_28.smt2",
    "description": "The benchmark encodes a quantified verification problem in 32‑bit bit‑vector arithmetic: a universal quantifier over a variable λ and an inner existential over λ′ combine a collection of Boolean flags (bool.b5, bool.b22, …) with linear inequalities such as bvsle(‑1·(x3+λ′),‑20) and weighted sums (40·λ′) together with constant bounds (‑10, ‑4100, ‑4500, ‑4910, 4820).  The formula checks whether, for every λ, the selected subset of these linear constraints (controlled by the Boolean switches) can be simultaneously satisfied, which corresponds to testing redundancy/removal of constraints in a non‑convex polyhedral representation.  The instance is challenging because it features a single ∀∃ quantifier alternation, a deep term nesting (depth 20), and a dense mix of Boolean combinations with bit‑vector linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_432.smt2",
    "description": "The file encodes a **software‑verification safety condition** (unreachability/overflow check) generated by Ultimate Automizer.  Three 32‑bit program variables `x`, `y`, `z` and several nondeterministic inputs are related by universally quantified linear bit‑vector equalities/inequalities; the first assertion states that for all choices either a certain affine combination of the variables equals zero or two other affine terms are distinct, while the second assertion negates a similar universally quantified distinctness property.  The query is satisfiability of these combined constraints, i.e. whether the negated property can hold—unsat would prove the program safe.  The problem features only universal quantifiers, a modest number of bit‑vector variables, but many large constant coefficients (close to 2³²) and several `bvmul`/`bvadd` terms, giving a moderately deep term structure (depth 6) that makes quantifier reasoning the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_462.smt2",
    "description": "This instance is a safety‑verification condition generated by Ultimate Automizer for a C benchmark (the “jain_4” program).  It asserts that, for all possible values of the program’s 32‑bit variables `x`, `y`, `z` and the nondeterministic inputs (the `|main_#t~nondet*|` terms), a certain linear equality between weighted sums of these values can never hold—i.e., an overflow/erroneous state is unreachable.  The formula consists of several universally‑quantified bit‑vector constraints involving only small constant multiplications (by 4 and 8) and additions, so the difficulty stems mainly from handling quantified bit‑vector arithmetic rather than from a large number of variables or deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "The instance encodes a software‑verification condition generated by Ultimate Automizer for a C benchmark (jain_4). It asserts a universally quantified linear relationship over 32‑bit bit‑vectors between the program’s main variables x, y, z and several nondeterministic inputs, and then negates a similar universally quantified formula to ask whether a counterexample violating the intended invariant exists. Hence the solver must decide the (un)satisfiability of quantified bit‑vector arithmetic (with only constant coefficients 4 and 8), a typical safety‑property check that involves a single quantifier alternation and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_240.smt2",
    "description": "This benchmark encodes a safety‑property verification condition generated by Ultimate Automizer for a C program (SV‑COMP 2017).  Three 32‑bit program variables x, y, z are related by a universally quantified linear equality over bit‑vectors: for every choice of three nondeterministic inputs the expression  \n\\(2·y + 4290772992·n_0 + 4294967292·x + 4194304·n_1 + 1048576\\)  \nmust be distinct from  \n\\(z + 4194304·n_2\\).  The outer `assert (not …)` asks whether there exists a valuation (including auxiliary substitution variables) that violates this distinctness or satisfies a particular derived equation, i.e., it checks reachability of a bad state.  The problem is thus a quantifier‑based bit‑vector safety check with a single block of universal quantifiers, moderate term depth (≤ 8) and a handful of constants, which makes the main difficulty the handling of quantified linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "This SMT‑BV instance encodes a software safety verification condition generated by Ultimate Automizer for the SV‑COMP benchmark “jain_4”. The goal is to prove that a certain error state is unreachable: two universally‑quantified formulas relate the program’s 32‑bit constants (main_~x, main_~y, main_~z) with three nondeterministic inputs and, after a negation, require that a specific linear‑arithmetic equality (involving multiplications by 4 and 8 and a possible wrap‑around) can never hold. The problem is a pure bit‑vector reachability check with modest term depth (≈10) but featuring multiple universally quantified variables and mixed arithmetic/negation, making it a typical challenging case for quantifier‑handling solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_2400.smt2",
    "description": "This instance encodes a safety‑property check for a C program (the *verisec_sendmail* benchmark) that parses a string of decimal digits.  The bit‑vector variables `c_main_~i~5` and its primed copy model the loop counter, while the quantified 8‑bit variables (`main_~c~5`, `v_subst_*`) range over ASCII codes 48…57 and are used to build the integer represented by the digit sequence via repeated multiplications by 10 and additions; the constraints assert that the constructed value stays non‑negative and respect the digit bounds.  The final negated universal quantifier seeks a counterexample to these invariants, i.e., it asks whether the loop can reach a state violating the numeric‑range condition—typical of an automated software‑verification (reachability) query with several nested quantifiers, many sign/zero extensions, and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "The script encodes a software‑verification problem generated by Ultimate Automizer for a SV‑COMP benchmark: it asserts that a universally quantified transition relation on three 32‑bit program variables ( x, y, z ) and several nondeterministic inputs always satisfies a certain arithmetic equality, and then asks whether, under this invariant, another universally quantified distinctness condition can be violated (i.e., whether an error state is reachable).  The instance is a pure bit‑vector safety check (unreachability/overflow) that involves only one quantifier block (no alternation) but many large constant multiplications and additions, giving a moderate term depth (8) and requiring precise modulo‑2³² reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_253.smt2",
    "description": "The script encodes a safety‑verification condition for a small C program whose three 32‑bit variables x, y, z are updated in one step by adding large constant multiples of three nondeterministic inputs.  The first assertion defines the post‑state (primed) variables, while the quantified assertions express an invariant (a linear combination of the variables and the nondet values must be distinct from another expression, or must equal 0); the final negated forall checks whether the invariant can be violated after the update.  Thus the solver is asked to show that the error state is unreachable, i.e. that the quantified invariant holds for all possible nondeterministic choices.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_70.smt2",
    "description": "The script encodes a safety‑verification condition for a tiny C fragment in which three 32‑bit variables x, y and z are updated in one step by adding large constant multiples of three nondeterministic values. The first assertion defines the transition relation (the primed variables are the old values plus 2²⁰·nondet0, 2²¹·nondet1, 2²²·nondet2); the second asserts, universally over the nondeterministic inputs, that a certain linear combination of the pre‑state variables is distinct from another expression, while the third asserts the negation of the analogous distinctness property for the post‑state. The final check‑sat asks whether there exists a choice of nondeterministic inputs that makes the post‑state violate the invariant, i.e., whether the error state is reachable. The problem is a bounded‑model‑checking style BV safety proof with a small number of variables, moderate term depth (≤ 6), and only two quantifier blocks, making it a typical industrial verification instance for Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_459.smt2",
    "description": "The file encodes a safety‑verification condition for a small C program, using three 32‑bit program variables x, y and z together with three nondeterministic inputs.  The core constraints are universally quantified linear bit‑vector equalities/inequalities that express an intended invariant (a linear relation among x, y, z and the inputs); the outer `not (and …)` asks whether there exists a concrete valuation of x, y, z that falsifies any of these universally quantified conditions, i.e. whether an error state (or overflow) is reachable.  The problem features several universal quantifiers with many `bvmul` terms and coefficients close to 2³², giving a moderate term depth (8) but a non‑trivial quantified‑BV solving task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_408.smt2",
    "description": "The instance encodes a bit‑vector verification condition generated by Ultimate Automizer for a C benchmark (jain_1). It asserts that for all choices of three 32‑bit nondeterministic values, either the linear term \\(c\\!+\\!2·v_3\\!+\\!2·v_2\\!+\\!2·n\\) is non‑zero or the simpler term \\(c\\!+\\!2·n\\) equals zero, while simultaneously requiring the existence of some \\(v_2,n\\) that make \\(c\\!+\\!2·v_2\\!+\\!2·n = 0\\). Thus the solver must decide the satisfiability of a quantified linear arithmetic property (a reachability/overflow check) involving a single constant and a handful of universally‑quantified variables, with a modest term depth and only two quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_307.smt2",
    "description": "The instance encodes a safety‑verification condition for a C program (the “jain_7” benchmark) generated by Ultimate Automizer.  It asserts that for all possible 32‑bit nondeterministic inputs the linear combination  \n\n```\n2·y + 4290772992·nondet0 + … + 1048576\n```  \n\ncannot equal the similarly constructed expression involving z, and additionally that another affine expression of x, y, z never evaluates to zero.  The second (negated) ∀‑formula forces the solver to look for a concrete witness that violates these universal constraints, i.e., to prove the unreachable‑call / no‑overflow property.  Thus the problem is a quantified bit‑vector verification task with several universally‑quantified variables, a moderate term depth (≈7) and many large constant multiplications, making it a non‑trivial instance for BV solvers handling quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_469.smt2",
    "description": "This instance is a BV‑based safety‑verification problem generated by Ultimate Automizer for an SV‑COMP benchmark.  It encodes that for all possible 32‑bit nondeterministic inputs (`|main_#t~nondet0|`, `|main_#t~nondet1|`) a certain linear relation between the constants `main_~x~5_const_-993908852` and `main_~y~5_const_-993907773` must hold; the final negated universal quantifier turns the query into an existential search for a counterexample, i.e., a reachable error (or overflow) state.  The formula consists of a handful of bit‑vector additions and multiplications but requires reasoning under three quantified alternations, making the main difficulty quantifier handling rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_3_true-unreach-call_true-no-overflow.i_1105.smt2",
    "description": "This instance encodes the verification of a small Euclidean‑algorithm implementation for computing the greatest common divisor of two 8‑bit signed integers. The formula asserts that, for any positive input a, every possible value of the auxiliary variable b satisfies the arithmetic invariant that the remainder of a divided by b is non‑negative, bounded by a, and that b never becomes negative; the second assertion negates a disjunctive violation of the same invariant, thereby checking the unreachability of an error state (e.g., overflow or incorrect remainder). The problem is a bit‑vector safety check with a single universal quantifier, moderate term depth (16) and many sign‑extensions/extractions, which makes the arithmetic reasoning non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_true-unreach-call_true-no-overflow.i_415.smt2",
    "description": "This instance encodes a software‑verification task generated by Ultimate Automizer for a simple loop that computes the arithmetic sum ∑_{k=0}^{i}k.  The bit‑vector variables represent the loop index i, the bound n, the running sum sn, its “next‑state’’ version sn′, and the closed‑form Gauss expression n·(n+1)/2 (c_main_~gauss~6); the assertions state the loop’s transition (sn′ = sn + i) together with quantified invariants that relate sn, i and n to the Gauss formula, and finally assert that the next sum is **not** equal to either 0 or the Gauss value.  The solver therefore checks the unreachability of a state where the computed sum deviates from the mathematically correct result, a typical invariant‑preservation verification problem with several quantified bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_476.smt2",
    "description": "The instance encodes a safety‑verification task for a small C‑style program, generated by Ultimate Automizer. It asserts that for all possible 32‑bit nondeterministic inputs the linear combination of program variables `x`, `y`, `z` (represented by the constants `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`) and the inputs can never be equal to a second expression (or, equivalently, can never sum to zero), i.e., an unreachability/overflow check expressed with `distinct` and an equality to zero. The problem is a single‑quantifier bit‑vector formula with many large constant multipliers, a moderate term depth (7) and a sizable quantified variable list, making quantifier reasoning the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_341.smt2",
    "description": "The script encodes a bit‑vector safety condition generated by Ultimate Automizer for an SV‑COMP benchmark.  It asserts that, for all possible 32‑bit values of the program’s inputs x, y and of two nondeterministic choices, a certain linear equality (involving x, y, 2·variables and a constant 1) can never hold, while simultaneously asserting the existence of a pair of nondeterministic choices that makes the same equality true – i.e. it checks whether the universal invariant is violated.  The problem thus reduces to a quantified bit‑vector satisfiability check with a single alternation (∃ over ∀) and shallow term depth, typical of software‑verification reachability/invariant‑violation queries.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_228.smt2",
    "description": "This instance encodes a BV‑based safety verification condition generated by Ultimate Automizer: it asserts that for all choices of auxiliary variables the only way a certain linear relation between the program’s two constant parameters ( x  and  y ) and nondeterministic inputs can hold is if another specific linear equation (involving the same inputs) also holds, while simultaneously asserting the existence of nondeterministic values that make the first relation true. In other words, the formula checks whether a “bad” equality (representing an unsafe state or overflow) is reachable, given the program’s arithmetic constraints. The benchmark features a small number of 32‑bit variables but a quantifier alternation (∃ … ∀ …) and nested bit‑vector additions, multiplications by 2 and negations, giving a moderate term depth and making it a typical challenging case for BV solvers handling quantified formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_475.smt2",
    "description": "This instance encodes the safety‑verification condition generated by Ultimate Automizer for a small C program whose 32‑bit variables x, y, z are combined with three nondeterministic inputs. The formula asserts that a specific linear combination of these values is always distinct from another combination (the intended invariant) and then negates that universal distinctness, thereby asking the solver to find an assignment that violates the invariant. It is a bit‑vector reachability/overflow check with linear arithmetic, moderate term depth (≤6) and a single quantifier alternation (existential → universal), typical of industrial software‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_387.smt2",
    "description": "The script encodes a safety‑reachability check for a tiny C‑style program with three 32‑bit variables x, y, z and three nondeterministic inputs. It asserts that for **all** possible values of the nondet variables a certain linear combination of x, y, z (with coefficients near 2³²) must stay distinct from another linear combination, and additionally that a specific affine expression (z + 2·y + 4·x + 0xFFFFFFFFC) is never zero; the outer ¬(or …) asserts the negation of this property, i.e., it asks whether the “bad” state is reachable. The problem is a quantified bit‑vector verification instance with two universal quantifiers, deep (depth 7) linear arithmetic terms and large constant coefficients, making it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "The file encodes a bounded‑size software‑verification query generated by Ultimate Automizer for an SV‑COMP benchmark, checking a safety (unreach‑call) property on a program that manipulates 32‑bit integers x and y together with two nondeterministic inputs. The first universally‑quantified assertion captures the program’s transition relation (a linear combination of x, y and the nondet values under multiplication by 2), while the second asserts the negation of the safety condition – essentially “x + y ≡ −1 (mod 2³²) or an algebraic invariant is violated” – and the solver is asked whether these constraints are simultaneously satisfiable. The instance involves only a few bit‑vector variables but features two quantifier blocks and nested arithmetic expressions, making it a modestly challenging bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_464.smt2",
    "description": "The script is a BV‑logic encoding of a safety‑verification condition generated by Ultimate Automizer for the SV‑COMP benchmark *jain_2* (a true‑unreach‑call, no‑overflow case). It asserts that three universally‑quantified arithmetic relations over 32‑bit variables—capturing the program’s invariant and the absence of integer overflow—cannot all hold simultaneously; the outer “not (and …)” forces the solver to prove the conjunction of the three ∀‑formulas unsatisfiable, i.e., that the unsafe state is unreachable. The problem features a moderate term depth (≈11) with many linear bit‑vector operations (adds, mul by 2, negation) and several quantified variables, making quantifier‑instantiation the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_407.smt2",
    "description": "The formula models a safety‑verification condition for a program in which a 32‑bit variable y (represented by the constant `c_main_~y~5`) is repeatedly incremented by an even amount (`2·nondet`). The first universally quantified assertion encodes the intended invariant that `y + 2·nondet` is never zero, while the second, negated universally quantified assertion seeks a counterexample in which adding additional even multiples (`2·v_subst_3` and `2·v_subst_2`) can make the sum zero even though the original sum was non‑zero. Thus the instance checks the unsatisfiability of this invariant violation, involving a small set of quantified bit‑vector variables and moderate term depth, characteristic of software model‑checking benchmarks produced by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_409.smt2",
    "description": "The script encodes a safety‑property check on a 32‑bit integer variable `c_main_~y~5`. The first universally quantified assertion states that for every choice of two nondeterministic 32‑bit values the linear combination `c_main_~y~5 + 2·v + 2·nondet` is never zero. The second (negated) universally quantified assertion asserts the existence of three nondeterministic values such that the same combination with three terms equals zero while the simpler combination `c_main_~y~5 + 2·nondet` is non‑zero, i.e. it looks for a counterexample to the invariant. Thus the instance is a quantified bit‑vector reachability/verification problem (unreachability of a zero‑value state) with a handful of variables but a non‑trivial quantifier pattern that can be hard for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "This instance encodes a bit‑vector safety verification problem: it asserts that for all possible values of the program variables `x, y, z` and three nondeterministic 32‑bit inputs, a certain linear combination of these values can never satisfy a forbidden relation (expressed as an equality to 0 or a distinctness condition). The final `assert (not …)` negates the disjunction of these forbidden relations, so the solver must show the formula unsatisfiable, i.e., that the program cannot reach the error state. The problem involves only linear arithmetic over 32‑bit bit‑vectors with many constant multiplications, a few universally‑quantified variables (no alternation), and a modest term depth (7), making it a typical quantifier‑heavy BV verification task generated by Ultimate Automizer from an SV‑COMP benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "The script encodes a software‑verification condition for a 32‑bit C benchmark (SV‑COMP 2017) generated by Ultimate Automizer. It asserts that a certain linear bit‑vector equality (involving the program’s global variables c_main_~x~5, c_main_~y~5 and nondeterministic inputs) can never hold, while simultaneously requiring the existence of concrete values that make that equality true and violate a second “zero‑mod‑2³²” condition; the negated universal quantifier thus creates an ∃∀ pattern. The problem consists of a handful of quantified bit‑vector constraints with modest term depth (≤ 10) but with multiplication by a constant and several equality checks, typical of reachability/overflow checks in automated software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "The file encodes a software‑verification condition for a C benchmark (“jain_4”) generated by Ultimate Automizer.  It declares three 32‑bit program variables (x, y, z) and asserts a quantified invariant: for all nondeterministic inputs and auxiliary variables, a certain linear combination of the inputs (using coefficients 4 and 8) must imply that the sum z + y + x + 0xffffffff is zero.  The second assertion negates the disjunction of that invariant with the same condition expressed without the auxiliary variables, thereby requiring a concrete counterexample where the invariant fails and the summed expression is non‑zero.  Hence the instance is a quantified bit‑vector safety check (reachability/overflow) with a single universal quantifier block inside a negated existential context, featuring moderate term depth and a handful of arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_266.smt2",
    "description": "The script encodes a safety‑verification condition for a small C‑like program in which three 32‑bit program variables x, y and z are combined with three nondeterministic inputs through linear bit‑vector arithmetic. The first quantified assertion states that, for all possible nondet values, the expression 4·nd0 + x can never equal −(z + 8·nd2) −(y + 4·nd1) + 1; the second assertion negates a universally quantified property that would allow a certain linear combination of the same variables (augmented with auxiliary substitution variables) to be zero, thereby expressing the existence of a reachable error state. Consequently the problem is an ∃∀ bit‑vector reachability check (true‑unreach‑call) with a modest number of variables but a non‑trivial quantifier alternation, which makes it a typical industrial verification benchmark for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "The script encodes a safety‑verification condition generated by Ultimate Automizer for a C benchmark (the “jain_4” program).  It asserts that for all possible values of the program’s integer variables x, y, z and the nondeterministic inputs (modelled as 32‑bit bit‑vectors), a certain linear relation – a combination of multiplications by 4 and 8 and additions – can never hold; the second, negated universal clause adds a disjunct that would correspond to an overflow‑to‑zero situation.  Thus the formula checks whether the asserted invariant (or the absence of an overflow‑induced error) is universally valid; satisfiability means a counterexample (a reachable error state) exists.  The problem features only universally quantified variables (no alternation) but involves many bit‑vector multiplications and additions, giving a moderate term depth (10) and a quantified BV reasoning challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3235.smt2",
    "description": "The file encodes a verification condition produced by Ultimate Automizer for a SV‑COMP benchmark that checks the commutativity of a multiplication-by‑2 operation (combined with an addition) in a small C program. It asserts that, when the input constant `c_mult_#in~m` is zero, the computed result `c_mult_#res` must also be zero, and formalises the required relational property with a forall‑exists quantifier pattern over 32‑bit bit‑vectors involving `bvmul` and `bvadd`. The alternating quantifiers over bit‑vector arithmetic, although shallow (max depth 8), make the instance non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "The instance encodes a safety‑verification condition for a small C‑like program (the SV‑COMP “true‑unreach‑call” benchmark). It asserts that for all possible 32‑bit nondeterministic inputs the arithmetic expression  \n`−(2·nondet0 + x) + 1` can never equal `y + 2·nondet1`, and additionally checks that there exists a valuation of auxiliary variables for which both a similar equality and a wrap‑around overflow condition (`y + 2·nondet0 + x + 2·nondet1 + 0xffffffff = 0`) fail, i.e. an error state is unreachable. The formula features a ∀∃ quantifier pattern over a handful of bit‑vector variables with linear arithmetic, producing modest term depth but non‑trivial quantifier alternation that challenges bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_214.smt2",
    "description": "The script encodes a safety‑verification condition for a tiny program that reads a nondeterministic 32‑bit value ( |c_main_#t~nondet0| ) and updates a variable y by the assignment y' = y + 2·nondet0.  The asserted quantified formula states that for all possible values of an auxiliary nondet variable v_subst_1 and another copy of the input, either the expression y + 2·v_subst_1 + 2·input is non‑zero or, if the second term is omitted, y + 2·input must be zero – a condition that captures the “no‑overflow to zero” property the benchmark is checking.  Thus the problem is a pure bit‑vector SAT instance (BV logic) with a single universal quantifier and shallow term depth, typical of automated software model‑checking queries generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "The instance encodes a software‑verification condition for a C program extracted by Ultimate Automizer, expressed in 32‑bit bit‑vector arithmetic. It asserts that, for all nondeterministic inputs (the three “|main_#t~nondet*|” symbols) and auxiliary substituted variables, a specific linear combination of the program’s variables c_main_~x~5, c_main_~y~5, c_main_~z~5 cannot equal another linear combination involving the nondeterministic values—i.e., it checks that a potential error state (such as an overflow or an illegal call) is unreachable. The formula contains two universal quantifiers, a modest number of variables, and a maximum term depth of nine, making the main difficulty the handling of quantified bit‑vector arithmetic rather than scale.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_223.smt2",
    "description": "This instance encodes a safety‑verification condition for a C benchmark (the “jain_2” true‑unreach‑call case). It declares two 32‑bit constants `c_main_~x~5` and `c_main_~y~5` (the program’s variables) and universally quantifies over two nondeterministic 32‑bit inputs; the core property states that the equality  \n\\(2·\\text{nondet0}+x = -(y+2·\\text{nondet1})+1\\)  \ncan never hold, and additionally a derived strengthening clause involving extra substitution variables must be false. Consequently the solver is asked to prove the unsatisfiability of a quantified bit‑vector formula that mixes addition, multiplication by a constant, and negation, a pattern that is typical for reachability/invariant verification and can be challenging due to the nested universal quantifiers and the depth of the bit‑vector terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_2674.smt2",
    "description": "The instance encodes a safety‑checking condition generated by Ultimate Automizer for a 32‑bit C benchmark that tests the commutativity of multiplication (i.e. a·b = b·a) under the assumption that no overflow occurs.  It asserts that the program’s initial input `c_mult_#in~m` is zero and then uses a combination of universal and existential quantifiers to state that for every possible “before‑call” value of the multiplicand there must exist a matching value such that the doubled product computed in two different ways is either equal or differs from the summed terms, thereby ruling out a counterexample to the commutative property.  The formula is a single, moderately sized BV constraint (≈2 kB, term depth 8) with nested quantifiers, which makes it a non‑trivial verification task in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This instance encodes a software‑verification task generated by Ultimate Automizer: it checks that a certain linear combination of the 32‑bit program variables x, y, z (and several nondeterministic temporaries) can never satisfy a forbidden relation, i.e. it verifies a reachability/overflow safety property of the original C program. The property is expressed with two universally quantified bit‑vector constraints—one enforcing distinctness of two affine expressions and the other (negated) stating that either a specific sum equals zero or the two expressions are distinct—so the solver must refute the existential counterexample to prove the property. The difficulty stems from the heavy use of quantified bit‑vector multiplications with large constants and a term depth of seven, which makes reasoning about the linear arithmetic over 32‑bit words challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.c_415.smt2",
    "description": "This instance encodes a software‑verification task for a simple loop that computes the sum ∑_{k=0}^{i} k.  The bit‑vector constants c_main_~i~5, c_main_~n~5, c_main_~sn~5 represent the loop index, the upper bound n, and the current partial sum sn; c_main_~sn~5_primed is the sum after one iteration (sn + i).  The constraints assert the loop guard (i ≤ n), the transition relation (sn′ = sn + i), and an invariant that either the sum equals the triangular number n·(n+1)/2 or is zero, together with a quantified condition that this invariant is preserved for all possible n.  The final negated disjunction forces the solver to show that after the transition the invariant still holds, i.e. that the error state (the invariant violated) is unreachable.  The problem is a bounded‑bitvector verification of a loop invariant, featuring a single universal quantifier, arithmetic with multiplication and division, and moderate term depth (≈9).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_61.smt2",
    "description": "This BV instance encodes a safety‑verification condition for the program *jain_7*: it asserts that for every possible choice of three nondeterministic 32‑bit inputs, a certain linear combination of the program’s variables x, y, z (and the nondet values) must be distinct from another linear combination, and additionally that a second linear expression involving x, y, z cannot evaluate to 0.  The formula is a conjunction of a universal quantifier over the nondeterministic values and a negated conjunction, representing an unreachability/overflow check, and it features only a handful of quantified variables but relatively large constant coefficients and bit‑vector arithmetic, which can be difficult for solvers handling quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "The file encodes a safety‑verification query generated by Ultimate Automizer for a C program fragment. It declares three 32‑bit program variables ( x, y, z ) and asserts, with universally quantified bit‑vector arithmetic, the relationships imposed by the program’s transition relation (linear combinations of the variables and nondeterministic inputs). The final negated universal clause searches for a valuation that violates the intended invariant (expressed as an equality or a distinctness condition), so the solver’s *unsat* answer corresponds to proving the invariant (or absence of overflow/reachability of an error state). The problem features only universal quantifiers, moderate term depth (≤7) and a handful of linear bit‑vector constraints, but the presence of many large constant multipliers and substitution variables makes the arithmetic non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "This instance encodes a safety‑verification condition generated by Ultimate Automizer for a small C benchmark: the three 32‑bit constants x, y and z (c_main_~x~5, …) must never satisfy a certain linear equality with arbitrary 32‑bit nondeterministic inputs (the “main_#t~nondet*” variables).  The property is expressed as a conjunction of universally quantified bit‑vector formulas stating that a specific combination of additions, subtractions and multiplications by the constants 4 and 8 can never be equal to another combination, i.e., the error state is unreachable.  The problem contains only universal quantifiers but many quantified variables and nested bv‑operations, giving a modest term depth (≈11) while still posing a non‑trivial quantifier‑instantiation challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_340.smt2",
    "description": "The formula encodes a software‑verification condition generated by Ultimate Automizer for a SV‑COMP benchmark: three 32‑bit program variables (`x`, `y`, `z`) are related by linear bit‑vector equations with large constant coefficients (close to 2³²), and the safety property requires that a certain combination of these variables and nondeterministic inputs is always distinct from another combination. The instance asserts this universal distinctness while simultaneously asserting the negation of a stronger universally quantified version (i.e., an existential counterexample), turning the query into a check for unsatisfiability of the combined universal/existential constraints. It involves a modest number of quantified variables (two ∀‑quantifiers with an outer ¬∀), shallow term depth (≤ 6), but the wrap‑around arithmetic and alternating quantifiers make it a non‑trivial bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_198.smt2",
    "description": "The script encodes a safety‑verification condition for the SV‑COMP benchmark **jain_4**, where three 32‑bit program variables x, y, z are related to three nondeterministic inputs. The first universally quantified assertion expresses an invariant that either a linear combination of the variables and inputs equals 0 (mod 2³²) or a derived inequality holds, while the second (negated) universal quantifier asserts the existence of inputs that make a specific equality true—i.e., it checks whether the alleged invariant can be violated. Thus the instance is a quantified bit‑vector reachability/overflow check, with a modest number of variables but a non‑trivial combination of arithmetic operations and quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "The file encodes a safety‑verification condition for a small 32‑bit integer program generated by Ultimate Automizer.  Two universally‑quantified constraints relate the program’s constant inputs c_main_~x~5, c_main_~y~5 and nondeterministic values (|main_#t~nondet0|, |main_#t~nondet1|) through linear bit‑vector expressions involving addition, multiplication by the constant 2 and a constant 1; the outer assertion negates a universally quantified equality, thereby asking whether there exists a valuation that makes the two sides equal (i.e., a reachable error state).  The instance contains only a handful of bit‑vector variables and shallow terms (depth 9) but includes quantifier alternation (universal inside a negated universal), which makes it a typical quantified bit‑vector verification problem rather than a large‑scale combinatorial search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_383.smt2",
    "description": "The script encodes a safety‑verification query for a small C‑like program: three global 32‑bit variables x, y, z are assumed, and the tool asserts that for every choice of four nondeterministic 32‑bit inputs the linear combination  \n\n  2·y + 4290772992·nondet₀ + 4294967292·x + 4194304·nondet₁ + 1048576  \n\nis never equal to  \n\n  z + 4194304·nondet₂.  \n\nThe second assertion negates a similar universally quantified “distinct” condition (with auxiliary substitution variables), turning the problem into a ∃‑counterexample check: does there exist values making the two sums equal? The instance therefore represents a bounded‑model‑checking / software verification problem expressed with a single quantifier block (∀) and its negation, involving only linear bit‑vector arithmetic of modest depth (max 6) and a handful of variables, which makes the primary difficulty the handling of quantified equality rather than combinatorial explosion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_250.smt2",
    "description": "The formula encodes a single‑step transition of a small C‑like program whose three 32‑bit variables x, y and z are each increased by a nondeterministic multiple (scaled by 2²⁰, 2²¹ and 2²² respectively).  An invariant expressed as a universally quantified linear‑combination‑distinctness over the pre‑state variables and the nondeterministic choices is asserted, and the final clause negates the same universally quantified condition for the post‑state (i.e. it asks whether there exists a nondeterministic choice that makes the invariant false after the update).  Hence the instance is a software‑verification reachability check (unreachability of an assertion violation) that relies on quantifier reasoning over bit‑vector arithmetic with several large constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.i_336.smt2",
    "description": "The script encodes the verification condition of a small integer‑loop that computes the triangular number \\(n·(n+1)/2\\).  Three 32‑bit constants stand for the loop counter \\(i\\), the accumulator \\(sn\\) and a fixed bound \\(n\\); universal quantifiers assert the loop invariant that \\(sn+i\\) (or \\(sn+2·i+1\\)) equals the triangular expression for every admissible \\(n\\), and the final assertions negate an off‑by‑one error state, forcing the solver to prove unsatisfiability.  The instance contains a handful of quantified bit‑vector constraints with modest term depth (8), typical of SV‑COMP “sum02” verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "This instance encodes the safety‑verification of a C benchmark (the “jain_6” program) produced by Ultimate Automizer.  The formula asserts, for all possible nondeterministic 32‑bit inputs and intermediate substitution variables, that a certain linear combination of the program variables x, y, z (and three “nondet” values) can never satisfy a specific equality (or a related inequality), and then negates the same property to obtain a standard “no‑error reachable” check.  Consequently the SMT problem is a quantified bit‑vector verification task consisting of two ∀‑quantifier blocks over many variables, each building shallow (depth ≤ 7) linear arithmetic expressions with large constant coefficients near 2³², which makes the core difficulty the handling of quantified linear bit‑vector constraints rather than sheer term size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_58.smt2",
    "description": "The script encodes a safety‑verification condition for a tiny imperative program that updates three 32‑bit variables x, y, z by adding nondeterministic 32‑bit values multiplied by the constants 2, 4 and 8 respectively. The first assertion states that, for any nondeterministic choices, a certain linear combination of the pre‑state variables (with coefficients ‑2, ‑8, ‑4 modulo 2³²) is always different from the post‑state z expression; the second (negated) assertion requires that after the update there exists a choice of nondeterministic values making that same linear combination equal to the updated z, i.e. the invariant is violated. Thus the instance checks whether the transition can break the “distinctness” invariant, using quantified bit‑vector arithmetic with a single universal quantifier and a surrounding negation, which makes the problem a quantified‑BV safety‑verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "The script encodes a BV‑based safety verification problem generated by Ultimate Automizer for a C benchmark. It declares three 32‑bit global variables x, y, z and three nondeterministic inputs, and asserts (via two universally‑quantified clauses) that a specific linear combination of these values can never equal a target word (mod 2³²) – i.e., that a particular overflow/reachability condition is impossible. The verification query is expressed as the negation of the conjunction of these ∀‑formulas, so the solver must prove unsatisfiability of the universally quantified arithmetic constraints; the instance features moderate term depth (11) and several quantifier alternations, making it a non‑trivial quantifier‑heavy BV verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_1353.smt2",
    "description": "The instance encodes a safety‑verification problem for a C program that iterates over an array of ASCII digits (values ‘0’ – ‘9’) and builds a decimal number by repeatedly multiplying a 32‑bit counter i by 10 and adding the current digit.  The SMT formula models the loop step with a primed version of i (i′ = i − 1) and asserts a universally quantified loop invariant that the intermediate value stays non‑negative and respects the digit bounds; the final “not‑forall” clause negates this invariant to check that an unsafe state (the false‑unreach‑call) cannot be reached.  The problem is a BV‑based verification task with several universal quantifiers, moderate term depth (14) and a focus on overflow/bound correctness of the numeric computation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for an SV‑COMP benchmark. It encodes the negation of a safety property: for all nondeterministic 32‑bit inputs (and auxiliary substitution variables) a certain linear equality involving the program constants `c_main_~x~5` and `c_main_~y~5` must never hold (the equality mixes additions, a subtraction of 1, and multiplications by 2). The solver therefore has to prove unsatisfiability of a quantified bit‑vector formula with four universal quantifiers, moderate term depth (11) and a handful of arithmetic operators, i.e., whether the asserted condition can be violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_382.smt2",
    "description": "This instance encodes a software‑verification safety check in the bit‑vector logic: three program variables x, y, z are declared and the model must guarantee that a certain linear combination of them (together with nondeterministic 32‑bit inputs) is always different from another linear combination. The formula asserts the universal “distinct” property and then immediately asserts its negation, so the solver must determine whether a counterexample exists, i.e., whether the safety property can be violated. The problem features quantified bit‑vector arithmetic with several large constant multiplications, a modest term depth (6) but requires quantifier reasoning, making it a typical challenging case for BV‑solver quantifier handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3226.smt2",
    "description": "This instance encodes a software‑verification task generated by Ultimate Automizer for a tiny C benchmark that computes the product of two 32‑bit integers.  The single conjunct asserts, via a mixture of universal and existential quantified bit‑vector constraints, that the multiplication routine respects the expected algebraic relation (essentially the commutative property and absence of overflow) and that the program never reaches an error state (the asserted result must be zero).  The formula features several quantified variables, nested `bvmul`/`bvadd` terms, and a modest term depth, making it a typical BV‑logic safety‑property check rather than a large‑scale combinatorial search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_2_true-unreach-call_true-no-overflow.i_921.smt2",
    "description": "This instance encodes the verification of a small Euclidean‑algorithm implementation for computing the greatest common divisor.  The bit‑vector formula models one loop iteration (using signed remainder `bvsrem`) together with a quantified invariant that relates the current dividend, divisor and the original input b, and then asserts the negation of the safety property (that the loop never reaches an error state such as a non‑positive divisor or overflow).  The problem is a BV‑logic safety‑check with a handful of 8‑bit variables, a moderate term depth (≈11), and two universal quantifiers, generated by the Ultimate Automizer tool from an SV‑COMP benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "The script encodes a verification condition for a small C benchmark (jain_2) in which two 32‑bit variables x and y and two nondeterministic inputs must satisfy a linear relation.  It asserts that whenever a certain equality between a sum of x, y, the nondet values and auxiliary variables holds, the combined sum x + y + 2·nondet₀ + 2·nondet₁ + 2·v₁ + 2·v₂ must be congruent to 1 (mod 2³²); a second clause guarantees that the equality is realizable, thereby forcing the “sum‑equals‑1’’ property.  The instance features a single quantifier alternation (∀…∃…) over a handful of 32‑bit bit‑vectors, with moderate term depth (9) but non‑trivial arithmetic and quantifier interaction, making it a typical SMT‑LIB encoding of an industrial software‑verification reachability/overflow check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_259.smt2",
    "description": "The file encodes a safety‑verification condition for a small C benchmark (a “jain” program) generated by Ultimate Automizer.  Three 32‑bit variables x, y, z are constrained by a universally‑quantified invariant that relates a linear combination of the variables with nondeterministic inputs, and the final assertion checks the negation of the conjunction between a distinctness condition on another linear expression and either this invariant or a particular equality; the solver must show the formula unsatisfiable to prove that the error state is unreachable.  The problem is thus a bit‑vector reachability/invariant check with a handful of variables but featuring quantified arithmetic and moderate term depth (≈8), which can be challenging for solvers because of the combination of universal quantifiers and large 2’s‑complement constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "The script encodes a safety‑verification condition for a small C benchmark (jain_2) generated by Ultimate Automizer. It asserts that for **all** possible 32‑bit nondeterministic values `nondet0` and `nondet1` a certain linear equality between doubled variables and two fixed constants (`main_x` and `main_y`) never holds, and simultaneously asserts the **existence** of a concrete assignment (via the negated universal) that makes this equality true while another derived sum modulo 2³² is non‑zero. Thus the problem checks the unreachability of an error state expressed as a bit‑vector arithmetic relation; the presence of two quantifier alternations together with several multiplications by the constant 2 gives the instance a modest but non‑trivial solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "The instance encodes a software‑verification condition generated by Ultimate Automizer for a C program that contains nondeterministic 32‑bit inputs and performs linear arithmetic over those inputs.  Three global 32‑bit variables (`c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`) are constrained together with universally quantified fresh variables and nondet symbols (`|main_#t~nondet0|`, …) by a Boolean formula that expresses a safety invariant (essentially that a certain linear combination of the variables never equals 0 modulo 2³²).  The final top‑level assertion negates a disjunction of two cases, turning the problem into an “unreach‑call/ no‑overflow” check: the solver must show that the conjunction of the quantified invariant and the negated unsafe condition is unsatisfiable.  The formula features only universal quantifiers, a moderate number of bit‑vector operations (multiplications by constant 4 and 8, additions, negations), and a term depth of 10, making it a typical but non‑trivial BV‑verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_460.smt2",
    "description": "This instance encodes a software‑verification safety check (unreachability of an error call) for a C benchmark from SV‑COMP 2017. The property is expressed as a set of universal quantified equalities/inequalities over 32‑bit bit‑vectors that relate the program’s concrete variables `x`, `y`, `z` with several nondeterministic inputs; the outer `(not (and …))` turns the universally quantified constraints into an existential search for a violating execution. The problem features four ∀‑quantifiers, many bit‑vector multiplications (≈37), and a moderate term depth (8), creating a challenging quantified bit‑vector reasoning task for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "The script encodes a safety‑verification condition for a small C‑like program: a 32‑bit constant `c_main_~y~5` must never combine with any nondeterministic 32‑bit input `|main_#t~nondet0|` (and with additional auxiliary variables) to yield the zero bit‑vector when multiplied by 2 and added (`c + 2·x ≠ 0`). The solver is asked to prove unsatisfiability of the negated conjunction of two universally quantified invariants, i.e., to show that reaching a zero result is impossible. This yields a quantified bit‑vector problem with three universal quantifiers and modest term depth, typical of software model‑checking conditions generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "This instance is a bit‑vector safety‑verification condition generated by Ultimate Automizer for a C benchmark (the “true‑unreach‑call” category). It declares three 32‑bit variables x, y, z and asserts, via two universal quantifiers, that a linear combination of these variables together with several nondeterministic inputs can never equal another combination, and that a specific equality to 0 (representing a bad program state) is unreachable. The formula therefore checks an unreachability/invariant property over BV arithmetic, containing a modest number of variables (3 + 6 quantified) but non‑trivial multipliers and a term depth of 7, which makes quantified BV reasoning the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_306.smt2",
    "description": "The script encodes a safety‑checking problem for a C‑style program with an `assert` statement.  The bit‑vector variables `c_main_~x~5_Hier`, `c_main_~y~5_Hier`, `c_main_~z~5_Hier` model program state, and the asserted condition is a linear combination of these variables (and several nondeterministic inputs) that must be non‑zero; violating this condition corresponds to reaching the `assert`.  The formula therefore consists of a quantifier‑free definition of the assertion, a universally‑quantified relation over the nondeterministic inputs describing the program’s transition relation, and the negation of a universal property (i.e., an existential search for a counterexample).  It is a bit‑vector linear arithmetic verification instance with a single quantifier block, modest term depth (7) and a handful of constants, typical of Ultimate Automizer’s encoding of SV‑COMP “unreach‑call” benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem1_32bit.smt2",
    "description": "The instance encodes a quantified verification condition for 32‑bit bit‑vectors that checks whether a handcrafted signed‑comparison predicate **SC(s,t)** is equivalent to the existence of a divisor *x* such that the signed‑greater‑or‑equal relation holds between the totalised unsigned remainder `uremtotal(s,x)` and *t*.  It asserts the negation of the equivalence  \n\\[\nSC(s,t) \\;\\leftrightarrow\\; \\exists x.\\; \\text{bvsge}( \\text{uremtotal}(s,x), t),\n\\]  \nso a solver must find a counterexample or prove the formula unsatisfiable.  The problem involves mixed signed/unsigned operations, a single existential quantifier, and a few auxiliary definitions (total‑division/remainder, min/max), with modest term depth (7) and only two free variables, making it a concise but non‑trivial benchmark for quantified‑BV reasoning and invertibility‑condition verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_2_64bit.smt2",
    "description": "The formula verifies an invertibility condition for the unsigned‑greater‑or‑equal relation over concatenated bit‑vectors.  It states that the simple condition `SC` (if the 2‑bit selector `tx` is all‑ones then the 64‑bit value `s` is ≥ `ts`) is equivalent to the existence of a 2‑bit prefix `x` such that the 66‑bit concatenations `concat(x,s)` and `concat(tx,ts)` satisfy `bvuge`.  The single assertion negates this equivalence, so the task is to prove (or refute) that the quantified property holds; the problem involves only existential quantifiers, a concatenation with mixed widths, and a modest term depth, making it a crafted quantified‑bit‑vector verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_64bit.smt2",
    "description": "This instance encodes a quantified verification of the invertibility condition for 64‑bit signed multiplication: it defines the predicate SC(s,t) that characterises exactly those target values t for which there exists a multiplier x satisfying bvmul x s = t, and then asserts the negation of the equivalence between SC(s,t) and the existence of such an x. The problem therefore tests a solver’s ability to handle a single universal‑implicit quantifier over the free variables s and t together with an inner existential quantifier, using only bit‑vector operators (and, or, neg, mul) and a modest term depth (7). The formulation is deliberately crafted (64‑bit width, no additional theory) to stress quantified reasoning and invertibility‑condition reasoning rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvlshr1_64bit.smt2",
    "description": "The instance checks the correctness of an invertibility condition for unsigned comparison and logical right‑shift on 64‑bit bit‑vectors: it asserts the negation of the equivalence “\\(s \\ge_u t\\) iff there exists a shift amount \\(x\\) such that \\((s \\mathbin{>>_{l}} x) \\ge_u t\\)”.  The problem therefore amounts to finding a pair of 64‑bit constants \\(s,t\\) that falsify this bi‑implication, requiring a solver to handle an existential quantifier together with bit‑vector shifts and unsigned comparisons.  The benchmark is a small, crafted quantified bit‑vector test (two variables, modest term depth) intended to exercise a solver’s support for such quantifier‑based verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_64bit.smt2",
    "description": "The instance checks the correctness of an invertibility condition for signed less‑than after addition on 64‑bit bit‑vectors: it asserts that the predicate “\\(t\\neq\\text{min}\\)” (where min is the most‑negative signed value) is equivalent to the existence of an \\(x\\) such that \\((x + s) <_{\\text{signed}} t\\). By negating the conjunction of the two implication directions, the solver is asked to find a counterexample (or prove none exists) to this equivalence. The formula involves a single existential quantifier, a few arithmetic operators (addition, signed‑less‑than) and defined constants, yielding a modest term depth (7) and a small number of variables, but it tests the solver’s handling of quantified bit‑vector reasoning and edge‑case overflow conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_32bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility property of unsigned addition and comparison on 32‑bit bit‑vectors: it asserts that “ t ≠ 0 ” is logically equivalent to the existence of an unsigned 32‑bit value x such that x + s <₍u₎ t. The formula is the negation of the bidirectional implication, so the solver must show the equivalence holds for all bit‑vector assignments. It is a quantified BV problem (one existential quantifier per implication) with a modest term depth (7) and only three bit‑vector variables (s, t, x), making the main difficulty the handling of the quantified arithmetic rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_32bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem: it checks whether the quantifier‑free condition SC(s,t) (a signed‑less‑than test involving bitwise‑or and negation) is logically equivalent to the existence of a 32‑bit signed multiplier x such that bvmul(x,s) > t. The sole assertion negates the bi‑implication between these two formulations, thus asking the solver to find a counter‑example (or prove none exists). The benchmark features only two universally‑quantified variables (s, t) and a single existential quantifier (over x), modest term depth (≤7), and a mixture of arithmetic and bit‑wise operations typical of invertibility‑condition checks for quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_64bit.smt2",
    "description": "The instance encodes a short‑circuit verification of an invertibility condition for the 64‑bit left‑shift operator.  It defines the predicate  \n\n```\nSC(s,t)  ≡  (t >> s) << s = t\n```  \n\nand checks whether this predicate is equivalent to the existential statement “there exists an x such that x << s = t”.  The single assertion negates the conjunction of the two implications (SC ⇒ ∃x, and ∃x ⇒ SC), so the solver must find a pair of 64‑bit values s and t that falsify the equivalence.  The problem therefore is a quantified bit‑vector verification task with two 64‑bit variables, a shallow term depth (≤7), and only one existential quantifier inside each implication, making it a modestly sized but non‑trivial case for solvers that handle quantified shifts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem1_32bit.smt2",
    "description": "The instance encodes a verification condition for the invertibility condition of the unsigned remainder operation on 32‑bit bit‑vectors. It defines totalised versions of `bvudiv`/`bvurem` that give a defined result even when the divisor is zero, then asserts that the predicate “at least one of `s` or `t` is non‑zero” is logically equivalent to the existence of a value `x` such that `uremtotal s x` differs from `t`. By negating this equivalence the solver is asked to find a counter‑example, i.e., to check whether the stated invertibility condition is sound. The formula contains a single existential quantifier, two implications, and shallow terms (depth ≤ 7) over a small set of variables, making the difficulty stem mainly from the quantified remainder operation rather than size or quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_32bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification condition for the unsigned remainder operation. It defines totalized versions of `bvudiv` and `bvurem` (returning a default value on divisor 0) and an auxiliary predicate `SC` that requires `s≠1 ∨ t≠0`. The formula asserts the negation of the bi‑implication “`SC(s,t)` holds iff there exists an `x` with `uremtotal(x,s) ≠ t`”, thus checking whether this invertibility condition for `bvurem` is valid over 32‑bit vectors. The problem features a single existential quantifier inside an implication, a handful of ite‑based definitions, and modest term depth, making it a crafted quantified‑BV verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_64bit.smt2",
    "description": "This instance encodes a verification task for a 64‑bit bit‑vector property: it asserts the negation of the equivalence between the predicate SC(s,t) (which holds when t is signed‑less than s masked by the maximal unsigned value) and the existence of a witness x such that the signed‑greater‑than relation (bvand x s) > t holds. The solver must determine whether a counterexample exists, which requires reasoning about an existential quantifier together with signed comparisons, bitwise‑and, and the defined min/max constants. The problem is crafted to stress quantified bit‑vector reasoning (single‑level exists, no alternation) in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_32bit.smt2",
    "description": "The benchmark checks the correctness of a hand‑crafted invertibility condition for the unsigned left‑shift operation on 32‑bit bit‑vectors.  It defines a predicate **SC(s,t)** that explicitly tests, for every shift amount 0…32, whether `s << i` is unsigned‑greater‑or‑equal to `t**, and then asserts that this finite disjunction is equivalent to the true existential statement ∃ x. `s << x ≥_u t`.  The solver must find values of the free constants `s` and `t` that break the bi‑implication, i.e., a counterexample to the derived condition; the instance features a single existential quantifier together with a large (33‑term) disjunction of bit‑vector shift and comparison operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_32bit.smt2",
    "description": "The instance encodes a tiny verification of the invertibility condition for 32‑bit bit‑vector negation: it asserts that a (trivially true) predicate SC holds exactly when there exists an x such that bvneg x equals a given t.  Because bvneg is a bijection on 32‑bit vectors, the existential is always satisfied, making the whole conjunction true and its outer negation unsatisfiable.  The problem features only a single existential quantifier, a few bit‑vector operations, and shallow term depth, serving mainly to test a solver’s handling of quantified bit‑vector equalities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvudiv0_64bit.smt2",
    "description": "The instance checks the correctness of an **invertibility condition** for unsigned division on 64‑bit bit‑vectors. It defines a “total” division `udivtotal` that returns a distinguished value when the divisor is zero, and asserts (by negating) that the predicate “both operands are non‑zero” (`SC s t`) is equivalent to the existence of a dividend `x` such that `udivtotal x s` is strictly less than `t`. Thus the formula encodes a quantified verification problem (two existential sub‑formulas inside implications) over BV 64, involving division, remainder, and conditional constructs, which is intended to be unsatisfiable if the invertibility condition holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_32bit.smt2",
    "description": "This instance encodes a verification condition for a 32‑bit bit‑vector invertibility property: it defines the predicate SC(s,t) as “t is smaller than (bvor (bvneg s) s)”, and asserts that SC(s,t) is equivalent to the existence of a 32‑bit multiplier x with bvmul x s > t. The single top‑level assertion negates the conjunction of the two implications (SC ⇒ ∃x·bvmul x s > t and ∃x·bvmul x s > t ⇒ SC), turning the problem into a quantified bit‑vector check that involves non‑linear multiplication and inequalities. The formula contains one existential quantifier, moderate term depth (7), and a few auxiliary totalized division/ remainder definitions, making it a crafted, quantifier‑heavy benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvurem1_32bit.smt2",
    "description": "The instance verifies an invertibility condition for the signed‑less‑or‑equal relation on 32‑bit signed remainder: it asserts that a predicate SC(s,t) (which holds when t is non‑negative or t is signed‑greater‑or‑equal to s) is equivalent to the existence of a divisor x such that the totalized unsigned remainder uremtotal(s,x) is signed‑≤ t.  The formula contains two free bit‑vector constants, a single existential quantifier over x, and uses totalized versions of bvudiv and bvurem to avoid division‑by‑zero, yielding a shallow term depth (≤ 7) but requiring quantified reasoning over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv1_64bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification of an invertibility condition for unsigned division: it defines a totalised `udivtotal` (returning the maximal value on division‑by‑zero) and asserts that the property  \n\\(SC(s,t) : s\\;\\text{udivtotal}\\;(s\\;\\text{udivtotal}\\;t)=t\\)  \nis logically equivalent to the existence of an \\(x\\) with \\(s\\;\\text{udivtotal}\\;x = t\\).  By negating the conjunction of the two implication directions, the solver must find a 64‑bit counterexample (or prove unsatisfiability), exercising quantified reasoning over a small number of bit‑vectors with shallow term depth but non‑linear division/remainder operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem0_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility property of the unsigned remainder operation on 32‑bit bit‑vectors.  A predicate SC(s,t) is defined as “the unsigned‐greater‑or‑equal of the bit‑wise‑negated negation of s and t”, and the formula asserts (and then negates) that this predicate is equivalent to the existence of a value x such that the total‑ized remainder `uremtotal(x,s)` is also unsigned‑greater‑or‑equal to t (with a special case for divisor 0).  Thus the solver must decide the unsatisfiability of the negated equivalence, a quantified bit‑vector problem with two existential quantifiers, a few defined functions (including an ite to handle division‑by‑zero), and moderate term depth (≈7) but no quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_32bit.smt2",
    "description": "The instance checks a quantified invertibility condition for the totalized unsigned‑remainder operation on 32‑bit bit‑vectors: it asserts that the predicate SC(s,t) (i.e., t < s or s ≤ 0, using signed order) is equivalent to the existence of an x such that the remainder of x divided by s (with a safe definition for divisor 0) is signed‑greater‑or‑equal to t. By negating the conjunction of the two implications, the solver is asked to find a counterexample, thus performing a verification of this equivalence. The formula involves a single existential quantifier, a few bit‑vector operations (signed comparisons, totalized remainder), and a shallow term depth, making it a compact benchmark for quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_32bit.smt2",
    "description": "The instance encodes a verification of an “invertibility condition’’ for 32‑bit unsigned division.  It defines a total division operator that returns all‑ones when the divisor is zero, then asserts the negation of the equivalence  \n  SC(s,t) ↔ ∃x (udivtotal x s ≠ t)  \nwhere SC(s,t) holds unless s = 0 and t = 0xFFFFFFFF.  The goal is to check (via a single existential quantifier, ite‑based totality, and 32‑bit arithmetic) whether the side‑condition precisely characterises the existence of a value that makes the division result differ from t.  This crafted bit‑vector problem tests quantified reasoning and handling of division‑by‑zero in solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_64bit.smt2",
    "description": "The instance encodes a quantified verification condition for 64‑bit signed bit‑vectors. It defines a predicate `SC(s,t) ≡ t ≥_s (t » s)` (signed‑greater‑or‑equal between `t` and the logical right‑shift of `t` by `s`) and checks that this predicate is exactly equivalent to the existence of a witness `x` such that `(x » s) ≤_s t`. The single top‑level assertion negates the bi‑implication, so the solver must prove the universally quantified equivalence (i.e., that the formula is unsatisfiable). The problem involves only a few 64‑bit variables, shallow term depth (≤ 7), but uses quantified bit‑vectors with signed comparisons and shifts, making it a crafted benchmark for invertibility‑condition reasoning in BV logics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_64bit.smt2",
    "description": "This instance checks the correctness of an invertibility condition for signed 64‑bit multiplication. It asserts the negation of the equivalence  \n\n\\[\n\\text{SC}(s,t)\\;\\;\\Leftrightarrow\\;\\; \\exists x.\\; (x \\times_{s} s) >_{s} t,\n\\]\n\nwhere **SC** is a Boolean predicate built from signed‑less‑than, subtraction and bitwise‑or of `s` and `t`. The formula contains a single existential quantifier over a 64‑bit variable together with several bit‑vector operations (shift, or, neg, add, mul, signed comparisons), yielding a moderate term depth (7) and a small number of variables, but the presence of quantified arithmetic makes it a non‑trivial verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvurem1_32bit.smt2",
    "description": "The benchmark encodes a verification condition for an invertibility property of unsigned remainder: it defines a totalised `uremtotal` (returning the dividend when the divisor is zero) and asks whether the unsigned ordering predicate `SC(s,t) ≜ (t <_u s)` is equivalent to the existence of a divisor `x` such that the remainder of `s` modulo `x` is strictly greater than `t`. The single assertion negates this equivalence, so a solver must either find 32‑bit values `s` and `t` that violate it (making the formula satisfiable) or prove none exist (unsat). The instance involves only two 32‑bit variables, one existential quantifier, shallow term depth (7) and a handful of ite‑based total‑function definitions, typical of quantified bit‑vector verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_64bit.smt2",
    "description": "The instance encodes a quantified verification condition for a 64‑bit bit‑vector “invertibility condition”: it asserts that the predicate  \n\n\\[\nSC(s,t)\\;:=\\; (\\,\\texttt{bvslt}(\\,\\texttt{bvnot}\\;t,\\; \\texttt{bvor}(\\texttt{bvneg}\\;s,\\;\\texttt{bvneg}\\;t))\\,)\n\\]\n\nholds exactly when there exists an \\(x\\) such that the totalised unsigned remainder \\(\\texttt{uremtotal}(x,s)\\) is signed‑less‑than \\(t\\).  The formula is the negation of the biconditional \\((SC\\;s\\;t) \\leftrightarrow \\exists x.\\; \\texttt{bvslt}(\\texttt{uremtotal}(x,s),t)\\), so the solver must show the condition is valid (unsat).  This crafted BV problem features a single existential quantifier, totalised division/remainder to avoid undefinedness, and moderate term depth (7) on 64‑bit vectors, assessing the solver’s ability to handle quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_64bit.smt2",
    "description": "The instance encodes a verification task for an invertibility condition of 64‑bit signed multiplication: it defines a predicate SC(s,t) that holds exactly when the unsigned bound t is below the bit‑wise “sign‑mask” s ∨ (−s), and then checks whether this predicate is equivalent to the existence of a 64‑bit multiplier x making x·s strictly greater than t. The single existential quantifier over x and the surrounding implication‑equivalence are asserted negated, so the solver must look for a counter‑example to the claimed equivalence. This is a quantified bit‑vector problem with modest term depth (7) and few variables, typical of crafted verification of mathematical properties rather than large‑scale synthesis or scheduling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv1_64bit.smt2",
    "description": "The file encodes a verification task for an invertibility condition of signed 64‑bit division: it defines a total‑division operator (guarding against division‑by‑zero) and a predicate SC(s,t) that relates s and t via signed comparisons, then checks whether SC(s,t) is equivalent to the existence of an x such that the total‑division of s by x is signed‑greater‑or‑equal to t. The problem is a quantified bit‑vector formula (∃ x) with a handful of 64‑bit variables and shallow term depth, stressing the solver’s ability to reason about division, signed ordering, and the handling of undefined division cases.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_64_64bit.smt2",
    "description": "The instance checks the correctness of an invertibility condition for the unsigned‑greater‑or‑equal relation on concatenated 128‑bit bit‑vectors. It introduces three 64‑bit variables `s`, `tx`, `ts` and defines a simple premise `SC` that says “if `tx` is all‑ones then `s ≥₍u₎ ts`”. The single asserted clause states that the premise `SC` is **not** equivalent to the existence of a 64‑bit prefix `x` such that the 128‑bit numbers `concat x s` and `concat tx ts` satisfy `bvuge`; the solver must decide whether this equivalence holds. The formula involves two existential quantifiers, bit‑vector concatenation, shifts and logical operations, and is a crafted verification benchmark for quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_64bit.smt2",
    "description": "The file encodes a verification condition for a 64‑bit signed‑multiplication invertibility lemma: it defines a predicate SC(s,t) that is intended to be equivalent to the existence of a 64‑bit value x such that the signed product x·s is greater‑or‑equal to t (the relation bvsge). The single asserted formula negates the bi‑implication “SC(s,t) ⇔ ∃x · bvsge(bvmul x s, t)”, so the solver must find a counter‑example (values of s and t) or prove the equivalence holds. The problem features nested quantifiers (an existential inside an implication over free universally‑quantified bit‑vectors) and a handful of arithmetic and bit‑wise operations, leading to a modest‑size, crafted BV benchmark that tests the solver’s handling of quantified bit‑vector reasoning and invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat1_64_64bit.smt2",
    "description": "The formula tests the exactness of an invertibility condition for unsigned concatenation: it asserts that the Boolean SC—“ s is unsigned‑greater‑or‑equal to ts and, when they are equal, tx is not ‑1 ” —holds if and only if there exists a 64‑bit word x such that the 128‑bit number obtained by concatenating s with x is unsigned‑greater‑than the 128‑bit number obtained by concatenating ts with tx.  This is expressed with a single existential quantifier over x and uses BV concat, unsigned comparison, and a few bit‑wise constants, so the instance checks a quantified bit‑vector equivalence (a crafted invertibility condition) that can be difficult for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvlshr0_64bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification task: it defines a predicate SC(s,t) that involves a logical right‑shift of bvnot(‑t) by s and a signed‑less‑than test against t, and then checks whether SC(s,t) is logically equivalent to the existence of a 64‑bit word x such that the shifted value (bvlshr x s) is signed‑less‑than t. The single assertion negates the conjunction of the two implications (SC ⇒ ∃x …) and (∃x … ⇒ SC), so the solver must decide the satisfiability of this equivalence under the quantified condition. The problem features only two free constants but includes non‑linear bit‑vector operations (shift, bitwise not, arithmetic negation) combined with an existential quantifier, making quantifier reasoning and invertibility‑condition checking the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr1_64bit.smt2",
    "description": "The instance encodes a verification condition for a 64‑bit bit‑vector property: it defines a predicate SC(s,t) that combines a signed‑less‑than test on s with a logical‑right shift of s by the bitwise‑negation of t, and an unsigned‑less‑than test on t and s. The single asserted formula checks the equivalence between SC(s,t) and the existence of a shift amount x such that the arithmetic right‑shift of s by x is unsigned‑greater‑than t (i.e., ∃x·(s >>> x) >_u t). Thus the problem is a quantified bit‑vector verification task, involving mixed signed/unsigned comparisons, arithmetic and logical shifts, and an existential quantifier, with a modest number of variables but non‑trivial reasoning about shift semantics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_64bit.smt2",
    "description": "The file encodes a quantified bit‑vector verification condition: for two 64‑bit variables `s` and `t` a predicate `SC(s,t)` (which compares the unsigned result of shifting the signed‑minimum constant `min` left by `s` against `t+min`) is meant to be equivalent to the existence of a 64‑bit shift amount `x` such that the signed‑less‑than relation `bvslt (bvshl s x) t` holds. The single asserted formula negates the conjunction of the two direction implications, so the solver is asked to find a concrete `s` and `t` that violate this equivalence. This is a crafted BV‑logic instance for checking an invertibility condition, featuring a single existential quantifier inside each implication, modest term depth (7) and only two free bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_32bit.smt2",
    "description": "The instance encodes a verification of an invertibility condition for unsigned division on 32‑bit bit‑vectors: it defines a “total” division that returns a safe value on divisor 0 and formulates the condition SC(s,t) as the inequality bvugt (udivtotal (∀1) s) t. It then asserts the negation of the equivalence between SC(s,t) and the existence of a witness x such that bvugt (udivtotal x s) t, thus checking that the existential condition holds exactly when the derived invertibility condition does. The problem involves a single existential quantifier, ite‑based total operators, and 32‑bit arithmetic, making it a crafted quantified‑BV verification benchmark that stresses solvers’ handling of division‑by‑zero and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_64bit.smt2",
    "description": "This instance encodes a quantified verification condition for 64‑bit unsigned arithmetic: it asserts that the predicate “t ≠ 0” (the “SC” condition) is equivalent to the existence of a 64‑bit value x such that x + s <₍u₎ t. The single top‑level assertion negates the bi‑implication, so the problem is to prove the equivalence unsatisfiable (i.e., that the condition holds for all s and t). It involves only two bit‑vector variables, one existential quantifier, and a modest term depth, but includes auxiliary total‑division and bound functions that increase the term size without affecting the core quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr0_32bit.smt2",
    "description": "The file encodes a quantified bit‑vector verification condition that checks an invertibility property of the signed arithmetic‑right‑shift operator.  A predicate `SC(s,t)` is defined (using the signed‑greater‑or‑equal relation) and the formula asserts that `SC(s,t)` is logically equivalent to the existence of a 32‑bit value `x` such that `bvashr x s` is signed‑less‑or‑equal to `t`.  The instance is a crafted, quantifier‑heavy BV problem (one existential quantifier over a 32‑bit variable) meant to test solvers’ handling of quantified bit‑vector reasoning and the associated invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_4bit.smt2",
    "description": "The instance encodes a verification of an invertibility condition for 4‑bit signed shift‑right: it introduces the predicate **SC(s,t)** that compares `t` with a shifted version of the maximal 4‑bit value, and then asserts (and negates) the equivalence between **SC(s,t)** and the existential statement “∃ x · (bvlshr x s) >_s t”.  The formula contains two quantified implications (with a single existential quantifier each) over bit‑vectors, together with auxiliary total‑division functions to avoid undefinedness.  Thus the problem is a small quantified bit‑vector verification task that tests a solver’s ability to handle polarity‑preserving quantifiers and shift operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_32bit.smt2",
    "description": "The instance encodes a verification condition for an “invertibility condition” of the signed‑less‑than predicate applied to the remainder of a 32‑bit unsigned division.  It defines a totalised remainder (returning the dividend when the divisor is zero) and a Boolean predicate SC(s,t) that captures a necessary condition on the divisor s and bound t; the formula checks whether SC(s,t) is logically equivalent to the existence of a 32‑bit value x such that (bvslt (uremtotal x s) t) holds.  The problem is thus a quantified bit‑vector verification task (with an existential quantifier inside an implication) that tests the correctness of the derived condition, featuring moderate term depth and a handful of bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_34_32bit.smt2",
    "description": "The benchmark encodes a verification of an invertibility condition for the signed‑greater‑than predicate on concatenated bit‑vectors. It defines a Boolean predicate SC that requires s ≥ₛ ts (signed) and, when s = ts, forces tx ≠ −1; the query then asserts that SC holds exactly when there exists a 34‑bit extension x such that the signed comparison concat(s,x) >ₛ concat(ts,tx) is satisfied (and vice‑versa). The instance therefore tests a quantified bit‑vector equivalence involving concatenation, signed inequalities, and a few bit‑wise constants, presenting a modest but non‑trivial challenge for solvers due to the interplay of quantifiers and signed‑comparison semantics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv1_64bit.smt2",
    "description": "The instance encodes a verification check for an **invertibility condition** of unsigned 64‑bit division (with a totalized definition that returns all‑ones on division‑by‑zero). It introduces a trivial predicate SC that is always true and asserts, in negated form, the equivalence between SC(s,t) and the existence of an operand x such that `udivtotal(s,x)` is *different* from t. In other words, it asks whether there are bit‑vectors s and t for which no x can make the division result differ from t, thereby falsifying the intended invertibility condition. The formula contains a single existential quantifier, a handful of bit‑vector operations, and very shallow term depth, making it a small crafted benchmark focused on quantified bit‑vector reasoning with division‑by‑zero handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_32bit.smt2",
    "description": "The instance encodes a verification condition for a quantified bit‑vector property: it asserts that a predicate **SC(s,t)**—which compares an unsigned‑shifted constant with *t* plus that constant—is equivalent to the existence of a 32‑bit value *x* such that the signed‑less‑than relation (bvshl s x) <ₛ t holds. By negating the bi‑implication, the solver is asked to find a counter‑example where the predicate and the existential inequality diverge, thus checking the correctness of an invertibility condition for left‑shift and signed comparison. The problem features mixed signed/unsigned operations, a shift by a symbolic amount, and an existential quantifier, making quantifier handling the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_32bit.smt2",
    "description": "The instance encodes a verification condition for an **invertibility condition** of the predicate “\\( \\text{bvsge}(\\text{udivtotal}(x,s),t) \\)” over 32‑bit bit‑vectors. It defines a candidate condition \\(SC(s,t)\\) that uses the extreme signed values (‑2³¹ and 2³¹‑1) and checks, via a single existential quantifier, whether the existence of an \\(x\\) satisfying the total unsigned division bound is equivalent to \\(SC(s,t)\\). The problem is a crafted quantified‑BV formula with modest term depth but includes division‑by‑zero handling, making it a non‑trivial test for solvers’ support of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvlshr0_64bit.smt2",
    "description": "This instance verifies the correctness of an invertibility condition for the logical right‑shift (`bvlshr`) on 64‑bit bit‑vectors. It introduces the predicate `SC(s,t) := (bvlshr (bvshl t s) s) = t`, which should characterize exactly those pairs (s,t) for which there exists an x with `bvlshr x s = t`. The sole assertion negates the equivalence between `SC(s,t)` and the existential condition, asking the solver to find a counterexample; thus the problem is a quantified BV verification task with a single existential quantifier and modest term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_32bit.smt2",
    "description": "The benchmark encodes a verification condition for the invertibility condition of signed 32‑bit multiplication used in the paper “Solving Quantified Bit‑Vectors using Invertibility Conditions”. It introduces two 32‑bit variables **s** and **t**, defines a predicate **SC(s,t)** that is false only when `s = 0` and `t` is negative, and asserts that **SC(s,t)** is logically equivalent to the existence of a 32‑bit witness `x` satisfying the signed inequality `bvmul x s ≤ t`. The single quantified assertion (an existential over `x`) is negated, so the solver must prove the formula unsatisfiable; the instance features a modest term depth (7) and a handful of bit‑vector operations, but includes quantifier reasoning that exercises invertibility‑condition handling in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvadd_32bit.smt2",
    "description": "The benchmark encodes a verification of an invertibility condition for 32‑bit addition. Two uninterpreted 32‑bit constants `s` and `t` are declared, a trivial condition `SC(s,t)` is defined to be always true, and the instance asserts that `SC(s,t)` is equivalent to the existence of a witness `x` satisfying `x + s = t`. The formula therefore checks that the universally true invertibility condition matches the actual solvability of the addition equation (which always holds in modular bit‑vector arithmetic). It involves a single existential quantifier and a few auxiliary total‑division/remainder definitions, yielding a modest term depth but exercising quantified‑BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv0_32bit.smt2",
    "description": "The file verifies an “invertibility condition’’ for a quantified bit‑vector predicate involving unsigned division.  It defines totalised versions of bvudiv and bvurem (that return a default value when the divisor is zero), fixes the signed minimum and maximum 32‑bit constants, and introduces the predicate  \n\n```\nSC(s,t)  ≜  (bvsle t 0) ⇒ (bvslt (udivtotal min s) t)\n```  \n\nThe sole assertion checks that for all 32‑bit variables s and t, SC(s,t) is equivalent to the existence of an x such that bvslt (udivtotal x s) t; the outer not makes the solver look for a counter‑example.  Thus the instance is a crafted verification problem (no alternation of quantifiers, just one existential) that tests the correctness of the derived condition for the signed‑less‑than of a totalised unsigned division, using only a few 32‑bit variables and shallow term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvshl1_64bit.smt2",
    "description": "The instance encodes a verification of an invertibility condition for a quantified bit‑vector property involving signed‑less‑or‑equal (`bvsle`) and left logical shift (`bvshl`). It introduces a predicate `SC(s,t)` that holds when the unsigned right‑shift of `t` by `s` is smaller than a constant `min`, and then asserts the negation of the equivalence between `SC(s,t)` and the existence of a 64‑bit shift amount `x` such that `bvshl s x` is signed‑less‑or‑equal to `t`. Thus the solver must decide whether the quantified statement “`SC(s,t)` ↔ ∃x. s << x ≤ₛ t`” is universally valid over 64‑bit vectors, featuring a single existential quantifier, modest term depth (≤ 7), and only two free bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvurem1_64bit.smt2",
    "description": "The instance encodes a verification of an invertibility condition for the (totalized) unsigned remainder operation on 64‑bit bit‑vectors: it asserts that the predicate “there exists an \\(x\\) such that \\( \\text{uremtotal}(s,x) < t\\)” is equivalent to the simple side‑condition “\\(t \\neq 0\\)”. By negating this equivalence and asking the solver to find a model, the benchmark checks whether the condition \\(t\\neq0\\) is both necessary and sufficient for the existence of a divisor yielding a remainder smaller than \\(t\\). The problem involves two quantified 64‑bit variables, a small amount of ite‑based total‑function definitions, and a single existential quantifier, making it a concise crafted quantifier‑heavy BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_64bit.smt2",
    "description": "The instance encodes a quantified verification condition for the invertibility of unsigned division on 64‑bit bit‑vectors: it asserts that for any pair of bit‑vectors `s` and `t`, the predicate `SC(s,t)` (which holds exactly when `t` is strictly below the maximum 64‑bit value) is equivalent to the existence of an `x` such that the totalized division `udivtotal(s,x)` is greater than `t`. The formula is the negation of this equivalence, so the solver must either find concrete `s` and `t` that falsify the condition (showing a counter‑example to the invertibility condition) or prove it unsatisfiable. The problem features a single existential quantifier inside implications, uses totalized `bvudiv` (with a conditional for division‑by‑zero), and operates over the full 64‑bit domain, giving a modest term depth (≤ 7) but requiring quantifier reasoning over large bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_4bit.smt2",
    "description": "The file encodes a verification task on 4‑bit bit‑vectors.  It introduces two free constants `s` and `t` and defines a side‑condition `SC(s,t)` that simply requires `t` to be less than the maximal 4‑bit value (`t < 0b1111`).  The main property to be checked is whether this side‑condition is equivalent to the existence of a 4‑bit witness `x` such that the arithmetic right‑shift of `x` by `s` is unsigned‑greater‑than `t` (`∃x · (bvashr x s) >_u t`).  The assertion negates the conjunction of both implication directions, so the solver must determine if the equivalence holds.  The benchmark features a single existential quantifier, a few nested bit‑vector operations (shift, comparison, ite‑based total division/remainder), and only two free variables, making it a small but non‑trivial crafted instance for testing invertibility‑condition reasoning in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_64bit.smt2",
    "description": "This instance formalises a tiny verification of the invertibility condition for 64‑bit two’s‑complement negation. It introduces two bit‑vector constants `s` and `t`, defines a side‑condition predicate `SC` that is always true, and then asserts that the equivalence  \n`SC(s,t)  ↔  (∃x. bvneg x = t)`  \nis violated. Because `bvneg` is a bijection over 64‑bit vectors, the existential always holds, so the negated conjunction is unsatisfiable. The benchmark therefore tests a solver’s handling of a single existential quantifier over bit‑vectors and a simple logical equivalence, with only a handful of variables and shallow term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_64bit.smt2",
    "description": "This instance checks a quantified invertibility condition for 64‑bit bit‑vectors: it asserts that “\\(t\\) is not the maximum unsigned value” (\\(SC(s,t)\\)) is equivalent to the existence of a value \\(x\\) such that the arithmetic right‑shift of \\(x\\) by \\(s\\) is unsigned‑greater than \\(t\\). The formula negates the bidirectional implication, so the solver must find a counter‑example (or prove none exists), exercising quantified reasoning over bit‑vector arithmetic with a single existential quantifier and a few nested operations (shift, compare, ite).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_64_64bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem: it defines a predicate **SC** that requires `tx` to be the unsigned‑all‑ones constant and, under this condition, the 64‑bit word `s` to be unsigned‑greater than `ts`. The main check asserts the negation of the equivalence between **SC** and the existence of a 64‑bit word `x` such that the 128‑bit concatenations `concat x s` and `concat tx ts` satisfy `bvugt`. In other words, it asks whether the simple condition **SC** precisely characterises the existence of an upper‑word `x` making the concatenated values ordered, a typical invertibility‑condition verification task with a single existential quantifier and modest term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvudiv1_64bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility rule involving 64‑bit bit‑vector division. It asserts that a sign‑based predicate SC(s,t) (which holds when t is non‑negative or t ≥ s) is equivalent to the existence of a divisor x such that the totalized unsigned division udivtotal(s,x) is signed‑less‑or‑equal to t; the solver is asked to find a counterexample to this equivalence. The problem features a single existential quantifier nested inside two implications and uses totalized division/remainder to avoid undefinedness, yielding a modest‑size quantified BV formula with term depth 7.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv0_64bit.smt2",
    "description": "This instance encodes a quantified verification condition for the invertibility of unsigned division on 64‑bit bit‑vectors. It defines totalised versions of **bvudiv** and **bvurem** that return a default value when the divisor is zero, then states property SC: `udivtotal(s·t, s) = t`. The sole assertion negates the logical equivalence between SC and the existence of a witness x satisfying `udivtotal(x, s) = t`, i.e., it checks whether the invertibility condition holds for all s and t. The problem involves a small number of variables but uses existential quantifiers combined with ite‑based totalisation, making it a typical quantified bit‑vector verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_64bit.smt2",
    "description": "The instance encodes a quantified verification condition for 64‑bit bit‑vectors: it checks that a hand‑crafted “invertibility condition” SC(s,t) (which uses a totalised unsigned division that returns ‑1 on divisor 0 and compares the result to t with signed ≥) is logically equivalent to the existential property ∃x · (bvsge (udivtotal x s) t). In other words, it verifies that the condition SC precisely characterises when there exists some divisor x making the signed‑greater‑or‑equal test hold, even in the presence of division‑by‑zero. The formula contains a single quantifier alternation, a few defined functions, and moderate term depth, posing a typical challenge for bit‑vector solvers handling quantified division and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility lemma about the signed‑greater‑or‑equal relation on the totalized unsigned remainder operator. It asserts (and then negates) the equivalence between a simple signed‑comparison predicate SC(s,t) – which holds when t is less than s or s is non‑positive – and the existence of a bit‑vector x such that bvsge(uremtotal x s, t) holds, using totalized definitions for division and remainder to avoid undefinedness at b = 0. The problem is a single‑quantifier (existential) verification query in 64‑bit bit‑vectors, with modest term depth (7) and a small number of variables, stressing the solver’s ability to reason about quantified remainder constraints and the associated invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr1_64bit.smt2",
    "description": "The instance verifies an equivalence that characterises when a 64‑bit word `s` can be shifted right arithmetically by some amount `x` to become strictly unsigned‑less than a non‑zero word `t`.  The side condition `SC(s,t)` (essentially “either `s <_u t` or `s` is non‑negative signed, and `t ≠ 0`”) is asserted to be logically equivalent to the existence of an `x` satisfying `bvashr(s,x) <_u t`; the solver is asked to find a counter‑example to this equivalence.  This crafted benchmark features only two universally‑free constants, a single existential quantifier, and modest term depth, but it tests quantified bit‑vector reasoning and invertibility‑condition reasoning for arithmetic‑shift operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_4bit.smt2",
    "description": "The instance encodes a verification condition for a 4‑bit bit‑vector remainder operation with a total‑ity wrapper (returning the dividend when the divisor is zero). It defines a predicate SC(s,t) that relates the signed sign of s to a comparison with t, and then asserts the negation of the equivalence “ SC(s,t) ↔ ∃x. uremtotal(s,x) > t ”, i.e., it asks the solver to find a counter‑example to this invertibility condition. The problem involves quantified bit‑vectors (existential quantifier), conditional division/remainder handling, and a moderate term depth (≈7), making it a crafted verification benchmark for solvers’ quantifier‑instantiation capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_32bit.smt2",
    "description": "The file encodes a quantified verification condition over 32‑bit bit‑vectors. It introduces totalised unsigned‑division (`udivtotal`) that returns all‑ones on divisor = 0 and defines a simple safety condition `SC(s,t)` that holds whenever `t` is not the maximal unsigned value (i.e., `t < 0xFFFFFFFF`). The asserted formula checks the equivalence between `SC(s,t)` and the existence of a divisor `x` such that `udivtotal(s,x) > t`; the outer `not` seeks a counterexample, so the solver must decide whether for all `s,t` the two statements are logically equivalent. This is a crafted quantified bit‑vector problem requiring reasoning about division‑by‑zero handling, an existential quantifier inside implications, and unsigned comparisons, which makes it a non‑trivial test for solvers that support quantifier instantiation over BV.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_4bit.smt2",
    "description": "This instance checks a quantified bit‑vector invertibility condition: it asserts that for 4‑bit vectors `s` and `t`, the predicate `SC(s,t)` (signed‑greater‑or‑equal of `t` and `t>>s`) holds exactly when there exists a 4‑bit `x` such that the logical right‑shift of `x` by `s` is signed‑less‑or‑equal to `t`. The formula is the negation of the bidirectional implication between `SC(s,t)` and the existential shift‑bound condition, so the solver must prove the formula unsatisfiable. It involves a single existential quantifier, simple bit‑vector arithmetic (shifts, signed comparisons) and a few auxiliary total‑division definitions, making it a small‑scale quantified verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_32bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem: it checks whether the predicate  \n\n```\nSC(s,t)  ≡  (s<0 ⇒ (s>>1) > t) ∧ (s≥0 ⇒ s > t)\n```  \n\nis equivalent to the existence of a shift amount x such that the logical right‑shift of s by x exceeds t, i.e.  \n\n```\n∃x. (s >>_log x) > t .\n```  \n\nThe formula asserts the negation of the bi‑implication “SC(s,t) ⇔ ∃x …” for all 32‑bit variables s and t, thus testing the validity of this equivalence. It involves only a single universal quantifier (over s and t) and an inner existential quantifier (over x), uses signed‑greater‑than, signed‑less‑than, and logical shift‑right, and has modest term depth (≤7) but requires reasoning about quantified bit‑vectors with non‑linear shift operations, which can be hard for QBV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvshl0_64bit.smt2",
    "description": "The benchmark encodes a verification condition for an invertibility rule of the signed greater‑than operation after a left shift on 64‑bit bit‑vectors. It defines a predicate SC(s,t) that captures a bound on t relative to a shifted maximum value, and then asserts that SC(s,t) should be equivalent to the existence of an x with (x << s) > t (signed). The single quantified assertion tests this equivalence, using only Boolean connectives, shifts, bitwise‑and, and signed comparisons, resulting in a shallow (depth 7) but non‑trivial quantified BV formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvshl1_64bit.smt2",
    "description": "The instance encodes a verification of an invertibility condition for the unsigned‑greater‑than relation after a left‑shift on 64‑bit vectors. It defines a predicate SC(s,t) that is true iff (bvshl s k) > t for some concrete shift amount k ∈ {0,…,64}, and then asserts the negation of the equivalence between SC(s,t) and the quantified statement ∃x. (bvshl s x) > t.  The goal is to check whether the existence of some shift making the comparison hold can be captured by the finite disjunction over all possible shift amounts. The problem features a single quantified existential over a 64‑bit variable, a large (67‑clause) disjunction, but only shallow term depth, making it a crafted quantified‑bit‑vector verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_4bit.smt2",
    "description": "The instance encodes a quantified verification condition for a 4‑bit arithmetic‑shift‑right operation. It defines a predicate SC(s,t) that relates s and t via a signed‑greater‑or‑equal test on a logical right‑shift of the maximal 4‑bit value, and then asserts (negated) the bidirectional implication that SC(s,t) holds exactly when there exists a 4‑bit value x such that the signed‑greater‑or‑equal of bvashr (x,s) and t holds. The problem therefore checks the correctness of an “invertibility condition’’ for bvashr, requiring a solver to reason about existential quantifiers over bit‑vectors and signed comparisons, albeit on a small (4‑bit) domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_34_32bit.smt2",
    "description": "The benchmark encodes a tiny quantified verification task: it asks whether the simple condition `SC` (“if the 34‑bit word `tx` is all‑ones then the 32‑bit word `s` is unsigned‑greater‑or‑equal to `ts`”) is logically equivalent to the existence of a 34‑bit filler `x` making the concatenated 66‑bit numbers `x‖s` and `tx‖ts` satisfy `bvuge`.  The solver must decide the satisfiability of the negated equivalence, i.e., produce a model where the implication in either direction fails.  The instance contains only three uninterpreted constants, two shallow existential quantifiers, and a few bit‑vector operations (`concat`, `bvuge`, `bvnot`, `bvlshr`), making it a crafted test of quantified BV reasoning and invertibility‑condition handling rather than a large‑scale combinatorial problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv1_64bit.smt2",
    "description": "The instance encodes a verification condition for an “invertibility” property of unsigned division over 64‑bit bit‑vectors.  It defines totalised versions of `bvudiv` and `bvurem` (returning a default value when the divisor is zero) and a predicate  \n\n```\nSC(s,t)  ≜  (s <_s t) ∨ (t ≥_s 0)\n```  \n\nwhere `<_s`/`≥_s` are signed comparisons.  The formula asserts the negation of the equivalence  \n\n```\nSC(s,t)  ⇔  ∃x . (udivtotal s x) <_s t,\n```  \n\ni.e., it checks whether the signed‑less‑than condition `SC(s,t)` exactly characterises the existence of a divisor `x` making the totalised unsigned division of `s` smaller than `t`.  The problem involves quantified bit‑vectors (two free 64‑bit variables and a single existential quantifier), a moderate term depth (7), and handcrafted definitions, making it a typical quantified‑BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_32bit.smt2",
    "description": "This instance checks the correctness of an “invertibility condition’’ for the signed arithmetic right‑shift operator on 32‑bit bit‑vectors. It asserts that the predicate **SC(s,t)**—which holds exactly when either t is non‑negative or t is at least s (signed)—is logically equivalent to the existence of a shift amount x such that (bvashr s x) ≤ t (signed). The formula is a small quantified BV problem (two 32‑bit constants, one existential quantifier) that tests solvers’ ability to reason about quantified bit‑vector arithmetic and the interplay of signed comparisons with shift operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvurem1_64bit.smt2",
    "description": "This instance verifies an **invertibility condition** for the unsigned remainder operation on 64‑bit bit‑vectors. It introduces totalized division/remainder functions (handling division‑by‑zero) and a predicate `SC(s,t)` that captures the necessary condition for the equation `uremtotal(s,x)=t` to have a solution. The single quantified assertion checks that `SC(s,t)` is logically equivalent to the existence of some `x` satisfying the remainder equation; the solver must decide the unsatisfiability of the negated equivalence, a crafted quantified BV problem with modest term depth (7) and only two quantified variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_32bit.smt2",
    "description": "The instance encodes a tiny verification task for the invertibility condition of the 32‑bit logical left‑shift operator.  It defines the predicate  \n\n```\nSC(s,t) ⇔ (bvshl (bvlshr t s) s) = t\n```  \n\n(which holds exactly when the low‑`s` bits of `t` are zero) and asks the solver to prove the equivalence between this predicate and the existence of a witness `x` such that `bvshl x s = t`.  The benchmark therefore tests quantified bit‑vector reasoning (a single existential quantifier) over 32‑bit words, with a modest term depth (7) and a handful of arithmetic/shifts, reflecting the “invertibility‑condition” checks introduced in the CAV‑2018 paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_32bit.smt2",
    "description": "The instance checks a quantified bit‑vector invariant: it asserts that for all 32‑bit signed values `s` and `t`, the predicate `SC(s,t)` (which relates `s` and `t` via signed comparisons) is equivalent to the existence of a 32‑bit divisor `x` such that the totalized unsigned remainder of `s` by `x` is strictly greater than `t`.  The formula uses totalized `bvurem` (to avoid division‑by‑zero) and a small combination of signed and unsigned operations, yielding a single existential quantifier inside an implication, making it a crafted verification problem for invertibility‑condition reasoning over BV‑32.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_64bit.smt2",
    "description": "The instance verifies an invertibility condition for a quantified bit‑vector shift: it asserts that the predicate SC(s,t) (a signed‑less‑than test involving a left‑then‑right shift of the maximal signed value) is equivalent to the existence of an 64‑bit value x such that (bvlshr x s) is signed‑greater‑than t. The formula is a single quantified (∃ x) Boolean constraint over 64‑bit vectors, combined with nested shifts, signed comparisons, and auxiliary total‑division helpers, making it a crafted verification benchmark that challenges solvers’ handling of variable‑shift, non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_64bit.smt2",
    "description": "The instance checks the correctness of the invertibility condition for unsigned 64‑bit division when the division is *totalised* (division by 0 returns all‑ones).  It asserts the negation of the equivalence  \n\\[\n(s\\neq0\\ \\lor\\ t\\neq2^{64}-1)\\;\\;\\Longleftrightarrow\\;\\;\\exists x.\\; \\text{udivtotal}(x,s)\\neq t,\n\\]  \nthereby asking whether there is a pair (s,t) that violates this equivalence.  The formula involves only one existential quantifier, a few bit‑vector operations (division, equality, ite) on 64‑bit vectors, and a shallow term depth, making it a crafted quantified‑BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility property of the unsigned remainder operation on 64‑bit bit‑vectors. It defines total‑ized versions of division and remainder (guarding against division‑by‑zero) and a predicate SC(s,t) that relates a signed value s and a bound t; the formula asserts that SC(s,t) is equivalent to the existence of an x such that the guarded remainder uremtotal(s,x) is strictly greater than t. The solver must refute the negated equivalence, which involves existential quantification, nested ite‑expressions, and signed/unsigned comparisons, making it a crafted quantified‑BV verification problem of moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_64bit.smt2",
    "description": "The instance checks a quantified bit‑vector correctness condition: it asserts that for 64‑bit variables `s` and `t` the predicate  \n\n\\[\nSC(s,t)\\; \\leftrightarrow\\; \\exists x.\\; (s\\; \\text{bvashr}\\; x) \\le_u t\n\\]\n\nholds for all values, where `SC(s,t)` is defined as “either `s` is below \\(2^{63}\\) (i.e., its most‑significant bit is 0) or `t` is unsigned‑greater‑or‑equal to `s`”. The formula is negated, so the solver must show the equivalence is valid (expecting `unsat`). The problem is a handcrafted verification of an invertibility condition for the arithmetic right‑shift operator, featuring a single existential quantifier over 64‑bit vectors and a few auxiliary total‑division definitions, with modest term depth but non‑trivial quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_64_64bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule of the signed‑greater‑than operation on concatenated 64‑bit bit‑vectors. It defines a predicate SC that relates two 64‑bit variables s and ts (and requires tx ≠ 0 when s = ts), and then checks whether SC is logically equivalent to the existence of a 64‑bit witness x such that the signed comparison (concat s x) > (concat ts tx) holds. The problem consists of a single quantified assertion (two ∃ quantifiers) together with bit‑vector arithmetic, concatenation and signed comparisons on 64‑bit values, making quantifier instantiation and large word‑size reasoning the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_32bit.smt2",
    "description": "The file encodes a quantified verification condition for a 32‑bit signed logical‑right‑shift.  It defines the predicate  \n\n```\nSC(s,t)  ≡  t ≥ₛ (t >>ₗ s)\n```  \n\nand asserts that this predicate is logically equivalent to the existence of an element x such that  \n\n```\n(x >>ₗ s) ≤ₛ t .\n```  \n\nThe single top‑level assertion negates the bidirectional implication between the two statements, so the solver must show the formula is unsatisfiable.  The problem features only two free bit‑vector constants (s and t), one existential quantifier over x, signed comparisons (bvsge, bvsle) and a logical shift‑right (bvlshr), making it a small, crafted instance focused on verifying an invertibility condition for the shift operation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_64bit.smt2",
    "description": "The file encodes a quantified verification condition over 64‑bit signed bit‑vectors. It introduces a predicate SC(s,t) that distinguishes the sign of s and demands either s ≫ 1 > t (when s is negative) or s > t (when s is non‑negative), and then checks whether this predicate is exactly equivalent to the existence of a shift amount x such that (s ≫ x) > t. The sole assertion is the negation of the bidirectional implication, i.e. it asks the solver to find a counter‑example to the equivalence, thus testing an invertibility condition for the bvlshr operator. The problem features a single existential quantifier over a 64‑bit variable, a handful of arithmetic and logical bit‑vector operations, and a modest term depth, making it a crafted benchmark for quantified‑BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_32bit.smt2",
    "description": "The benchmark encodes a verification condition for an “invertibility‑condition” of the logical right‑shift operator on 32‑bit signed bit‑vectors. It defines a predicate SC(s,t) that holds exactly when either t is unsigned‑less than the signed minimum (0x80000000) or t is signed‑greater‑or‑equal to s, and then asserts that this predicate is equivalent to the existence of a shift amount x such that the signed‑less‑or‑equal relation (bvsle (bvlshr s x) t) holds. The problem is a pure‑BV query with two existential quantifiers (inside implications) and a handful of auxiliary total‑division/remainder functions that are not used in the core property, yielding a modest term depth (7) but requiring quantified reasoning about bit‑vector shifts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvlshr1_64bit.smt2",
    "description": "The instance checks a quantified bit‑vector property: it asks whether the unsigned order predicate `SC(s,t) ≡ (t <_u s)` is equivalent to the existence of a 64‑bit shift amount `x` such that the logical right‑shift of `s` by `x` is unsigned‑greater‑than `t` (`(s >>_u x) >_u t`).  This is expressed as an equivalence of two implications, whose negation is asserted, so the solver must refute the claim that the two conditions are interchangeable.  The problem is a crafted verification query involving a single existential quantifier, shift and comparison operators on 64‑bit vectors, which tests solvers’ ability to reason about invertibility conditions for quantified bit‑vector expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_64bit.smt2",
    "description": "This instance encodes a verification condition for an “invertibility condition’’ of the signed‑greater‑or‑equal predicate after an arithmetic right‑shift on 64‑bit bit‑vectors. It asserts that the simple condition  \n\n\\[\n\\text{SC}(s,t)\\;:=\\;(\\text{max} \\,>>_{\\!\\text{logical}}\\, s) \\ge_{s} t\n\\]\n\nis equivalent to the existence of a witness \\(x\\) such that \\((x \\,>>_{\\!\\text{arith}}\\, s) \\ge_{s} t\\), and then negates this equivalence to force the solver to prove unsatisfiability if the equivalence holds. The problem features a quantified formula with one outer universal (implicit over the free variables \\(s,t\\)) and an inner existential over \\(x\\), uses several bit‑vector operations (shifts, signed comparison, and total‑division helpers) and thus tests a solver’s ability to handle quantified bit‑vector reasoning with moderate term depth (7) but few variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem1_64bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification problem: it defines a totalised unsigned remainder (`uremtotal`) that safely handles division‑by‑zero and a predicate `SC(s,t)` relating two 64‑bit variables `s` and `t`. The sole assertion checks the equivalence between `SC(s,t)` and the existence of an `x` such that `uremtotal s x` is unsigned‑greater‑or‑equal to `t`; the formula is negated so the solver must look for a counterexample. This crafted benchmark features a single existential quantifier inside an implication, a modest term depth (7), and only basic bit‑vector operators, making the main difficulty the handling of the quantified remainder condition rather than combinatorial explosion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_32bit.smt2",
    "description": "This instance encodes a quantified bit‑vector verification problem that checks the correctness of an invertibility condition for the signed‑greater‑or‑equal predicate combined with multiplication.  It asserts that, for all 32‑bit values `s` and `t`, the predicate `SC(s,t)` (a guard built from bitwise operations and the constants min/max) is equivalent to the existence of a 32‑bit multiplier `x` such that `bvsge(bvmul x s, t)` holds; the goal is to find a counterexample to this equivalence by negating the conjunction of the two implications.  The formula involves only two universally quantified constants, two nested existential quantifiers, and a modest term depth (≤7), making it a small‑scale but non‑trivial quantified BV verification task that stresses solvers’ handling of mixed quantifiers and signed arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_64bit.smt2",
    "description": "This instance encodes a verification condition for an invertibility rule of the signed‑less‑or‑equal relation after a logical right‑shift on 64‑bit bit‑vectors. It asserts that, for all vectors `s` and `t`, the predicate  \n\n  SC(s,t) ≡ (t < min) ∨ (t ≥ₛ s)  \n\nholds exactly when there exists a shift amount `x` such that `(s >>ₗ x) ≤ₛ t`; the negated conjunction of the two implications is checked for unsatisfiability. The problem involves a single quantified existential over a 64‑bit variable, mixed signed/unsigned comparisons, and a modest term depth, making it a crafted quantified‑BV verification task that challenges solvers’ handling of quantifiers and shift‑operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvashr0_64bit.smt2",
    "description": "The instance verifies an invertibility condition for signed‑less‑than after an arithmetic right‑shift on 64‑bit vectors. It defines the predicate SC(s,t) as bvslt(bvashr min s, t) (where min is the most‑negative 64‑bit value) and checks that this predicate is logically equivalent to the quantified statement “there exists an x such that bvslt(bvashr x s, t)”. The single quantified assertion (an ∃ over a 64‑bit BV) is negated and handed to a BV solver, making the problem a small‑scale verification of a quantified bit‑vector equivalence with modest term depth (≈7) and no deep quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_32bit.smt2",
    "description": "This benchmark verifies the invertibility condition for 32‑bit unsigned multiplication introduced in the CAV‑2018 paper: the Boolean predicate SC(s,t) (defined as t ∧ (bvor (bvneg s) s) = t) is intended to be equivalent to the existence of a factor x with x · s = t. The single top‑level assertion negates the conjunction of the two implicational directions, i.e. it asks whether there is a pair (s,t) that violates the “SC ↔ ∃ x. bvmul x s = t” equivalence. The problem involves only two universally free bit‑vector constants, one existential quantifier per implication, and a modest term depth (≤ 7), making it a focused quantified‑bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_64bit.smt2",
    "description": "This crafted BV‑logic instance encodes a verification condition for an invertibility rule of the signed arithmetic right‑shift operator. It asserts the negation of the equivalence between a simple signed‑range predicate SC(s,t) ( t ≥ 0 or t ≥ s ) and the existence of a 64‑bit shift amount x such that bvashr(s,x) ≤ t, using a single existential quantifier and signed comparisons. The problem tests a solver’s ability to handle quantified bit‑vectors with arithmetic shifts, but involves only two free variables and modest term depth, so the difficulty stems chiefly from the quantifier rather than size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule of the signed‑greater‑than operation over 32‑bit vectors: it asserts that the predicate `SC(s,t)` (meaning `t` is signed‑less than the masked value `s & 0x7fffffff`) is equivalent to the existence of a witness `x` such that `(x & s) > t` (signed). The formula negates this equivalence and asks the solver to determine its unsatisfiability, i.e., whether the two conditions are indeed interchangeable. It involves a single existential quantifier over a 32‑bit variable, a handful of bit‑vector operations (and, not, shifts, division/remainders defined for totality), and modest term depth, making it a crafted quantified‑BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_2_64bit.smt2",
    "description": "The instance verifies an invertibility condition for the unsigned‑greater‑than (`bvugt`) operation on concatenated bit‑vectors. It defines a premise `SC` that requires `s > ts` whenever the 2‑bit selector `tx` equals `0b11`, and then checks that this premise is logically equivalent to the existence of a 2‑bit word `x` such that the 66‑bit concatenations `x‖s` and `tx‖ts` satisfy `x‖s  >  tx‖ts`. The formula asserts the negation of the bidirectional implication, so the solver must show the equivalence holds (unsat). The query involves quantified bit‑vectors (two existential sub‑formulas) and a moderate term depth (7), typical of verification tasks for quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility property of the arithmetic right‑shift (`bvashr`) on 32‑bit bit‑vectors. It defines a predicate `SC(s,t)` that holds when either `s` is below the signed‑minimum constant (`0x80000000`) or `t` is at least `s`, and then checks whether this condition is logically equivalent to the existence of a shift amount `x` such that the shifted value `bvashr s x` is unsigned‑less‑or‑equal to `t`. The single quantified formula (an existential quantifier over `x`) is negated together with the two implication directions, so the solver must determine unsatisfiability of the negated equivalence; the problem features bit‑vector arithmetic, variable shifts, and a modest quantifier depth (no alternation) but is representative of the challenging quantified‑BV reasoning required for invertibility‑condition verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_64bit.smt2",
    "description": "This instance encodes a verification condition for the unsigned remainder operation on 64‑bit bit‑vectors. It checks whether the simple side‑condition SC (“s ≠ 1 ∨ t ≠ 0”) is equivalent to the existence of an argument x such that the totalised remainder uremtotal(x,s) differs from t; the formula asserts the negation of that equivalence, thereby asking the solver to find a counter‑example. The problem is a crafted quantified BV benchmark with two 64‑bit constants, three user‑defined totalising functions, and a single existential quantifier in each implication, yielding modest term depth (7) but requiring quantifier reasoning over bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvshl0_32bit.smt2",
    "description": "The instance formalizes a small verification condition about signed comparisons involving left‑shifts of 32‑bit vectors. It defines the predicate  \n\n```\nSC(s,t) ⇔ ( (max ⟪ s)  ∧ max ) ≥_s t\n```  \n\n(where `max` is the greatest 32‑bit signed value) and asks whether this predicate is equivalent to the existence of a witness `x` such that `(x << s) ≥_s t`. The single top‑level assertion negates the biconditional, so the solver must decide whether a counterexample to the equivalence exists. The problem features a single existential quantifier over a bit‑vector, a few arithmetic/shift operators, and modest term depth (7), reflecting a crafted benchmark for checking invertibility‑condition reasoning in quantified bit‑vector verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_64bit.smt2",
    "description": "This instance checks an **invertibility condition** for the 64‑bit unsigned left‑shift (`bvshl`) with respect to the unsigned‑greater‑or‑equal relation (`bvuge`). It defines a predicate `SC(s,t)` that is true iff one of the 65 possible shifts of `s` (by 0…64 bits) is ≥ `t`, and then asserts that `SC(s,t)` is logically equivalent to the existence of a shift amount `x` such that `bvshl s x ≥ t`. The formula negates this equivalence, so a solver must prove it unsatisfiable, thereby confirming the condition holds for all 64‑bit values of `s` and `t`. The problem features a single existential quantifier and a large disjunction (≈ 65 terms) but shallow term depth, making it a crafted quantified‑bit‑vector verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_62_4bit.smt2",
    "description": "The benchmark checks whether the Boolean condition  \n\n\\[\nSC \\;=\\; (s \\ge_{s} ts)\\;\\land\\;(s=ts \\rightarrow tx \\neq -1)\n\\]\n\nis logically equivalent to the existence of a 62‑bit word `x` such that the signed‑greater‑than comparison  \n\n\\[\n\\text{bvsgt}(\\; \\text{concat}(s,x),\\;\\text{concat}(ts,tx)\\; )\n\\]\n\nholds.  It asserts the negation of the bidirectional implication between `SC` and the existential formula, thus probing the correctness of an invertibility condition for `bvsgt` on concatenated bit‑vectors.  The instance is a crafted verification problem with a single existential quantifier, a small number of variables (three globals plus one quantified), moderate term depth (7), and involves signed comparisons after concatenation, making it a focused test for solvers’ handling of quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_4bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility lemma about the signed‑less‑than relation on the totalised unsigned‑remainder operator.  It asserts that for 4‑bit bit‑vectors s and t, the predicate  \n\n  SC(s,t) ≡ bvslt( ¬t , (bvneg s) ∨ (bvneg t) )  \n\nholds exactly when there exists an x such that bvslt( uremtotal x s , t ), where uremtotal is defined to return a default value when its divisor is zero.  Thus the formula checks the equivalence of a concrete bit‑vector condition with the existence of a solution to a quantified remainder inequality, using a single existential quantifier, small 4‑bit widths, and a modest term depth (≈7), which makes it a crafted quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem0_32bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility lemma of the unsigned remainder operation on 32‑bit bit‑vectors: it defines a predicate SC(s,t) relating two bit‑vectors s and t, and checks whether the existence of an x with a signed‑greater‑than remainder (uremtotal x s) > t is logically equivalent to SC(s,t). The formula asserts the negation of this equivalence, so the solver must find a counter‑example or prove unsatisfiability. It involves quantified (∃) bit‑vector terms, totalised division/remainder to avoid division‑by‑zero, and a mix of signed comparisons, making it a non‑linear BV problem with moderate term depth and a few alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_64bit.smt2",
    "description": "The instance encodes a verification check for an invertibility condition of unsigned division on 64‑bit bit‑vectors.  It defines a “total” division operator (`udivtotal`) that returns the maximal bit‑vector when the divisor is zero, and then asserts that the predicate `SC(s,t) ≡ (udivtotal(−1,s) > t)` is logically equivalent to the existence of some `x` such that `udivtotal(x,s) > t`.  The formula is a single quantified assertion (two implications chained with an `and`, negated) that must be shown unsatisfiable, testing the solver’s handling of existential quantification, conditional definitions, and edge‑case division semantics in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvmul_32bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification condition for 32‑bit signed multiplication: it defines a predicate SC(s,t) and asserts that SC(s,t) is equivalent to the existence of a 32‑bit value x such that x · s <ₛ t (signed less‑than). By negating the conjunction of the two implications, the solver must either find a counterexample or prove the equivalence, i.e., validate the invertibility condition for bvmul under bvslt. The problem features a single existential quantifier inside each implication, moderate term depth (7) and uses only BV operators, making it a crafted quantified‑BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_64bit.smt2",
    "description": "The instance encodes a quantified bit‑vector verification task: it asserts that for 64‑bit signed values `s` and `t`, the predicate `SC(s,t)` (which excludes the case `s = 0` together with a negative `t`) is equivalent to the existence of a 64‑bit `x` such that the signed multiplication `x·s` is less‑or‑equal to `t`. By asserting the negation of the two implications that form this equivalence, the solver must either find a counter‑example or prove the equivalence universally true. The problem features a single existential quantifier over a multiplication term, modest term depth (7) and a handful of bit‑vector operations, making it a crafted benchmark for testing invertibility‑condition reasoning in quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_32bit.smt2",
    "description": "The instance verifies an invertibility condition for the signed‑less‑than relation after addition on 32‑bit bit‑vectors: it asserts that “\\(t\\) is different from the minimum signed value (i.e., \\(t\\neq\\text{min}\\))” is logically equivalent to the existence of a word \\(x\\) such that \\((x+s) <_{s} t\\). By negating this equivalence, the solver is asked to find a pair \\((s,t)\\) that disproves it, thereby checking the correctness of the condition used in quantified‑BV reasoning. The benchmark features a handful of quantified existentials, simple arithmetic (addition, signed comparison) and a few auxiliary total division/remainder definitions, with modest term depth (≈7) and a small number of variables, making it a crafted verification test for quantifier‑handling capabilities of BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem1_64bit.smt2",
    "description": "The instance verifies an invertibility condition for the signed‑less‑than relation on 64‑bit bit‑vectors: it checks whether the simple predicate SC(s,t) ( s < t or 0 < t ) is equivalent to the existence of a divisor x such that the “total” remainder uremtotal(s,x) is signed‑less than t. The formula contains a nested existential quantifier together with totalised division/remainder (handling division‑by‑zero via ite), a handful of constants and shallow term depth, making it a crafted quantified‑BV benchmark that tests solvers’ ability to reason about quantified arithmetic and conditional definitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr0_32bit.smt2",
    "description": "The file encodes a quantified bit‑vector verification task: it asserts the negation of the equivalence between the simple condition `SC(s,t) ≡ (t ≠ 0)` and the existence of a 32‑bit value `x` such that the arithmetic right‑shift of `x` by `s` is unsigned‑less‑than `t` (`bvult (bvashr x s) t`). In other words, it checks whether the invertibility condition “`t ≠ 0` iff there is an `x` with `bvashr x s <_u t`” holds for all 32‑bit `s` and `t`. The problem consists of a single existential quantifier inside two implications, a modest term depth (7) and a handful of auxiliary total‑division definitions that are not used, making it a crafted benchmark for quantified BV reasoning (especially handling `bvashr` and `bvult`).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_62_4bit.smt2",
    "description": "The instance encodes a verification condition for an invertibility rule on unsigned‑greater‑than over concatenated bit‑vectors: it asserts that the Boolean predicate SC (which requires that when the 62‑bit value tx is all 1’s then the 4‑bit term s is larger than ts) is equivalent to the existence of a 62‑bit vector x such that concat(x,s) > concat(tx,ts). The formula negates this equivalence and asks the solver to find a counter‑example, thus testing quantified BV reasoning (existential quantifier, concat, bvugt) rather than large‑scale combinatorial searching. The problem is a crafted, shallow (depth 7) benchmark aimed at assessing solvers’ ability to handle quantified bit‑vector constraints arising from invertibility‑condition verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-4.smt2",
    "description": "The formula checks a fix‑point (loop‑closure) property of a small unrolled transition system: starting from a₀ = 1, b₀ = 0, each step updates aᵢ to aᵢ₋₁ + bᵢ₋₁ while aᵢ₋₁ < 100 (otherwise it stays unchanged) and sets bᵢ to the previous aᵢ₋₁. A universally quantified 5‑step trace and an existentially quantified copy of the same trace are introduced, and the assertion requires that the final universal state (a₄,b₄) equals one of the intermediate existential states, i.e., a loop is reachable. The instance involves large 2501‑bit vectors, a ∀…∀∃…∃ quantifier alternation, and nested ite/bvadd/bvult expressions, making it a demanding quantified bit‑vector verification (hardware fixpoint) problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-4.smt2",
    "description": "The formula encodes a fix‑point (state‑equivalence) check for a small Verilog datapath that computes a remainder ( bvurem ) and a related subtraction (bvsub (bvudiv …)). It universally quantifies the inputs and outputs of five successive iterations of the circuit (indices 0 to 4) and existentially quantifies a candidate previous state (indices *_39_*); the asserted implication requires that, whenever the circuit’s functional definitions hold at each step, the state at iteration 4 must be identical to one of the earlier states (0–3). This yields a deep (term depth 44) quantified bit‑vector problem with 20 ∀‑quantifiers followed by 16 ∃‑quantifiers, making it a challenging industrial‑style fix‑point verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-6.smt2",
    "description": "The file encodes a fix‑point/loop detection property for a small Verilog‑style pipeline: a sequence of six clock‑cycle transition relations (reset handling, arithmetic and bitwise updates of stage registers) is described with universal variables, while a second set of existential variables represents a candidate unrolled execution; the final clause asserts that after the sixth cycle the state must coincide with one of the earlier states. Thus the formula checks whether the pipeline admits a reachable cycle (i.e., a fix‑point) using quantified bit‑vector constraints. It features a large number of variables (≈100 BV terms), many quantifier alternations (≈60 ∀ followed by 50 ∃) and a deep term nesting (depth 116), making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-9.smt2",
    "description": "The instance encodes a quantified fix‑point/loop‑detection property for a hardware model: starting from the concrete state (a₀=1, b₀=0), the 10‑step transition aᵢ₊₁ = ite(aᵢ < 100, aᵢ + bᵢ, aᵢ) and bᵢ₊₁ = aᵢ is unrolled both for a universally‑quantified 10‑step sequence and for an existentially‑quantified 40‑step sequence, and the formula requires that the 10‑step state (a₉,b₉) coincides with one of the intermediate states of the longer trace.  The problem is thus a reachability/fix‑point check expressed as a heavily nested quantified bit‑vector formula (20 universals, 18 existentials) over 2501‑bit vectors, with deep term nesting (depth ≈ 46), making quantifier‑alternation handling and large bit‑width the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-10.smt2",
    "description": "The file encodes a quantified bit‑vector verification of a small Verilog division circuit.  For each of 11 consecutive steps it asserts that the outputs `out1` (remainder) and `out2` (in1 – quotient·in2) are exactly the results of `bvurem` and `bvudiv` on the step’s inputs, and then requires that the state at step 10 coincides with one of the earlier states in a second, existentially‑chosen 10‑step trace – i.e., a fix‑point / loop‑detection property for the circuit.  The formula features a deep alternation of ∀ (44) and ∃ (40) quantifiers over 84 8‑bit vectors, with term depth 92, making it a challenging industrial‑style fixpoint‑equivalence check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-6.smt2",
    "description": "The instance encodes a fix‑point verification problem for a Verilog hardware component (a UART‑like controller).  All signal variables (booleans, 8‑, 10‑ and 4‑bit vectors) are quantified, the nested forall blocks describe the transition relation from one clock cycle to the next, and the inner exists block asserts that after a bounded number of cycles the state vector repeats a previously‑seen valuation (i.e., a fix‑point/periodicity condition).  Because the formula contains thousands of nested ite and equality terms, deep term nesting (depth ≈ 360) and alternating forall/exists quantifiers over hundreds of Boolean variables, it is a highly quantified, large‑scale bit‑vector verification task that is difficult for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-7.smt2",
    "description": "The benchmark checks a fix‑point property of an 8‑bit hardware division module: for eight successive clock cycles the outputs must obey the division‑algorithm identities (remainder = bvurem in1 in2 and in1 − quotient·in2), and the final state is required to coincide with one of the earlier states that could be reached after a bounded number of additional iterations (the “_39_” variables).  This is expressed as a single quantified formula with 32 universal variables followed by 28 existential variables, many BV arithmetic operators, a term depth of 68 and a dense nesting of conjunctions, yielding a challenging industrial fix‑point verification instance due to the alternation of quantifiers and the large number of bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-8.smt2",
    "description": "The instance encodes a fix‑point verification problem for a simple 8‑stage hardware pipeline written in Verilog.  It universally quantifies over the 32‑bit state registers (dataOut, stageOne, stageTwo, temporary stages), the input data, reset signal and constant parameters for eight successive cycles, and existentially quantifies a second copy of the same 9‑step trace; the body asserts that each step follows the pipeline’s transition equations (addition, bitwise‑and and conditional reset) and finally requires that the state after the ninth step coincides with one of the earlier eight states, i.e. a reachable loop (fix‑point) exists.  The formula features a deep quantifier alternation (≈ 77 ∀ followed by 68 ∃), a large number of bit‑vector variables (130) and a maximal term depth of 152, making it a challenging industrial benchmark for quantified bit‑vector solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-8.smt2",
    "description": "The file encodes a **hardware‑verification** problem for a sequential circuit (a UART‑like transmitter) as a quantified bit‑vector formula.  A universal block quantifies the initial Boolean/bit‑vector signals (send_en, tx_conta, out_reg, etc.); an existential block then describes eight unrolled transition steps using a huge network of `ite`‑defined next‑state equations, and finally asserts that the state reached at step 8 must coincide with one of the intermediate states (a fix‑point/loop property).  The instance features deep term nesting (depth ≈ 472), many alternating ∀/∃ quantifiers (≈ 240 ∀ and 213 ∃), and a large number of Boolean and bit‑vector variables (≈ 370 Bool, 83 BV), making it a challenging industrial fixpoint‑checking benchmark for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-3.smt2",
    "description": "This instance models the bit‑vector dynamics of an Ethernet‑style CSMA/CD network (including transmitters L0/L1, frame‑transmit modules FT0/FT1, back‑off counters BT0/BT1, receivers FR0/FR1, the physical layer pls/plr and the shared channel CHN) and asserts a *fix‑point* safety property over several time‑steps.  The single quantified formula universally quantifies all Boolean and bit‑vector signals for four sequential cycles, then links each step with a large conjunction of ite‑based update rules (carrier‑sense, collision‑detect, delay counters, back‑off windows, frame readiness, etc.) and finally demands that the resulting state satisfies the intended invariant.  The benchmark therefore checks whether the Ethernet protocol’s state‑machine reaches a stable, collision‑free configuration, exercising a deep quantified‑BV formula with thousands of variables and a term depth exceeding one thousand.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-10.smt2",
    "description": "This instance encodes an industrial hardware fix‑point verification task for a small MIPS‑style processor datapath.  It models a sequence of 11 clock cycles (State_64_0 … State_64_10) with detailed control signals (e.g. PC, IR, ALUOp, RegDst, MemRW, ZSel, branch/jump enables) expressed as quantified bit‑vectors, and asserts that the transition relation respects the specification and reaches a stable state within the bounded horizon.  The formula contains deep nesting of ∀/∃ quantifiers, many ite and extract operations, and a maximal term depth of 688, making it a challenging quantified‑BV verification benchmark.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-2-fixpoint-6.smt2",
    "description": "This benchmark encodes a formal verification task for a two‑processor cache‑coherence protocol (including the caches, a bus arbiter and the shared memory) as a quantified bit‑vector fixpoint problem. The single assertion universally quantifies over all state variables for several time‑steps (0…6), defining the transition relation, cache requests, snoop handling, invalidation and shared‑state updates, and finally asserts that a safety invariant (e.g., no two caches simultaneously hold exclusive data) holds for every reachable state; an existential block is used to witness a counterexample if the invariant is violated. The instance is challenging because it contains thousands of Boolean and BitVec variables, deep nesting of `ite` expressions (term depth > 1300), and a large alternation of universal and existential quantifiers, typical of industrial hardware‑verification fixpoint checks.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-9.smt2",
    "description": "The benchmark encodes a verification of a small 10‑stage hardware pipeline: each stage updates a pair of 32‑bit registers (stageOne, stageTwo) and temporary copies based on the previous registers, an input word, two constant words, and an optional reset, with the output computed as the sum of the two registers when not reset. The universally quantified variables describe all possible sequences of inputs, resets and constants, while the existential block searches for a state after nine transitions that is identical to one of the earlier states (a fix‑point/loop), expressed as a conjunction of equalities combined with an implication over the transition relations. The formula features deep term nesting (depth ≈ 170) and a high number of quantifier alternations (≈ 86 ∀ → 77 ∃), making it a challenging quantified bit‑vector fixpoint‑checking problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-6.smt2",
    "description": "The instance encodes a bounded‑step fixpoint verification of a small MIPS‑style processor.  It defines, with a deep chain of universally quantified time‑frame variables (State ₆₄₀ … State ₆₄₅, control signals, IR fields, etc.), the exact transition relation of the datapath and control unit, then existentially searches for a concrete 6‑step execution that violates the expected fixpoint property (the initial state is all‑zero and after the unroll the next‑state equals the current state).  The problem is a hardware‑verification task that features many alternating quantifiers, a huge number of ite/extract expressions, and a term‑depth of over 400, making it challenging for quantified‑BV solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-10.smt2",
    "description": "The benchmark encodes a hardware fix‑point verification in the bit‑vector logic: a pair of 2501‑bit registers (a,b) evolve for ten steps according to the recurrence aₖ₊₁ = ite(aₖ < 100, aₖ + bₖ, aₖ) and bₖ₊₁ = aₖ, starting from a₀ = 1, b₀ = 0.  The formula universally quantifies over the ten forward states and existentially quantifies over a parallel “unrolled” trace of length 39, finally asserting that the state after ten steps must coincide with one of the earlier existential states – i.e. a fix‑point (or loop) must be reached within 39 iterations.  The instance features a deep quantifier alternation (22 ∀, 20 ∃), very large bit‑vectors (2501 bits) and a term depth of 50, making it a challenging industrial fix‑point check for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-5.smt2",
    "description": "The instance encodes a verification of a small hardware pipeline by asking whether a five‑step unrolled execution can reach a fixpoint: starting from all registers equal to 0, each step updates dataOut, stageOne, stageTwo, and temporary registers with simple bvadd, bvand and ite operations (guarded by a reset flag), and the formula requires that the state after the fifth step coincides with one of the states from steps 0‑4. This property is expressed as a single quantified assertion with a long prefix of 50 nested forall variables (the concrete pipeline states at each step) followed by 41 exists variables representing a candidate fixpoint, yielding deep quantifier alternation, a term depth of 98, and numerous bit‑vector equalities. The problem thus falls into the class of quantified bit‑vector fix‑point checks for hardware models, challenging solvers with a large number of quantified variables and deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-7.smt2",
    "description": "This benchmark encodes a hardware fix‑point verification problem as a quantified bit‑vector formula. It universally quantifies eight pairs of 2501‑bit state variables ( a₀…a₇, b₀…b₇ ) that evolve according to a simple loop ( aᵢ₊₁ = ite(aᵢ < 100, aᵢ + bᵢ, aᵢ), bᵢ₊₁ = aᵢ ) from the initial state a₀ = 1, b₀ = 0, and existentially quantifies a second copy of the same trajectory (the “_39_” variables). The formula asserts that, if both trajectories follow the loop, the final universal state (a₇,b₇) must coincide with one of the earlier existential states, i.e., a loop/fix‑point exists. The instance features a large 2501‑bit width, deep term nesting (depth ≈ 38), and a chain of quantifier alternations (16 ∀, 14 ∃), making it a challenging industrial verification case for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-9.smt2",
    "description": "The formula verifies a fix‑point (loop) property of a small 8‑bit division circuit: for ten successive executions it defines the remainder (`bvurem`) and the quotient‑derived remainder (`bvsub (bvudiv …)`) and then asks whether there exists a later state (the “_39_” variables) that can be reached and whose values at step 9 coincide with one of the earlier states, i.e., the circuit may enter a cycle. This is expressed as a deep quantified bit‑vector query with a ∀‑prefix over 40 variables (10 time steps × 4 signals) followed by an ∃‑prefix over 36 variables, using many arithmetic BV operators, resulting in high quantifier alternation and term depth (≈84).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-7.smt2",
    "description": "This benchmark encodes an inductive‑invariant (fix‑point) verification of a Verilog UART‑style controller.  The problem quantifies universally over the whole state of the circuit (control flags, 8‑bit data registers, 10‑bit counters and several 1‑bit status signals) for eight successive clock cycles, then existentially guesses a loop‑back state that repeats after the seventh cycle; the sole assertion checks that the all‑zero initial configuration can never lead to a violation of the invariant.  Because the model is expressed with thousands of nested ite, =, and ite‑based updates, it yields a deep term‑depth, heavily quantified bit‑vector formula that is representative of industrial hardware fix‑point checking problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-6.smt2",
    "description": "The formula encodes a fix‑point / equivalence check for a small hardware module that computes the remainder and the “division‑by‑multiplication” part of an unsigned division ( out1 = a % b, out2 = a − (b·(a / b)) ). It universally quantifies over seven consecutive pipeline states (indexed 0…6) and existentially quantifies over six candidate states (the “_39_” copies), asserting that each state satisfies the exact division arithmetic and that the seventh state must be identical to one of the earlier five candidate states. Thus the instance asks whether the circuit reaches a loop‑invariant state after a bounded number of steps; the problem is a quantified bit‑vector fix‑point verification with many alternations (28 ∀, 24 ∃) and deep term nesting (depth ≈ 60), making it representative of industrial hardware model‑checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/usb-phy-fixpoint-4.smt2",
    "description": "This benchmark encodes an inductive‑invariant (fixpoint) check for a USB PHY transceiver model.  The quantified formula describes the bit‑vector state of the transmitter and receiver pipelines (registers, control signals, clock‑ed updates, reset handling, NRZI encoding, etc.) over several clock cycles, and asserts that the transition relations preserve a safety property.  The instance features a huge block of universal quantifiers followed by many existential witnesses, deep term nesting (depth ≈ 972) and thousands of Boolean/bit‑vector constraints, making it a challenging industrial hardware‑verification problem.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-3-fixpoint-3.smt2",
    "description": "The file encodes a quantified‑bit‑vector fix‑point verification of a three‑cache coherence protocol (caches A, B, C plus a bus arbiter) that is modelled over four time‑steps.  The universally‑quantified part ranges over all possible values of the protocol’s control signals (request, snoop, invalidate, state bits, counters, etc.), while the existentially‑quantified tail searches for a concrete execution that violates the coherence invariant (e.g., two caches simultaneously believing they hold exclusive data).  Because the model contains thousands of Boolean and bit‑vector variables, nested ite/concat expressions, and an alternation of ∀/∃ quantifiers with a term depth exceeding 1 000, it poses a highly challenging industrial benchmark for quantified‑BV solving.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-5.smt2",
    "description": "The benchmark encodes a fix‑point verification for a small Verilog datapath that computes, on 8‑bit inputs, the remainder (`bvurem`) and the difference `in1 − (bvudiv in1 in2)·in2`.  Six unfolding steps of the circuit are universally quantified, and an existentially quantified “candidate” execution trace of the same length is introduced; the formula demands that the outputs and inputs at step 5 of the universal trace coincide with those of *some* step of the existential trace, i.e. that the system reaches a previously seen state (a fix‑point).  The instance features a deep term nesting (depth ≈ 52) and a quantifier alternation pattern ∀…∀∃…∃ over dozens of 8‑bit bit‑vectors, making it a challenging quantified bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-8.smt2",
    "description": "The instance encodes a hardware fix‑point verification task: a sequence of eight symbolic states \\((a_i,b_i)\\) (2501‑bit vectors) is defined by the recurrence  \n\\(a_{i}= \\text{ite}(a_{i-1}<100,\\;a_{i-1}+b_{i-1},\\;a_{i-1})\\) and \\(b_i = a_{i-1}\\) with the initial condition \\(a_0=1,\\;b_0=0\\).  After the eighth step the formula requires that the final state \\((a_8,b_8)\\) must coincide with one of the eight intermediate states of a second, existentially‑quantified copy of the same recurrence, i.e., the system must have entered a loop (a fix‑point) within eight iterations.  The problem is a quantified bit‑vector verification query with a large (2501‑bit) word size, deep term nesting (depth ≈ 42) and a forall‑exists alternation, making it a challenging industrial‑scale fix‑point check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-3.smt2",
    "description": "The benchmark encodes a hardware fix‑point property as a quantified bit‑vector formula.  It models four successive states (a₀…a₃, b₀…b₃) of a simple loop where each new state is defined by  \n\\(a_{i+1}= \\text{ite}(a_i < 100,\\; b_i+a_i,\\; a_i)\\) and \\(b_{i+1}=a_i\\) with the initial values \\(a_0=1, b_0=0\\).  The formula universally quantifies over these five‑step‑unrolled states and existentially quantifies over a second copy of the same recurrence (indexed “_39_”), then requires that the third state of the first execution coincides with one of the three intermediate states of the second execution, thereby checking for a recurrence (fix‑point) after 39 iterations.  The instance features deep nesting of 8 universal and 6 existential quantifiers, large 2501‑bit vectors, and numerous ite, bvadd and bvult terms, making it a challenging quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-9.smt2",
    "description": "This benchmark encodes a safety‑verification problem for a Verilog‑modeled serial‑interface module, unrolling its state‑machine (signals such as send_en, tx_end, load, counters, and status flags) over ten clock cycles and asserting that an error flag can never become true.  The formula is a quantified bit‑vector fix‑point condition (∃ initial state ∀ transition steps) generated from the VCEGAR hardware suite, featuring thousands of ite and equality constraints and deep terms that challenge quantified‑BV solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-4.smt2",
    "description": "This benchmark encodes an inductive‑invariant (fixpoint) check for a hardware model of an Ethernet CSMA/CD system.  The quantified formula links two successive cycles of several inter‑connected state machines—two MAC controllers (L0, L1), their transmit (FT0/FT1) and back‑off timers (BT0/BT1), frame receivers (FR0/FR1), the shared channel (CHN), and associated control signals—using small‑width bit‑vectors, arithmetic, and many ite/zero‑extend terms to capture carrier‑sense, collision detection, random back‑off, and frame‑delivery logic.  The instance asks whether a universally quantified transition relation admits a fixpoint satisfying the safety constraints (e.g., correct handling of collisions and successful frame transmission), and it stresses solvers with a very deep term structure, thousands of quantified variables, and extensive Boolean/bit‑vector nesting.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_osrusbfx2_exe_testapp.c.smt2",
    "description": "The benchmark asks for a **ranking‑function synthesis**: does there exist a 32‑bit constant c (the variable `c__G_ReadLen_36_C`) such that for **all** possible values of the loop length `c__G_ReadLen_35_0` that are not multiples of 4, and for the next length `c__G_ReadLen = c__G_ReadLen_35_0+1`, the signed product `c·c__G_ReadLen` is strictly smaller than `c·c__G_ReadLen_35_0`. In other words, it encodes the requirement that a linear (multiplicative) ranking function decreases on each iteration of a loop whose counter increments by 1 under the given precondition. The formula is a quantified bit‑vector problem with one existential quantifier followed by three universals, using only a few arithmetic operators (addition, multiplication, remainder, sign‑extension) and has modest term depth, typical of industrial termination‑proving benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm610.c.smt2",
    "description": "The benchmark encodes a termination‑proof problem for a small loop in the GSM‑610 encoder: it asks whether there exists a 32‑bit coefficient C such that the linear ranking function C·n strictly decreases (as a signed 64‑bit product) when the loop variable n is incremented by 1 while staying ≤ 8. This is expressed as an ∃ C ∀ (pre‑state, n₀, n) formula over bit‑vectors, using sign‑ and zero‑extensions to perform the comparison of the two products. The instance contains a single quantified conjunction with three nested universal quantifiers, a modest term depth (9) and only four bit‑vector variables, typical of ranking‑function synthesis tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kernel_uagp35_gart.c.smt2",
    "description": "The instance encodes a **ranking‑function synthesis** problem for a loop in the program `gart.c`: it asks whether there exists a 32‑bit coefficient `c__gart__main__1__Index_36_C` such that, for every possible valuation of the loop’s pre‑state variables (the current index, the number of pages, nondeterministic values, etc.), the relation  \n\n\\[\nc \\cdot \\text{Index} < c \\cdot \\text{pre‑Index}\n\\]\n\nholds whenever the loop guard is true (i.e., the index is below the page bound) and the loop body advances the index by one.  The formula therefore contains a single existential quantifier over the coefficient followed by a block of universal quantifiers over the program variables, and it mixes signed/unsigned extensions, 32‑bit multiplication, and signed less‑than – a pattern that is known to be challenging for SMT solvers due to the quantifier alternation and non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_hwsim.cpp.smt2",
    "description": "The instance asks whether a linear ranking function exists for a loop that manipulates three 32‑bit counters (`BufferRemaining`, `ScatterGatherMappingsQueued`, `ScatterGatherBytesQueued`) in the AVStream hardware‑simulation code. It is expressed as an ∃∃∃…∀…∀ formula in the BV logic: three existentially‑quantified coefficient variables must make the ranking expression (a signed linear combination of the three counters) strictly decrease ( bvslt ) for every pair of pre‑ and post‑state values that satisfy the loop’s update constraints, which involve non‑deterministic choices, subtraction, and bounded‑integer arithmetic. The problem is a termination‑verification / ranking‑function synthesis task with a deep term structure (depth 26) and a large quantifier alternation (3 existentials followed by 14 universals), making it a notably hard bit‑vector quantified benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_sysfx_swap.cpp.smt2",
    "description": "The benchmark encodes the synthesis of a linear ranking function for a decrementing loop in the file *audio_sysfx_swap.cpp*.  An existential 32‑bit coefficient `cpp__main__c__main__1__u32ValidFrameCount_36_C` must be found such that, for every admissible transition (captured by four universally quantified Bit‑Vec variables that express the loop’s state update: the frame‑count is decreased by 1 and stays non‑zero), the product of the coefficient with the current frame‑count is strictly smaller (signed) than the product with the predecessor frame‑count.  Hence the formula checks the existence of a coefficient guaranteeing a strictly decreasing ranking measure across all loop steps; the presence of nested quantifiers, sign/zero extensions and a non‑linear multiplication makes the problem a non‑trivial quantified bit‑vector synthesis instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_voice.cpp.smt2",
    "description": "The instance encodes a termination‑proof problem for a loop in *audio_ddksynth_voice.cpp*: it asks whether there exist two 32‑bit constants (the “ranking function” coefficients) such that for every possible pre‑state of the loop variables `dwSoFar` and `dwLength`, every nondeterministic choice, and the corresponding post‑state, the constructed linear measure strictly decreases (the `bvslt` inequality) while remaining non‑negative. The formula is an ∃∃∀⁸ quantified bit‑vector constraint that mixes signed/unsigned extensions, multiplication and addition, and therefore exhibits a deep term structure (depth 17) and a modest quantifier alternation, typical of ranking‑function synthesis benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_pcidrv_sys_hw_nic_init.c.smt2",
    "description": "The benchmark asks whether there is a 32‑bit coefficient c such that, for every pair of states related by the transition \\(i' = i+2\\) with the guard \\(i<6\\), the signed product \\(c·i'\\) is strictly smaller than the signed product \\(c·i\\).  Formally it is an ∃ c ∀ i, i₀, i′ formula over bit‑vectors that captures the existence of a linear ranking function for a tiny loop.  The instance involves a single existential quantifier, three universal variables, and uses sign‑extension, multiplication and signed‑less‑than, yielding a shallow term depth (9) but a non‑trivial quantifier alternation typical of ranking‑function synthesis problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_usbnwifi_mp_util.c.smt2",
    "description": "The benchmark encodes a **ranking‑function synthesis** problem for a loop extracted from the C source `network_usbnwifi_mp_util.c`.  Three 32‑bit coefficient variables (the “_36_C” symbols) are existentially guessed, and the formula universally quantifies over all possible pre‑state flag values, asserting that the linear combination  \n\\[\n\\text{coeff}_1\\cdot\\text{FlagsObj}+ \\text{coeff}_2\\cdot\\text{NewFlags}\n\\]  \nstrictly decreases (signed‑less‑than) after the loop’s update, which is expressed with bit‑vector multiplications, sign‑ and zero‑extensions, and bitwise operations.  Hence the solver must find bit‑vector coefficients that make the quantified inequality hold for every transition, a typical termination‑verification query that features a single ∃∀ quantifier alternation, moderate term depth (23) and several arithmetic and bit‑wise operations over 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_pnpi8042_moudep.c.smt2",
    "description": "The instance asks for a 32‑bit coefficient `c__moudep__main__1__i_36_C` (existential) that makes the linear term `c * i` a strict descent ranking function for a loop: for every possible pre‑state value `i`, a nondeterministic value (fixed to 0), an upper bound `Attempts`, and the next state `i+1` (with `i < Attempts`), the signed product `c*i` must be greater than `c*(i+1)`. In other words, it encodes a quantified bit‑vector synthesis problem for a termination ranking function, with one existential followed by six universal quantifiers and moderate term depth (12). The challenge lies in the alternation of quantifiers and the need to discover a coefficient that satisfies the strict inequality across all admissible loop transitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_isochapi.c.smt2",
    "description": "The benchmark asks whether there exists a 32‑bit constant C such that the linear expression C · i is a strictly decreasing signed ranking function for a loop body of the function isochapi_main.  The formula is an ∃ C ∀ (pre‑state, current‑state, nondeterministic values, loop bound) implication: under the loop’s guard (i < nNumberOfDescriptors) and the update i = pre_i + 1, the signed product C·i must be less than C·pre_i.  This quantified bit‑vector problem features one existential followed by eight universals, mixed sign‑ and zero‑extensions and bit‑vector multiplication, typical of ranking‑function synthesis/termination checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_misc.c.smt2",
    "description": "The instance encodes a **linear ranking‑function synthesis** problem for a loop in the C function `st_misc` (network driver code). It asks whether there exist 32‑bit coefficients (`c__st_misc__…`) such that, for all possible values of the loop variables `i`, `j`, the array length `rateSet_uRateSetLength` and a nondeterministic choice, a weighted‑sum expression strictly decreases (the `bvslt` inequality) whenever the loop guard holds. The formula features three nested existential quantifiers over the coefficients followed by eight universal quantifiers over program variables, and combines bit‑vector addition, multiplication, and sign/zero extensions, leading to deep terms (depth 23) and a challenging quantified‑BV reasoning task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_csynth2.cpp.smt2",
    "description": "The benchmark asks for a 16‑bit constant `C` (the existential variable) that serves as a linear ranking function for a loop whose counter `nNew` is decremented by 1 each iteration, provided the counter is positive and a 32‑bit nondeterministic value is non‑zero.  The formula universally quantifies over the pre‑state counter, the nondet value and an auxiliary 32‑bit variable, and requires that whenever the loop condition holds the product `C·nNew` (sign‑extended to 32 bits) is strictly smaller than `C·nPrev`, thus enforcing a strictly decreasing measure.  The problem is a quantified‑bit‑vector synthesis task with an ∃∀ alternation and non‑linear multiplication, which makes it challenging for QBV solvers despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_usbsamp_sys_queue.c.smt2",
    "description": "The instance encodes a **ranking‑function synthesis** problem for a bit‑vector loop taken from the USB‑sample queue implementation. It asks whether there exists a 32‑bit coefficient `c__queue__main__1__ix_36_C` such that, for every possible pre‑state index, nondeterministic value and loop iteration (described by the universally quantified variables), the product `c * ix` strictly decreases after the loop body (`bvslt (c*ix_next) (c*ix_pre)`), while also respecting the loop’s guard (`bvsgt ix_pre 0xffffffff`) and the nondeterministic condition (`c__main___36_tmp__return_value_nondet_36_1 ≠ 0`). The formula contains a single existential quantifier over the coefficient and five universal quantifiers over state variables, with modest term depth (11) and a small number of bit‑vector variables, making it a typical quantified BV ranking‑function benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_cseries.c.smt2",
    "description": "The formula asks whether there exists a 32‑bit constant C that serves as a linear ranking function for a loop that repeatedly decrements a signed 32‑bit counter c while it stays non‑negative. Formally, it seeks a C such that for every state where the predecessor counter equals a non‑negative value n and the successor is n‑1, the signed product C·(n‑1) is strictly smaller than C·n. This is a quantified bit‑vector synthesis problem for a termination proof, featuring one existential quantifier over C followed by three universal quantifiers and modest term depth (sign‑extensions and 64‑bit multiplications).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_wavepcistream2.cpp.smt2",
    "description": "The instance encodes a termination‑proof query for a loop in *audio_ac97_wavepcistream2.cpp*: it asks whether there exists a 32‑bit constant `C` (the variable `cpp__main__c__main__1__1__i_36_C`) such that for every possible loop iteration the linear ranking function `C·i` strictly decreases (signed‑less) when the loop variable `i` is updated to `i' = (i+1) & 31` under the loop guard `i' ≠ zero_extend(nCurrentIndex)`.  Formally this is an ∃ C ∀ (pre‑state, post‑state) implication over bit‑vectors, using sign‑ and zero‑extensions, addition, bitwise‑and, and multiplication.  The problem features a single quantifier alternation with a modest number of variables and shallow term depth, but the mixed extensions and multiplication make the quantified bit‑vector reasoning non‑trivial for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_aplst.c.smt2",
    "description": "The benchmark encodes a ranking‑function synthesis task for a loop in a C program: it asks whether there exists a 32‑bit coefficient C such that, for every reachable state (characterised by the current loop counter i, its predecessor i₀, an auxiliary count APCount and a termination pre‑state value), the signed product C·i is strictly smaller than C·i₀, while also respecting the loop’s unsigned bound i₀ < 4294967295 + APCount.  The formula is a single existential quantifier over C followed by four universal quantifiers over the state variables, using only basic BV operations (addition, multiplication, sign/zero‑extension) and a depth‑11 term structure, typical of quantified bit‑vector termination‑proof benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_detect.c.smt2",
    "description": "The instance encodes a termination‑proof (ranking‑function synthesis) problem for a 32‑bit loop in the program *detect.c*.  It asks whether there exists a 32‑bit coefficient C such that, for every reachable loop state satisfying the loop’s entry conditions (initial index 0, a non‑zero guard s₀, and the index incremented by 1), the signed product C·i is strictly smaller than the signed product C·i₀, i.e. the linear ranking function C·i strictly decreases across the transition.  The formula features a single existential quantifier over C followed by four universal quantifiers over the loop variables, uses sign‑extension to 64‑bit for signed multiplication and comparison, and has a modest term depth (10) with only a handful of bit‑vector variables, making the main difficulty the quantifier alternation rather than raw size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_common.cpp.smt2",
    "description": "The formula encodes the synthesis of a linear ranking function for a loop in the C file *audio_ac97_common.cpp*. It asks whether there exists a 32‑bit coefficient `cpp__main__c__main__1__ulCount_36_C` such that for every possible pre‑state (the loop counter, a nondeterministic byte read, and the loop guard `ulCount ≤ 100`) the transition `ulCount' = ulCount+1` strictly decreases the product `C·ulCount` (checked with a signed‑less‑than comparison). The instance features a single existential quantifier followed by six universal quantifiers over bit‑vectors and uses extensions, multiplication, and bounded arithmetic, yielding a modest term depth (14) but non‑trivial quantifier alternation typical of termination‑proof ranking‑function synthesis problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_cdfs_allocsup.c.smt2",
    "description": "This benchmark asks whether there exist 32‑ and 64‑bit constants (the “ranking‑function coefficients” c__allocsup__…_C) that make a linear arithmetic expression strictly decrease across every transition of the allocsup loop in a file‑system driver.  Formally it is a quantified bit‑vector synthesis problem: three existentially quantified coefficient variables are followed by a block of universally quantified state variables describing the pre‑state and post‑state of the loop, and the core constraint is a signed‑less‑than (`bvslt`) comparison between two sign‑extended linear combinations of offsets, byte counts and the coefficient variables.  The instance features a deep (≈25) term structure, extensive use of sign/zero extensions, multiplications and additions, and a single quantifier alternation (∃…∀…), making it a challenging ranking‑function synthesis/check for termination of the underlying C code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_image.cpp.smt2",
    "description": "The benchmark encodes a **termination‑proof problem** for a loop extracted from *AVStream_image.cpp*: it asks whether there exist two 32‑bit coefficients (the variables ending in _36_C) that define a linear ranking function guaranteeing a strict signed‑decrease ( bvslt ) from one loop iteration to the next. The formula contains an ∃∃ / ∀∀ quantifier alternation: the coefficients must work for **all** possible previous states (mask and CurSpaceX) and a nondeterministic 32‑bit update, under the side‑condition that the mask and space variables are non‑zero and the mask is right‑shifted each iteration. The instance is a quantified bit‑vector problem with moderate term depth (16) and several arithmetic operations (sign/zero extensions, multiplication, addition), typical of the ranking‑function synthesis benchmarks used to evaluate solvers on industrial termination tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm6103.c.smt2",
    "description": "The formula encodes a ranking‑function synthesis query for a loop that doubles a signed 32‑bit variable ( x ← x « 1 ) while staying above the constant 3221225472. It asks for an existential 32‑bit coefficient c such that, for every reachable pre‑state value x, the signed product c·x′ (the new value) is strictly smaller than c·x, i.e. bvslt (c·(bvshl x 1) , c·x). This yields a quantified bit‑vector problem with one ∃‑∀‑∀‑∀ alternation, non‑linear multiplication and sign‑extension, typical of industrial termination‑proof (ranking‑function) benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/general_pcidrv_sys_hw_eeprom.c.smt2",
    "description": "The benchmark encodes the synthesis of a linear ranking function for a loop that manipulates EEPROM data. It asks whether there exist two 16‑bit coefficients ( c__eeprom__main__1__x_36_C and c__eeprom__main__1__size_36_C ) such that, for every possible pre‑state (values of x and size) satisfying the loop’s update relations (size is doubled, x is OR‑ed with 8, masked with ¬4, and a non‑zero low‑order 8‑bit test) and a nondeterministic assignment, the ranking function c₁·x + c₂·size strictly decreases (signed‑less‑than) while staying within a bounded range (no overflow beyond 256). The formula features two outer existential quantifiers over the coefficients and a deep nest of universal quantifiers over the program variables, leading to a quantified bit‑vector problem of moderate size but with high quantifier alternation depth and term complexity, which makes it a challenging instance for termination‑proving solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_filter_namelookup.c.smt2",
    "description": "The benchmark encodes the synthesis of a linear ranking function for a simple loop that decrements a 32‑bit counter `i` (with `i>0` and `i' = i‑1`).  An existential coefficient `c` (a 32‑bit constant) is sought such that, for all possible pre‑states and a nondeterministic value forced to 0, the inequality  \n`c*i < c*i_pre` (after sign‑ and zero‑extending to 65 bits and multiplying) holds, i.e. the ranking function strictly decreases each iteration.  The formula therefore combines a single existential quantifier over `c` with five universal quantifiers over the program variables, uses bit‑vector multiplication and extensions, and features a moderate term depth (11) and nested quantifiers, making it a typical quantified‑BV ranking‑function synthesis problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_e100bex_5x_kd_mp_dbg.c.smt2",
    "description": "This benchmark encodes a termination‑proof problem: it asks whether there exist 32‑bit coefficients `c__mp_dbg__main__1__cb_36_C` and `c__mp_dbg__main__1__cbLine_36_C` that define a linear ranking function guaranteeing a strict decrease across every loop transition of the C function *network_ndis_e100bex*. The formula is a single ∃ ∀ quantified bit‑vector constraint: the existential block fixes the coefficients, the universal block quantifies the pre‑state variables, and the body asserts that, under the loop’s update (captured by equalities and the `ite` for a bounded decrement), the weighted sum of the variables strictly decreases (`bvslt`). The instance features non‑linear BV arithmetic (sign‑extends, multiplications) and a modest term depth (15), typical of ranking‑function synthesis benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/hid_hclient_ecdisp.c.smt2",
    "description": "The instance encodes a **ranking‑function synthesis** problem for a simple loop that iterates over a 32‑bit unsigned index `UlongIndex`.  It asks for a 32‑bit coefficient `c__ecdisp__main__1__UlongIndex_36_C` such that, for every possible pre‑state where the index is less than the loop bound `nUlongs` and the next index is `UlongIndex = UlongIndex₀+1`, the linear term `c·UlongIndex` (sign‑extended to 65 bits) is strictly smaller (signed‑less‑than) after the increment than before, i.e. `c·(i+1) < c·i`.  This is expressed as an ∃‑∀ quantified bit‑vector formula with a single existential coefficient and several universally quantified loop variables, yielding a shallow term depth (≈10) but a non‑trivial alternation that challenges solvers on quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_fmsynth_miniport.cpp.smt2",
    "description": "The instance asks for a 32‑bit coefficient `cpp__main__c__main__1__dwPitch_36_C` that serves as a linear ranking function for a loop that repeatedly halves the variable `dwPitch` (via a logical right‑shift) while it stays at least 1024. Formally it is an ∃‑∀ quantified bit‑vector formula requiring that for every pre‑state `termination__pre__0__cpp__main__c__main__1__dwPitch` equal to the current `dwPitch` (≥ 1024) and its successor `dwPitch = bvlshr(pre,1)`, the product `C·dwPitch` (sign‑extended) is strictly smaller than `C·pre` (zero‑extended). The problem is a typical ranking‑function synthesis check, featuring a single existential coefficient, three universally quantified bit‑vectors, and non‑linear multiplication with sign/zero extensions, but with modest term depth and variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_fastfat_cachesup.c.smt2",
    "description": "The benchmark encodes the synthesis of a linear ranking function for a small loop: it asks whether there exists a 32‑bit coefficient c such that, for every pre‑state where the loop counter i is less than 4 and the next state sets i′ = i + 1, the signed product c·i′ is strictly smaller than c·i (after sign‑extending c and zero‑extending the counters for 65‑bit multiplication).  This is expressed as an ∃ c ∀ pre‑state ∀ i₀ ∀ i implication, involving bit‑vector arithmetic, extensions, and a signed‑less‑than comparison, which makes the problem a quantified‑BV ranking‑function synthesis instance with a single quantifier alternation and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_hw_hw_ccmp.c.smt2",
    "description": "The benchmark encodes a termination‑proof obligation for a loop in the **ccmp** routine of a wireless driver: it asks whether there exists a 16‑bit constant C that can serve as a (multiplicative) ranking function, i.e. such that C·i is strictly smaller (signed) than C·i′ for every loop transition satisfying the given pre‑conditions on the loop variables (indices, length, etc.).  This is expressed as a single‑alternation quantified bit‑vector formula (∃ C ∀ i,i₀, … ) that mixes zero‑ and sign‑extensions, non‑linear multiplication, and inequalities, making it a typical “ranking‑function synthesis” problem with a modest number of variables but a non‑linear, deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_gfxswap.xp_filter.cpp.smt2",
    "description": "This benchmark encodes the synthesis of a linear ranking function for a simple integer loop that decrements a 32‑bit counter by 4 while it is non‑zero. It asks whether there exists a 32‑bit coefficient C such that, for every reachable pre‑state and loop variable value, the signed product C·new is strictly smaller than C·old (expressed with sign‑extended multiplication and signed‑less‑than). The formula features an ∃ ∀ ∀ ∀ quantifier alternation over bit‑vectors, with multiplication, sign‑extension and subtraction, making it a challenging quantified‑BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_ioctl.c.smt2",
    "description": "The instance encodes a termination‑proof synthesis problem for a loop in the ioctl function of a device driver: it asks for two 32‑bit constants (the coefficients c__ioctl__main__1__ulBuffSize_36_C and c__ioctl__main__1__i_36_C) such that, for all possible values of the loop variables and related buffers, the linear expression c·ulBuffSize + c·i strictly decreases on each iteration under the given guard conditions.  The formula is a quantified bit‑vector constraint (∃ 2 coefficients ∧ ∀ ≈ 10 state variables) that combines additions, multiplications, sign‑ and zero‑extensions, and comparisons (bvuge, bvslt) with a moderate term depth (≈ 20).  The presence of a single existential block followed by many universals makes it a typical ranked‑function synthesis benchmark that challenges solvers on quantified BV arithmetic rather than sheer variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_11.smt2",
    "description": "The file encodes a termination‑verification problem for a tiny C program (the SV‑COMP benchmark “jain_2”).  The bit‑vector constants c_main_~x~0 and c_main_~y~0 represent the two 32‑bit program variables, and the existentially quantified “nondet” variables model the nondeterministic updates performed by the loop body.  The first assertion asserts that there exist concrete nondet values that satisfy the loop’s transition relation (a linear combination of the variables using the constant ‑2 mod 2³²).  The second assertion, negated, states that no ranking‑function‑like witness (again expressed by a linear combination of the same variables) can be found; thus the overall check‑sat queries whether the termination proof fails.  The instance contains only quantifier‑free bit‑vector arithmetic with a few variables and shallow terms, making it a typical, small‑scale software‑verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_5.smt2",
    "description": "This instance encodes a software‑verification query for a C benchmark that uses a software‑implemented floating‑point addition. The bit‑vector constraints model the mantissa extraction (mask 0x00FFFFFF with a hidden exponent bit) and the program’s `assert` that the first operand is not less than the second; the final clause asserts that there is **no** choice of the three internal variables (`addflt_~a`, `addflt_~b`, `addflt_~delta~0`) that makes a particular equality involving a shifted, negated sum hold, i.e. it checks that the assertion cannot be violated. The problem consists of a handful of quantified existentials (no alternation) and shallow terms (depth ≤ 9), making it a typical bit‑vector safety‑property check generated by Ultimate Automizer for the SV‑COMP 2019 suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "The script encodes a software‑verification condition for the SV‑COMP “jain” benchmark.  Three 32‑bit program variables x, y and z are declared, and the first assertion requires that, for each of three separate nondeterministic choices, a linear bit‑vector equation of the form  \n`a·v₁ + a·v₂ + c = b·v₃`  \nhas a solution (each wrapped in an existential quantifier).  The second assertion states that it is **not** the case that three analogous, slightly simplified equations (each missing one of the nondet terms) are simultaneously solvable.  Thus the overall formula checks whether the original set of constraints can hold while the reduced set cannot, which corresponds to proving or refuting a safety/termination property of the generated program.  The problem involves only existential quantifiers (no alternation) but many bit‑vector multiplications with large constants, leading to a moderate‑size quantified BV formula that is typical for automated software model‑checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/pals_lcr-var-start-time.6_true-unreach-call.ufo.UNBOUNDED.pals.c_1.smt2",
    "description": "The script encodes a safety‑verification condition for the SV‑COMP “pals_lcr‑var‑start‑time” benchmark (a Lamport‑style bakery/critical‑section protocol with six participants).  It models each participant’s state with an 8‑bit variable ( ~st1~0 … ~st6~0 ) and uses sign‑extended 32‑bit sums of those values, asserting that the total never exceeds the bound 1 (i.e., at most one process may be in the critical section) while relating current and “old” states after each transition; a single universally‑quantified clause captures the transition relation.  The problem is a pure bit‑vector safety check with moderate term depth (≤ 8), 24 declared constants, many sign‑extensions and bvadd operations, and only one quantifier, making it a typical yet non‑trivial bounded‑model‑checking instance for an industrial concurrent program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_16.smt2",
    "description": "This instance encodes a software‑verification condition for a C benchmark (the “jain_6” program from SV‑COMP 2019) in the bit‑vector logic.  The goal is to prove that a safety/termination property holds for all possible nondeterministic 32‑bit inputs: two universally quantified constraints assert that a certain linear combination of the program’s global variables x, y, z and the nondeterministic values can never be equal to another combination involving the same inputs.  The second assertion negates a universal statement, effectively introducing an existential search for a counter‑example; the solver must decide whether the quantified arithmetic constraints are unsatisfiable, thereby confirming the property.  The formula contains only shallow (depth ≤ 7) bit‑vector multiplications and additions but includes quantified variables, giving it a moderate difficulty typical of automated software model‑checking queries.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "The script encodes a safety/termination verification condition generated by Ultimate Automizer for an SV‑COMP benchmark: it asks whether there exist integer (32‑bit) values for three “nondet” variables that satisfy linear equations of the form c·x + k = m·y for three separate program counters (x, y, z). The second assertion negates the conjunction of three similar existential constraints, so the overall formula is equivalent to checking that **no** assignment of the coefficients c_main_~x~0, c_main_~y~0, c_main_~z~0 can simultaneously witness a decreasing measure for all three loops—i.e., the program lacks a linear (or lexicographic) ranking function and therefore does not terminate. The problem involves only existential quantifiers (no alternation) but uses 32‑bit bit‑vector multiplication by large constants (≈ 2³² − k), giving a modest term depth (7) while still posing a non‑trivial challenge for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "The script encodes a software‑verification condition generated by Ultimate Automizer for a C benchmark: it asks whether there exist 32‑bit nondeterministic values that simultaneously satisfy three linear bit‑vector equations relating the program variables x, y and z (each equation mixes large near‑\\(2^{32}\\) constants with a multiplication by 2, 4 or 8), while at the same time contradicting the simpler divisibility constraints “x is even, y is a multiple of 4, z is a multiple of 8”.  The formula consists of a conjunction of three existential blocks together with the negation of another conjunction of existential blocks, yielding a single‑alternation quantified BV problem with moderate term depth and a handful of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_7.smt2",
    "description": "The script encodes a verification condition for a small 32‑bit floating‑point addition routine.  It models the mantissa/exponent layout with the masks 0x01000000 and 0x00FFFFFF and relates the input operands a, b and a shift amount δ to the computed results ma and mb using bit‑vector shift, mask, neg‑and‑add operations; the final clause asserts that no operand a exists whose normalized form equals the computed result ma, i.e. that the addition never yields an illegal (non‑normalised) float.  The formula consists of three existential quantifiers followed by a negated existential, a modest term depth (≤8) and only a handful of bit‑vector variables, so the main difficulty lies in quantifier reasoning over BV rather than sheer size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_14.smt2",
    "description": "This instance encodes a software‑verification condition generated by Ultimate Automizer for an SV‑COMP benchmark. It asks whether there exist two nondeterministic 32‑bit inputs (|main_#t~nondet0|, |main_#t~nondet1|) that make a specific linear bit‑vector equality involving the program constants c_main_~x~0 and c_main_~y~0 hold, while a stronger quantified invariant (stating that the same equality never holds for any auxiliary variables) must remain true. In other words, the solver must find a counterexample to the universally quantified invariant—corresponding to a potential non‑termination or reachability violation—using only bit‑vector arithmetic, two quantified blocks (no alternation) and a modest term depth (≤ 8).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_21.smt2",
    "description": "The script encodes a verification condition generated by Ultimate Automizer for a SV‑COMP 2019 benchmark (the “jain_7” program). It asserts the negation of a disjunction of a universally‑quantified and an existentially‑quantified linear BV‑equation, i.e., it checks that neither a universal invariant nor an existential counter‑example can be satisfied; proving this unsatisfiable corresponds to establishing the intended safety/termination property of the original C code. The problem features a single large conjunct with many `bvmul` terms, moderate term depth (≈11) and a quantifier alternation (∀ … ∨ ∃ …), making it a non‑trivial quantified bit‑vector reasoning task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/gcd_3_true-unreach-call_true-no-overflow.i_0.smt2",
    "description": "The script encodes a bounded‑model‑checking problem for an 8‑bit Euclidean‑algorithm implementation of **gcd**.  It asserts that for every non‑negative input value |c_gcd_test_#in~a| the algorithm (modeled with signed‑extension, `bvsrem` and `bvneg`) must satisfy the characteristic GCD relations between the symbols c_gcd_test_~a, c_gcd_test_~b and an existentially quantified intermediate value, and simultaneously asserts the negation of the same relational clause to test unreachability of a violating state.  The instance therefore checks a safety property (no incorrect GCD result / no overflow) and is challenging mainly because of the nested quantifier (an existential inside a universal context) together with deep sign‑extension/bit‑extraction terms on bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "This instance encodes a software‑verification condition for a C benchmark (the “jain” program) in the bit‑vector logic, checking a termination‑related property. The constraints are expressed as two quantified formulas: a universal clause that enforces a strict inequality between two linear combinations of program variables and nondeterministic inputs (using large constant coefficients), and the negation of another universal clause that would make two such linear expressions equal. Satisfiability of the whole formula therefore corresponds to the existence of a counterexample to the intended ranking‑function proof (i.e., non‑termination), with a modest number of variables but non‑trivial quantified arithmetic that can be challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "The file encodes a verification condition generated by Ultimate Automizer for the SV‑COMP benchmark **jain_2**, checking that a certain bad state (the conjunction of a specific arithmetic relation on the program variables x and y and a universally quantified loop invariant) is **unreachable**.  Two quantified assertions describe the loop’s transition relation using 32‑bit bit‑vector arithmetic (multiplications by 2, additions of nondeterministic values, and a constant 0xFFFFFFFF), and the final top‑level assertion negates the disjunction of the target state (`x + y = 1`) and the invariant, so the problem is SAT iff the program violates the safety/termination property.  The instance features only a handful of variables but includes nested `forall` quantifiers and deep bit‑vector terms (depth 9), making it a typical quantified BV‑only check‑reachability/termination query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_3.smt2",
    "description": "The script encodes a software‑verification condition extracted by Ultimate Automizer from the SV‑COMP 2019 benchmark *soft_float_4*.  It models 32‑bit IEEE‑754 floating‑point numbers with bit‑vector operations that mask the mantissa (`bvor … bvand …`) and extract the exponent (`bvlshr …` plus a constant), and then asserts that there is **no** choice of two input floats `a`, `b` and a delta such that, after normalising the operands, adding the negated shifted mantissa of `b` to the normalised mantissa of `a` yields the normalised mantissa of `a` again.  The problem is a small‑scale BV verification query containing a single existential quantifier, moderate term depth (≤9) and a handful of bit‑vector arithmetic operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "The instance encodes a bit‑vector verification query generated by Ultimate Automizer for a C benchmark, asking whether there exist nondeterministic 32‑bit values that satisfy two linear Diophantine equations derived from the program’s transition relation (the equations involve the constants ‑2 and ‑1 modulo 2³²). The first assertion asserts the existence of such values for a “small” combination of variables, while the second asserts the negation of the existence of a “larger” combination, effectively checking a safety/termination property of the original program. The problem is purely existential (with a top‑level negation turning one conjunct into a universal condition) and consists of a handful of quantified bit‑vector equalities, making quantifier handling the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "The file is a bit‑vector verification query produced by Ultimate Automizer for an SV‑COMP “termination” benchmark (the jain_7 program).  It encodes, with two quantified formulas, a candidate linear ranking function over the program’s 32‑bit variables x, y, z and three nondeterministic values: the first universally quantified clause asserts that the affine combination of these variables is never equal (i.e., strictly decreasing) for any iteration, while the second clause asserts the existence of a concrete assignment where the two sides become equal, i.e., a potential counter‑example to the termination argument.  The problem therefore tests whether the proposed ranking function is valid, and its difficulty stems from several quantified bit‑vector variables, large constant multipliers, and a modest term depth (≈10) but with a mix of universal and existential quantification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "The instance encodes a software‑verification reachability check in the bit‑vector logic. Three 32‑bit outputs c_main_~x~0, c_main_~y~0, c_main_~z~0 are required to satisfy separate existential linear equations that combine four nondeterministic 32‑bit variables with large constant multipliers; the final assertion negates a simpler condition stating that each output could be expressed as a single multiplier times one nondeterministic variable. Thus the solver must decide whether the complex linear constraints can hold while the simplified “single‑term” representation is impossible, i.e. whether a supposed error state is unreachable. The problem involves only existential quantifiers, modest term depth (≤ 6) but a handful of large‑coefficient bit‑vector multiplications, typical of automated verification benchmarks derived from SV‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "This instance encodes a bit‑vector safety‑verification problem: it models a single transition of a program with three integer variables x, y, z, each updated by adding respectively 2·nondet0, 4·nondet1 and 8·nondet2, where the nondet constants are uninterpreted 32‑bit values. The initial state is constrained (via existential witnesses) to make x, y, z multiples of 2, 4, 8, and the query asserts the negation of the same “multiple‑of‑k” property for the post‑state, thus asking whether the invariant that these variables remain multiples of their factors is preserved. The formula involves only a handful of quantified variables, shallow terms (max depth 6), and basic BV arithmetic, making it a relatively small but quantifier‑rich BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "The file encodes the termination check for the SV‑COMP benchmark **jain_7** as a quantified bit‑vector verification condition.  Three program variables (`x`, `y`, `z`) and several nondeterministic inputs are related by linear BV expressions; the first universally‑quantified assertion states that a certain linear combination cannot be equal, while the second asserts that neither a simple arithmetic equation nor another universally‑quantified inequality can hold, which together correspond to the non‑existence of a suitable ranking function.  Hence the instance is a software‑verification problem (termination) expressed as a small set of deep (max depth 11) quantified BV formulas, with no large numbers of variables but with quantifier alternations that make the solving task non‑trivial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "The script encodes a verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2019.  It models three program variables x, y, z as 32‑bit bit‑vectors that must be even multiples of nondeterministic inputs (x = 2·n₀, y = 4·n₁, z = 8·n₂).  The final assertion negates a conjunction of three existential equalities that would establish a linear relation among these multiples; proving the negation unsatisfiable shows that the intended ranking‑function‑like invariant (or termination property) cannot be violated.  The problem involves only a few quantified bit‑vector variables but uses large 32‑bit constants and multiple nested `exists`, making it a shallow‑depth quantified BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "The instance encodes a termination‑proof query generated by Ultimate Automizer for a C program from the SV‑COMP benchmark suite.  It asserts the negation of a disjunction that (i) universally forbids a linear ranking‑function inequality, (ii) forces a specific linear equality on the candidate ranking function, and (iii) existentially requires a witness satisfying the same inequality; the variables marked |main_#t~nondet*| represent the program’s nondeterministic inputs.  Consequently the solver is asked to decide whether a bit‑vector linear ranking function exists (i.e., whether the program terminates); the formula involves several quantified blocks, large constant multiplications, and moderate term depth, making it a typical quantified BV termination‑verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_8.smt2",
    "description": "The file encodes a bit‑vector verification condition for a small floating‑point routine generated by Ultimate Automizer from an SV‑COMP benchmark.  It models the construction of normalized 24‑bit mantissas (by forcing the top bit to 1 and extracting the low 24 bits) for three values a, b and a result mb, introduces an unknown shift amount δ, and then asserts that there is **no** choice of a, b and δ for which the expression  \n\n```\n‑( (mb  >>  δ) )  +  ma   =   ma\n```  \n\nholds in the 32‑bit bit‑vector domain.  In other words, the instance checks the unreachability of a faulty equality that would correspond to an incorrect soft‑float addition.  The problem contains three existential quantifier blocks, a handful of bit‑vector variables and shallow terms (max depth 9), making it a moderate‑size safety‑property query in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "The script encodes a verification condition generated by Ultimate Automizer for a SV‑COMP 2019 benchmark. It asserts that three separate linear equations over 32‑bit bit‑vectors (each involving a constant c_main_~x~0, c_main_~y~0, c_main_~z~0 and four nondeterministic variables) are simultaneously satisfiable, and then asserts the negation of the same three equations where one term is omitted, i.e. it checks that a solution requiring all four nondeterministic terms cannot exist without the missing term. Consequently the instance is a pure quantifier‑existential bit‑vector problem (no universals) that tests the consistency of these arithmetic constraints, typical of reachability/termination or overflow verification tasks, with modest term depth (7) and a handful of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_31.smt2",
    "description": "This instance encodes a reachability / safety verification problem for a C implementation of the IEEE‑754 `sqrtf` routine. It asserts, via a universal quantifier over a 32‑bit input variable, that a specific linear combination of the constants `c___ieee754_sqrtf_~r~0` and `c___ieee754_sqrtf_~s~0` can never equal zero, and simultaneously forbids the concrete assignment `r = 65536` and `s = -4261412864` (mod 2³²). The solver must decide whether these bit‑vector constraints are jointly satisfiable, i.e., whether the alleged “error” state can be reached; the instance features only two constants, a single quantifier, and shallow term depth, making it a compact but non‑trivial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "The instance encodes a software‑verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2019. It declares three 32‑bit input variables ( x, y, z ) and asserts that each of three simple linear equations with large constant multipliers has a solution for some nondeterministic 32‑bit values, while simultaneously asserting that a stronger version of the same three equations – each allowing three nondeterministic terms summed together – cannot all hold together. The problem thus reduces to checking whether the combination of existential bit‑vector constraints is jointly unsatisfiable, a typical reachability/termination safety query that involves only existential quantifiers but many large‑constant multiplications, making it a non‑trivial BV‑solving task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "The instance encodes a verification condition for a C program generated by Ultimate Automizer: three 32‑bit program variables x, y and z must satisfy three linear Diophantine equations (each involving large constants and fresh nondeterministic bit‑vectors) simultaneously, while it is required that the same three equations cannot be satisfied with one fewer nondeterministic term each. Formally the formula is  \n\n ∃ triples (v₀₇,v₀₆,v₀₅), (v₁₇,v₁₆,v₁₅), (v₂₇,v₂₆,v₂₅) . Eqs(x,y,z) ∧ ¬∃ pairs (v₀₆′,v₀₅′), (v₁₆′,v₁₅′), (v₂₆′,v₂₅′) . ReducedEqs(x,y,z),\n\nso the solver must decide satisfiability of a quantified bit‑vector formula with a single existential block and a negated existential block (effectively an ∃‑∀ alternation). The problem is typical of software‑model‑checking (unreachability/termination) where the difficulty stems from the quantified arithmetic constraints rather than from large term depth or many variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_2.smt2",
    "description": "The script encodes a safety verification condition for a C function that implements a soft‑float addition.  Two 32‑bit bit‑vector constants model the mantissas of the addends, and a series of existential quantifiers relate them to the concrete bit‑wise representation of the inputs (masking, shifting and OR‑ing the exponent‑biased fields).  The final asserted negation checks that, after the addition (performed with two’s‑complement arithmetic and a shift of the second operand), the resulting mantissa never has the overflow‑indicator bit set – i.e., the unreachable‑error condition for overflow is proved unsatisfiable.  The problem is a pure BV verification task with a handful of exists‑quantifiers and moderate term depth, typical of automated software model checking of floating‑point arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "The formula checks a software‑verification condition for the benchmark *jain_6*: it asserts that there exist 32‑bit values for three program variables (`x`, `y`, `z`) together with three nondeterministic inputs satisfying three linear bit‑vector equations (the “base” state), while simultaneously asserting that no extension of these equations with an additional nondeterministic step (four‑variable versions) can be satisfied. In other words, it encodes the unreachability of a bad state after one more loop iteration, i.e. a termination/ safety proof expressed as a pure BV problem with only existential quantifiers and modest term depth (7) and a few dozen bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_7.smt2",
    "description": "The formula checks the existence of coefficients for a lexicographic ranking function proving termination of a C program (SV‑COMP 2019 benchmark). It asserts, via three 4‑variable existential constraints over 32‑bit bit‑vectors, that a linear combination of large constant multiples of nondeterministic variables can equal the program’s variables x, y, z, while simultaneously negating a conjunction of three simpler 2‑variable existential constraints, i.e. forbidding a single‑phase ranking function. The problem is a quantified bit‑vector linear arithmetic instance with six existential quantifier blocks, many large‑constant multiplications, and moderate term depth, typical of termination verification encodings generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "This instance encodes a software‑verification query for a tiny C‑like program, generated by Ultimate Automizer.  The SMT formula describes one transition of the program: the state variables x and y are updated to x′ = x + 2·nondet0 and y′ = y + 2·nondet1, where the nondeterministic 32‑bit inputs are modeled as uninterpreted bit‑vectors.  Two universally quantified constraints assert that, for all possible nondet values, a certain linear relation between the pre‑ and post‑state (involving addition of 2·nondet and a constant 0xFFFFFFFF) never holds; the outer negated‑forall asks whether there exists a pair of nondet values making that relation true, i.e. whether a potential error (reachability, overflow or non‑termination condition) is reachable.  The problem is a bit‑vector verification task with a handful of variables, shallow term depth (≤ 8) but a quantifier pattern (∃­¬∀) that introduces a modest amount of logical difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification query generated by Ultimate Automizer for an SV‑COMP benchmark. It encodes a safety property as a universally quantified non‑equality over two nondeterministic inputs (|main_#t~nondet0|, |main_#t~nondet1|) together with a negated universal that introduces an existential witness, i.e. it asks whether there exists values of the program variables (c_main_~x~0, c_main_~y~0, and auxiliary substitutions) that violate the intended invariant. The problem contains only four quantified variables but features nested arithmetic (addition, multiplication by 2, negation) and a combination of ∀/∃ quantifiers, making it a small but quantifier‑intensive BV check typical of software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_28.smt2",
    "description": "The script encodes a safety‑property check for a piece of C code that implements the IEEE‑754 `sqrtf` routine. It universally quantifies over a 32‑bit variable `ix` and asserts that the linear bit‑vector equation  \n\n```\n2 * (-( (c_r >> 1) + c_s ))  +  4 * ix  =  0\n```  \n\nhas **no** solution for any `ix`. In other words, the instance asks whether the constants `c___ieee754_sqrtf_~r~0` and `c___ieee754_sqrtf_~s~0` can ever make the expression `C + 4*ix` equal to zero, which corresponds to proving an unreachable program state. The problem is a quantified BV verification query with a single universally‑quantified variable, two uninterpreted constants, shallow term depth (≤9), and thus a relatively small search space, but the presence of the quantifier makes it non‑trivial for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_0.smt2",
    "description": "The script encodes a software‑model‑checking problem for a C routine that implements a soft‑float addition (the symbols `c_addflt_*` represent the mantissa, exponent and other fields of 32‑bit floating‑point values).  The first assertion builds the normalized mantissa and exponent from the raw bit‑vectors, forces the second operand to be non‑zero, and the second assertion fixes the primary input `a` (and its copy) to the bit‑pattern `0xffffffff` (i.e., –1 in two’s‑complement).  The final (negated) assertion asks whether there exists a shift amount `addflt_~delta~0` and a second operand `addflt_~b` that make the shifted mantissa of `b` equal the previously computed mantissa of `b` **and** that the mantissa of `a` plus a large constant (`0xfedcba01`) wraps to zero; the solver is asked to prove that such a combination cannot occur.  Hence the instance is a bounded safety/overflow verification task for a floating‑point addition routine, featuring only one existential quantifier and shallow bit‑vector terms (max depth 8), which keeps the problem relatively small but requires reasoning about the bit‑level encoding of floating‑point components.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "The instance is a verification condition produced by Ultimate Automizer for the SV‑COMP 2019 benchmark “jain”, encoded in the bit‑vector logic. It asks whether there exist 32‑bit coefficients (the existentially‑quantified “nondet” variables) that satisfy three linear equations linking the program’s global variables `c_main_~x~0`, `c_main_~y~0`, and `c_main_~z~0` to these coefficients, while at the same time ensuring that a stronger conjunctive variant of the same equations cannot hold (the outer `not … and …`). This formulation corresponds to checking a termination/absence‑of‑overflow property via a candidate ranking function, and involves six quantified blocks, modest term depth (7) and a handful of bit‑vector multiplications with large constants, making it a compact but quantified BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "The file encodes a verification condition for the SV‑COMP benchmark *jain_6*: three global 32‑bit variables `c_main_~x~0`, `c_main_~y~0`, `c_main_~z~0` must satisfy a linear relation that involves several nondeterministic inputs. The first assertion states that **for all** choices of many auxiliary and nondet variables a certain equality between two bit‑vector linear combinations (with large negative‑wrapped coefficients) cannot hold, while the second assertion is the negation of a universal “not‑equal”, i.e. it requires that **there exists** a triple of nondet values for which a related equality *does* hold. Satisfiability of the conjunction therefore asks whether there is a concrete valuation of the globals that makes the invariant both always false for the full set of inputs and yet true for some restricted choice—typical of a safety‑property or termination check. The instance features only a handful of bit‑vector variables, moderate term depth (7), but combines universal and existential quantification over linear arithmetic with wrap‑around coefficients, which can be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_36.smt2",
    "description": "The instance encodes a verification condition for a C implementation of the IEEE‑754 single‑precision square‑root routine generated by Ultimate Automizer. It asserts that for every 32‑bit input ix the linear equation 4·ix + 2·(‑((r≫1)≫1)≫1 + s) ≠ 0 must hold, while simultaneously demanding that the constants r and s cannot satisfy the specific equalities r = 16384 and s + 4261412864 = 0. The problem is a quantifier‑rich bit‑vector check (one universal quantifier, a handful of arithmetic operations) arising from a software‑verification (unreachable‑call) benchmark, making quantifier reasoning the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_5.smt2",
    "description": "The instance encodes a verification condition for a 32‑bit C program that computes the sum \\(1+2+\\dots+n\\) with a loop: the three bit‑vector variables represent the loop index \\(i\\), the running sum \\(sn\\), and the input bound \\(n\\), and the quantified assertions capture the intended invariant linking \\(sn\\) to the closed‑form expression \\(n·(n+1)/2\\) under various cases of the loop counter. The final negated universal and equality assertions express the property that the invariant must hold at the loop exit, so the solver is asked to find a counterexample (i.e., a reachable error state). The problem involves quantified bit‑vector arithmetic with modest term depth and a handful of variables, typical of software‑verification benchmarks checking arithmetic correctness and overflow safety.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "The file contains the bit‑vector verification condition generated by Ultimate Automizer for the SV‑COMP 2019 benchmark *jain_6*: three 32‑bit inputs `c_main_~x~0`, `c_main_~y~0`, `c_main_~z~0` must satisfy simple linear equations that enforce divisibility by 2, 4 and 8 (expressed with existentially quantified auxiliary variables). The second assertion negates a stronger conjunction in which each of the three equations is allowed three auxiliary variables, i.e., it checks that the “multiple‑summand” version cannot hold simultaneously with the original divisibility constraints. Thus the instance is a small quantified BV safety check (six existentials, depth 7) testing whether the weaker divisibility properties imply the stronger combined property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_38.smt2",
    "description": "This instance encodes a safety verification condition for a C implementation of the IEEE‑754 single‑precision square‑root routine (the function `__ieee754_sqrtf`).  The bit‑vector variables `c___ieee754_sqrtf_~r~0`, `c___ieee754_sqrtf_~ix~0` and `c___ieee754_sqrtf_~s~0` represent intermediate integer encodings of the floating‑point value, and the single quantified assertion states that no input `__ieee754_sqrtf_~ix~0` can satisfy a specific linear equation involving those intermediates (a combination of shifts, multiplications and a negated addition).  The additional concrete assertion fixes `c___ieee754_sqrtf_~ix~0` to zero, and the solver is asked to check whether the quantified “bad‑state” can be reached.  The formula is a small BV problem with one quantifier, moderate term depth (11) and nested bit‑vector shifts, typical of automated software‑verification conditions generated by Ultimate Automizer from SV‑COMP benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_1.smt2",
    "description": "The formula encodes the verification condition for a C program that computes the arithmetic sum ∑ₖ₌₁ⁿ k inside a loop indexed by i.  The three bit‑vector constants `main_~i~0`, `main_~sn~0` and `main_~n~0` stand for the current loop index, the accumulated sum, and the loop bound, and the assertions state that the sum must equal n·(n+1)/2 (expressed with `bvudiv` and `bvmul`) and that the usual loop‑invariant relations hold for successive values of i.  The final two negated assertions look for a state where the invariant is violated (i.e., the sum does not match the closed‑form) while `i+sn ≠ 0`, turning the problem into a quantifier‑rich bit‑vector safety check for overflow/incorrect accumulation.  The instance features only universal quantifiers over n (no alternation) but a moderate term depth (≈9) and several nested arithmetic expressions, making it a typical BV‑verification task generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "The instance encodes a safety‑verification check for a C benchmark (jain_2) generated by Ultimate Automizer: it asserts that for all nondeterministic 32‑bit inputs the equality between two linear bit‑vector expressions (involving additions, multiplications by 2 and the constant 0xFFFFFFFF) never holds, and then asks whether the negation of a similar universally quantified statement is satisfiable (i.e., whether a counter‑example exists). The problem is thus a quantified bit‑vector SAT query with a single block of ∀‑quantifiers (no alternation) and moderate term depth (8), featuring only basic arithmetic operations and a handful of variables, making the main difficulty the handling of universal quantification over 32‑bit arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "This instance is a bit‑vector safety/termination check produced by Ultimate Automizer from an SV‑COMP benchmark. It declares two 32‑bit program variables ( x  and  y ) and encodes, via two quantified formulas, a universal invariant stating that a certain linear equality between doubled variables, nondeterministic inputs and the constants x and y  can never hold, while the negated universal clause searches for a concrete assignment that violates this invariant. Thus the solver is asked whether a reachable bad state (or a non‑terminating execution) exists, using only shallow (depth ≤ 8) linear BV arithmetic with a few multiplications by 2 and a constant 0xffffffff.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "The instance encodes a safety‑reachability check for a small imperative program whose three 32‑bit variables x, y and z are updated in one step by adding respectively 2·nondet0, 4·nondet1 and 8·nondet2 (where the nondet values are uninterpreted 32‑bit constants).  Two universally quantified constraints state that a certain linear combination of the pre‑state variables and arbitrary nondet values can never equal a given constant, while the final (negated) quantifier asserts the existence of nondet values that make the same linear relation hold after the update.  Thus the solver is asked whether the “bad” equation can become true in a successor state, i.e., whether the safety property is violated; the formula contains only a handful of bit‑vector variables, shallow terms (depth ≤ 7) and two quantifier alternations, making it a typical small‑scale software verification problem generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "This instance is a safety‑verification condition produced by Ultimate Automizer for the SV‑COMP benchmark *jain_7*. It declares three 32‑bit input variables (**x**, **y**, **z**) and, for each of them, existentially quantifies several nondeterministic 32‑bit witnesses that must satisfy a linear bit‑vector equation involving large constant multiplications; the first assertion states that such witnesses exist, while the second asserts the negation of a simultaneous existence of a second set of analogous equations that would correspond to an error state (i.e., “not (∃ … ∧ ∃ … ∧ ∃ … )”). The solver therefore has to decide whether the conjunction of the pre‑condition equations and the negated error condition is unsatisfiable, i.e., whether the error is unreachable. The problem contains only existential quantifiers (no alternation), a modest number of variables (three inputs plus auxiliary locals), but several nested `bvadd`/`bvmul` terms with large constants, giving a term depth of 7 and requiring quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "The instance encodes a safety‑verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2019.  It asserts that, for all nondeterministic 32‑bit inputs (|main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2|) and the program’s global variables (c_main_~x~0, c_main_~y~0, c_main_~z~0), a certain linear combination of these values—built from multiplications by large 32‑bit constants and additions—cannot equal another linear combination involving the same inputs and constants.  The script then negates a similar universally‑quantified equality with additional substitution variables, turning the verification question into a (un)satisfiability check.  Thus the problem is an SMT‑based verification of a reachability/termination property using bit‑vector arithmetic, featuring only universal quantifiers, a modest term depth (7), and a handful of variables, but heavy use of constant multiplications that can make reasoning about overflow‑free integer relations challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "The instance encodes a software‑verification condition for a C program (generated by Ultimate Automizer) in the bit‑vector logic. It asserts that there exist nondeterministic 32‑bit values satisfying two linear arithmetic equalities involving the program’s input variables `c_main_~x~0` and `c_main_~y~0`, and then negates a simpler pair of existential equalities that would witness an error state; the whole formula checks whether the conjunction of the first constraints can coexist with the negated error‑state constraints. Consequently, the SMT problem tests the (un)reachability of a particular program state (or termination condition) via a handful of quantified bit‑vector equations, featuring only a few variables and shallow term depth but requiring reasoning over quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "The instance is a verification condition generated by Ultimate Automizer for a SV‑COMP 2019 benchmark. It encodes a safety property over 32‑bit bit‑vectors: a universally quantified inequality between two linear expressions (involving the program variables c_main_~x~0, c_main_~y~0 and nondeterministic inputs) is asserted to always be false, while a second assertion negates this universal, thereby requiring the existence of nondeterministic values that make a specific equality hold. Hence the formula has a ∀‑∃ quantifier pattern (a universal block inside a negated universal, yielding an existential witness) over simple linear bit‑vector arithmetic. Although the overall size is small (2 constants, 2 assertions, max term depth 8), the alternating quantifiers make the problem non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/073.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation: it models reads (`R_…`) and writes (`W_…`) of five 32‑bit variables in two program states (`S1` and `S2`) and in the original expression (`E1`).  A single quantified block (a deep `forall` with many nested `let`‑bindings) expresses the weakest‑precondition of the transformation by relating the concrete values through a large set of `ite`‑based aliasing choices (`MW_…`), disjointness predicates (`DISJ_…`) and arithmetic constraints (`bvadd`, `bvsle`, `bvsge`).  The outer assertions force certain disjointness conditions to be false, so the solver must decide whether an execution satisfying all the memory‑consistency and numeric relations exists; the mixture of many Boolean flags, deep term nesting (depth 85) and combined bit‑vector arithmetic makes this an industrial‑strength safety‑verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/133.smt2",
    "description": "The benchmark encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesiser.  It models reads and writes of several 32‑bit program variables (E1, E2, S1) with Boolean flags (R_…, W_…, MW_…) and asserts, for all possible inputs and write‑mask choices, that the transformed program preserves the required equalities, ordering constraints (bvsge/bvsle) and non‑interference (DISJ_…) between the original and optimised states.  The single universally‑quantified formula contains deep nesting of ite, arithmetic and Boolean operators (≈56‑level term depth) and a large conjunction of disjointness and consistency clauses, making it a challenging industrial verification instance in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/026.smt2",
    "description": "The file encodes a verification condition for a compiler‑optimisation transformation, generated by the PSyCO weakest‑precondition synthesis tool.  It uses a single quantified block over 32‑bit input values together with Boolean flags that model reads (R_*) and writes (W_*) of three program locations (S1, S2, E1); the body contains a large collection of “if‑then‑else” (ite) equalities, ordering constraints (bvsle/bvsge) and disjointness predicates that capture the preservation of variable values across the transformation.  The final top‑level assertions negate a combination of these predicates, so the SAT query checks whether the optimisation is unsound (i.e., whether there is a reachable state violating the required read/write and value‑equality properties).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/121.smt2",
    "description": "The file encodes a verification condition for a compiler transformation generated by the PSyCO weakest‑precondition synthesis tool: Boolean flags model reads (R_*) and writes (W_*) of six 32‑bit variables in three program fragments (E1, E2, S1), and the quantified core forces the values after the optimisation to be equal to the original ones, respects the required ordering (bvadd, bvsle, bvsge) and enforces that the write set of S1 is disjoint from the read sets of S1, E1 and E2.  The final check asserts the negation of the disjointness predicate (DISJ_W_S1_R_S1) together with the large conjunction of equalities and ordering constraints; unsatisfiability would prove the optimisation safe.  The problem features a single deep ∀‑quantifier over 32‑bit vectors, many nested ite‑terms, a term‑depth of 312 and over three hundred let‑bindings, making it a demanding BV‑verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/099.smt2",
    "description": "The file encodes a correctness‑check for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  Boolean variables such as R_* and W_* model reads and writes of several program variables, while the quantified core ($x5110) relates these actions to versioned 32‑bit values (via a network of ite, bvadd, bvsle/​bvsge constraints) and to Boolean “choice” flags MW_* that select which write a read observes.  The surrounding assertions impose mutual‑exclusion (DISJ_*) and ordering conditions and finally assert their negations, so the solver must decide whether a consistent assignment of reads, writes and values exists—i.e., whether the transformed program can violate the original specification.  The instance therefore represents a large, deeply nested bit‑vector verification problem with many Boolean control variables and a single universal quantifier, typical of industrial‑scale compiler‑optimisation correctness checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/052.smt2",
    "description": "The benchmark encodes a weakest‑precondition verification of a compiler optimisation.  Boolean flags R_* and W_* model reads and writes to three abstract memory locations (E1, S1, S2), while a universally‑quantified clause describes how optional updates (the MW_* flags) transform the 32‑bit program variables V1…V5 together with signed‑comparison and addition constraints that capture ordering requirements.  The final assertions negate several disjointness and coherence conditions, so the solver must exhibit a state that breaks the optimisation; the formula is an industrial BV verification problem with a deep term depth (≈ 205) and a large, highly inter‑connected Boolean/ite structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/075.smt2",
    "description": "The formula checks the correctness of a compiler optimization by encoding the weakest‑precondition relationship between three program versions (the original E1 and two transformed snapshots S1, S2). Boolean flags such as R_*/W_* model whether each variable (V1–V5) is read or written in each version, and a single ∀‑quantified block relates the 32‑bit values of those variables via many ite and let constructions together with ordering constraints (e.g., increments, bounds). The surrounding assertions impose disjointness conditions on read/write sets (DISJ_*), forbid conflicting accesses, and finally ask the solver to prove the conjunction unsatisfiable, i.e., that the transformation preserves the program’s semantics. The instance is thus a verification problem with deep nested terms, many Boolean inter‑dependencies, and a single quantified formula, making it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/045.smt2",
    "description": "The file encodes a verification problem for a compiler‑level memory transformation: a single quantified formula over 32‑bit program values and a large set of Boolean flags that represent whether particular reads (`R_…`) and writes (`W_…`) are enabled, together with “disjointness’’ predicates (`DISJ_…`).  The quantified part expresses the weakest‑precondition constraints that the transformed program must satisfy (ordering, non‑interference and value‑preservation), while the trailing ground assertions negate various conjunctions of these flags, turning the check into “does there exist a selection of reads/writes that violates the consistency constraints?”.  The instance is challenging because it mixes one deep ∀‑quantifier with many nested `ite`s, a high term depth (≈170) and a dense Boolean combination (≈140 or, 143 not, 65 and), leading to a large, highly intertwined SAT/SMT search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/086.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation: Boolean variables such as R_E1_V4, W_S1_V4, DISJ_W_S2_R_E1, etc., represent whether particular program variables are read, written, or must be mutually disjoint in the original (E1) and transformed (S1, S2) versions, while the large quantified‑forall block expresses the weakest‑precondition relationship between the bit‑vector program states (V1…V5) of the three versions.  All constraints are combined into a single SAT/SMT query that checks the existence of a consistent assignment to the read/write and disjointness flags satisfying the equivalences, ite‑definitions and arithmetic relations (bvadd, bvneg, bvsle/ge) together with several propositional disjointness axioms; thus the problem is a bit‑vector‑based verification/synthesis task with a deep term structure (max depth 165) and a single universal quantifier over 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/079.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It models two program states (S1 and S2) and a source expression E1, using Boolean flags (e.g. R_E1_V4, W_S1_V5) to represent reads and writes of four‑byte variables, together with “disjoint‑ness” constraints (DISJ_…) that enforce non‑interference between the reads and writes.  The main formula is a universally quantified relationship over 32‑bit values with many nested `ite`‑terms and let‑bindings, and a handful of additional Boolean assertions that together test whether a consistent assignment to the read/write flags exists – i.e. whether the optimisation preserves the program’s semantics.  The problem is therefore a verification/synthesis check with a large, deeply nested BV formula and many inter‑dependent Boolean variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/115.smt2",
    "description": "The file encodes a relational‑verification / weakest‑precondition synthesis task for a small compiler optimisation.  Bool variables W_S1_* and R_S1_*, together with R_E1_* and R_E2_*, represent predicates that must hold in the original (S1) and in two transformed versions (E1, E2); the quantified block asserts, for all 32‑bit program states V1…V6, that the candidate predicates respect the semantics of the optimisation (equality of the “ite‑updated” variables, signed ordering constraints, and a disjointness condition between the original and the transformed behaviours).  The problem asks whether such predicates exist (the final negated assertions turn the check into an unsatisfiability query) and is challenging because it contains a single 32‑bit universally quantified formula with deep nesting of ite, bvadd/bvneg, and many Boolean combinations, yielding a large term depth and a dense combinatorial search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/078.smt2",
    "description": "The instance encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  It models the reads ( R_* ) and writes ( W_* ) of several program variables (V1…V5) at different program points with Boolean flags and captures the data‑flow and dependency constraints through a single quantified formula that uses many nested ite terms over 32‑bit vectors.  The final assertions negate various “disjoint‑write/read” and ordering properties, so the solver must show unsatisfiability (i.e., that the optimisation preserves the intended semantics) despite a deep term structure, a large number of Boolean variables, and one universally quantified block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/060.smt2",
    "description": "The instance encodes a verification condition generated by the PSyCO weakest‑precondition synthesis framework for a compiler optimisation: it relates the original program variables (R_S1_*) to their potentially updated “write” versions (W_S1_*) through a quantified formula over 32‑bit inputs, using `ite`‑conditionals to model when each write occurs and imposing arithmetic constraints (multiplication, division, sign‑order) that must hold in both the source and the transformed code. A global disjointness predicate (`DISJ_W_S1_R_S1`) and a non‑emptiness condition on the set of writes are also asserted, making the check a quantified bit‑vector verification problem with deep term nesting and a mixture of Boolean and arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/074.smt2",
    "description": "The benchmark encodes a verification condition for a compiler‐optimization transformation generated by the PSyCO weakest‑precondition synthesis tool.  It models two program versions (S1, S2) and an original execution (E1) with Boolean read/write flags (R_*, W_*) and “disjointness’’ predicates (DISJ_*) together with a single universally quantified block that relates the transformed values through deeply nested ite expressions and bit‑vector arithmetic; the final assertions ask whether the read/write and disjointness constraints can be simultaneously satisfied, i.e., whether a conflict (a violation of the intended correctness property) exists.  The problem is thus an industrial verification instance featuring a large quantified formula, many Boolean variables, and high term depth, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/056.smt2",
    "description": "The file encodes a weakest‑precondition verification problem for a compiler optimisation: a single universally‑quantified transition relates the pre‑state values of several 32‑bit variables (V1…V5) to the post‑state values after a series of conditional writes (the MW_… flags) and reads (the R_… and W_… booleans).  The Boolean variables capture read/write permissions, disjointness constraints (DISJ_…) and control‑flow choices, while the quantified part asserts that the values satisfy a host of arithmetic relations (bvadd, bvsle, bvsge) that model the optimisation’s semantic preservation.  The instance is difficult because it contains one deep quantifier over many bit‑vectors, a massive Boolean “selection” network built from dozens of ite‑terms (term depth ≈ 205), and a large number of intertwined disjointness and consistency clauses that force a hard SAT/SMT search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/034.smt2",
    "description": "The formula encodes a weakest‑precondition check for a compiler optimisation: it models two program states (S1 and S2) and an intermediate expression (E1) with Boolean flags for reads (R_…) and writes (W_…) of five 32‑bit variables, together with “disjointness’’ predicates (DISJ_…) that enforce that the chosen write sets do not interfere with the read sets. A single universally quantified block relates the concrete bit‑vector values before and after each possible write (via many nested ite’s) and adds arithmetic ordering constraints (bvsle/bvsge) that capture the optimisation’s semantic requirements; the outer assertions then force various combinations of the read/write flags to be inconsistent, so the solver must decide whether a selection of writes exists that satisfies all pre‑condition constraints. The instance therefore represents a verification‑style problem (semantic preservation of an optimisation) with one deep quantifier, many Boolean control variables, and extensive ite nesting, making it a challenging industrial BV query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/172.smt2",
    "description": "This instance encodes a relational verification problem that checks the semantic equivalence of a source program fragment and an optimized target fragment.  The formula consists of a single universal quantifier over five 32‑bit variables (V1…V5) together with a large Boolean “selection” matrix (the MW_S*_V* flags, W_*/R_* predicates and DISJ_* constraints) that models which write/read actions are performed in each version; the core constraints force the post‑state values produced by the two versions to be equal (or to satisfy a prescribed ordering) under every possible selection, while also enforcing disjointness of the read/write sets.  The encoding features a deep nesting of ite‑terms (≈80) and a mixture of bit‑vector arithmetic and Boolean reasoning, making it a challenging quantified BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/119.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation as described in the PSyCO “weakest‑precondition synthesis” framework.  A single universally‑quantified formula relates original 32‑bit program variables (V2, V4, V5, V6) to their possibly updated copies (S1_V*_!…, E1_…, E2_…) using ite‑guards (MW_S1_*) and expresses arithmetic relations (increments, decrements, signed ≤/≥) together with a large collection of Boolean consistency clauses that tie the modification flags (W_S1_*) and read‑set flags (R_S1_*, R_E1_*, R_E2_*) to equalities and to disjointness predicates (DISJ_W_S1_R_E1, DISJ_W_S1_R_S1, DISJ_W_S1_R_E2).  The instance asks whether there exists an assignment to all Boolean and bit‑vector variables satisfying these weakest‑precondition constraints while also falsifying a final clause that forces either a write flag (W_S1_V2) or a disjointness condition, i.e., it is a SAT‑based verification problem with a deep quantified bit‑vector term (depth 210) and many intertwined Boolean conjuncts that make it a challenging industrial case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/185.smt2",
    "description": "The formula encodes a weakest‑precondition synthesis problem for a compiler optimisation: Boolean selectors (the W_* and R_* variables) indicate which writes and reads of a set of SSA‑style variables are taken, and a single universal quantifier relates the resulting values through a large network of ite‑expressions, equality tests and ordering constraints on 32‑bit bit‑vectors. The constraints demand consistency between the “source” and “target” program fragments (e.g., equalities of different versions, bounds on counters, and preservation of control‑flow relationships) while also forbidding trivial solutions (e.g., all writes false). Hence the instance is a verification‑style check that the transformed code satisfies the same functional specification as the original, reduced to a SAT‑like search over the Boolean selectors with moderate term depth and a single quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/092.smt2",
    "description": "The instance encodes a **verification of a compiler optimisation** generated by the PSyCO weakest‑precondition synthesis tool.  It models three program states (the original expression E1 and two transformed versions S1, S2) with Boolean flags for reads, writes and mutual‑exclusion (DISJ_*) and a single ∀‑quantified block that ties the values of a set of 32‑bit variables together through a cascade of `ite`‑based write‑selection, arithmetic (`bvadd`, `bvneg`) and ordering (`bvsle`, `bvsge`) constraints.  The final assertion asks the solver to refute a large conjunction of equality, ordering and disjointness constraints; thus the problem is an industrial‑strength **verification** task that features a deep term depth (≈ 480), many Boolean variables (≈ 30) and a solitary but heavy quantifier over bit‑vectors, making it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/081.smt2",
    "description": "This instance encodes a weakest‑precondition verification problem for a compiler optimisation: Boolean flags model reads (R_…) and writes (W_…) of several program variables across three program points (E1, S1, S2), while the large quantified formula describes the transformed program’s memory updates using nested ite expressions over 32‑bit values. The constraints enforce disjointness between reads and writes (e.g., DISJ_W_S2_R_E1) and relational properties such as ordering and value equality, and the final assertions negate specific combinations of those properties to search for a counter‑example to the optimisation’s correctness. The formula contains a single universal quantifier, many Boolean variables, deep term nesting, and mixed bit‑vector arithmetic, making it a demanding industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/122.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation created by the PSyCO weakest‑precondition synthesis framework.  A single quantified block (∀ over 32‑bit variables and a handful of Boolean “mode” flags) describes the relational semantics of the original and the transformed program, enforcing that the values of all variables after the transformation satisfy a long series of conditional equalities, ordering ( bvsle / bvsge ) and read/write‑disjointness constraints (the R_/W_… and DISJ_* flags).  The outer assertions ask whether the disjointness of writes and reads ( DISJ_W_S1_R_S1 ) can be violated while a particular write ( W_S1_V1 ) is forced true; the solver must handle a deep quantified formula (term depth 65) with many nested ite and bit‑vector arithmetic, making the instance a hard verification‑type problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/027.smt2",
    "description": "The file encodes a verification condition for a compiler optimization generated by the PSyCO weakest‑precondition synthesis tool.  Boolean constants such as R_E1_Vi, W_S1_Vi and W_S2_Vi model the read/write sets of three program fragments (an original expression E1 and two transformed statements S1 and S2), while the large universally‑quantified bit‑vector formula asserts that for every possible input the values of the variables after the transformation satisfy the required equalities, ordering and disjointness constraints (captured by the DISJ_* flags).  The solver must decide whether these complex consistency constraints—featuring deep nested ite‑expressions, many Boolean disjunctions and three‑way equivalences—are simultaneously satisfiable, i.e., whether the optimization preserves the program’s semantics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/123.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It encodes, with a single universally‑quantified block over 32‑bit values, the relationship between original and transformed program states (variables E1, E2, S1) together with Boolean flags that denote which variables are read (R_…) or written (W_…) in each version; the main property being checked is that the write set of the transformed program (`W_S1_*`) is disjoint from the read set of the original (`R_S1_*`, `R_E*_`) and from other conflicting accesses, expressed by the `DISJ_…` predicates.  The solver is asked to satisfy the whole formula while intentionally falsifying the disjointness predicate (`(assert (not DISJ_W_S1_R_S1))`) under the assumptions that `W_S1_V1` and `R_S1_V1` hold, thus looking for a counter‑example to the optimisation’s safety.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/094.smt2",
    "description": "The instance encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis framework.  Boolean variables such as R_* (reads) and W_* (writes) together with the “DISJ_*” predicates model the read‑write sets and their required disjointness for three program fragments (the original expression E1, statement S1, and statement S2), while a large universally‑quantified formula ties these flags to concrete 32‑bit values of the program variables (V1…V5) through a cascade of `ite`‑expressions that capture the possible data‑flow choices.  The final assertions demand that the disjointness and value‑equality constraints hold simultaneously, effectively checking that the transformed code preserves the original semantics; the presence of a deep single quantifier, many nested `ite`s, and extensive Boolean combinators makes the problem a challenging bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/137.smt2",
    "description": "The instance encodes a verification condition for a compiler optimisation that was generated by the PSyCO weakest‑precondition synthesis tool.  A single universally‑quantified block relates the pre‑state bit‑vector variables (V2, V4, V5, V6) and a set of Boolean “write‑enable’’ flags (MW_S1_Vx) to the post‑state variables of several program locations (S1_V1…V6, E1, E2), expressing that the transformation must preserve the required ordering (bvsle / bvsge) and equality of values when writes are enabled, while also enforcing non‑interference constraints (DISJ_W_S1_R_S1, DISJ_W_S1_R_E1, DISJ_W_S1_R_E2).  The final check asserts the negation of the disjointness condition, turning the problem into a safety‑verification query that asks whether the optimisation can violate the non‑interference property; the formula is large (≈58 k characters), contains a deep term nesting (depth ≈ 1167) and a single 5‑tuple forall over 32‑bit vectors, making it a challenging industrial‑level bit‑vector verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/160.smt2",
    "description": "This SMT‑LIB file encodes a verification condition produced by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation. It asserts Boolean “write” (W_S1_V*) and “read” (R_S1_V*) flags for four 32‑bit variables V1…V4, together with a universally quantified relation that captures the effect of the transformation on the variables (inequalities, updates via ite‑expressions, and consistency of intermediate versions). The final query asks whether the combination of certain flag settings (e.g., ¬W_S1_V2 together with the disjointness condition) is reachable, i.e., whether the optimisation preserves the required invariants. The formula features a single deep quantifier over many BV terms, extensive nested `ite`/`let` constructions and many Boolean combinations, leading to a challenging BV‑verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/055.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation: a weakest‑precondition formula that relates reads (`R_*`) and writes (`W_*`) to five abstract memory locations across three program versions (source S1, source S2 and an intermediate expression E1).  The condition is expressed with a single universally‑quantified clause over four 32‑bit indices together with a large set of Boolean “must‑write” flags and disjointness predicates (`DISJ_…`) that enforce non‑interference and proper ordering of the accesses; the final assertions negate several conjuncts to ask the solver to find a counter‑example (i.e., to prove the transformation unsafe).  The problem is therefore a hard industrial verification instance, featuring deep nested `ite` terms (max term depth 205), many Boolean variables (32) and a single quantifier, which together make the search space highly combinatorial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/167.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation, generated by the PSyCO weakest‑precondition synthesiser.  It models reads (R_*) and writes (W_*) of five 32‑bit variables (V1 … V5) in three program fragments (S1, S2, B1) using Boolean flags and equality constraints that tie the post‑write values (expressed with ite and bvadd) to the original values; additional Boolean “DISJ_…” variables capture the required disjointness of write‑read pairs.  The final assertion (¬ DISJ_W_S1_R_B1) asks the solver to find a reachable state that violates the disjointness between the writes of S1 and the reads of B1 while all other semantic constraints hold, i.e., to check whether the proposed optimisation is unsafe.  The problem features a single deep quantifier over many bit‑vector variables, a large number of Boolean interdependencies, and a maximal term depth of 138, making it a non‑trivial industrial‑scale verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/048.smt2",
    "description": "The instance encodes a weakest‑precondition verification condition for a compiler optimisation: Boolean variables such as `R_…` and `W_…` describe whether a read or a write of a particular program variable (V1…V5, E1, S1, S2) occurs, while the huge quantified block (`forall …`) relates the concrete 32‑bit values of the variables after the optimisation (through `ite`, `bvadd`, `bvsle`, `bvsge`).  The formula asserts that all the required equalities, ordering constraints and mutual‑exclusion (DISJ_…) conditions hold simultaneously, and finally forces the negation of the conjunction `(and DISJ_W_S2_R_S1 DISJ_W_S2_R_S2)`, making the whole problem a consistency/verification check.  Because the single universal quantifier quantifies over many 32‑bit vectors and the Boolean part contains hundreds of nested `ite`s, disjunctions and equality tests (term depth ≈ 492, > 170 `or`s, ≈ 180 `=`), the instance is a large, highly combinatorial BV verification problem rather than a simple arithmetic or pure SAT query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/015.smt2",
    "description": "The file encodes a verification condition for a small two‑statement program (statements S1 and S2) whose variables V1 … V5 may be read ( R_* ) or written ( W_* ).  Boolean flags MW_S*_V* select one of several possible “memory‑write” versions of each variable, and a single quantified formula over 32‑bit values relates the chosen versions by a chain of `ite`‑expressions, equality constraints, and ordering constraints (e.g. `bvsge`, `bvsle`).  Together with a collection of disjointness axioms (e.g. `DISJ_W_S1_R_S2`, `DISJ_W_S1_W_S2`) and read/write consistency constraints, the instance asks whether there exists a consistent assignment of the flags and bit‑vector values that respects the weakest‑precondition semantics of the transformation – essentially a compiler‑optimization correctness check.  The encoding features a deep term structure (depth ≈ 75), many nested `let/ite`s, and a single universal quantifier, making it a challenging BV‑satisfiability problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/084.smt2",
    "description": "The file encodes a weakest‑precondition / verification problem for a small program fragment that has been optimized: it models reads ( R_… ) and writes ( W_… ) to five 32‑bit variables in two statements (S1, S2) and an expression E1, together with Boolean “disjointness’’ flags (DISJ_…) that enforce mutually exclusive choices of which write a read may observe. A single universally‑quantified formula relates the versioned values of the variables through nested ite expressions and integer ordering constraints ( bvsle, bvsge ), while a large Boolean conjunct describes the allowed combinations of read/write selections. The instance therefore checks the satisfiability of a memory‑consistency specification for a compiler optimisation, featuring one quantifier, deep ite nesting (term depth ≈ 165), over a hundred Boolean variables and many disjunctions, which makes it a challenging industrial‑style BV verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/046.smt2",
    "description": "This instance encodes the verification of a weakest‑precondition condition for a tiny three‑step program (an expression E1 followed by statements S1 and S2) that reads and writes five 32‑bit variables (V1…V5).  Boolean flags (R_*/W_*) denote which reads and writes occur, auxiliary selectors (MW_*) choose the most‑recent write for each variable, and a large quantified formula relates the selected values with a series of equality, ordering and “disjointness” constraints (DISJ_*) that capture the required memory‑consistency of the optimization.  The final constraints negate several conjunctions of these flags, turning the whole problem into a SAT/UNSAT check: does there exist an assignment to the selectors and read/write indicators that satisfies all weakest‑precondition and disjointness requirements?  The formula features a single forall over 32‑bit vectors, deep nesting of ite‑expressions (depth ≈ 170) and many Boolean combinations, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/008.smt2",
    "description": "This instance encodes a **verification condition for a compiler optimisation** that was generated by the PSyCO weakest‑precondition synthesis tool.  The formula models two program fragments (S1 and S2) together with an expression E1, each of which has several versioned variables (V1…V6).  Boolean flags `R_…` and `W_…` denote whether a version is read or written, and a set of `DISJ_…` constraints require the reads and writes of the two fragments to be pairwise disjoint.  The core of the problem is a single quantified block that, for arbitrary 32‑bit inputs, uses nested `ite`‑terms controlled by the write‑enable flags (`MW_…`) to describe the shifted SSA values of the fragments and then asserts a collection of equalities, ordering constraints (`bvsle`, `bvsge`), and arithmetic relations (adds, negates, a multiplication).  A second, much smaller conjunct simply forces an impossible combination of read/write flags, turning the whole check into a **satisfiability/unsatisfiability test of the generated weakest‑precondition**.  \n\nThe instance is industrial‑style, with 37 Boolean constants, a deep term nesting (depth 517) caused by many layered `ite`s, and a single universal quantifier over six 32‑bit bit‑vectors.  These characteristics – the massive combinatorial explosion of Boolean disjunctions, the deep nested ite‑structure, and the quantified arithmetic – make the solving task non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/050.smt2",
    "description": "The benchmark encodes a verification condition for a compiler optimisation, generated by the PSyCO weakest‑precondition synthesis tool.  Boolean variables such as R_S1_V4, W_S2_V5, DISJ_W_S2_R_E1 represent reads, writes and disjointness of memory locations V1…V5 and an expression E1, while the large quantified formula relates the possible values of these locations (32‑bit bit‑vectors) through ite‑based write‑propagation equalities and ordering constraints.  The final assertions negate the conjunction of the disjointness and read/write consistency hypotheses, so the solver is asked to prove unsatisfiability (i.e., that no counter‑example to the optimisation exists), a typical safety‑verification problem with many Boolean combinations, deep ite nesting and a single universal quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/125.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation: Boolean constants such as R\\_E1\\_V6, W\\_S1\\_V6, R\\_S1\\_V6, … denote whether a given program version (original E1/E2 or transformed S1) reads or writes a particular memory location, while a large quantified block models the bit‑vector semantics of the involved statements (values, increments, and order constraints).  The main property being checked is the **disjointness** of the write‑set of the transformed program (S1) from the read‑sets of the original programs (S1, E1, E2), expressed by the booleans DISJ\\_W\\_S1\\_R\\_S1, DISJ\\_W\\_S1\\_R\\_E1, DISJ\\_W\\_S1\\_R\\_E2; the final assertion negates DISJ\\_W\\_S1\\_R\\_S1 to ask whether a conflict can occur.  Hence the instance is a **safety‑verification** problem (absence of read‑write aliasing) for a bit‑vector encoded program transformation, featuring a single universal quantifier, deep term nesting (depth ≈ 464) and many Boolean let‑bindings, which makes it a challenging industrial BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/035.smt2",
    "description": "The file encodes a weakest‑precondition based verification of a compiler optimisation: a source program fragment (statements S1, S2 and an expression E1) is transformed, and Boolean flags R_… and W_… record which variables V1…V5 are read or written in each fragment.  A single universally‑quantified formula ($x3462) relates the pre‑state bit‑vector values (32‑bit integers) to the post‑state values under the transformation, together with a large collection of read/write‑set consistency and disjointness constraints (the DISJ_* Booleans).  The final assertions negate several combinations of these constraints, turning the problem into a SAT/SMT check whether a counter‑example exists; the instance features deep nesting (term depth ≈ 170), many ite expressions and a mixture of bit‑vector arithmetic and Boolean reasoning, making it a non‑trivial industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/058.smt2",
    "description": "The formula encodes a verification condition for a compiler optimisation: Boolean flags such as R_E1_Vi and W_Sj_Vi represent reads and writes of variables at different program points (E1, S1, S2), while the bit‑vector terms model their abstract timestamps.  The large quantified assertion expresses the weakest‑precondition of the optimisation, requiring that all ordering, coherence (equality of timestamps for the same variable under different schedules) and disjointness constraints (the DISJ_* booleans) hold; the final top‑level clauses negate several conjunctions of these constraints, so the solver is asked to show the formula is unsatisfiable, i.e. that no illegal interleaving exists.  The instance features a single deep universal quantifier, many nested let/ite expressions, and a mixture of Boolean control‑flow and 32‑bit arithmetic, typical of industrial memory‑model verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/148.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  A single universally‑quantified Horn‑like clause relates the original program state (variables E1_V*) and the transformed state (variables S1_V*) through Boolean mode switches (MW_S1_*) and a number of Boolean flags (W_*, R_*, DISJ_*) that express whether a write, a read or a disjointness property must hold.  The remaining assertions demand the consistency of these flags (e.g. that the write and read predicates are mutually exclusive) and finally assert the negation of the conjunction of the two disjointness constraints, so the solver is asked to check whether the optimisation’s correctness condition is unsatisfiable.  The problem features a single quantifier, deep nested ite‑expressions and many let‑bindings (max term depth 77), making it a non‑trivial bit‑vector verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/110.smt2",
    "description": "This formula is a single‑quantifier verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimization.  It quantifies over the 32‑bit values of several program variables (V2, V4, V5, V6) together with Boolean “must‑write” flags (MW_S1_*) and encodes, via many chained `ite`, `bvadd`, `bvsge`/`bvsle` equalities and order constraints, the relational semantics of the original and the optimized code, plus disjointness constraints on read/write sets (DISJ_W_S1_R_*).  The solver must decide whether the asserted conjunction—expressing that the weakest precondition of the optimized program implies that of the original—is universally true, a typical industrial‑scale bit‑vector verification problem with deep term nesting but only one quantifier block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/064.smt2",
    "description": "The instance encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  It checks, with a single quantified forall over 32‑bit variables, that a pair of program fragments (S1 and S2) preserve a set of relational predicates (R_*) and respect various disjointness constraints (DISJ_…) while respecting ordering constraints expressed with signed‑comparison and arithmetic on the bit‑vectors.  The formula contains many Boolean control flags, deep nested ite‑expressions (max term depth 93) and a handful of Boolean‑only conjuncts, making the solving task challenging due to the combination of a quantifier, extensive let‑binding structure, and intertwined BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/113.smt2",
    "description": "This instance encodes a weakest‑precondition synthesis / verification problem for a compiler optimisation.  The core formula is a single ∀‑quantified condition over 32‑bit variables (V1…V6) and Boolean “must‑write’’ flags (MW_*), expressing that for every concrete state the transformed program’s reads (R_*) and writes (W_*) satisfy the semantic preservation constraints (equality/inequality of the original and rewritten values, order constraints with bvadd/bvneg, and disjointness of write sets).  The outer assertions then require the existence of a write assignment (the W_* booleans) that makes the disjointness predicates DISJ_W_S1_R_* true, while also respecting specific read‑write exclusions, turning the problem into a quantified bit‑vector SAT check with moderate depth (≈60) and a sizable Boolean/bit‑vector interplay.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/070.smt2",
    "description": "The formula expresses a verification condition generated by a weakest‑precondition synthesis for a compiler optimization.  Boolean constants such as R_E1_Vi, W_S1_Vi, W_S2_Vi encode reads and writes of program variables in the original (E1) and transformed (S1, S2) code, while the quantified part relates the values of the corresponding 32‑bit variables through a web of `ite`‑equalities, ordering constraints (`bvsle`, `bvsge`) and disjointness predicates (e.g. DISJ_W_S1_R_E1).  The solver is asked to prove unsatisfiability of a negated conjunction of these consistency and exclusivity constraints, which amounts to checking that no interference or value‑mismatch can occur; the instance features a single universal quantifier, many Boolean flags, and deeply nested `let`/`ite` terms (depth ≈ 85), making it a challenging industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/083.smt2",
    "description": "This instance is a verification condition produced by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation. It models the equivalence of an original and an optimised program fragment by representing five 32‑bit integer variables (V1…V5) as bit‑vectors and using Boolean flags for reads (R_*), writes (W_*), and disjointness constraints (DISJ_*). A single quantified formula (∀ over the variables and write‑selection flags MW_*) encodes the weakest‑precondition relationship together with many nested ite‑expressions, equality checks and Boolean “or/and/not” combinations, producing very deep terms (depth ≈ 165) and a dense Boolean structure that makes the SAT/SMT solving non‑trivial.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/041.smt2",
    "description": "The benchmark encodes a verification condition for a compiler optimisation obtained with the PSyCO weakest‑precondition synthesis tool.  Boolean variables such as R_S1_V4, W_S2_V5 represent reads and writes of the five 32‑bit program variables (V1…V5) in the original and transformed code, while the massive nested ite expressions model the value of each variable after a possible write, under the control‑flow flags MW_…; the formula also contains explicit “disjointness” constraints (the DISJ_… flags) that enforce non‑interfering read/write sets.  The instance asks whether all these constraints can be satisfied together with a collection of negated combinations of the disjointness predicates, i.e., it checks the unsatisfiability of a potential counter‑example to the optimisation’s correctness.  Solving difficulty stems from a single universally quantified block over four 32‑bit vectors together with a very deep term structure (depth ≈ 170) and a large number of Boolean variables and nested let‑bindings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/126.smt2",
    "description": "The file encodes a verification condition for a compiler‑optimisation transformation, generated by the PSyCO weakest‑precondition synthesis tool.  It asserts that a set of Boolean flags marking reads (R_…) and writes (W_…) to six program variables in the original (E1, E2) and transformed (S1) code are mutually disjoint, together with a large universally quantified Boolean/bit‑vector formula that captures the semantics of the two program versions; the final check asks whether the disjointness of the S1 reads and writes can be violated while a particular write (W_S1_V1) holds.  The problem is a pure‑BV verification instance with a single forall over many bit‑vector variables, deep ite‑nested terms (depth ≈ 87) and an extensive Boolean combination, making it a challenging industrial‑style SAT/SMT query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/101.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  It models two original statements (S1, S2) and an expression (E1) with Boolean flags for each possible read (R_…) and write (W_…) of the four program variables (V1…V5).  The large quantified formula $x5110 relates the concrete 32‑bit values of the variables before and after the transformation using many nested ite‑terms and arithmetic constraints (orderings, non‑overflow), while the surrounding Boolean constraints enforce disjointness of read/write sets (DISJ_…) and mutual exclusivity of the write‑choice flags (MW_…).  The final assertions demand that no conflicting combination of reads, writes and disjointness violations is possible, so the instance is a safety‑verification problem for the transformed program, characterized by a single deep ∀‑quantifier over 32‑bit vectors and a dense network of Boolean disjunctions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/190.smt2",
    "description": "This instance encodes a verification task for a compiler optimisation: it asks whether a choice of “write‑selection’’ Booleans W_* and “read‑selection’’ Booleans R_* can make the weakest‑precondition of the transformed program equivalent to that of the original program for **all** 32‑bit inputs.  The core of the formula is a single universally‑quantified block that uses many nested `ite`‑expressions to select variable values (V1…V5, S1_…, S2_…, E1_…) according to the W_* flags, together with equality and ordering (`bvsle`, `bvsge`) constraints that capture value preservation and monotonicity; a large collection of propositional clauses (big disjunctions of negated/positive W_* and R_*) forbids illegal combinations of reads and writes.  The problem is thus a quantified bit‑vector verification/synthesis query with deep term nesting (max depth ≈ 147) and a heavy Boolean combinatorial structure, making it challenging for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/182.smt2",
    "description": "The benchmark encodes a verification‑by‑synthesis problem for a tiny compiler optimisation: it asks whether the transformed version of a block that manipulates seven 32‑bit variables (V1…V7) is semantics‑preserving.  Boolean flags `R_S1_V*`/`W_S1_V*` (read/write) and auxiliary “may‑write’’ flags `MW_S1_V*` are used together with a single universal quantifier over all 32‑bit inputs to require that, whenever a variable is read or written, the value produced by the original program equals the value produced by the optimised program; the constraints also include the arithmetic relationships of the original code (addition, multiplication) and a disjointness condition `DISJ_W_S1_R_S1`.  The formula features a deep term hierarchy (≈30), many nested `ite`s and equalities, and a single quantifier alternation, typical of industrial weakest‑precondition synthesis instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/154.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation derived by weakest‑precondition synthesis: a set of 32‑bit program variables (V1 … V6) and Boolean flags (MW_S1_Vi, W_S1_Vi, R_S1_Vi) model the “write” and “read” versions of a program fragment, and the formula asserts that the synthesized precondition (the quantified block) together with the disjointness of write‑ and read‑effects (DISJ_W_S1_R_S1) holds.  The core constraint is a single ∀‑quantifier over the bit‑vector variables that combines many nested ite‑expressions, arithmetic (addition, multiplication, signed comparisons) and equalities, followed by Boolean clauses linking the write/read flags and requiring ¬DISJ_W_S1_R_S1.  The instance is a BV‑only verification problem with a deep term nesting (depth ≈ 104), one quantifier and a moderate number of Boolean and arithmetic operations, making it a challenging industrial‑style check of invariant preservation and effect disjointness.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/040.smt2",
    "description": "The instance encodes a verification condition for a compiler optimisation: Boolean variables such as R_S1_Vi, W_S2_Vi represent reads and writes of integer‑typed program variables (V1…V5) in three program states (E1, S1, S2). A single universal quantifier relates the concrete 32‑bit values of these variables before and after possible writes (controlled by the MW_* flags) and imposes ordering constraints (bvsle/bvsge) together with a large set of disjointness clauses (DISJ_*) that forbid illegal read‑write interferences; the outer conjuncts assert the negation of several forbidden combinations, turning the whole formula into a consistency check. Thus the problem is a (mostly quantifier‑free) bit‑vector verification task that searches for a reachable state violating the memory‑access discipline, featuring a deep term structure, many Boolean auxiliaries, and a single‑quantifier component that together make the instance challenging for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/174.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation, generated by the PSyCO weakest‑precondition synthesis tool.  Boolean variables such as W_Si_Vj (write flags) and R_Si_Vj (read flags) describe two program states S1 and S2, while the quantified part relates the concrete 32‑bit values of the variables before and after the transformation using a lattice of `ite`‑expressions and simple arithmetic (`bvadd`, `bvsge`, `bvsle`).  The model must satisfy a series of “disjointness” constraints (e.g., DISJ_W_S1_R_S2) that enforce consistency between reads and writes, together with ordering constraints on the bit‑vector values; the final assertions negate a conjunction of these properties, so the solver is asked whether a counter‑example to the optimisation’s correctness exists.  The problem is a single‑quantifier verification query with deep term nesting (max depth 55) and a large number of Boolean combinations, making it a challenging industrial‑style BV‑verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/076.smt2",
    "description": "The file encodes a verification condition for a compiler optimisation generated by the PSyCO weakest‑precondition synthesis tool.  It models three program fragments (the original expression E1, and two transformed statements S1 and S2) with Boolean flags for reads (R_*) and writes (W_*) of five integer variables (V1…V5).  A single universally‑quantified bit‑vector formula ties the values of all versions of the variables together using a cascade of `ite`‑terms guarded by write‑selection flags (MW_*), and imposes ordering constraints ( signed ≤ / ≥ ) on the numeric values.  Around this core the instance asserts a collection of disjointness/guard constraints (DISJ_*) that express that conflicting reads and writes must not overlap, and then adds a few negated conjuncts to force certain conflict patterns to be impossible.  The overall problem is to decide whether the proposed optimisation can preserve the program’s semantics – i.e., whether there exists an assignment to the Boolean selectors and bit‑vector values satisfying all the read/write consistency, ordering, and disjointness requirements.  The instance is challenging because it combines deep‑nested `let`/`ite` expressions, a quantified block over 32‑bit vectors, and a large propositional backbone with many mutually exclusive conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/117.smt2",
    "description": "The file encodes a weakest‑precondition verification condition for a small program fragment that has been transformed by a compiler optimisation (generated by the PSyCO tool). Boolean flags `W_S1_V*` and `R_S1_V*` model whether a variable is written or read in the original statement S1 and in the two transformed statements E1 and E2; a single universally‑quantified block relates the 32‑bit values of the variables before and after the transformation with many `ite`‑expressions and ordering constraints (`bvsle`/`bvsge`). The remaining assertions tie these flags together with disjointness conditions (`DISJ_…`) and assert that certain combinations must be false, so the solver must find a model that violates the optimisation. The problem features a single forall over 32‑bit vectors, deep term nesting, numerous Boolean disjunctions, and a mixture of arithmetic and logical constraints, giving a moderately challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/077.smt2",
    "description": "This instance is a verification condition generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimisation.  It encodes, with a single universal quantifier over 32‑bit values, the functional relationship between two program versions (S1 and S2) and the original code (E1), using Boolean flags for reads (R_*) and writes (W_*) and auxiliary “disjointness’’ predicates (DISJ_*) to state that each read must observe the correct write and that the write sets of the transformed and original programs do not overlap.  The final asserts negate several conjunctions of these flags, so the solver must prove the formula unsatisfiable, i.e. that the optimisation preserves the intended semantics; the problem is hard because of a deep term nesting (≈165) and a large, heavily ite‑laden universally quantified block but only a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/033.smt2",
    "description": "The formula verifies a compiler‑optimisation transformation that manipulates three program states – the original execution E1 and two transformed versions S1 and S2 – by modelling reads and writes to five 32‑bit variables (V1…V5) with Boolean flags (R_*/W_*) and their bit‑vector values.  A single universal quantifier encodes the weakest‑precondition of the transformation, relating the values after each possible write (via many nested `ite`s) and imposing ordering, equality/inequality and non‑interference (DISJ_*) constraints among the reads, writes and the three states; the outer assertions then ask whether the combination of these read/write and disjointness predicates can be simultaneously satisfied.  In effect, the instance checks that the optimisation is semantically sound (i.e., preserves the required invariants) under the given memory‑model constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/095.smt2",
    "description": "The instance encodes a verification condition for a compiler optimization: a weakest‑precondition formula (generated by PSyCO) is expressed as a large quantified Boolean‑BV constraint that models all possible reads and writes (R_/W_…) to the program’s variables together with disjointness requirements (DISJ_…) between those actions.  The core of the problem is to decide whether there exists a consistent assignment to the Boolean flags (choosing which reads/writes occur) and to the 32‑bit data values such that the weakest‑precondition holds; the surrounding assertions force a contradiction (e.g., asserting both a conjunction and its negation), so the solver must prove unsatisfiability to certify the optimisation.  The formula contains a single deep forall (≈190 nesting depth), dozens of ite‑expressions, many Boolean combinations (≈200 or, ≈110 not, ≈74 and) and a sizeable set of uninterpreted Boolean control variables, making it a challenging industrial‑style safety‑verification benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/150.smt2",
    "description": "This instance encodes a verification condition for a compiler optimisation: the Boolean variables W_… and R_… model, respectively, which program variables are written or read before and after the transformation, while the quantified part describes the weakest‑precondition relationship between the original (E1) and the optimised (S1) versions using 32‑bit integer arithmetic.  The formula asserts that the optimisation’s read‑set and write‑set are disjoint (DISJ_…) and that the transformed program’s post‑state satisfies the same relational constraints as the original, and finally checks whether a particular read condition ( R_S1_V1 ) can hold.  The problem is a single‑quantifier, deep‑nesting BV‑verification task with many Boolean combinations and let‑bindings, making it a difficult industrial‑style weakest‑precondition synthesis check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/006.smt2",
    "description": "The instance encodes a verification problem for a compiler‑level program transformation: it asks whether the weakest‑precondition predicates (the *W_* Booleans) can be chosen so that the transformed program states **S1**, **S2** and the expression **E1** remain semantically equivalent to the original state, while respecting a set of non‑interference (disjointness) conditions (the *DISJ_* Booleans).  This is expressed by a single universal quantifier over six 32‑bit variables together with many Boolean control flags (*MW_*), equalities between the original and updated bit‑vector terms, and relational constraints (*R_*).  The formula features deep nesting of `let`, `ite`, and arithmetic operations (addition, subtraction, multiplication) and a dense web of conjunctive/disjunctive Boolean clauses, making it a challenging BV‑logic instance with high term depth and a large number of interdependent Boolean variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/medium.smt2",
    "description": "This instance encodes a hardware‑rewrite‑rule verification problem from the PEak benchmark suite.  A single quantified \\((\\forall)\\) assertion builds a massive combinational circuit by concatenating many control‑field bit‑vectors (condition codes, ALU ops, multiplexers, signed flags, constants, etc.), then applies extracts, arithmetic (addition, subtraction, multiplication, sign/zero extensions), and comparison operators to express that the output of the rewritten instruction sequence must equal the original for **all** possible 16‑bit inputs, clock‑enable and data values.  The formula is pure bit‑vector logic (BV) with a deep term nesting (depth ≈ 6700) and extensive use of extracts, concatenations and ite‑chains; solving it checks unsatisfiability of the rule’s counterexample, i.e., that the rewrite is universally correct.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/easy.smt2",
    "description": "The instance encodes a hardware‑verification problem for a bit‑vector processing element (PE).  A single universally quantified formula describes the PE’s datapath – concatenating fields such as condition codes, ALU control bits, constants, multiplexers and signed flags into an instruction word, extracting sub‑words, and applying a rich set of arithmetic operations (add/sub with carry, multiplication, logical shifts, comparisons, etc.) that are selected by many nested `ite` expressions.  The constraints require that, for every possible combination of the six 16‑bit inputs, a clock‑enable flag and a data word, the PE’s output (`ob_0`) must equal a prescribed value (and certain instruction‑bit patterns `ib_0` must hold), while also respecting a wrapper flag (`PE_wrapped_if_0`).  The problem is thus a verification/synthesis check for a rewrite rule of the PE: find concrete bit‑vector constants for the instruction fields that satisfy all functional equations.  The formula is extremely deep (term depth ≈ 1378) with thousands of `let`, `extract`, `concat` and `ite` nodes, making it challenging for BV solvers despite having only a single universal quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/easy.smt2",
    "description": "This instance encodes a universal verification condition for a hardware rewrite‑rule in the PEak benchmark suite.  A large bit‑vector is built from many declared components (ALU flags, multiplexers, constants, signedness bits, etc.) using concatenations, extracts, arithmetic, and conditional (ite) operators, and the formula asserts that for *all* input vectors (including a clock‑enable flag) various sliced fields lie within fixed ranges and that the output bit‑vectors (`ib_0`, `ob_0`) match prescribed constants—essentially checking that a candidate rewrite preserves the original circuit’s behavior.  The problem is a quantified bit‑vector unsatisfiability/verification task with very deep term nesting (depth > 10 000) and thousands of extracts and ite expressions, making it a challenging industrial‑scale hardware equivalence check.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy1.smt2",
    "description": "The file encodes a **hardware rewrite‑rule verification** query from the PEak benchmark suite.  A single universally‑quantified assertion states that a very large combinational circuit built from extracts, concatenations, arithmetic (add, mul, shift, negate) and many nested `ite` conditionals (modeling ALU, multiplexers, LUTs, signed/unsigned operations, etc.) must satisfy a Boolean property for **all** possible input bit‑vectors (the declared data, constant, condition and mux signals).  The problem is a pure BV‑logic equivalence/functional‑correctness check that is exceptionally hard for solvers because of its massive size (≈225 KB), deep term depth (> 4600), thousands of extracts and ite’s, and the presence of a universal quantifier, leading to a large, highly nested Boolean‑bit‑vector formula.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/hard.smt2",
    "description": "This instance encodes the **equivalence‑checking** of a hardware rewrite rule (from the PEak rewrite‑rule synthesis benchmark).  A universally quantified block builds a 720‑bit input word from many selector, constant, and ALU fields, then performed a full symbolic execution of the original and rewritten datapaths using concatenations, extracts, arithmetic (+,‑, neg, mul), comparisons (bvule, bvsle, bvslt), and conditional (ite) wiring.  The final assertion requires that the two resulting bit‑vectors are equal for **all** possible input assignments, together with a collection of auxiliary range and flag constraints; the formula is expected to be UNSAT, proving the rewrite rule sound.\n\nThe core difficulty lies in the massive term depth (≈ 160 k) and the huge number of nested ite/concat/extract operations (tens of thousands), plus a single top‑level ∀‑quantifier over many 16‑bit inputs, which yields an extremely large bit‑vector expression that is hard for solvers to bit‑blast efficiently.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium2.smt2",
    "description": "The file encodes a verification condition for a hardware rewrite rule (PEak data‑path synthesis) expressed entirely in BV logic.  A huge quantified term builds the exact functional behavior of a processor‑style unit – extracting bits, sign/zero extending, multiplexing, adding, multiplying, and shifting based on condition‑code, signedness and control flags – and the single top‑level assertion requires that the computed 420‑bit result always equals a fixed constant pattern.  The instance therefore tests the soundness of the rewrite under all possible inputs, and is characterized by extreme term depth (≈ 100 k) and thousands of nested bit‑vector operations, making it a difficult industrial‑scale SAT/SMT benchmark.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy4.smt2",
    "description": "This instance encodes a hardware‑verification problem from the PEak rewrite‑rule synthesis benchmark.  A single universal quantifier builds a massive bit‑vector representation of an instruction (combining condition fields, mux selections, constants, LUT entries and three 16‑bit data operands) and then defines a cascade of arithmetic, logical and shifting operations (including adds, subtractions, multiplications, comparisons and sign/zero extensions) that must satisfy a set of equality and Boolean constraints involving the input vector ib_6, the output flag ob_6 and a wrap‑around predicate PE_wrapped_if_10.  The formula is extremely deep (over 27 000 term nesting levels) with thousands of ite, extract, concat and extension operators, making it a challenging industrial‑scale BV verification task.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/08.smt2",
    "description": "The instance encodes a verification condition for LLVM’s constant‑range analysis: it models 16‑bit integer intervals (including full, empty and wrap‑around cases) and defines the “unsigned max” of two numbers. The formula asserts that for two non‑wrapped intervals N1 and N2, every possible max umaxInt(n1,n2) lies in a result interval R that is strictly smaller (in bit‑vector size) than the naïvely constructed interval umax(N1,N2). Thus the solver must decide whether the interval abstraction used in the optimizer is unnecessarily large, i.e., whether a tighter interval R exists that still over‑approximates all max values. The problem features a single universally quantified implication over bit‑vectors, a handful of auxiliary functions, and modest term depth, typical of industrial verification VCs derived from LLVM source code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/07.smt2",
    "description": "This instance encodes a verification condition for LLVM’s **ConstantRange** interval arithmetic, specifically the unsigned “max” operation on two non‑wrapped 32‑bit intervals. It models intervals as 64‑bit concatenations of lower and upper bounds, defines predicates for emptiness, fullness, wrapping, containment, and size, and asserts that for all elements n₁∈N₁ and n₂∈N₂ the value umaxInt(n₁,n₂) must belong to a result interval R, while R is required to be strictly smaller than the naïve interval constructed by the supplied umax function. The formula checks whether the implementation of the max‑range computation is sound, using a single quantified implication over bit‑vector terms, with modest term depth but non‑trivial interval reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/03.smt2",
    "description": "The instance encodes a verification condition for LLVM’s constant‑range analysis: given an 8‑bit interval N (represented by its low and high bytes) and a 12‑bit interval R, it checks that the sign‑extended interval of N (produced by the helper signExtend) safely over‑approximates all sign‑extended values of N (the quantified “contains” implication) and that the size of R is strictly smaller than the size of that sign‑extended interval while respecting the full/empty/wrapped semantics of circular bit‑vector intervals. The problem is a bit‑vector safety check with a single universal quantifier over an 8‑bit domain, modest term depth (≤6) and a small set of arithmetic and interval‑manipulation definitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/05.smt2",
    "description": "This instance encodes a verification condition for LLVM’s `ConstantRange` abstraction: it models 32‑bit integer intervals (possibly wrapped) and their 36‑bit extensions, defines membership and size predicates, and then asserts that the extended interval `zeroExtend(N)` both strictly contains the 36‑bit interval `R` (its size is larger) **and** is entirely included in `R` (forall n ∈ N → zero‑extended n ∈ R). The formula therefore checks the consistency of these interval‑inclusion and size constraints, effectively testing whether such a configuration can exist (it is unsatisfiable except for degenerate cases). The problem uses only bit‑vector arithmetic with a single universal quantifier and shallow term depth, typical of industrial verification tasks derived from LLVM optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/01.smt2",
    "description": "The instance formalises a verification condition for LLVM’s constant‑range analysis: a 32‑bit interval N is lifted to a 36‑bit interval by a custom sign‑extension function, and a second 36‑bit interval R must both (i) be strictly smaller in size than the sign‑extended range of N and (ii) contain the sign‑extended value of every element of N (expressed with a universal quantifier).  The encoding uses bit‑vector extracts, concatenation, and wrap‑around interval predicates (full, empty, wrapped) to capture the semantics of unsigned intervals and their signed‑extension, and it checks the consistency of these predicates with a handful of quantified and arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/363_oggenc.smt2",
    "description": "This instance is a bounded translation‑validation query generated by the Alive2 verifier for an LLVM optimization in the oggenc encoder. It asks whether two complex bit‑vector arithmetic fragments (involving many 32‑bit multiplications, divisions, concatenations, extracts and conditional ite‑expressions) produce exactly the same result under all possible “undef’’ values, with additional Boolean flags (`isundef_*`) that capture definedness of intermediate operands. The check contains 31 universal quantifiers over dozens of fresh 32‑bit variables, a very deep term nesting (depth ≈ 243) and tens of thousands of nested concatenations, making it a large, highly quantified bit‑vector equivalence problem that stresses solvers’ handling of undefined‑behaviour and quantifier instantiation.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/386_oggenc.smt2",
    "description": "The file encodes an **Alive2 translation‑validation query** for an optimization in the Ogg encoder (oggenc). It asserts that two heavily‑nested 32‑bit bit‑vector expressions—modeling the original and optimized LLVM code and parameterised by many “undef’’ placeholders and `isundef` flags—are equal for all possible values of those undefined inputs. The formula contains dozens of universally‑quantified variables, deep nesting of `concat`/`extract`, and extensive use of `bvadd`, `bvmul`, `bvsdiv` and signed/unsigned comparisons, resulting in a very large, deeply‑structured benchmark that tests a solver’s ability to handle industrial‑scale bit‑vector verification.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/sqlite3/773_sqlite3.smt2",
    "description": "The instance is an **Alive2 translation‑validation query** that checks whether a compiler optimisation preserving two error‑code variables (`%posixError` and `%sqliteIOErr`) is semantics‑preserving when their low‑order bits may be undefined.  A single universally quantified block enumerates all possible undefined 32‑bit values, then uses a cascade of `bvand`, `bvor`, and `ite` expressions together with explicit equalities to constant codes (e.g., 37, 4, 16, 13, 11, 110) to assert that the original and transformed computations produce the same result under the given non‑poison (`np_%posixError`, `np_%sqliteIOErr`) assumptions.  The formula involves deep (>50) term nesting, many case splits, and bit‑vector reasoning, making it a non‑trivial verification problem for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/626_ph7.smt2",
    "description": "The instance is a bounded translation‑validation query generated by Alive2 for an LLVM optimizer. It checks that a transformation on two bit‑vector variables – a 32‑bit key %nKeyID and an 8‑bit flag %bCheckFunc – preserves the original semantics in the presence of undefined values (modeled by the “isundef_*” and “undef!*” constants). The formula encodes a large case‑analysis on the masked key (bvand/bvor with constant masks) against a set of concrete constants (4, 9, 10, 37, 40, 41, 42, 43, 256, 512, 8192, 15, 27, 128) and asserts that, under the non‑poison preconditions (np_%nKeyID, np_%bCheckFunc), the optimized code yields the same result as the original. The problem features a single universal quantifier over many undefined placeholders, deep nesting of let‑bindings, many equalities/inequalities, and numerous ite/and/or combinations, making it a challenging bit‑vector verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/659_ph7.smt2",
    "description": "The file encodes an **Alive‑2 translation‑validation query** for an LLVM peephole optimization under *partial undefined behaviour*.  It introduces a concrete 32‑bit value `%c` together with a flag `isundef_%c` and a collection of “undef” constants, then formulates a large quantified Boolean combination of signed‑less‑or‑equal range checks (e.g. 0…96, 47, 58, 64, 71, 103, 102) and conditional 32‑bit additions with offset constants.  The final assertion asserts that, assuming the pre‑condition `np_%c`, the post‑condition (expressed as a series of nested `ite` and equality constraints on sign‑extended sums) cannot be violated; in other words it checks that the optimized LLVM fragment refines the original one.  The instance features a single universal quantifier, deep nesting (term depth ≈ 81), many let‑bindings and a mixture of arithmetic, bitwise, and relational operators, making it a challenging BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-tptp/NUM917=1.smt2",
    "description": "The benchmark encodes a quantified bit‑vector property: it asserts the negation of “for every 32‑bit vectors U and V there exists a 32‑bit vector W such that U − W equals V”. In other words, it asks whether subtraction on 32‑bit bitvectors fails to be surjective; the solver must determine that the negated formula is unsatisfiable (the original property is universally true). This is a small BV‑logic instance with a single ∀∃ quantifier alternation and modest term depth, typical of industrial verification‑style checks on arithmetic operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium2.smt2",
    "description": "This instance encodes a hardware‐rewrite‑rule verification condition from the PEAK benchmark suite: a single universally quantified assertion states that, for every possible combination of instruction fields and input signals (clock enable, data operands, constants, etc.), a large expression built from extracts, concatenations, arithmetic (adds, mul, shifts), and bitwise operators must equal a reference output (ensuring the rewrite preserves the circuit’s semantics).  The formula lives entirely in the BV logic, contains thousands of ite/ite‑chains, tens of thousands of extracts and concatenations, and reaches a term depth of more than 130 000, making it a very deep, quantifier‑heavy industrial verification problem that stresses solvers’ handling of large bit‑vector expressions.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/medium.smt2",
    "description": "This benchmark encodes a hardware datapath consisting of an ALU, condition‑code registers, signed/unsigned arithmetic units, and several multiplexers, all built from bit‑vectors and concatenations of individual control and data bits. A single universally‑quantified assertion states that, for every possible combination of the 840‑bit input vector `ib_0` and the declared control signals, the produced output must equal a particular constant pattern (including `ob_0 = 1` and a huge fixed `ib_0` value), which is unsatisfiable and thus checks the correctness of a rewrite rule. The problem features extremely deep term nesting (over 200 k levels) and massive use of bit‑vector operators, making it a hard industrial‑scale verification instance.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/283_oggenc.smt2",
    "description": "This instance is an Alive 2 “bounded translation validation” query that checks the correctness of an LLVM‑level optimization applied in the Ogg encoder (oggenc). It asserts that, for all possible values of a large set of undefined 32‑bit variables, the transformed sequence of bit‑vector operations (adds, multiplies, signed divisions, extracts, concatenations and sign‑extensions) yields the same result as the original, respecting signed‑overflow and division‑by‑zero constraints. The formula is a single quantified assertion in BV logic with 31 ∀‑quantifiers, a deep nesting depth (≈ 250), and thousands of concatenation/extract/Ite terms, making it a heavy‑weight industrial verification problem for bit‑vector solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium0.smt2",
    "description": "This instance models the correctness of a hardware rewrite rule in the PEak benchmark suite: it builds an 840‑bit instruction word from many 16‑bit inputs, constants, control flags and sub‑components (ALU, multiplexer, LUT, signed/unsigned flags), then applies a long sequence of bit‑vector operations (concatenations, extracts, shifts, additions, multiplications and comparisons) to express the datapath semantics and finally asserts that a particular output condition holds for all possible input valuations. The formula contains a single quantified implication with hundreds of thousands of nested let‑bindings, deep term depth (≈ 275 K) and thousands of bit‑vector operators, making it a large‑scale industrial verification problem that stresses a solver’s handling of bit‑vector arithmetic, conditionals and quantifier reasoning.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard0.smt2",
    "description": "This instance encodes a massive bit‑vector verification condition for a single‑instruction datapath of a PE (processing element) used in the PEak hardware rewrite‑rule synthesis benchmark.  It quantifies over all 16‑bit inputs, control flags, and intermediate flags, then builds the exact arithmetic‑logic behavior (sign/zero extensions, multiplications, shifts, muxes, and condition checks) with thousands of nested ite, extracts and concatenations, finally asserting that the output bit ob_0 must equal 1 only when a long constant pattern on the inputs (ib_0) and the allowed opcode ranges holds.  The formula is a pure SAT/SMT‑BV problem that tests whether the proposed rewrite rule (the “wrapped if” transformation) is semantically equivalent to the original hardware implementation for every possible input.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium1.smt2",
    "description": "This SMT‑LIB file is a PEak “hardware rewrite‑rule synthesis’’ benchmark that checks the functional equivalence of a candidate circuit rewrite against the original datapath.  A single quantified assertion builds a massive 420‑bit input vector from individual fields (LUT, muxes, ALU control, signed flags, constants, etc.), applies a long cascade of concatenations, zero/sign‑extensions, arithmetic (add, mul, shifts), and comparisons, and finally asserts that the produced output bits match a given constant pattern.  The problem is therefore a pure SAT instance over bit‑vectors with extremely deep terms (≈130 k depth) and thousands of ite/concat/extend operations, making it challenging for solvers despite the absence of alternating quantifiers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node677435.smt2",
    "description": "This benchmark encodes a safety verification condition for a simple vehicle‑intersection hybrid system (the “intersection‑example” from KeYmaera).  The formula, written in 32‑bit bit‑vector arithmetic, asserts the negation of an existentially quantified state (the variable ts3233uscore0) that would violate the prescribed bounds on positions, velocities (v1, v2), distances (A, B, V, ep) and the hybrid dynamics expressed with non‑linear operations such as multiplication and signed division.  It is a single‑quantifier, non‑linear BV verification problem with moderate term depth (≈20) and many arithmetic constraints, typical of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node4106.smt2",
    "description": "This benchmark encodes a safety‑verification condition extracted from the KeYmaera hybrid‑system prover (ETCS‑essentials, node 4106).  It asserts that **no** 32‑bit value `ts2uscore0` can satisfy a conjunction of range bounds and a large collection of non‑linear bit‑vector inequalities involving products, sums, and signed divisions (e.g., \\((b·v)^2 \\le b·(m−z)\\), quadratic terms in `A`, `t2uscore0dollarskuscore0`, and `ep`).  The problem therefore tests a solver’s ability to handle a single existential quantifier over a highly non‑linear BV formula with deep nesting (depth 16) and many multiplications/divisions, a typical challenge for industrial verification of hybrid‑system safety properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node24127.smt2",
    "description": "This benchmark encodes a safety verification condition for the “one‑lane intersection” example from the KeYmaera hybrid‑system verifier.  The formula asserts (via a single existentially quantified time variable) a conjunction of range constraints on 32‑bit quantities together with non‑linear bit‑vector arithmetic (e.g., A·ts, v²/B) and a division, and then checks the unsatisfiability of its negation.  Hence the problem is a non‑linear BV verification task with moderate variable count but deep term nesting (depth 23) and mixed multiplication/division, which makes it challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard1.smt2",
    "description": "This instance encodes a hardware‑level rewrite‑rule verification problem: a single quantified assertion (∀ over a large bundle of input, constant, and control signals) equates the bit‑vector result of an original instruction implementation with that of a candidate transformed implementation built from muxes, arithmetic units, sign/zero extensions and condition bits. The formula checks that the rewrite rule holds for every possible 256‑bit input word and associated control flags, essentially proving functional equivalence of two circuit realizations. The difficulty comes from the massive term depth (over 600 k) and the explosion of nested ite, extract, concat and extension operations rather than from quantifier alternations, making the instance a heavyweight industrial‑scale bit‑vector equivalence check.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532347.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection, translated from the KeYmaera proof “intersection‑example‑simple”.  It asserts that under a set of linear‑inequality bounds on positions, velocities (v1, v2), accelerations (A, B), a time‑parameter ts2519₀ and other state variables, the nonlinear dynamics (involving products and a division of 32‑bit bit‑vectors) can never violate the safety predicate; consequently the formula checks the unsatisfiability of the negated existential condition.  The problem features a single quantified block with many conjunctive constraints, non‑linear bit‑vector arithmetic, and a moderate term depth (≈20) but only 19 declared constants, making it a typical industrial hybrid‑systems verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385461.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems model of a road‑intersection, originally generated by KeYmaera and translated into 32‑bit bit‑vector arithmetic. It asks whether there exists a time instant `ts1798uscore0` satisfying a conjunction of signed inequalities that relate vehicle positions (`xI1`, `xI2`) to their initial coordinates, bounded velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`), including non‑linear terms such as products (`v1*v1`, `v2*v2`) and signed divisions. The formula is negated and asserted, so solving amounts to proving the original safety property; the difficulty stems from mixed signed comparisons, non‑linear arithmetic encoded as bit‑vectors, a moderate depth of nested terms (depth 19) and a single existential quantifier over the time variable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601999.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts the negation of an existential witness for a set of 32‑bit variables representing positions, velocities, and parameters (e.g., v₁, v₂, A, B, V, ep) subject to non‑negativity, bound, and kinematic constraints such as a stopping‑distance inequality \\(x_{I2}>x_2+v_2^2/(2B)\\).  The problem is therefore a non‑linear bit‑vector verification task with a single quantified block, several multiplications/divisions, and a moderate term depth (≈21), making it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252045.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera proof “intersection‑example‑simple”, modelling a hybrid‑system scenario of two vehicles at an intersection. The formula asserts (by negating an existential) that, under non‑negative bounds on velocities (v1, v2), positions (x1, x2), and parameters (A, B, V, ep), the reachable states cannot violate the safety predicate relating the vehicles’ positions (xI1, xI2) and a time variable ts; the encoding uses 32‑bit bit‑vectors with non‑linear operations (multiplication, division) to represent the real‑valued arithmetic. The instance features a single quantified block, nested arithmetic constraints, and a moderate term depth (21), making it a challenging bit‑vector encoding of a non‑linear hybrid‑system invariant.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365475.smt2",
    "description": "The instance encodes a verification condition generated by the KeYmaera hybrid‑system verifier for a simple traffic‑intersection safety scenario.  It asserts (negated inside an existential over a time‑step variable) that, under non‑negative bounds on positions, velocities (v1,v2), acceleration constants (A,B) and a positive safety horizon (ep), the continuous dynamics ‑‑ expressed with non‑linear bit‑vector arithmetic (multiplications, signed divisions and additions) –‑ keep the state variables xI1, xI2 within prescribed safety intervals; the outer “not‑exists” checks that no counterexample time exists, i.e., the VC is valid.  The formula features a single quantifier, many intertwined BV operations, and a term depth of 21, making it a challenging non‑linear arithmetic benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21762.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems model of a single‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  It asserts the negation of an existential search for a time ts₄₈ (and associated state variables) that simultaneously satisfies a collection of bound constraints (non‑negative positions, velocities, accelerations, and time limits) and a critical inequality involving a non‑linear term (v·v)/(2·B) that would violate a safety invariant (xI > x + …); the formula is therefore checking that no such counterexample exists.  The problem features a single quantified variable, many conjunctive BV constraints, and non‑linear arithmetic (multiplication and division) over 32‑bit bit‑vectors, giving a moderately deep term structure (depth 22) that challenges solvers on the industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391949.smt2",
    "description": "The benchmark encodes a safety verification condition extracted from the KeYmaera proof of a simple intersection scenario: given bounds on two velocities \\(v_1, v_2\\), parameters \\(A, B, V\\) and a positive time horizon \\(ep\\), it asserts that no choice of the auxiliary time variable \\(ts_{1833}\\) can violate a set of signed inequalities that involve quadratic terms \\(v_i^2\\) divided by a linear expression in \\(ts_{1833}\\).  Technically, the formula is the negation of an existential quantifier over a 32‑bit bit‑vector, containing non‑linear multiplication, signed division and many relational constraints, which makes it a non‑linear BV verification problem of moderate size but with a deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8745.smt2",
    "description": "This benchmark encodes a safety verification condition extracted from the KeYmaera hybrid‑system model “binary_driver” (node 8745). After translating the original real‑valued nonlinear arithmetic into 32‑bit bit‑vector arithmetic, the formula asserts that **no** 32‑bit value for the time variable ts₁ can violate a large conjunction of linear and quadratic constraints (non‑negativity, upper bounds, and a complex inequality involving products such as amax·ts₁, vuscore², duscore², etc.). Consequently the instance tests a non‑linear bit‑vector invariant, featuring deep term nesting (depth 23) and many multiplications/divisions, which makes it a difficult industrial verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node622752.smt2",
    "description": "The instance encodes a safety verification condition for the “intersection‑example‑simple” hybrid‑system benchmark from KeYmaera.  It asserts (by negating an existential) that there is no time instant `ts2980uscore0` for which a collection of nonlinear bit‑vector constraints—quadratic terms (`bvmul` of velocities), a division (`bvsdiv`), and numerous linear inequalities over positions, velocities, and safety margins (`V`, `ep`)—can be simultaneously satisfied.  The formula therefore checks a safety invariant (no collision) under bounded ranges for the variables, and its difficulty stems from the presence of non‑linear arithmetic, a single quantified variable, and relatively deep term nesting (depth 20) within the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5587.smt2",
    "description": "The benchmark encodes a verification condition for the classic hybrid “bouncing‑ball” example (height h, velocity v, time variables t₁, t₂, etc.) translated from real arithmetic to 32‑bit bit‑vectors. It asserts that, under the ball’s dynamics (including quadratic terms such as t₁·t₁ and ts₁·ts₁) and the safety constraints (height ≥ 0, velocity bounds, and a post‑bounce relation h = 0, v = 16), no reachable state violates the bound “–(10·t₁ + v)/2 ≤ 16”. The formula is a single quantified (∃ ts₁) negated VC, featuring non‑linear multiplications, a handful of bit‑vector inequalities, and a quantifier, making it a challenging industrial verification instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672522.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts that, under non‑negative speed and acceleration bounds (`v1`, `v2`, `A`, `B`, `V`) and with the kinematic relation \\(x_{\\text{new}} > x + v^{2}/(2a)\\) expressed via bit‑vector multiplication and division, there is **no** assignment to the time variable `ts3205_0` (and the auxiliary variable `t3205_0`) that violates the safety inequality while respecting all interval constraints (upper bound `V`, positive epsilon `ep`, etc.).  The problem is thus a quantified bit‑vector verification task with non‑linear arithmetic (quadratic terms and division) and several linear ordering constraints, making it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550504.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, via a single quantified formula, that no time \\(ts\\) exists for which the vehicle states (positions \\(x_1,x_2\\), velocities \\(v_1,v_2\\), parameters \\(A,B,V,\\) …) violate a set of linear and non‑linear bit‑vector constraints—including a quadratic term \\(v_2·v_2\\) and a division by \\(2·B\\)—while respecting bounds on all variables.  The instance therefore tests a non‑linear BV verification problem with one existential quantifier, a moderate number of variables (19), and relatively deep terms (depth ≈ 20), making quantifier handling and non‑linear arithmetic the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5981.smt2",
    "description": "This benchmark encodes a verification condition for the simple “bouncing‑ball” hybrid system, translated from real‑valued nonlinear arithmetic into 32‑bit bit‑vector form. It asserts that, under the given initial height h = 0 and velocity v = 16, the quadratic relations linking height, velocity and time (e.g., h = 5·t² + v·t) together with a series of linear bounds on the variables never admit a counter‑example – expressed as a negated ∃‑quantifier over the time variable‑ts1. The formula therefore tests a universally quantified safety invariant using non‑linear BV multiplication, a moderate number of variables (7) and a relatively deep term structure (depth 18), which makes it a challenging instance for solvers handling quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351731.smt2",
    "description": "The benchmark encodes a safety‑verification condition for the “simple intersection” hybrid‑system example from KeYmaera.  It asks whether there exists a 32‑bit time value `ts1638_0` that can satisfy a conjunction of non‑linear bit‑vector constraints (squared velocities, products of acceleration parameters A, B with time, and signed divisions) together with a collection of bounds on positions, velocities and a deadline `ep`.  The formula is a negated existential, so the solver must prove unsatisfiability; the presence of multiplication, division, and a single quantified variable makes the instance a non‑linear BV verification problem of moderate size (19 constants, depth 20) that is known to be challenging for current solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node44538.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a one‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  The formula asserts the negation of an existential witness `ts99uscore0` that would violate a set of arithmetic constraints describing positions, velocities, accelerations and timing bounds (e.g., `0 ≤ ts ≤ t183`, `0 ≤ v ≤ V`, `B>0`, quadratic displacement `v·v/(2·B)`, etc.).  Thus the solver must prove that no such time exists; the problem features a single existential quantifier, deep (depth 24) nested BV arithmetic with non‑linear multiplications and divisions, which makes it a challenging bit‑vector verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172099.smt2",
    "description": "This SMT‑BV instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  It asserts that no 32‑bit time value `ts798` can satisfy a conjunction of arithmetic constraints linking positions (`x1`, `x2`), velocities (`v1`, `v2`), accelerations (`A`, `B`), and a deadline `ep`, together with bounds such as `0 ≤ v1, v2 ≤ V` and derived expressions like `xI1 = x1 + v1²/(2·B)`.  The formula is a single existential‐quantified check (negated) that involves several non‑linear bit‑vector operations (multiplication, division) and a moderate term depth (≈20), typical of industrial verification problems after translating real‑valued hybrid‑system VCs into fixed‑width bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488227.smt2",
    "description": "The instance encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera). It asserts, via a single existentially‑quantified time variable, that no reachable state can violate a collection of signed‑inequality bounds on positions, velocities (v1, v2), accelerations (A, B) and a global bound V, where the constraints involve non‑linear bit‑vector arithmetic (e.g., A·t, v1²/(2·B)). The problem is a quantified BV formula with 19 32‑bit variables, deep terms (depth 22) and a mixture of additions, multiplications and divisions, making it a moderately hard industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node32497.smt2",
    "description": "The benchmark encodes a safety‑verification condition for the “one‑lane intersection” hybrid‑system example taken from the KeYmaera proof suite.  It asks whether there exists a time instant `ts71uscore0` (and corresponding auxiliary variables) satisfying a collection of linear and non‑linear bit‑vector constraints (multiplications, a division, and many ≤/≥ comparisons) that would violate the required inequality between the vehicle’s current position `xI` and the predicted position based on its velocity `v`, the lane length `B`, and other parameters; the outer negation makes the whole query unsatisfiable exactly when the safety property holds.  The instance therefore tests a non‑linear arithmetic verification problem with a single existential quantifier and moderate term depth, which is known to be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267466.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera). It asserts the negation of an existential witness ts1242₀ that would violate a collection of linear and non‑linear (multiplication, division) 32‑bit bit‑vector constraints describing bounds on velocities, positions, and parameters (A, B, V, ep) together with interval and ordering requirements; thus the solver must prove the formula unsatisfiable to confirm safety. The instance features a single existential quantifier, several nested arithmetic expressions (max term depth 20), and 18 bit‑vector variables, making it a modest‑size but non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node248047.smt2",
    "description": "The benchmark is a safety‑verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 248047).  After a top‑level negated existential, it asserts that for every 32‑bit time value ts₁₂₅₂ the vehicle parameters (positions xI1, xI2, velocities v1, v2, constants A, B, V, ep) satisfy a set of signed‑comparison constraints that capture non‑negative speeds, bounded accelerations (including a non‑linear term v₂·v₂/(2·B)) and a distance‑safety inequality; the formula also encodes bounds on the time horizon and a branching case on a discrete choice.  The instance therefore encodes a non‑linear arithmetic verification problem over bit‑vectors, with one quantified variable, deep nesting (term depth 20) and mixed multiplication/division, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node38802.smt2",
    "description": "The file encodes a verification condition for the “safe‑intersection” hybrid‑system benchmark taken from the KeYmaera proof of an one‑lane traffic crossing.  It asserts the negation of an existential witness (a time `ts86uscore2`) that would violate a safety inequality relating the positions (`xI`, `x`, `xuscore4dollarskuscore29`), velocities (`v`, `vuscore4dollarskuscore34`), and parameters (`A`, `B`, `V`, `ep`) of the vehicles; the condition is expressed as a large conjunction of non‑linear 32‑bit bit‑vector arithmetic (multiplications, squares, divisions) and finally an “or” of two bounds on `xI`.  Consequently the problem is a single‑quantifier, non‑linear bit‑vector verification task with deep terms (depth 24) and many nested arithmetic constraints, making it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node253609.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example”) originally generated by KeYmaera.  The formula (negated existential) asserts that, assuming non‑negative bounded velocities (v1,v2), positions, and parameters (A,B,V,ep), and the kinematic relation xI2 > x2 + v2²⁄(2·B), no time ts1179 exists that would violate the safety invariant (e.g., a collision) while respecting all linear and non‑linear (quadratic multiplication/division) constraints.  The instance is a bit‑vector (32‑bit) encoding of non‑linear arithmetic with a single quantifier, moderate term depth (21) and 20 variables, making it representative of industrial‑scale hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node6814.smt2",
    "description": "This benchmark encodes a safety verification condition for the “one‑lane intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. The formula asserts (by negating an existential) that no value of the time variable ts13₀ can satisfy a conjunction of bounds on positions, velocities, accelerations (A·ts13₀ + v₍₂₀₎), and timing constants (ep, V, etc.), thereby proving a safety invariant for the system. The instance contains a single existential quantifier, non‑linear BV multiplication, and deep nested constraints, making it a moderate‑size industrial verification problem that is challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99986.smt2",
    "description": "This instance encodes a verification condition for a hybrid‑systems safety proof (the “safe intersection” example from KeYmaera) after translation into 32‑bit bit‑vectors.  The goal is to decide the satisfiability of the negated VC: it asserts the existence of a time‑step variable `ts467uscore0` such that, under a collection of pre‑conditions (non‑negative parameters A, B, V, ep; bounds 0 ≤ v₁,v₂ ≤ V; indices I1 = I2 = 2; ordering constraints on the state variables xI1 < x1, xI2 < x2, etc.), the computed positions  \n`?v_0 = v1uscore1dollarskuscore453 + (‑B)·ts467uscore0` and  \n`?v_1 = v2uscore1dollarskuscore453 + A·ts467uscore0`  \nboth stay within the interval [0,V] and the elapsed time stays below ep, while also respecting a case split on a flag `I1uscore1dollarskuscore453`.  \n\nThe formula contains a single existential quantifier, nonlinear bit‑vector multiplications, and a moderate depth of nested arithmetic (max term depth 18) with 19 declared constants, making it a typical industrial‑style bounded verification problem that challenges nonlinear BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271799.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems “intersection” model taken from the KeYmaera proof suite.  It asserts, in 32‑bit bit‑vector arithmetic, that no value of the time variable ts can satisfy a conjunction of equalities and linear/non‑linear inequalities (including products A·ts, ‑B·ts and a quadratic term v₂·v₂/(2·B)) together with the system’s domain constraints (positivity of parameters, ordering of positions, and a bound V).  The problem is thus a quantified (∃ ts) safety‑property check that features non‑linear multiplications and a division, a relatively deep term structure (depth 19) and a single quantifier, making it a challenging BV‑non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node618750.smt2",
    "description": "The file encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the KeYmaera “intersection‑example‑simple” proof).  It asserts, using 32‑bit bit‑vector arithmetic, that no choice of the time variable ts can satisfy a collection of non‑linear kinematic constraints (quadratic terms, multiplication by parameters A, B, and division) together with bounds on velocities v1, v2, positions x1, x2, and a positive time horizon ep; the outer‑most `(not (exists …))` therefore checks the unsatisfiability of a potential safety‑violation.  The presence of a single existential quantifier, deep non‑linear terms, and many inequality conjuncts makes the benchmark a challenging BV‑non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1377.smt2",
    "description": "This benchmark encodes a single verification condition from the KeYmaera hybrid‑systems prover, translated into 32‑bit bit‑vector arithmetic. It asserts that, under a set of linear and quadratic constraints on parameters (A, B, ep, v₁, vsl, xsl, t₇) and a bounded time variable ts₀, a particular inequality (involving products, a division by 2, and a squared term) must hold; the outermost “not‑exists” forces the solver to prove the implication universally. Thus the instance is a non‑linear arithmetic safety check with one existential quantifier, moderate term depth (17) and a mixture of multiplication, division and addition that makes the bit‑vector reasoning challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268443.smt2",
    "description": "The benchmark encodes a KeYmaera verification condition for the “safe‑intersection” hybrid‑system example: it asserts (by negating an existential over a time stamp `ts1247_0`) that a set of safety constraints—non‑negative bounds on position, velocity and parameters (`A`, `B`, `V`), a quadratic term `v2*v2/(2*B)` arising from a braking distance, and relational conditions such as `xI1 < x1` and `xI2 > x2 + …`—cannot be violated. The problem is a non‑linear arithmetic proof translated into 32‑bit bit‑vector arithmetic, featuring multiplication, division and several nested inequalities, with one quantifier and a moderate term‑depth (21), which makes it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node737898.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It states, in 32‑bit bit‑vector arithmetic, that under a set of bounds on positions (x1, x2), velocities (v1, v2), constants (A, B, V, ep) and the dynamics defined by non‑linear expressions (e.g. bvmul v1 v1, bvsdiv …), no reachable state exists that violates the safety predicate (expressed as the negated existential over the time variable ts3610uscore0).  The formula features a single quantifier, deep nested conjunctive constraints, and non‑linear BV operations, making it a challenging BV‑encoded non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3459.smt2",
    "description": "This benchmark encodes a verification condition taken from the KeYmaera hybrid‑system proof of an adaptive cruise‑control model.  It asserts that, given positive 32‑bit parameters A, B, ε and non‑negative states v₁, v₂, x₁, x₂, the arithmetic constraints  \n\n\\[\n0\\le t_s\\le t_1,\\quad  \nA\\cdot t_s+v_1\\ge0,\\quad  \nv_1+ A\\cdot\\varepsilon\\le v_2,\\quad  \nv_1\\le v_2,\\quad  \nx_1<x_2,\\quad  \nx_1^{\\prime}<x_2^{\\prime},\n\\]\n\n(and similar bounds on t₁) cannot be violated for any existentially‑quantified time t_s.  The formula is a single quantified conjunctive clause over 12 bit‑vector constants, featuring non‑linear (bit‑vector) multiplication and a moderate term depth (≈20), which makes it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node621704.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, under a set of linear bounds on the 32‑bit variables (e.g., 0 ≤ v₁,v₂ ≤ V, A,B,V,ep > 0) and non‑linear relationships such as xI₁ > x₁ + v₁² / (2·B) and xI₂ > x₂ + v₂² / (2·B), there is no choice of the time variable ts1688₀ that falsifies the safety property; this is expressed as the negation of an existential quantifier.  The formula contains a single quantified block, non‑linear multiplication and division on bit‑vectors, and a relatively deep term structure (depth 20), making it a challenging instance for BV solvers that must handle quantified non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270992.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, under a multitude of numerical assumptions about vehicle positions (x₁, x₂), velocities (v₁, v₂), acceleration A, braking distance B, speed limit V, and a small time‑step ep, no witness ts can violate the invariant that the velocities stay within [0,V] and the positional relation xI₁ < x₁, xI₂ > x₂ + v₂²/(2·B) holds; the formula is written as ¬∃ts …, i.e., a universal safety property.  The instance therefore tests non‑linear bit‑vector reasoning (multiplication, division) under quantifier alternation and relatively deep term nesting, making it a challenging industrial verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node529901.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a road intersection: it asserts that no 32‑bit time value ts can satisfy a conjunction of signed‑comparison constraints on vehicle positions, velocities (v1, v2), accelerations (A, B), and timing parameters (ep, V), together with a non‑linear relation v1·v1/(2·B) that appears in a braking‑distance inequality. Consequently the solver must show the unsatisfiability of an existentially‑quantified formula that mixes linear and non‑linear bit‑vector arithmetic, several signed inequalities, and a modest quantifier depth, making it a challenging BV‑based verification problem from the KeYmaera benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node54865.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from Keymaera).  It asserts the negation of an existential counter‑example: given non‑negative parameters A, B, V, ep and initial states (e.g., xI1 < x1, xI2 < x2, I1 = I2 = 2), any time step ts between 0 and a horizon t must keep the linearly‑updated positions ?v₀ = –B·ts+v1  and ?v₁ = A·ts+v2  within the interval [0,V] and the elapsed time ts below ep.  The formula is a single quantified (∃ ts) bit‑vector condition with non‑linear multiplications, several linear inequalities, and a modest depth of nesting, making it a typical non‑linear arithmetic verification problem translated into BV.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674647.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “Safe intersections”.  It asserts (by negating an existential) that for all admissible time‑step values ts3216₀, given non‑negative parameters A, B, V, v₁, v₂ and a positive bound ep, the derived position bounds   xI₁ > x₁ + (v₁²)/(2·B) and   xI₂ > x₂ + (v₂²)/(2·B)  hold together with several range constraints (e.g., 0 ≤ vᵢ ≤ V, 0 ≤ A, 0 < B, 0 < ep).  The formula is a 32‑bit bit‑vector encoding that mixes non‑linear multiplication, signed division, and a single existential quantifier, leading to a deep (≈20) term structure and making the problem challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node703624.smt2",
    "description": "This benchmark is a verification condition generated from the KeYmaera proof of a simple traffic‑intersection hybrid‑system model: it checks that, given non‑negative speeds (v1, v2) bounded by a safety limit V, non‑negative parameters A, B and a positive time horizon ep, no choice of the continuous‑time variable ts can make the safety inequality on vehicle positions (involving non‑linear terms A·ts, v²/(2·B) and a safety margin V) false. The assertion is the negation of an existential quantifier, so the solver must prove that the quantified bit‑vector formula with 32‑bit multiplications, a signed division and several order constraints is unsatisfiable. Consequently the instance tests BV‑non‑linear arithmetic and quantifier reasoning in an industrial‑style safety‑verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388424.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “KeYmaera” example).  It asserts that there is **no** choice of the time‑step variable `ts1812uscore0` for which a set of nonlinear bit‑vector constraints—capturing non‑negative speeds (`v1`, `v2`), bounded accelerations (`A`, `B`), position updates involving quadratic terms (`bvmul v1 v1`, `bvmul v2 v2`) and timing bounds (`ep`, `V`)—violates the required ordering of vehicle positions (`xI1`, `xI2`) and other safety predicates.  The problem is a single‑existential quantifier check over 19 32‑bit bit‑vectors with non‑linear multiplication and division, giving a moderate‑size, deep (depth 21) formula that challenges BV solvers on arithmetic reasoning rather than on quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532026.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the KeYmaera “intersection‑example‑simple”). It asserts that there is **no** choice of a time variable `ts2517uscore0` that can satisfy a collection of nonlinear 32‑bit bit‑vector constraints involving vehicle speeds (`v1`, `v2`), braking distance (`B`), position variables (`x1`, `x2`, `xI1`, `xI2`), and timing bounds (`ep`, `t2517uscore0`). The formula contains a single existential quantifier, several nested implications and arithmetic over multiplications such as `v1*v1` and `B*ts2517uscore0`, making the problem a non‑linear BV verification task with moderate variable count (19) but relatively deep term nesting (depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603757.smt2",
    "description": "The file encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (the “intersection‑example” from KeYmaera).  All relevant quantities (positions, velocities, time bounds, constants A, B, V, ep) are represented as 32‑bit bit‑vectors and are constrained to lie in non‑negative intervals; the core property asserts that no existential choice of a time ts can satisfy a set of non‑linear arithmetic relations (involving multiplication, a division, and several inequalities) that would lead to an unsafe state.  The benchmark therefore tests bit‑vector solvers on a single‑exists quantifier with deep, non‑linear terms and many bound checks, a typical industrial hybrid‑system verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384248.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑system prover: it checks that, under a set of linear bounds on variables (e.g., non‑negative speeds v1, v2, limits V, positive parameters A, B, ep) and nonlinear relationships involving squared speeds ( bvmul v₁ v₁, bvmul v₂ v₂ ) divided by 2·B, the positions xI1, xI2 remain ahead of the initial positions x1, x2 for all time steps ts1792₀.  The formula is expressed as the negation of an existential quantifier over the time variable, so the solver must prove unsatisfiability to confirm the safety invariant.  It features 32‑bit bit‑vector arithmetic with non‑linear multiplication and signed division, a moderate number of variables (18) but a deep term structure (depth 21) and several nested conjuncts, making it a challenging industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node676430.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple traffic‑intersection scenario.  The formula asserts (by negating an existential) that there is **no** 32‑bit time value `ts3229uscore0` for which the vehicle speeds `v1`, `v2` (bounded between 0 and a maximum `V`), the non‑negative parameters `A`, `B`, and the derived positions `xI1`, `xI2` violate a set of safety inequalities (e.g., `xI1 > x1 + v1²/(2·B·ts)` etc.) while also respecting auxiliary bounds on auxiliary variables and the event‑time `ep`.  The instance features a single quantified variable, several nonlinear bit‑vector operations (multiplication, division) together with many signed comparisons, giving a moderate term depth (21) and a typical industrial‑level difficulty for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3457.smt2",
    "description": "This benchmark encodes a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover (the “dccs‑example‑simple” adaptive‑cruise‑control model).  It asserts, via a single existentially‑quantified 32‑bit time variable `ts1uscore0`, a conjunction of linear and non‑linear bit‑vector inequalities over velocities (`v1`, `v2`), positions (`x1`, `x2`), parameters (`A`, `B`, `eps`) and timestamps, and then negates the whole existential formula so that the solver must prove that no such time can violate the safety bounds.  The problem features non‑linear multiplication (`A*ts1uscore0`, `A*t1uscore0dollarskuscore0`) together with many signed comparisons, a moderate number of variables (12) but a relatively deep term structure (depth 20), making it a challenging industrial BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1722.smt2",
    "description": "The benchmark encodes a verification condition extracted from a KeYmaera proof (node 1722 of the *vsl* example).  It asserts the negation of an existential statement over a 32‑bit time variable `ts1uscore0`, requiring that a conjunction of linear and non‑linear bit‑vector inequalities (including products, squares and divisions of the variables `A`, `B`, `ep`, `v1…`, `vsl…`, etc.) can never be satisfied.  Consequently the solver must prove that no assignment to the quantified variable fulfills all the bounds, making the problem a non‑linear BV safety‑property check with a moderate term depth (≈18) and a single quantified block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709146.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑systems model of a traffic intersection (the KeYmaera “intersection‑example”).  It asserts, via a negated existential over a time variable `ts3425uscore0`, that no assignment to the system’s parameters (positions `x1,x2`, velocities `v1,v2`, accelerations `A,B`, bounds `V`, etc.) can violate a set of linear and non‑linear bit‑vector constraints—e.g., the classic kinematic inequality `xI2 > x2 + v2*v2/(2*B)` together with bounds on speeds and times.  The problem is thus a bounded‑model‑checking/verification query with one quantifier, mixed linear and multiplicative/division constraints, and moderate term depth, making it a non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291962.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, under non‑negative bounds on acceleration A, braking B, speed limit V and positive parameters ep, the positions x₁, x₂ and velocities v₁, v₂ of two vehicles satisfy the invariant **x₂ > x₁** and the braking‑distance safety rule x₂ > x₁ + v₂²/(2·B) for every admissible time step ts (encoded by a negated existential quantifier).  The formula uses 32‑bit bit‑vector arithmetic with non‑linear multiplication and division, several nested let‑bindings and a depth of 20, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631857.smt2",
    "description": "The instance encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts, via a quantified formula, that there is **no** choice of the auxiliary time variable `ts3020uscore0` that can satisfy a collection of non‑linear bit‑vector constraints describing bounds on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), parameters (`A`, `B`), and a deadline `ep`.  The constraints involve quadratic terms (`v1*v1`, `v2*v2`) divided by a linear expression, together with a hierarchy of strict and non‑strict inequalities, and the whole formula is the negation of an existential, i.e., a proof‑obligation for the VC.  The problem is a non‑linear arithmetic verification task over 32‑bit bit‑vectors, with moderate term depth (21) and a single quantifier, which makes it challenging for SAT/SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292166.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a traffic intersection (the KeYmaera “intersection‑example‑simple” proof).  It asserts that no valuation of a time‑step variable (`ts1363uscore0`) can satisfy a collection of arithmetic constraints on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), accelerations (`A`), and bounds (`V`, `ep`), where the constraints involve non‑linear 32‑bit bit‑vector operations such as multiplication, division and signed comparisons.  The problem is a single‑quantifier (∃) check over a fairly deep term structure (max depth 20) with many non‑linear bit‑vector terms, making it a challenging instance for solvers that handle BV arithmetic and quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369871.smt2",
    "description": "This instance encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example‑simple” from KeYmaera).  It asserts, via a single existentially‑quantified time variable, that the vehicle positions x₁, x₂ and velocities v₁, v₂ respect a set of non‑linear arithmetic bounds (e.g. x > x₁ + v₁²/(2·B), x > x₂ + v₂²/(2·B), and upper/lower limits A, B, V, ep) and that no violating time exists; the whole formula is negated so the solver must prove unsatisfiability.  The problem is a bit‑vector encoding of non‑linear hybrid‑system verification with deep (≈19) term nesting and a single quantified block, making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54870.smt2",
    "description": "The benchmark encodes a safety verification condition for the “one‑lane intersection” hybrid‑system example from KeYmaera: a conjunction of bounds, non‑negativity, and quadratic inequalities over 32‑bit bit‑vector variables (positions, velocities, parameters) is asserted to be impossible for any choice of the time variable ts102uscore2 (the outer ¬∃ turns the property into a universal safety claim). The formula contains a single existential quantifier but many non‑linear multiplications (including products of variables with themselves) and nested arithmetic expressions (term depth 24), making it a challenging BV instance that tests solvers’ ability to handle nonlinear arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195048.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a vehicle intersection (the “intersection‑example” from KeYmaera).  After translating the real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts the negation of an existential witness for a time `ts909uscore0` that would violate the safety invariant: it combines non‑linear constraints (multiplication, division) on positions, velocities `v1`, `v2`, accelerations `A`, `B`, and bounds `V`, together with range restrictions (all variables non‑negative and ≤ `V`).  Proving unsatisfiability of this single quantified assertion shows that no unsafe state is reachable; the problem is difficult because it mixes bit‑vector non‑linear arithmetic with a quantifier and relatively deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node1479.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑onelane”, translated into 32‑bit bit‑vector arithmetic. It asserts—via a single existentially‑quantified time variable—that a conjunction of non‑negative, bounded linear relationships (e.g., 0 ≤ ts₀ ≤ t₁, 0 ≤ v ≤ V, A·ts₀ + v₀ ≤ V) together with a mode‑switch clause cannot be satisfied, i.e., that the implication holds for all admissible values. The instance features non‑linear BV terms (products of two unknowns) and a modest quantifier depth, making it a representative industrial verification problem for bit‑vector non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node386295.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a simple road‑intersection scenario (the “intersection‑example” from the KeYmaera hybrid‑system verifier).  It asserts that, for all admissible values of the velocities v₁, v₂, positions x₁, x₂ and braking parameters A, B, the post‑braking positions (computed with the non‑linear kinematic formula x + v²/(2·B)) remain separated by at least a positive safety margin ep; all variables are constrained to be non‑negative and bounded by a common upper bound V.  The property is expressed as the negation of an existential witness for a time‑stamp ts, resulting in a single quantified formula over 32‑bit bit‑vectors that involves multiplication, division and several linear inequalities, making it a non‑linear BV verification problem of moderate size (≈20‑term depth, 19 variables).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369234.smt2",
    "description": "This benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  The formula asserts that, for all admissible time steps `ts1723uscore0` and under bounds on velocities (`v1`, `v2` ≤ V), positions (`xI1`, `xI2`) and parameters (`A`, `B`, `ep`), the nonlinear constraints derived from the continuous dynamics (quadratic terms `v*v`, products with `A` and `B`, and integer division) never violate the required safety inequalities; the outer `not (exists …)` forces the solver to prove the condition unsatisfiable.  The instance is challenging because it mixes several 32‑bit bit‑vector multiplications and divisions, a nested existential quantifier, and deep term nesting (depth 19) with many relational constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node475811.smt2",
    "description": "The benchmark encodes a KeYmaera safety‑verification condition for a simple traffic‑intersection hybrid system.  It asserts, via a negated existential over a time variable ts, that under the given bounds on velocities (v1, v2), parameters (A, B, V, ep) and initial state relations (e.g., xI1 > x1 + v1²/(2·B), xI2 < x2), no reachable state violating the safety invariant can occur within the time horizon ep.  The problem is a purely bit‑vector formulation of non‑linear arithmetic (quadratic multiplication, division, and mixed constraints) with a single existential quantifier and moderate term depth, typical of industrial hybrid‑system verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39725.smt2",
    "description": "This instance encodes a safety verification condition for the “one‑lane intersection” hybrid system used in the KeYmaera benchmark suite.  It asserts (negated) that there exists a time instant ts₈₈ satisfying a large conjunction of bit‑vector arithmetic constraints—including non‑linear multiplications, divisions and a chain of inequalities on positions, velocities, and parameters (A, B, V, ep, etc.)—that would violate the safety invariant (e.g., a vehicle overtaking the lane‑boundary).  The problem is a single‑existential BV formula with deep term nesting (depth 24) and many non‑linear operations, making it a challenging industrial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287144.smt2",
    "description": "The instance encodes a safety verification condition for the “safe‑intersection’’ hybrid‑system example from KeYmaera.  All real‑valued parameters (positions, velocities, constants A, B, V, ep, etc.) have been bit‑vector‑translated (32‑bit) and are constrained by a large conjunction of linear and non‑linear inequalities (including multiplications and a division).  The asserted formula is the negation of an existential witness for a time stamp ts₁₃₃₇; proving unsatisfiability therefore shows that, under the given non‑negative preconditions, no reachable state violates the safety invariant.  The problem features a single quantified block, non‑linear BV arithmetic, and a moderate term depth (21) with 18 declared constants, making it a typical industrial verification benchmark derived from hybrid‑system reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345166.smt2",
    "description": "The instance is a safety‑verification condition for a hybrid‑system model of a road‑intersection, translated from KeYmaera’s real‑arithmetic proof into 32‑bit bit‑vector arithmetic.  It asserts that, under non‑negative speed bounds ( v₁,v₂ ≤ V ), positive parameters ( A,B, V, ep ), and braking‑distance constraints  \n\\(x_{I1}>x_{1}+v_{1}^{2}/(2B)\\) and \\(x_{I2}>x_{2}+v_{2}^{2}/(2B)\\), there exists no time‑step ts₀ (∈[0,t₀]) that violates the global safety bound (the combined positions stay ≤ V and the elapsed time stays ≤ ep).  The formula is a single‑existential‑quantifier check containing non‑linear multiplications and signed divisions, making it a non‑linear bit‑vector verification task typical of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node350275.smt2",
    "description": "The instance encodes a verification condition for a hybrid‑system safety proof (the “intersection‑example‑simple” from KeYmaera).  It asserts that, for non‑negative parameters A, B, V, ep and initial velocities v1, v2 bounded by V, the braking‑distance formulas  \n\n\\[\nxI1 > x1 + \\frac{v1^2}{2B},\\qquad\nxI2 > x2 + \\frac{v2^2}{2B},\n\\]\n\nand the acceleration update  \n\n\\[\n?v_1 = A\\cdot ts + v2_{240}\n\\]\n\ncannot be violated for any non‑negative time ts, i.e. no reachable state violates the safety bounds.  The check is formulated as a single quantified bit‑vector formula with non‑linear multiplication/division, a depth‑21 term structure and one existential quantifier, making it a non‑linear BV verification problem that is representative of industrial hybrid‑system proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560330.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, after negating an existential over a time variable `ts2669uscore0`, a conjunction of signed 32‑bit bit‑vector constraints that relate positions, velocities, accelerations and timing (including non‑linear products such as `A·ts` and a division by `2·B`).  The solver must show that no assignment satisfying all these linear and non‑linear inequalities (with several signed comparisons, a multiplication, and a division) exists; the presence of a single quantified variable, mixed arithmetic, and a term depth of 22 makes the instance a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272548.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system case study “intersection‑example‑simple”. It asserts that there is **no** 32‑bit time value `ts1272uscore0` that can satisfy a conjunction of bounds on velocities (`v1`, `v2`), parameters (`A`, `B`, `V`, `ep`) and positions (`x1`, `x2`, `xI1`, `xI2`), where the constraints involve both linear relations and non‑linear operations (multiplication, division) such as `v2*v2/(2*B)`. The problem is thus a single‑exists, non‑linear QF_BV check with 18 variables, moderate term depth (19) and a mix of arithmetic and ordering constraints, typical of industrial hybrid‑system verification instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5586.smt2",
    "description": "The benchmark encodes a verification condition for the “bouncing‑ball‑simple’’ hybrid‑system model from KeYmaera: it asserts that, given an initial height h = 0 and velocity v = 16, and with the dynamics h′ = v, v′ = –5·t² + u·t, no intermediate time ts₁ (0 ≤ ts₁ ≤ t₁) can make the height negative while all the auxiliary variables (u, h, t) satisfy the non‑linear polynomial relations (e.g., h = 5·t² + u·t, u ≤ –10·t + 16, t ≤ 16/5). The formula is a single negated existential over a 32‑bit bit‑vector variable, but its body contains many non‑linear multiplications, nested arithmetic, and a depth‑20 term structure, making it a challenging BV instance derived from non‑linear arithmetic verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561763.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑system prover for a simple traffic‑intersection scenario. It asserts that, under a set of signed 32‑bit bounds on variables (e.g., positions x₁,x₂, velocities v₁,v₂, parameters A,B) and a hybrid‑dynamics relation that involves non‑linear bit‑vector arithmetic (multiplication, division and a quadratic term v₂·v₂), there is no time‑step ts₍₂₆₇₈₎₀ that can satisfy the antecedent while violating the post‑condition; the outer “not ∃” expresses the required safety property. The problem features a single existential quantifier, a let‑binding, and moderate depth (≈20) with 19 declared bit‑vectors, making it a non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/rbc-controllability-characterisation-node3299.smt2",
    "description": "The benchmark encodes a verification condition from the KeYmaera proof of the European Train Control System “rbc‑controllability‑characterisation”.  It asks whether, for all 32‑bit values of the quantified variables zuscore2 and vuscore2, the antecedent A (a conjunction of non‑negative‑range constraints that includes non‑linear terms such as (vuscore2·vuscore2 − d·d) ≤ 2·b·(m − zuscore2) and d ≥ 0, b > 0) can ever hold while the consequent B (duscore1dollarskuscore2 ≥ 0) fails.  The instance is a quantified bit‑vector problem with a handful of variables but nonlinear multiplications, making it a small‑scale yet non‑linear arithmetic verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node717892.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts that there is **no** 32‑bit time value `ts3478uscore0` that can satisfy a collection of non‑linear bit‑vector constraints describing bounded velocities (`v1`, `v2`), positions (`x1`, `x2`), and parameters (`A`, `B`, `V`, `ep`) together with linear‑plus‑multiplicative relations (e.g., `bvmul A ts3478uscore0`, `bvsdiv (bvmul v2 v2) (bvmul 2 B)`) and ordering conditions (`bvslt`, `bvsle`, `bvsge`).  The instance therefore tests a BV solver’s ability to handle a single existential quantifier, deep (depth 21) non‑linear arithmetic expressions, and numerous simultaneous range/inequality constraints typical of hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5607.smt2",
    "description": "This instance is a verification condition from the KeYmaera hybrid‑system prover, encoding the safety of a single‑lane traffic‑intersection scenario.  It asserts (by negating an existential) that for all admissible time ts (bounded between 0 and t₁) the polynomial‑style constraints on positions (x, xI), velocities (v, V), and parameters (A, B, ep) – expressed with 32‑bit bit‑vector arithmetic (addition, multiplication, division and quadratic terms) – are never violated, i.e. no unsafe state exists.  The problem features a single quantified variable, many non‑linear BV operations (≈ 15 multiplications, quadratic expressions, depth 23), and thus tests solvers on quantified, non‑linear bit‑vector reasoning typical of industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369550.smt2",
    "description": "The instance encodes a safety‑verification condition for a simple hybrid‑system model of two intersecting traffic streams (the “intersection‑example” from KeYmaera).  It asserts that **no** value of the time‑step variable `ts1725uscore0` can satisfy a conjunction of non‑linear bit‑vector constraints that capture the dynamics (quadratic terms `v1·v1`, `v2·v2`), bounds on positions `xI1`, `xI2`, velocities `v1`, `v2`, and system parameters (`A`, `B`, `V`, `ep`).  The formula contains a single existential quantifier, deep (depth 19) non‑linear arithmetic, and numerous signed‑inequality constraints, making it a moderately hard industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174126.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple vehicle‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts that, assuming non‑negative bounds on velocities (v1,v2), a positive acceleration B, and given position updates that involve the quadratic term v1·v1/(2·B), no reachable state can violate the safety inequality (formalised as a negated existential over a time variable ts810₀).  Thus the solver must prove the unsatisfiability of a single‑quantifier, non‑linear bit‑vector formula containing multiplication, division and several linear bounds, a typical non‑linear arithmetic verification problem translated to 32‑bit BV.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node74776.smt2",
    "description": "The file encodes a safety‑verification condition extracted from the KeYmaera hybrid‑systems prover for a simple intersection scenario: it asserts that, under non‑negative bounds on parameters (A, B, V, ep) and initial states (x₁, x₂, v₁, v₂) with the indices I₁ = I₂ = 2, there is **no** choice of a time variable ts₃₄₃₀ that simultaneously satisfies the linear reachability constraints (affine updates using A·ts and –B·ts) and the deadline ep. The SMT‑LIB query is a single quantified bit‑vector formula containing only one existential quantifier, a moderate term depth (18) and a mixture of linear and a few non‑linear (multiplication) BV operations, which makes it a typical industrial verification instance rather than a large‑scale combinatorial search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node18278.smt2",
    "description": "This benchmark encodes a verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts that, for all admissible (non‑negative, bounded) values of positions, velocities, and acceleration parameters (A, B, V, ep, etc.), there exists a time instant ts40₀ at which the vehicle’s longitudinal position xI satisfies a complex non‑linear inequality guaranteeing that it stays ahead of a calculated safety bound; the formula also enforces invariants such as non‑negative speeds and upper limits on the score variable. The instance features a single existential quantifier, deep nested arithmetic (multiplication, division, addition) and many inequality constraints, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348711.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system model of a vehicle intersection (the “intersection‑example‑simple” proof node).  It asserts that, under a set of non‑negative bounds on the parameters A, B, V, v₁, v₂ and a positive horizon ep, the reachable states xI₁, xI₂ satisfy the distance‑over‑time inequalities  \n\\(xI₁ > x₁ + \\frac{v₁²}{2·(A·ts₀ + v₁_{233})}\\) and  \n\\(xI₂ > x₂ + \\frac{v₂²}{2·(A·ts₀ + v₁_{233})}\\),  \ntogether with other consistency constraints.  The condition is expressed as the negation of an existential over a 32‑bit bit‑vector variable, using non‑linear BV arithmetic (multiplication, division) and a relatively deep term nesting (depth 21), which makes the instance challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290877.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts that under a set of linear and non‑linear constraints on positions (x1, x2, xI1, xI2), velocities (v1, v2), and parameters (A, B, V, ep), no witness exists for a time variable ts such that the system can violate the safety bounds (e.g., exceed the maximal velocity V or breach the interval ep). The formula contains a single existential quantifier, deep term nesting (depth 21), and non‑linear operations (multiplication and division), making it a challenging bit‑vector non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37018.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a one‑lane intersection scenario, translated into 32‑bit bit‑vector arithmetic. It asserts that, under bounds on positions, velocities, timing variables ( ts82uscore1, t149uscore0dollarskuscore1 ), and parameters ( A, B, V, ep ), no assignment can make the vehicle’s position exceed a computed safe bound (involving the non‑linear term v·v and a division), i.e. it checks the unsatisfiability of an existentially‑quantified counterexample. The problem features a single existential quantifier, mixed linear and non‑linear bit‑vector operations, 13 constants and a moderate term depth (23), typical of industrial hybrid‑system VCs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534610.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”.  It asserts that no 32‑bit time value `ts2533uscore0` can satisfy a conjunction of non‑linear arithmetic constraints on positions, velocities (`v1`, `v2`), acceleration `A`, braking constant `B`, and a deadline `ep`; the constraints include quadratic terms (`v1*v1`), a division by `2*B`, and several interval bounds (e.g., `0 ≤ v1 ≤ V`, `xI1 > x1 + (v1*v1)/(2*B)`).  Thus the problem is a single‑existential‑quantifier verification check over bit‑vectors with mixed linear/non‑linear operations, a relatively deep term structure (depth 20) and many conjuncts, which makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369000.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a simple intersection scenario. It asserts that there is **no** 32‑bit time value `ts1722uscore0` that can satisfy a conjunction of arithmetic constraints on positions, velocities (`v1`, `v2`), accelerations (`A`, `B`), a deadline `ep` and related intermediate terms, where the constraints involve non‑linear operations such as quadratic products (`v1·v1`, `v2·v2`), division and multiplication by constants. The formula contains a single existential quantifier, numerous conjuncts (≈20) and a term depth of 19, leading to a difficult non‑linear bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269013.smt2",
    "description": "The formula is a safety‑verification condition from the KeYmaera hybrid‑systems tool, translated to 32‑bit‑vector arithmetic.  It asserts (via a negated existential) that there is **no** choice of the time variable `ts1251uscore0` satisfying a conjunction of linear bounds (non‑negativity, upper‑bound `V`) together with a non‑linear relation involving a quadratic term `v2*v2` (and a division by `2*B`) that encodes the geometric constraints of two vehicles approaching an intersection (e.g., `I1 = 2`, `I2 = 2`, `xI1 < x1`, `xI2 > x2 + …`).  The problem therefore is a single‑quantifier BV verification query with moderate term depth but costly non‑linear multiplication/division, making it a challenging instance for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252371.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple vehicle‑intersection scenario. It asserts that, given bounds on initial positions, velocities (v1, v2), accelerations (A, B) and a global speed limit V, the computed state after any elapsed time ts (captured by non‑linear bit‑vector expressions such as v₂·v₂ ÷ (2·B)) stays within the prescribed limits and respects a deadline ep, while also enforcing a particular branch condition (I1 = 2). The formula contains a single existential quantifier, nested conjuncts, and non‑linear multiplication/division over 32‑bit bitvectors, making it a representative industrial verification benchmark with moderate depth (≈20) and nonlinear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10279.smt2",
    "description": "The benchmark encodes a safety verification condition for the “binary driver” hybrid‑system model used in the KeYmaera tool: it asserts that there is **no** 32‑bit time value `ts3` satisfying a large conjunction of linear and non‑linear inequalities over a set of parameters (`b, d, v, amax, ep, …`).  The constraints contain many quadratic and higher‑degree bit‑vector terms (squares, products, divisions, and mixed multiplications), non‑negativity requirements, and bounds relating the variables, all wrapped in a single existential quantifier.  Because the formula mixes deep nested lets, several non‑linear arithmetic operations, and a quantifier, it represents a challenging non‑linear BV verification problem typical of industrial hybrid‑system VCs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174360.smt2",
    "description": "The benchmark encodes a safety verification condition for the “simple intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts (as a negated existential) that, for all admissible time steps ts, the vehicle positions and speeds (variables such as xI1, x1, v1, A, B, V, ep) satisfy a collection of nonlinear constraints—including non‑linear multiplications and a division (v1·v1 / (2·B))—under non‑negative bounds and a positive time horizon. The single quantified formula, moderate term depth (20) and the presence of nonlinear BV arithmetic make it a representative industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node13832.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof for a one‑lane intersection scenario, translated into 32‑bit bit‑vector arithmetic. It asserts (via a negated existential) that there is no time value ts₍₂₉₎ satisfying a large conjunction of bound constraints on positions, velocities, and timing variables—including non‑linear terms such as the product of a (negated) constant B with time variables—while also respecting positivity and upper‑limit requirements on speed and distance. The instance therefore tests BV solvers on a single‑existential, non‑linear arithmetic problem with 13 variables, deep nesting of conjuncts, and multiplications that make the check for unsatisfiability (i.e., safety) challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550261.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts the negation of an existential “collision‑time” variable together with a conjunction of arithmetic constraints on positions, velocities, and physical parameters (non‑negative speeds, acceleration bounds, a quadratic term \\(v_2^2/(2B)\\), and timing limits) that are all represented as 32‑bit bit‑vectors.  The problem amounts to discharging a single quantified verification condition that features non‑linear bit‑vector operations (multiplication, division) and several inequality relations, making it a non‑linear arithmetic‑heavy verification task with moderate term depth and one quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node630639.smt2",
    "description": "This benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system, originally proved in KeYmaera.  The bit‑vector formula asserts that, under non‑negative initial positions x₁, x₂, velocities v₁, v₂ bounded by a common limit V, and positive braking parameters A, B, there is **no** choice of a transition time ts that makes the vehicles’ positions exceed their respective stopping distances (expressed as x + v² ÷ (2·B)), i.e., the intersection remains collision‑free.  The encoding uses non‑linear arithmetic (multiplication and division) translated to 32‑bit BV, contains a single existential quantifier and a moderate term depth (≈21), making it a representative industrial‑style BV verification problem with non‑linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium0.smt2",
    "description": "This SMT‑LIB file encodes a **hardware rewrite‑rule synthesis / verification** problem in the BV logic.  A single (quantified) assertion describes a massive combinational datapath built from 2‑, 5‑, 16‑ and 1‑bit vectors that model a set of multiplexers, an ALU, signed/unsigned comparisons, shifts, extensions, adds, subtracts and a few 16‑bit multiplications.  The datapath is fed by a 5040‑bit input vector `ib_0` (and a few auxiliary bit‑vector constants) and produces a one‑bit output `ob_0`.  The assertion states that for **all** possible values of a large collection of input bits (the quantified variables) the complex expression reduces to a fixed Boolean condition on `ib_0` and `ob_0` (essentially a functional‑equivalence or safety property).   \n\nKey characteristics:  \n\n* **Industrial PEak benchmark** – generated for the PEak hardware rewrite‑rule synthesis project.  \n* Uses a single quantified formula with **≈1.2 million term depth**, over 25 declared constants and more than 90 million SMT symbols.  \n* Heavy use of `let`‑bindings, `extract`, `concat`, zero/sign‑extensions, `bvadd`, `bvsub`, `bvmul`, shifts, and comparisons (`bvule`, `bvsle`, `bvult`, `bvslt`).  \n* The problem is a pure SAT/SMT check (no arithmetic theory beyond bit‑vectors) asking whether there exists an assignment to the declared constants that satisfies the huge Boolean condition for every possible combination of the quantified inputs.  \n\nIn short, the instance tests the satisfiability of an extremely deep, highly regular bit‑vector circuit that models a candidate hardware rewrite rule, checking that the rewrite preserves the intended functionality for all possible inputs.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node34026.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems proof “intersection‑example‑onelane”.  After translating the real‑valued dynamics of a vehicle (position x, speed v, braking bound B, speed limit V, elapsed time ts) into 32‑bit bit‑vectors, the formula asserts that no assignment to the existential time variable ts can violate a set of bounds (0 ≤ ts ≤ t₁₃₅, 0 ≤ v ≤ V, 0 ≤ vuscore4≤ V, …) while also breaking the safety inequality xI > x + v²/(2·B).  Hence the instance checks unsatisfiability of a quantified non‑linear bit‑vector constraint, featuring multiplications, a division and several linear inequalities, which makes quantifier elimination and bit‑vector arithmetic the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369346.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a simple vehicle‑intersection scenario: given non‑negative positions x₁,x₂, velocities v₁,v₂, accelerations A,B and a speed bound V, it asserts that no time ts (0 ≤ ts ≤ t₁₇₂₄) can make the computed stopping distances (v² / (2·B)) exceed the remaining distance to the intersection, while all parameters stay within their prescribed bounds (e.g. B>0, V>0, ep>0). This is expressed as the negation of an existential quantifier over ts, together with a chain of BV arithmetic constraints (multiplication, addition, signed division and comparison). The instance therefore tests the satisfiability of a non‑linear bit‑vector formula with a single quantified variable, a relatively deep term structure (depth 19) and many intertwined arithmetic constraints, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365878.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera: given 32‑bit bit‑vector variables for two vehicles’ speeds (v1, v2), positions (x1, x2), braking bounds (A, B), a speed limit V, and a time horizon ep, it asserts that there is **no** reachable state (exists ts) in which the braking distance formulas x + v²/(2·B) exceed the prescribed safety bounds while all variables stay non‑negative and within their limits. The formula is a single quantified conjunctive assertion containing non‑linear arithmetic (multiplication, division) modeled with BV operations, a relatively deep term structure (depth 21) and many relational constraints, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559861.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example” of a traffic‑intersection scenario). The formula asserts, via a negated existential over a time‑stamp variable, that no reachable state can violate a set of nonlinear constraints involving positions, velocities and braking distances (e.g., \\(x_{I2}>x_2+v_2^2/(2B)\\)) while all variables remain within prescribed non‑negative bounds (\\(\\le V\\)). The encoding uses 32‑bit bit‑vectors with multiplications, a division, and a single quantifier, yielding a non‑linear BV problem with moderate term depth and a mix of arithmetic and ordering constraints that make it challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345278.smt2",
    "description": "The instance encodes a safety verification condition for the “intersection‑example” hybrid‑system benchmark (from KeYmaera). It asserts that no 32‑bit signed time value `ts1607_0` can satisfy a conjunction of equalities and signed inequalities involving non‑linear arithmetic (products, sums and signed divisions of variables such as `v1`, `v2`, `A`, `B`) together with bounds on these variables. Consequently the problem is a quantified bit‑vector verification task that features a single existential quantifier, moderate‑size term depth (≈20), and non‑linear operations, making it a typical industrial‑style BV verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152733.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a simple traffic‑intersection scenario. It asserts the unsatisfiability of an existential 32‑bit time variable `ts707uscore0` together with a large conjunction of signed bit‑vector inequalities—some linear and some non‑linear (e.g., products of `B` and `ts707uscore0`, a division by `2·B`)—under fixed assumptions such as `I1 = I2 = 2`, `A,B,V,ep > 0`, and bounds on the state variables `v1`, `v2`, `x1`, `x2`. The problem features a single existential quantifier, deep (≈20) term nesting and mixed arithmetic, which makes it a hard BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node733082.smt2",
    "description": "This benchmark encodes a safety‑verification condition extracted from the KeYmaera hybrid‑system prover for a simple traffic‑intersection scenario. The formula asserts, after a negated existential quantifier, that no reachable state (parameterised by a time‑step variable `ts3574uscore0`) can violate a collection of inequalities that relate positions (`xI1`, `xI2`), velocities (`v1`, `v2`), a common bound `V`, and parameters `A`, `B`, `ep`; the constraints involve non‑linear bit‑vector arithmetic (quadratic terms `v1·v1`, `v2·v2` and a signed division). Consequently the instance is a non‑linear BV verification problem with a single quantified variable, many inter‑dependent constraints, and a relatively deep term structure (depth 20), which together make it a challenging case for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476116.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”.  It asserts, in 32‑bit bit‑vector arithmetic, that no time‑step `ts2257_0` can exist such that a set of nonlinear constraints—non‑negative variables, bounds `v1,v2 ≤ V`, quadratic braking‐distance terms `v1*v1/(2*B)`, and ordering conditions on positions `xI1`, `xI2` relative to `x1`, `x2`—are violated while all auxiliary bounds (`A,B,ep > 0`) hold.  The problem is thus a nonlinear arithmetic verification task, translated to bit‑vectors, featuring one existential quantifier, multiplications, a division, and a relatively deep term structure (depth 20), making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601673.smt2",
    "description": "This benchmark encodes a safety‑verification condition for the “intersection‑example” hybrid system used in KeYmaera: given non‑negative acceleration A, braking B, a speed bound V and a time horizon ep, it asserts that for all admissible time steps ts the derived velocities (A·ts + v₁₀ and –B·ts + v₂₀) stay within [0,V] and that the positional separation constraints (xI₁ < x₁ and xI₂ > x₂ + v₂²/(2·B)) hold, thereby preventing a collision. The formula is a single negated existential over a 32‑bit bit‑vector term with several linear and a few non‑linear (multiplicative) constraints, giving moderate term depth (19) but requiring bit‑vector reasoning about potential overflow.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152942.smt2",
    "description": "The formula is a single verification condition extracted from the Keymaera hybrid‑systems proof “intersection‑example‑simple”.  It encodes, with 32‑bit bit‑vectors, the safety invariant of a vehicle‑intersection scenario: given non‑negative bounds on positions (x₁,x₂), velocities (v₁,v₂), parameters A,B,V and interval counters I₁,I₂, it asserts that no reachable state exists (the outer `not`) in which a time step ts708₀ satisfying the continuous dynamics (linear combinations of B, v₁ and the elapsed time) stays within the allowed range and violates the safety deadline ep.  The instance therefore checks a safety‑property of a hybrid system, translated from non‑linear real arithmetic into bit‑vector arithmetic; it contains a single existential quantifier, moderate term depth (21) and 18 variables, making it a typical industrial‑style nonlinear‑arithmetic verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631164.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems tool for a simple intersection scenario, translated into 32‑bit bit‑vector arithmetic. It asserts that, under non‑negative bounds for the velocities (v1, v2), positions (x1, x2), and parameters (A, B, V, ep), the computed stopping‑distance formulas  \n\\(x_1 + \\frac{v_1^2}{2B}\\) and \\(x_2 + \\frac{v_2^2}{2B}\\) are never exceeded (i.e., the “intersection points” xI1, xI2 stay safely beyond these limits) and that all auxiliary variables stay within their prescribed ranges; the outer negated existential seeks a counterexample, so the problem is to prove its unsatisfiability. The instance features a single quantified block, non‑linear multiplications/divisions turned into bit‑vector operations, and a moderate term depth (21), making it a typical industrial hybrid‑system verification challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351935.smt2",
    "description": "The file encodes a verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential formula that ties together positions (x₁, x₂, xI₁, xI₂), velocities (v₁, v₂), time variables (t, ts), and parameters (A, B, V, ep) with non‑linear constraints such as bvmul (v·v), bvsdiv, and several linear and quadratic inequalities (e.g., bvsgt xI₁ (x₁ + v₁²/…)). The problem therefore amounts to checking unsatisfiability of a single quantified, highly non‑linear BV formula that features deep nesting (max term depth 20) and numerous arithmetic comparisons, making it a challenging industrial‑style non‑linear bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node10952.smt2",
    "description": "This benchmark encodes a safety‑lemma verification condition for a hybrid‑systems model (the European Train Control System case study) that has been translated from KeYmaera’s real‑arithmetic VCs into 32‑bit bit‑vector arithmetic. The formula asserts (by negating an existential) that a collection of non‑linear constraints—nested multiplications, divisions and several signed inequality relations among the variables b, A, d, v, m, z, ep, etc.—cannot be satisfied, thereby proving the original safety property. The problem is a single‑quantifier BV verification check with a deep term structure (depth 23) and a high density of non‑linear operations, which makes it a challenging instance for solvers handling bit‑vector non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534722.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verification of a simple intersection scenario. It asserts, in 32‑bit bit‑vector arithmetic, that under non‑negative bounds on the parameters A, B, V and on the velocities v1, v2, the quadratic dynamics bvmul v1 v1/(2·B) together with the position updates never allow the unsafe conjunction of predicates on the states xI1, xI2, I1, I2, etc., to be reachable; the outer (not exists…) turns the problem into an unsatisfiability check. The instance features a single existential quantifier, nested nonlinear (multiplication and division) bit‑vector terms, and a deep conjunction of relational constraints, making it a non‑linear BV verification problem of moderate size and depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287256.smt2",
    "description": "The benchmark encodes a safety verification condition extracted from the KeYmaera hybrid‑system proof for a simple traffic‑intersection scenario.  It asserts (via the negated existential) that no 32‑bit time value ts can satisfy a collection of non‑linear bit‑vector constraints that model vehicle positions (x‑variables), velocities (v₁,v₂), accelerations (A,B), and bounds on speed V and a horizon ep, together with premises such as non‑negative parameters and ordering of initial positions.  Solving the instance therefore requires proving unsatisfiability of a quantified, non‑linear BV formula containing multiplications, a division, and several relational constraints, which makes it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node247731.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the KeYmaera “intersection‑example”).  It asserts that there is **no** assignment to the time variable `ts1150uscore0` (and to the other 32‑bit parameters such as speeds `v1`, `v2`, accelerations `A`, `B`, distance bounds `V`, and a horizon `ep`) that simultaneously satisfies a collection of non‑linear bit‑vector constraints: non‑negativity of all physical quantities, upper bounds by a common limit `V`, the classic stopping‑distance inequality `xI2 > x2 + v2*v2/(2*B)`, and linear update relations `v1 + A*ts` and `v2 + A*ts` staying within `[0,V]`.  The formula features a single existential quantifier, several nested `let`s, and mixed multiplication/division (non‑linear BV arithmetic), giving a moderate term depth (21) but a non‑trivial solving challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46832.smt2",
    "description": "This instance encodes a safety verification condition for a one‑lane traffic intersection, taken from the KeYmaera hybrid‑systems prover. The formula asserts, after negation, that there exists a time point ( ts105 ) satisfying a large conjunction of non‑linear arithmetic constraints over 32‑bit bitvectors that model positions, velocities, accelerations and timing bounds (e.g., xI > x + v²/2B, B>0, A≥0, V>0, etc.). The problem is therefore a non‑linear BV verification task with a single existential quantifier, deep arithmetic terms (depth ≈ 25) and many intertwined inequalities, making it a challenging industrial‑style safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559428.smt2",
    "description": "This benchmark encodes a safety verification condition generated by the KeYmaera theorem prover for a simple vehicle‑intersection hybrid‑system model.  The formula asserts (by negating an existential) that there is no choice of a time‑step variable `ts2665uscore0` satisfying a conjunction of linear and non‑linear bit‑vector constraints on positions, velocities, intervals (`I1`, `I2`), and physical constants (`A`, `B`, `V`, `ep`), including multiplication, division, and quadratic terms (`v2*v2`).  The problem is thus a non‑linear BV verification task with a single quantifier, moderate depth (≈21), and about twenty 32‑bit variables, making it a representative industrial example of hybrid‑system safety proving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704363.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts that **no** assignment to the time variable `ts3394uscore0` can satisfy a conjunction of equalities, sign checks, and non‑linear bit‑vector arithmetic (including products such as `B*ts3394uscore0` and a division by `2*B`) that model vehicle positions, velocities (`v1`, `v2`), and control parameters (`A`, `B`, `V`, `ep`).  The problem is a single‑quantifier BV formula with moderate term depth (≈20) and a mixture of linear and non‑linear constraints, making it a typical industrial verification instance that challenges solvers’ handling of quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271104.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system “intersection” model taken from the KeYmaera proof suite.  It asserts the negation of an existential over a time‑step variable together with a conjunction of arithmetic constraints (bounds, ordering, and a nonlinear relation \\(bvmul\\) and \\(bvsdiv\\)) on 32‑bit bit‑vectors representing positions, velocities, and parameters, so that the solver must show the formula unsatisfiable to prove the original VC.  The problem features a single quantified block, deep term nesting (depth ≈ 20) and non‑linear bit‑vector arithmetic, which are known to make BV solving particularly challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3458.smt2",
    "description": "The benchmark encodes a safety verification condition from the Keymaera hybrid‑system verifier (an adaptive cruise‑control example). It asserts the negation of an existential over a time variable ts₁, requiring a conjunction of linear and non‑linear 32‑bit bit‑vector constraints on velocities, positions, parameters A, B, ε and a quadratic term in the elapsed time, and then checks that a derived inequality (involving products of these quantities) cannot be violated. The formula therefore tests whether the hybrid‑system’s safety property holds; its difficulty stems from the presence of a single quantified variable, deep nesting (depth ≈20), and many non‑linear bit‑vector multiplications and a division, making it a challenging non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node154163.smt2",
    "description": "This benchmark is a bit‑vector encoding of a safety verification condition generated by the KeYmaera hybrid‑system prover for a “safe intersection” example. It asserts that no reachable time instant (the existential variable ts714₀) can violate a set of nonlinear constraints on positions, velocities and parameters (e.g., xI1 > x1 + v₁²/(2·B), xI2 < x2, 0 ≤ v₁,v₂ ≤ V, A,B > 0, V,ep > 0), where the nonlinear arithmetic is represented with bit‑vector multiplication, signed division and comparisons. The problem thus tests a verification task involving a single quantifier, multiple non‑linear BV operations, and relatively deep terms (depth ≈ 20), making it a challenging instance for solvers handling nonlinear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171228.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example used in KeYmaera. It asserts, via a negated existential over a 32‑bit time variable `ts793uscore0`, that no assignment to the system’s parameters (velocities `v1`, `v2`, bounds `A`, `B`, limits `V`, safety margin `ep`, and position variables `x1`, `x2`, `xI1`, `xI2`) can satisfy a conjunction of linear bit‑vector inequalities together with a single non‑linear term `bvmul v1 v1` (the square of a velocity) that appears in a division, thereby checking an invariant that the intersection remains safe. The instance contains one quantifier, several nested conjunctions, and a modest term depth (20), but the presence of non‑linear multiplication in the BV domain makes it a non‑linear arithmetic verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal4-node5686.smt2",
    "description": "This benchmark encodes a safety verification condition for the “train_goal4” case study from the KeYmaera hybrid‑systems verifier.  The formula asserts, via an existentially‑quantified time variable `ts4uscore0`, a conjunction of nonlinear bit‑vector constraints that relate velocities, distances, accelerations and several physical parameters (e.g., `b`, `A`, `ep`, `m`, `z`).  Proving the goal amounts to showing the existential formula is unsatisfiable, i.e., the implication holds for all admissible states; the problem features many non‑linear multiplications/divisions, a moderate number of 32‑bit variables (15) and a term depth of 23, making it a challenging BV‑non‑linear arithmetic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node14168.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a one‑lane intersection scenario. It asserts the non‑existence of a time ts₃₀ (a 32‑bit bit‑vector) that simultaneously satisfies a collection of linear‑arithmetic constraints over positions, velocities and timing parameters (e.g., 0 ≤ ts₃₀ ≤ t₅₁, 0 ≤ A·ts₃₀+v ≤ V, ordering of positions x_I < x, non‑negative bounds on constants A, B, V, ep, etc.). The single existential quantifier is surrounded by a deep conjunction of BV additions, multiplications and signed‑order comparisons, yielding a moderately complex, quantifier‑free core but with non‑linear (multiplicative) bit‑vector arithmetic that makes the condition challenging for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19598.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a single‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  After translating the continuous dynamics into 32‑bit bit‑vector arithmetic, the formula asserts that **no** value of the time variable `ts43uscore0` can satisfy a large conjunction of linear and non‑linear inequalities involving positions, velocities (`xI`, `v`, `V`, etc.) and parameters (`A`, `B`, `ep`).  Consequently the instance is a **universal safety property** expressed as the negation of an existential query, and its difficulty stems from the presence of several non‑linear bit‑vector operations (multiplication, division, squaring) together with deep term nesting (depth 24) despite a modest number of constants (13).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node170139.smt2",
    "description": "The benchmark encodes a safety verification condition for the “intersection‑example” hybrid system from KeYmaera, translated into 32‑bit bit‑vector arithmetic.  It asserts the negation of an existential witness ts787₀ that would violate a set of linear and non‑linear constraints (including a quadratic term v₁·v₁ and a division by 2·B) modelling vehicle positions, velocities, and bounds (A, B, V, ep).  The solver must prove unsatisfiability of this quantified BV formula, a task made difficult by the presence of non‑linear multiplications/divisions and a moderate term‑depth (21) despite the relatively small number of variables and a single existential quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392932.smt2",
    "description": "This benchmark is a verification condition taken from the KeYmaera proof of a “safe intersection’’ hybrid‑system example, translated into 32‑bit bit‑vector arithmetic. It asserts that, given non‑negative parameters \\(A,B,V, v_1, v_2\\) (with \\(v_i\\le V\\)) and braking distances computed as \\((v_i^2)/(2\\cdot B)\\), the future positions \\(xI_1, xI_2\\) exceed the initial positions plus those distances, while all timing variables stay within bounds (\\(0\\le ts\\le t\\), \\(ts+0\\le ep\\)), and checks that no existential choice of the intermediate time \\(ts\\) can violate the safety inequality. The formula is negated and the solver must prove it unsatisfiable, thus establishing the safety property; the instance features a single existential quantifier, non‑linear multiplication/division on bit‑vectors, and moderate term depth, making it a challenging industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node694990.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  It asserts the non‑existence of a time stamp `ts3337uscore0` together with concrete 32‑bit values for positions, velocities, and parameters (A, B, V, ep, etc.) that satisfy a large conjunction of linear bounds, positivity constraints, and a non‑linear quadratic relation `bvmul v1 v1` divided by `2·B`.  The formula contains a single existential quantifier over a bit‑vector, many intertwined BV comparisons, and non‑linear arithmetic, providing a demanding industrial‑style verification query for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392708.smt2",
    "description": "This instance encodes a safety‑verification condition for the “safe intersection” hybrid‑system example from KeYmaera.  The formula (negated existential) asserts that, under a collection of pre‑conditions on non‑negative parameters (A, B, V, v₁, v₂, ep, etc.) and fixed mode identifiers (I₁ = I₂ = 2), no values of the time variable ts₁₈₃₇ can make the derived position bounds (involving non‑linear bit‑vector multiplications, a division and a quadratic term v·v) violate the prescribed safety inequalities; proving unsatisfiability shows the system is safe.  The problem features a single existential quantifier, deep non‑linear bit‑vector arithmetic (multiplication, division, quadratic terms) and a large conjunctive core, making it a challenging BV‑encoding of a hybrid‑system verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19624.smt2",
    "description": "This benchmark is a verification condition extracted from the Keymaera proof of a one‑lane traffic‑intersection safety model. It asserts (after negating an existential) that for all admissible values of time \\(ts\\) and the system parameters (positions \\(x\\), velocities \\(v\\), accelerations \\(A,B\\), etc.) a non‑linear safety inequality involving squares, products and divisions of 32‑bit bit‑vectors (e.g., \\(bvmul\\), \\(bvsdiv\\), \\(bvsle\\)) is never violated. The instance therefore checks a safety invariant of a hybrid system encoded in bit‑vector arithmetic; its difficulty stems from deep (depth 25) non‑linear terms, a single quantified variable, and numerous intertwined arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479619.smt2",
    "description": "This instance is a safety verification condition for the “safe‑intersection” hybrid‑systems benchmark from KeYmaera. It checks that, under given bounds on speeds (v1, v2), accelerations (A, B), a maximum speed V, and a positive time horizon ep, there is **no** assignment to the auxiliary time variable ts that simultaneously satisfies a collection of nonlinear signed‑bit‑vector inequalities (e.g., \\(v_1^2\\), \\(B·ts\\), division by \\(2B\\)) encoding the motion‑update equations and collision‑avoidance constraints of two vehicles. The problem features a single existential quantifier, deep (≈20) term nesting, and mixed multiplication/division over 32‑bit signed bit‑vectors, making it a non‑linear arithmetic verification task that is challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603232.smt2",
    "description": "The instance encodes a verification condition for a hybrid‑system safety proof (the “intersection‑example” from KeYmaera). It asserts that, for all admissible 32‑bit values of the system parameters (positions x₁,x₂, velocities v₁,v₂, constants A,B, time bounds V, ep, etc.), no choice of a time variable ts can violate the safety inequalities that model the intersection crossing; the outermost (not (exists …)) forces the solver to prove unsatisfiability of a counterexample. The formula mixes non‑linear bit‑vector arithmetic (products A·ts, B·ts, v₂·v₂, a division, and a negation) with a rich lattice of signed comparisons (≤, ≥, <, >), a single existential quantifier and a let‑binding, yielding a moderately deep term structure (depth 20) and making the problem challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node13791.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system example “binary_driver” (node 13791).  It asserts, via a negated existential quantifier over a 32‑bit time variable, that no assignment can satisfy a collection of non‑linear bit‑vector constraints—including non‑negativity, linear and quadratic relations among parameters such as `b`, `amax`, `d`, `v`, and various distance/velocity terms.  Thus the instance is a quantified non‑linear bit‑vector arithmetic verification problem with deep nested terms (depth 22) and many multiplications/divisions, typical of industrial safety‑property checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290002.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  It asserts, via a negated existential over a 32‑bit time variable, that under a set of pre‑conditions on positions (x1, x2, xI1, xI2), velocities (v1, v2), bounds (A, B, V, ep) and mode indices (I1, I2 = 2) there is **no** reachable state where the computed positions and velocities (including a non‑linear term v2·v2 / (2·B)) violate the safety limits before the deadline ep.  The formula involves non‑linear bit‑vector arithmetic (multiplication, division) and several relational constraints, with a moderate term depth (19) and a single quantified block, making it a challenging BV non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346170.smt2",
    "description": "The formula encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera). It asserts that, under a collection of linear and non‑linear bit‑vector constraints on positions (x1, x2, xI1, xI2), velocities (v1, v2) and parameters (A, B, V, ep), no witness for the existential variable ts1611₀ can violate the safety disjunction (either a position coincidence or a timing bound). The instance features 32‑bit arithmetic with multiplications, divisions and squares (e.g., v₁·v₁, v₂·v₂), a single quantifier alternation and moderate term depth (21), making it a typical non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197075.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that there is **no** assignment to the time‑step variable `ts921uscore0` (and the associated state variables `v1`, `v2`, `x1`, `x2`, `A`, `B`, `V`, `ep`, etc.) that simultaneously satisfies a collection of linear and non‑linear bit‑vector constraints – bounds on velocities (`0 ≤ v ≤ V`), positivity of parameters (`B, V, ep > 0`), a quadratic relation `xI1 > x1 + v1²/(2·B)`, and a reachable‑set inequality involving `ts921uscore0`, `v1`, `B`, and `v2`.  The formula contains a single existential quantifier, moderate term depth (20) and several non‑linear BV operations (`bvmul`, `bvsdiv`), making it a typical industrial verification instance that tests a solver’s ability to handle quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node6709-new.smt2",
    "description": "The benchmark encodes a safety verification condition for the “dccs‑example” adaptive‑cruise‑control hybrid system (from KeYmaera). It asserts the negation of an existential statement over a time variable, requiring that, given non‑negative parameters A, B, eps and the state variables v₁, x₁, x₂, the non‑linear inequality  \n\n\\(x₁ + v₁²·(1/(2·B)) < x₂\\)  \n\n(and related bounds on velocities and times) holds for all admissible timestamps; the formula is translated into 32‑bit bit‑vector arithmetic with multiplications, divisions, and squaring, yielding a single‑quantifier, moderately deep (depth 20) non‑linear BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node31555.smt2",
    "description": "This benchmark encodes a safety verification condition extracted from the KeYmaera hybrid‑system model of a one‑lane traffic intersection. The formula asserts (under a series of linear bounds on timestamps, positions, velocities and constants) that no value of the existential time variable `ts69uscore1` can make the vehicle’s position `xI` violate a nonlinear inequality involving quadratic terms such as `v·v`, products of timestamps and division by a constant `B`. The problem is therefore a quantifier‑free (after the outer `not exists`) non‑linear arithmetic check, translated to 32‑bit bit‑vectors; the presence of many multiplications, divisions and deep let‑bindings makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/hard1.smt2",
    "description": "This instance encodes a hardware‑level rewrite‑rule verification problem from the PEak benchmark suite.  A massive quantified bit‑vector formula describes a combinational circuit (muxes, ALU, LUT, multiplication, sign/zero extensions, extracts and concatenations) and asserts that the rewritten implementation produces the same 1‑bit output and respects several overflow/guard conditions for all possible 16‑bit inputs.  The model features extreme term depth (≈1.6 M) and thousands of nested ite, concat, extract and arithmetic operations, making it a very deep, quantifier‑rich BV‑satisfiability/verification task.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389601.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example‑simple” from KeYmaera).  It asserts that, under non‑negative bounds on the positions (x1,x2), velocities (v1,v2) and acceleration parameters (A,B) with a positive velocity limit V and a positive time horizon ep, there is **no** choice of a time‑step ts that can make the two cars’ future positions violate the safety inequality  \n\\[\nx_{I1}>x_1+\\frac{v_1^2}{2A\\cdot ts+v_{1,421}},\\qquad  \nx_{I2}>x_2+\\frac{v_2^2}{2A\\cdot ts+v_{1,421}}\n\\]  \nwhile respecting all bounds.  The instance is a quantifier‑free bit‑vector encoding (32‑bit) of a non‑linear arithmetic VC, featuring a single existential quantifier, multiple multiplications and a division, about 20 constants and a maximal term depth of 20, which makes it a moderately challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45116.smt2",
    "description": "The file encodes a safety‑verification condition for a hybrid‑system model of a single‑lane vehicle intersection (the “intersection‑example‑onelane” from KeYmaera).  It asserts the negation of an existential clause that would witness a violation of the braking‑distance invariant — roughly, that a vehicle’s position after decelerating with maximum brake B (expressed as \\(x_I > x + v^2/(2B)\\) and related bounds on timestamps, velocities v, V and parameters A, B) stays within allowed limits.  The problem is a bit‑vector instance with non‑linear (quadratic) arithmetic, a single existential quantifier, and a moderate depth of nested arithmetic terms, making it a challenging verification query rather than a synthesis or scheduling task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193438.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier for a simple intersection scenario.  The formula (negated existential) asserts that, assuming non‑negative parameters A, B, V, ep and velocities v₁, v₂ bounded by V, together with the geometric constraints  \n`xI1 > x1 + v₁²/(2·B)` and `xI2 < x2`, no time ts (0 ≤ ts ≤ t₉₉₉) can be chosen that violates the safety bound `ts + 0 ≤ ep` while keeping the derived position terms `v₁·ts + v₁₍₄₁₄₎` and `v₂·ts + v₂₍₄₁₄₎` inside `[0,V]`.  The instance uses 32‑bit bit‑vectors to represent non‑linear arithmetic (multiplication, division) and contains a single existential quantifier with moderate term depth (≈21) and about 18 variables, typical of industrial verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606769.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “safe‑intersection” benchmark from KeYmaera).  The formula asserts the negation of an existential over a time variable ts, requiring that numerous 32‑bit bit‑vector constraints—non‑negative bounds on velocities v₁, v₂ and parameters A, B, V, a braking‑distance inequality x₂ + v₂·v₂ / (2·B) < xI₂, and linear relations such as v₂ + (−B)·ts = …—hold simultaneously; proving unsatisfiability would confirm the original safety property.  The problem features a single quantified variable together with non‑linear multiplication and division in the bit‑vector domain, making it a challenging industrial‑style VC for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254826.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (generated by KeYmaera).  It asserts that, given bounds on the initial positions x₁, x₂, velocities v₁, v₂, parameters A, B, V and a positive time horizon ep, the continuous dynamics – which include a quadratic term v₂·v₂/(2·B) and a linear term –B·t – keep all derived quantities (such as the updated positions ?v₀, ?v₂) inside prescribed intervals and maintain the required ordering of the vehicles.  After translating the original real‑arithmetic VC into 32‑bit bit‑vectors, the problem becomes a single‑quantifier (negated existential, i.e., universal) non‑linear BV formula with multiplication, division and several inequality constraints, featuring a moderate term depth (≈20) and 18 variables, making it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345482.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera). The formula asserts the negation of an existentially quantified BV term that combines non‑linear arithmetic (multiplications, divisions) with a host of linear bounds on velocities, positions, acceleration, and a time variable, together with non‑negativity and upper‑bound constraints (e.g., v₁,v₂≤V, A≥0, ep>0). The solver must decide unsatisfiability of a single quantified bit‑vector formula of moderate size (19 variables, term depth 20) that features many nested arithmetic constraints, making it a non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488018.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera proof of a \"safe intersection\" hybrid‑system example, translated into 32‑bit bit‑vector arithmetic. The formula asserts the negation of an existential statement over a time variable `ts2315uscore0`, requiring that a conjunction of bounds on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), parameters (`A`, `B`), and a safety horizon `ep` cannot be simultaneously satisfied—i.e., no collision occurs within the allowed time. It features non‑linear BV operations (multiplication, division) and a single quantified bit‑vector, providing a compact yet challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619055.smt2",
    "description": "The file encodes a verification condition for a hybrid‑systems safety proof (the “intersection‑example” from KeYmaera).  It checks that, under non‑negative parameters \\(A,B,V\\) and velocities \\(v_1,v_2\\) bounded by \\(V\\), the positions \\(x_{I1},x_{I2}\\) are always beyond the braking distances \\(\\frac{v_1^2}{2B}\\) and \\(\\frac{v_2^2}{2B}\\); the condition is expressed as a quantified bit‑vector formula with non‑linear multiplications, a division, and several positivity and ordering constraints.  The instance therefore tests a bounded‑model‑checking style safety property with a single existential quantifier, a moderate number of 32‑bit variables, and relatively deep non‑linear term structure, making it a challenging BV‑encoded non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392183.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a simple vehicular intersection model taken from the KeYmaera hybrid‑systems tool.  The formula (negated existential) asserts that, assuming non‑negative velocities v₁, v₂ bounded by a maximum V, non‑negative accelerations A, B, and positive constants ep and I₁ = I₂ = 2, there is no time ts ≥ 0 at which the calculated stopping distances ( v² ⁄ (2·B) ) plus the current positions x₁, x₂ violate the required separation (expressed with bit‑vector additions, multiplications and signed comparisons).  Thus the instance checks a non‑linear arithmetic safety invariant over 32‑bit bit‑vectors, featuring a single existential quantifier, nested arithmetic, and deep term structure, which makes it a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node719994.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example‑simple” proof).  After translating the real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts the negation of an existential‑time‑step that would violate a set of nonlinear constraints on positions ( x₁, x₂ ), velocities ( v₁, v₂ ), and parameters ( A, B, V, ep ), together with bounds such as non‑negative speeds and positive acceleration.  The problem is thus a non‑linear arithmetic verification task with a single quantified variable, numerous inequality constraints, and mixed multiplication/division, making it challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53911.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a one‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera). It asserts, under a collection of linear bounds on parameters such as speed v, acceleration A, braking B, and a time horizon t, that the vehicle’s position x plus the stopping distance \\(v^2/(2B)\\) never exceeds the intersection position xI; the formula is the negation of an existential over a time variable, so proving unsatisfiability amounts to showing the invariant holds for all admissible values. The instance features non‑linear bit‑vector arithmetic (multiplication and division), several quantified and nested conjuncts with a depth of 22, making it a representative industrial BV non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node535359.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover: it asserts that there is **no** time instant `ts2538_0` (the sole existentially‑quantified variable) for which a set of signed‑inequality constraints on 32‑bit bit‑vector variables—representing positions, velocities, accelerations (`v1`, `v2`, `A`, `B`, `V`, `ep`) and indices (`I1`, `I2`)—can simultaneously hold.  The constraints include non‑linear arithmetic such as a quadratic term `v1*v1/(2*B)` and a linear combination `-B*ts + v2`, together with bounds and relational conditions that model a vehicle‑intersection scenario.  The formula is a single‑quantifier, deep (term depth 20) bit‑vector problem with 19 constants, making it a challenging instance for solvers that must handle non‑linear BV arithmetic and mixed inequality reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368427.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts, after translating the continuous dynamics into 32‑bit bit‑vector arithmetic, that for any admissible time step ts (bounded by the non‑negative constant ep) the positions xI1 and xI2 of two vehicles remain beyond the reachable intervals x1 + v₁²/(2·B) and x2 + v₂²/(2·B) under the given bounds on velocities v₁, v₂ (0 ≤ v ≤ V), accelerations A, B (non‑negative) and other constants.  The check is a single existential quantifier over ts inside a negated implication, featuring non‑linear multiplications and divisions on bit‑vectors, a moderate term depth (21) and many conjunctive inequalities, making it a non‑linear arithmetic verification problem encoded in BV.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351044.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (the “intersection‑example” from KeYmaera). The formula asserts, after negating an existentially‑quantified time‑step variable, that under a set of linear bounds on velocities ( v₁, v₂ ), non‑negative parameters ( A, B, V, ep ) and quadratic distance updates ( bvmul v₁ v₁ / (2·B + A·t) , bvmul v₂ v₂ / same ), the resulting positions xI₁ and xI₂ remain strictly larger than the updated positions, i.e. no collision occurs. The instance features non‑linear 32‑bit bit‑vector arithmetic (multiplication, signed division, signed comparisons) with a single existential quantifier and a deep term structure (depth 21), making it a challenging industrial verification problem for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290415.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera). The formula asserts that no choice of the continuous‑time variable ts1353 can violate a set of bounds on positions, velocities (v1, v2), and derived quantities (e.g., x2 + v2²/(2·B)), while all variables are constrained to be non‑negative and within a global limit V; the core arithmetic is expressed as 32‑bit bit‑vector operations with non‑linear multiplications (bvmul) and a division. The instance contains a single existential quantifier, a moderate number of conjuncts (≈20), and a maximum term depth of 19, making it a non‑linear BV verification problem of industrial size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672726.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  It asserts, via a single quantified formula, that no reachable state violates a set of non‑linear relationships among 32‑bit variables representing positions (x1, x2, xI1, xI2), velocities (v1, v2), accelerations (A, B) and timing parameters (ts3206₀, ep); the constraints involve bit‑vector multiplication, division, and signed inequalities.  The instance therefore tests a solver’s ability to handle quantified, non‑linear bit‑vector arithmetic with moderate depth (≈20) and a handful of variables, typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3897.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems suite (the adaptive cruise‑control example) that has been translated to 32‑bit bit‑vector arithmetic. It asserts the negation of an existentially quantified time variable ts1uscore2 together with a conjunction of linear and non‑linear inequalities involving products, squares, and divisions of the parameters A, B, eps, v1, v1₍₂₎, and the state variables x₁, x₂, etc., and checks that the resulting formula is unsatisfiable. The problem features a single quantifier, deep term nesting (depth 22), and extensive non‑linear bit‑vector arithmetic, making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672976.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid‑system model taken from the KeYmaera prover. It asserts (by negating an existential) that there exists a time ts such that a conjunction of signed 32‑bit constraints on positions, velocities, and constants (A, B, V, ep) – including non‑linear terms like v₁·v₁ and v₂·v₂, as well as signed division and orderings – holds; the solver must show that this conjunction is unsatisfiable. The problem features non‑linear bit‑vector arithmetic with multiplication and division, a single existential quantifier, and a relatively deep term structure (depth 20), making it a demanding industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172570.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple intersection scenario.  It asserts, in 32‑bit bit‑vector arithmetic, that under the given bounds on velocities (v1, v2), accelerations (A, B), and positions (x1, x2, xI1, xI2), there is **no** existential time instant `ts800` that can violate the safety inequality `xI1 > x1 + v1²/(2·B)` while respecting all initial‑state and evolution constraints (non‑linear multiplications, signed division, and ordering).  The formula contains a single quantified block, many conjuncts, and non‑linear BV operations, making it a non‑linear arithmetic verification problem with moderate term depth (21) and a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197946.smt2",
    "description": "The instance encodes a safety verification condition extracted from the KeYmaera proof of a simple intersection scenario.  It asserts, for a whole set of 32‑bit parameters (velocities v₁,v₂, maximal speed V, distances x₁,x₂, timing variables ts₉₂₆₀, t₉₂₆₀, etc.) that no choice of the existential time ts₉₂₆₀ can satisfy a conjunction of signed inequalities involving non‑linear bit‑vector arithmetic (multiplications and a division) together with bounds such as 0 ≤ v₁,v₂ ≤ V, B > 0, ep > 0 and positional relations that model the vehicles’ motion.  The formula therefore checks a hybrid‑system invariant (collision‑avoidance) using a single existential quantifier over a deep, non‑linear BV term structure, which makes the problem a moderately hard industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node633178.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (a KeYmaera proof obligation). The formula asserts that, for all admissible values of the system’s positions, velocities and parameters (encoded as 32‑bit vectors), the derived quadratic safety bounds (e.g., xI₁ > x₁ + v₁²/(2·B)) cannot be violated within the given time horizon, which is expressed as the negation of an existential witness for a time step that would breach the bound. The problem features non‑linear arithmetic (quadratic terms, division) translated into bit‑vector operations, a single quantified block (under a top‑level negation) and deep nesting of conjunctions, making it a challenging verification instance for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389285.smt2",
    "description": "The formula is the negated existential verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example. It checks that, under a collection of non‑linear arithmetic constraints (quadratic terms v₁·v₁, v₂·v₂, divisions, and several positivity/bound conditions on the variables A, B, V, ep, t, ts…), there is **no** assignment to the time‑stamp variable ts₁₈₁₇ that can violate the safety invariant; thus the SAT‑solver is asked to prove unsatisfiability. The encoding uses 32‑bit bit‑vectors to model the arithmetic, contains a single existential quantifier, deep nested let‑expressions (term depth 21) and several non‑linear multiplications/divisions, making it a challenging BV‑non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5920.smt2",
    "description": "This benchmark encodes a safety verification condition for the “bouncing‑ball” hybrid system (Keymaera example).  The formula asserts that there is **no** assignment to the time‑step variable `ts1uscore5` (and the already declared state variables) satisfying a collection of nonlinear constraints that model the ball’s kinematics – quadratic terms for position (`ts1uscore5*ts1uscore5`), velocity, and height, together with bound and positivity conditions on all variables.  After translation to 32‑bit bit‑vectors the problem features a single existential quantifier, several nested arithmetic multiplications and additions, and a term depth of 19, making it a non‑linear arithmetic verification task expressed in the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195519.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts, via a single existentially‑quantified time variable, that under a set of linear and non‑linear constraints on positions (x₁, x₂), velocities (v₁, v₂), accelerations (A, B), and bounded speed limits (V), no reachable state can violate the safety inequality xI₁ > x₁ + v₁²⁄(2·B) while maintaining all physical bounds (e.g., B > 0, 0 ≤ v₁,v₂ ≤ V).  It is expressed in 32‑bit bit‑vector logic with multiplications, a division, and a depth‑21 term graph, making it a challenging non‑linear arithmetic instance with one quantifier and many conjuncts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5581.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑onelane”, checking that a vehicle’s state (position xI, velocity v, etc.) always respects a separation bound along a one‑lane road intersection. The formula is a single quantified assertion (¬∃ ts10uscore0) that combines linear and non‑linear 32‑bit bit‑vector constraints (additions, multiplications, divisions, and comparisons) over time, distances, accelerations (A, B) and safety limits (V, ep). The problem is thus a non‑linear arithmetic VC with one existential quantifier, moderate term depth (23) and a handful of variables, posing a typical industrial hybrid‑system verification challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631052.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of two vehicles crossing an intersection (the “intersection‑example‑simple” from KeYmaera).  The formula asserts that, under non‑negative bounds on velocities v1, v2, a maximal speed V, a positive distance B, and a positive time horizon ep, no time‑step ts can make the computed future positions (which involve quadratic terms v1·v1 and v2·v2 divided by 2·B) violate the required separation constraints between the vehicles (expressed with a series of signed‑greater/less‑than and equality checks).  The problem is a single‑quantifier (∃ ts) safety‑verification VC translated to 32‑bit bit‑vector arithmetic, featuring non‑linear multiplication and division, which makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21162.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system model of a one‑lane traffic intersection.  The formula asserts that, for all admissible time steps, the computed stopping distance (the quadratic term v²/(2·B)) together with other bounds on positions, velocities, and timing parameters never violates the safety inequality that keeps the vehicle’s position xI ahead of the intersection; the negated existential quantifier makes the instance a universal check.  The encoding uses 32‑bit bit‑vectors, mixed linear and non‑linear (multiplication of two variables) arithmetic, and a single quantified variable, yielding moderate term depth (23) but posing a hard non‑linear BV solving problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node489032.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple vehicle‑intersection scenario. It asserts that, under non‑negative 32‑bit parameters (speeds v₁,v₂, limits V, acceleration A, braking B, a time horizon ep, etc.) and kinematic relations such as x₁ ≤ x₁₀ + v₁²/(2·B), no state exists (the quantified ts2320uscore0) that violates the safety bound xI₂ < x₂ while respecting all bounds and the piecewise case (1 = 2 ∨ I2 = 2). The problem is a single‑existential, non‑linear bit‑vector verification query involving multiplication, division and several inequality constraints, typical of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156618.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, via a single existential quantifier over a time variable, that under a set of linear and one non‑linear (v₁·v₁) bit‑vector constraints on positions, velocities (v₁, v₂), bounds (A, B, V) and auxiliary variables (I₁, I₂, xI₁, xI₂, ep), no reachable state violates the prescribed safety inequality (e.g., the distance between the cars stays positive).  The proof obligation is expressed in 32‑bit BV arithmetic, contains only one quantifier block, moderate term depth (20) and a handful of variables, making it a typical industrial benchmark for non‑linear arithmetic solving in the BV domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node12552.smt2",
    "description": "The file encodes a verification condition generated by the KeYmaera hybrid‑system verifier (binary‑driver example) that has been translated to 32‑bit bit‑vectors.  The single top‑level assertion negates an existential formula over a time variable ts₆₀ and contains a large conjunction of linear and non‑linear BV inequalities (positivity, bounds, and a safety‑type inequality involving products such as (v·v – d·d) ≤ … and quadratic terms in the time and control variables).  The problem is essentially a non‑linear arithmetic safety check with one quantifier, a deep term depth (23) and many nested multiplications, which makes it a difficult industrial‑style BV instance for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43329.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a one‑lane traffic‑intersection scenario. It asserts that there is **no** 32‑bit time value `ts97uscore0` satisfying a conjunction of linear and non‑linear bit‑vector inequalities (including products, a division, and ordering constraints such as `B>0`, `v≥0`, `xI > x + v*v/(2*B)`, etc.) that would violate the required safety invariant. Consequently the problem reduces to checking the unsatisfiability of a quantified non‑linear BV formula with a single existential quantifier and deep arithmetic terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156170.smt2",
    "description": "This instance encodes a safety verification condition taken from a KeYmaera hybrid‑systems proof (the “intersection‑example” of a traffic crossing). The formula asserts, after negating an existential quantifier over a time variable, that a collection of non‑linear arithmetic constraints on 32‑bit bit‑vector variables (positions, velocities, constants A, B, V, etc.) together with several linear and non‑linear inequalities must be unsatisfiable; in other words, the safety invariant must hold for all admissible time steps. The encoding features mixed multiplication, division, and signed comparisons, a single quantifier, and deep term nesting (depth 21), which together make the problem a challenging non‑linear BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node191763.smt2",
    "description": "The benchmark encodes a KeYmaera verification condition for a simple traffic‑intersection scenario: two vehicles with velocities v₁, v₂ (both non‑negative and bounded by a common limit V) travel along straight paths, and the safety property requires that, for any elapsed time t ≥ 0 up to a deadline ep, their positions (expressed through quadratic terms v₁·v₁ and v₂·v₂) remain separated and respect the bounds defined by constants A, B, I₁, I₂, etc.  The SMT‑LIB formula asserts the negation of an existentially‑quantified time variable, i.e., it checks that no time t satisfies a conjunction of linear and non‑linear (bit‑vector multiplication/division) inequalities, all over 32‑bit bitvectors.  Consequently the instance is a single‑quantifier, non‑linear bit‑vector verification problem with moderate term depth (≈21) that tests the solver’s ability to handle arithmetic‑rich safety invariants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192976.smt2",
    "description": "The benchmark encodes a safety verification condition for the “intersection‑example” hybrid system used in the KeYmaera tool: given non‑negative velocities \\(v_1,v_2\\) bounded by a maximum speed \\(V\\), a non‑negative deceleration bound \\(B\\), and initial positions \\(x_1,x_2\\), it asserts that no reachable time instant \\(ts\\) exists (the outer `not (exists …)`) at which the braking dynamics \\(v_1- B\\cdot ts\\) and the corresponding position constraints violate the required separation (e.g., \\(xI1 > x_1 + v_1^2/(2B)\\) and \\(xI2 < x_2\\)).  The formula is a purely bit‑vector encoding with non‑linear operations (multiplication, division) and a single quantified variable, leading to a relatively deep term structure (depth 20) and a moderate number of bit‑vector variables (18).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node16159.smt2",
    "description": "This benchmark encodes the safety verification of a one‑lane vehicle‑intersection scenario (the “intersection‑example‑onelane” from KeYmaera) as a quantified bit‑vector formula.  The single existentially quantified variable represents a time instant, and the body combines linear and non‑linear constraints (multiplications, a quadratic term, and divisions) over positions, velocities, accelerations (A, B), and a safety margin (ep) to enforce that the vehicle’s position stays within a safe region; the outer negation turns the check into a universal safety condition.  The instance features deep terms (depth 23), non‑linear BV arithmetic and a single quantifier, making it a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node723526.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover, modelling a simple vehicle‑intersection scenario.  The formula asserts (via a negated existential over a 32‑bit time variable) that, under non‑negative velocity bounds (v₁,v₂ ≤ V), positive parameters (A,B,ep) and quadratic position updates (x + v²·t/(2·B)), the two vehicles cannot simultaneously violate the prescribed separation constraints; the condition mixes bit‑vector multiplication, division and several inequality comparisons.  The problem is a single‑quantifier, non‑linear BV verification task with moderate term depth (≈21) and a handful of variables, making it a representative industrial benchmark for solving quantified non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194065.smt2",
    "description": "The formula encodes a safety verification condition for a simple intersection scenario taken from the KeYmaera hybrid‑system benchmark suite. It asserts (via a negated existential) that there is no time ts at which the bounded‑integer (32‑bit) state variables (velocities v1, v2, positions x1, x2, intermediate values xI1, xI2, counters I1, I2, etc.) can simultaneously satisfy a mixture of linear bounds, a non‑linear relation xI1 > x1 + v1²/(2·B), positivity constraints, and the transition‑time equations ?v₀ = A·ts + v1′ while also violating the safety predicate (I1 ≠ 2 ∧ I2 ≠ 2). The instance is a single‑quantifier, bit‑vector encoding of a hybrid‑system invariant check that involves multiplication and signed division, which makes it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709258.smt2",
    "description": "The benchmark encodes a safety‑property proof for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  All variables (positions x₁, x₂, velocities v₁, v₂, acceleration A, braking B, time bounds, etc.) are represented as 32‑bit bit‑vectors, and the assertion states that there is **no** choice of a time ts that can violate a collection of non‑linear constraints (including a quadratic term v₂·v₂ / (2·B)) while respecting the required bounds (non‑negative speeds, limits V, ep > 0, etc.).  Consequently, the instance is a quantifier‑free BV verification problem that checks a universal safety invariant of the intersection model, featuring moderate term depth and a single existential quantifier but many non‑linear arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166868.smt2",
    "description": "The benchmark encodes a Keymaera verification condition for a “safe‑intersection’’ hybrid system: the formula asserts (by negating an existential for a time variable ts771₀) that under a set of linear and non‑linear relationships among 32‑bit variables (positions x₁, x₂, xI₁, xI₂, velocities v₁, v₂, bounds A, B, V, etc.) no unsafe state can be reached.  The constraints involve multiplications, a signed division, and several ordered comparisons, all modeled as BV arithmetic, and the check reduces to proving the universally‑quantified safety property (i.e., the negated ∃ ts771₀ is unsatisfiable).  The instance is notable for its non‑linear BV arithmetic, a modest number of variables (18) but relatively deep terms (depth 20) and a single quantified block, which makes it a challenging industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391376.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the KeYmaera “intersection‑example‑simple” proof).  All state variables (positions x1, x2, velocities v1, v2, accelerations A, B, safety distance V, etc.) are represented as 32‑bit bit‑vectors, and the formula asserts that under non‑negative bounds and the nonlinear dynamics x + (v²)/(2·A) (captured with `bvmul` and `bvsdiv`) no reachable time ts can violate the safety distance V.  The instance is a single quantified (existential) check turned into a negated VC, featuring non‑linear bit‑vector arithmetic, a modest quantifier depth (one ∃) but relatively deep terms (depth 21), making it a challenging BV‑non‑linear verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190062.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts, via an existentially‑quantified time step `ts883uscore0`, that a collection of nonlinear relations among positions, velocities (`v1`, `v2`), bounds (`A`, `B`, `V`, `ep`) and interval indices (`I1`, `I2`) can be satisfied; the outer negation turns the query into a proof‑obligation that no such counterexample exists.  Hence the solver must show unsatisfiability of a single quantified bit‑vector formula containing multiplication, division and several layered inequalities, a typical non‑linear arithmetic verification task with moderate term depth (≈21) and one quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5964.smt2",
    "description": "The benchmark encodes a safety verification condition for the “bouncing‑ball‑simple’’ hybrid system from KeYmaera.  It asserts that, under the given initial values (height h = 0, velocity v = 16) and the quadratic dynamics of a falling ball (terms such as t·t, t·v, t·u etc.), there exists a time ts₁ within the interval \\([0, t₀]\\) that satisfies all evolution constraints and makes the derived expression \\((h + …)\\) non‑negative.  Thus the problem is a non‑linear bit‑vector verification query with a single existential quantifier, several bilinear multiplications and a relatively deep term structure (depth 19), which makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548485.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑systems model of a traffic intersection (the “safe‑intersection” example from KeYmaera).  The formula asserts, after translating the continuous dynamics (positions x, velocities v, accelerations A, braking B, time bounds ts, ep, etc.) into 32‑bit bit‑vector arithmetic, that there is **no** assignment to the existential time variable ts2613uscore0 that violates the safety invariant (e.g., that the two cars’ positions remain separated given the bounds v1, v2 ∈ [0,V], A,B ≥ 0, and the kinematic constraints involving multiplication and division).  The problem is a non‑linear bit‑vector verification task with a single existential quantifier, several coupled arithmetic operations (multiplication, division, addition), moderate term depth (21) and about twenty variables, making it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12517.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a one‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  The formula asserts, via a single existentially‑quantified time variable, that under a set of linear and non‑linear constraints on positions, velocities and parameters (expressed with 32‑bit bit‑vector arithmetic, including multiplication, division and squaring), a vehicle’s state (`xI`) must stay within a safe region; the final disjunction checks whether `xI` violates a derived bound.  The instance is a pure‑BV verification problem featuring non‑linear arithmetic and a modest number of variables but relatively deep term nesting (depth 24), which makes it challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live2.proof-node640.smt2",
    "description": "This instance encodes a safety verification condition from the Keymaera proof of the European Train Control System (ETCS). It asserts that no 32‑bit signed value *dollarnuscore0* can make the implication  \n\n  (vo > 0 ∧ ep > 0 ∧ b > 0 ∧ A ≥ 0) ⇒ (zo + (dollarnuscore0·ep·vo) ≥ puscore0dollarskuscore0 ∧ vo ≥ vo)  \n\nfalse; in other words, under the given positivity pre‑conditions the inequality involving a nested multiplication must always hold. The problem is a quantifier‑free BV check with a single existential quantifier and non‑linear (multiplied) bit‑vector arithmetic, which makes it a non‑linear arithmetic verification task despite the small number of variables and shallow term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node4261.smt2",
    "description": "The benchmark encodes a safety verification condition for the “one‑lane intersection” hybrid‑system example from KeYmaera.  It asserts (via a negated existential) that there is no value of the time variable `ts7uscore0` satisfying a conjunction of linear and non‑linear arithmetic constraints over 32‑bit bit‑vectors, which model vehicle positions, velocities, accelerations and safety bounds (e.g., `xI`, `v`, `A`, `B`, `V`).  The formula features a single quantifier, a let‑binding, and many non‑linear BV multiplications/divisions, making it a challenging non‑linear arithmetic/verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559749.smt2",
    "description": "The instance encodes a safety‑verification condition from the KeYmaera hybrid‑system benchmark “intersection‑example‑simple”. It asserts the negation of an existential witness for a time‑step \\(ts\\) that would satisfy a large conjunction of arithmetic constraints on 32‑bit variables representing positions, velocities, and parameters (A, B, V, ep, etc.), including non‑negativity, bounds, and a nonlinear relation \\(v^2/(2B)\\) that appears via bit‑vector multiplication and division. Thus the solver must prove that no such assignment exists, i.e., that the hybrid‑system invariant holds; difficulty stems from a single quantified variable, deep nesting (depth 21), and non‑linear bit‑vector arithmetic over 20 constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291616.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example” for safe traffic intersections).  It asks, via a single existentially‑quantified time variable, whether a set of non‑linear bit‑vector constraints—mixing additions, multiplications, a division, and relational checks on positions, velocities, timers and constants (A, B, V, ep)—can be satisfied; the outer negation means the solver must prove that no such witness exists.  The problem is thus a quantified BV verification task featuring nonlinear arithmetic, a moderate term depth (19) and a dense conjunction of ordering constraints, which makes it representative of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152045.smt2",
    "description": "The file encodes a single verification condition from the KeYmaera hybrid‑system prover that checks the safety of a simple vehicle‑intersection scenario.  It asserts (via a negated ∃‑quantifier) that there is no reachable state violating the invariant that the two cars’ positions (x1, x2) and velocities (v1, v2) stay within prescribed bounds while respecting acceleration limits (A, B) and a positive time horizon (ep), with nonlinear relationships such as v₁²/(2·B) appearing in the position update.  After being translated to 32‑bit bit‑vectors, the condition contains a single existential quantifier, several nonlinear multiplications/divisions, and deep term nesting, making it a challenging BV‑non‑linear arithmetic instance arising from industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5338.smt2",
    "description": "This instance encodes a safety‑verification condition from the KeYmaera hybrid‑systems benchmark “intersection‑example‑onelane”.  The formula states, in 32‑bit bit‑vector arithmetic, that no assignment to the time variable ts9 can violate a collection of non‑linear constraints on positions, velocities and other parameters (non‑negativity, upper bounds, quadratic terms such as vuscore², and mixed products involving A, B, ep, etc.), and that a disjunction over the control mode I1 must hold.  It is a single‑existential‑quantifier query with deep (≈23) term nesting and many non‑linear BV multiplications/divisions, making it a challenging industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732272.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑systems tool (the “intersection‑example‑simple” proof).  All variables are 32‑bit bit‑vectors and the formula asserts that no choice of the time variable ts3568uscore0 can violate a set of non‑linear constraints describing two cars’ positions (xI1, xI2), velocities (v1, v2), and parameters (A, B, V, ep) under the hybrid dynamics (multiplication, division and linear inequalities).  Thus the solver must prove the negated existential (i.e., show the VC is valid), a single‑quantifier, non‑linear arithmetic problem translated to BV with moderate term depth (≈20) and a handful of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99874.smt2",
    "description": "The formula is the negated existence of a time‑step variable that would violate a safety invariant for a simple traffic‑intersection hybrid system.  It encodes bounds on velocities (v1, v2), positions (x1, x2), acceleration parameters (A, B), a speed limit V and a deadline ep, together with non‑linear (multiplicative) update constraints on the state, and checks that under the assumed non‑negative parameters no reachable state can make the combined “unsafe” condition true.  Consequently the instance is a bit‑vector verification condition (BV‑encoded non‑linear arithmetic) generated by KeYmaera to prove safety of the intersection model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dynamic_reaction_to_static_bounds.proof-node849.smt2",
    "description": "The benchmark encodes a safety verification condition extracted from a KeYmaera hybrid‑system proof (dynamic reaction to static bounds). It asserts, after negating an existential, that for every 32‑bit time‑step `ts0` satisfying a set of linear and non‑linear (bit‑vector multiplication) inequalities over the parameters `a2`, `b`, `A`, `B`, `Tr`, `t1` and `v2`, a final inequality relating `v2`, `a2·t1` and `B·Tr` must hold. Consequently the solver must decide a quantified non‑linear bit‑vector formula with one existential quantifier (effectively a universal property) and several multiplications, making it a challenging industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347607.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system taken from the KeYmaera prover. It asserts (by negating an existential) that, under non‑negative bounds on positions, velocities (v1, v2), maximal speed V, and positive parameters A, B, ep, the continuous dynamics expressed with non‑linear bit‑vector arithmetic (multiplications, a division by a term involving B) cannot lead to a violation of the collision‑avoidance invariant (expressed by inequalities on the future positions xI1, xI2). The problem is a single‑quantifier BV formula featuring several non‑linear multiplications and a division, with deep term nesting (depth ≈ 20), making it a challenging instance for solvers that handle bit‑vector non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619900.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, for any choice of the time‑step variable ts, the kinematic updates for two vehicles – xI₁ = x₁ + v₁²⁄(2·B) and xI₂ = x₂ + v₂²⁄(2·B) – satisfy a collection of bounds (non‑negative velocities, upper bound V, positive accelerations A,B, and a deadline ep), and that the resulting positions respect a disjunction of safety predicates.  The solver must show that the existentially‑quantified conjunction of these nonlinear 32‑bit bit‑vector constraints is unsatisfiable, i.e., no counterexample to the safety property exists; the problem features a single quantifier, non‑linear multiplications and divisions, and a moderate term depth (≈21) with about twenty variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267257.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover (the “intersection” example). It asserts the negation of an existential claim about a time stamp `ts1241uscore0` together with non‑linear relationships among 32‑bit variables representing positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`). The constraints enforce non‑negativity, bounded velocities, and a collision‑avoidance inequality of the form `xI2 > x2 + v2²/(2·B)`, together with auxiliary conditions on auxiliary variables; the whole formula is a single quantified assertion over bit‑vectors with multiplications, a division, and a term depth of 20. Consequently, the instance tests BV solvers on a non‑linear, quantified verification problem typical of hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264965.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of an intersection (the “simple intersection” example from KeYmaera).  The formula asserts, via a single existential quantifier, that there is no assignment to the time variable ts1230 that simultaneously satisfies a collection of nonlinear arithmetic constraints over 32‑bit bit‑vector variables representing velocities (v1, v2), accelerations (A, B), positions (x1, x2), a global speed bound V, and a time horizon ep.  The constraints express bounds such as non‑negative speeds, acceleration limits, braking distance calculations (involving multiplication and division), and ordering of positions, and the outer negation checks unsatisfiability to prove the safety property.  The instance is a quantifier‑free BV encoding of a nonlinear hybrid‑system invariant, with moderate term depth (20) and a single quantified block, making it a typical industrial verification check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3896.smt2",
    "description": "This benchmark encodes a safety verification condition from the Keymaera hybrid‑system proof of an adaptive cruise‑control controller (the “dccs‑example”).  The formula asserts, via a single existential quantifier over a time‑step variable, that under the continuous dynamics (quadratic velocity terms, divisions by 2·B, and linear constraints on positions x₁, x₂, velocities v₁, v₁′, and parameters A, B, ε) no reachable state can violate the distance‑safety bound expressed by a series of inequalities.  It is translated to 32‑bit bit‑vector arithmetic, featuring non‑linear multiplications and divisions, a deep term nesting (depth 22), and thus poses a challenging quantifier‑free‑BV solving task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682405.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example‑simple” proof).  The formula asserts, via a single existentially‑quantified time variable ts, that under a set of linear bit‑vector constraints on positions (x₁, x₂), velocities (v₁, v₂), constants A, B, a maximum speed V and a deadline ep (all 32‑bit vectors), no reachable state can violate the safety invariant (e.g., vehicles staying within bounds and not colliding).  The instance is a pure BV encoding of a non‑linear arithmetic VC, with moderate term depth (≈20) and a single quantifier, making it a typical industrial hybrid‑system safety check rather than a large‑scale combinatorial problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551039.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a road intersection (the “safe‑intersection” example from KeYmaera).  It asserts, via a single existential quantifier over a time‑step variable, that under a set of linear and non‑linear bit‑vector constraints on positions, velocities (v1, v2), accelerations (A, B), and a safety margin (ep), a collision‑free invariant holds; the outer “not” turns the problem into checking the unsatisfiability of the negated VC.  The formula features non‑linear multiplication (v2·v2), division by a doubled acceleration term, numerous signed comparisons, and a quantifier‑alternation‑free but deeply nested structure (max term depth 20), making it a challenging BV non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48996.smt2",
    "description": "The formula encodes a safety verification condition extracted from a KeYmaera proof for a one‑lane intersection scenario.  It asserts that there is **no** 32‑bit time value `ts110uscore0` for which a conjunction of non‑linear bit‑vector constraints (bounds on velocity `v`, acceleration `A`, limits `V`, `B`, a positive epsilon, and quadratic terms like `v·v` and `vuscore4dollarskuscore75·vuscore4dollarskuscore75`) holds, i.e. it checks that a potential unsafe state (expressed by the inequality `xI > x + v·v/…`) cannot be reached.  The problem is a hybrid‑system verification VC with non‑linear BV arithmetic, a moderate number of variables (12) but deep nesting (term depth 22) and several multiplications/divisions, making it a challenging instance for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289727.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system “intersection” model (from KeYmaera).  It asserts that there is **no** assignment to the time variable `ts1350uscore0` satisfying a conjunction of 32‑bit bit‑vector constraints that capture non‑negative bounds on velocities `v1`, `v2`, positions `x1`, `x2`, parameters `A`, `B`, a quadratic term `v2*v2/(2*B)`, and ordering relations required for a safe crossing.  The formula contains a single existential quantifier, a moderate term depth (21) and non‑linear BV arithmetic (multiplication and division), making it a non‑linear arithmetic verification problem with a relatively compact but non‑trivial constraint set.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174997.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the KeYmaera “intersection‑example‑simple”).  It asserts that there is **no** choice of a time‑step variable `ts815_0` (bounded between 0 and `t815_0`) for which the updated velocity `v1 – B·ts815_0` leaves the admissible range `[0,V]` or violates the stopping‑distance inequality  \n`xI1 > x1 + v1²/(2·B)` while the other state bounds (`0 ≤ v2 ≤ V`, `A≥0`, `B>0`, `V>0`, `ep>0`, etc.) hold.  The formula is a single existential quantifier over bit‑vectors, with non‑linear multiplications/divisions and moderate term depth, typical of industrial hybrid‑system invariant proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node403505.smt2",
    "description": "The file encodes a safety verification condition generated by the KeYmaera hybrid‑systems prover for a simple traffic‑intersection scenario.  It asserts that there is **no** 32‑bit bit‑vector value for the time variable `ts1901uscore0` that simultaneously satisfies a collection of linear and non‑linear arithmetic constraints on velocities, positions and parameters (e.g., `bvmul A ts1901uscore0`, `bvmul B ts1901uscore0`), together with bounds such as `0 ≤ v1,v2 ≤ V`, `A,B ≥ 0`, and a positive safety margin `ep`.  The problem is a quantified bit‑vector check with a single existential quantifier, non‑linear multiplication of variables, and moderate term depth, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5980.smt2",
    "description": "This instance encodes a verification condition for a simple hybrid‑system model of a bouncing ball. It asserts that, starting from height 0 and upward velocity 16 (both 32‑bit bit‑vectors), there is **no** choice of a time instant ts₁ within a bounded interval \\([0,t₁]\\) that satisfies the ball’s kinematic equation (including a quadratic term for gravity) together with the safety constraints that height and velocity remain non‑negative and respect given bounds. The formula consists of a single existential quantifier over a 32‑bit variable, a conjunction of linear and quadratic bit‑vector arithmetic constraints, and a final disjunction on the sum \\(t₁+ t_u\\), making it a moderate‑size BV verification problem with depth‑19 terms but no quantifier alternations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392295.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems prover for a simple vehicle‑intersection scenario.  It asserts—via a single existentially‑quantified time variable—that, given bounds on positions (x1,x2), velocities (v1,v2), accelerations (A,B) and a maximum speed (V), the computed stopping distances (v²⁄(2·B)) and related linear inequalities can never be satisfied simultaneously, i.e. a collision cannot occur before the deadline (ep).  The problem is a nonlinear bit‑vector verification task with moderate size (19 constants) but non‑linear multiplications, a division, and a nesting depth of 19, making it a typical industrial safety‑VC encoded as BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166425.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection’’ hybrid‑system example used in KeYmaera.  It asserts (via a negated existential) that there is **no** time‑step `ts769uscore0` that can violate a set of linear and non‑linear BitVec constraints describing bounds on velocities (`v1`, `v2`), acceleration parameters (`A`, `B`), a safety margin `V`, and positional relations such as `xI1 > x1 + v1²/(2·B)` while all variables remain non‑negative and within prescribed limits.  The formula features a single existential quantifier, nested let‑bindings, and several multiplications/divisions of 32‑bit vectors, making it a non‑linear BV verification problem typical of industrial hybrid‑system proof obligations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5963.smt2",
    "description": "The instance encodes a verification condition for the “bouncing‑ball” hybrid system, translated from the KeYmaera proof into 32‑bit bit‑vector arithmetic. It asserts (after negating an existential) that for every possible intermediate time ts1 the quadratic relations of the ball’s position and velocity (e.g., huscore2 = 5·t² + v·t) satisfy a collection of bounds (non‑negativity of heights, time limits, velocity limits) together with the initial conditions h = 0 and v = 16. The problem is a non‑linear BV verification query with a single quantifier, many multiplications (quadratic terms), deep nesting (depth 19), and thus challenges solvers that handle quantified non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2228.smt2",
    "description": "The file encodes a single verification condition taken from a KeYmaera hybrid‑system proof (node 2228 of *vsl.proof*).  It asserts, after negating an existential quantifier over the time variable `ts2uscore1`, that a conjunction of non‑linear bit‑vector constraints (bounds, non‑negativity, and algebraic relations involving products, squares and divisions of the 32‑bit variables A, B, ep, v1, vsl, xsl, …) must hold for all admissible values; the final disjunction expresses the required safety invariant.  The problem is therefore a non‑linear arithmetic verification query with a quantified bit‑vector formula, featuring deep term nesting (depth 19) and several multiplications/divisions, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361630.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a vehicle intersection (the “safe‑intersection” example from KeYmaera).  The formula asserts, under bounds on velocities v₁,v₂ (0 ≤ vᵢ ≤ V), positive acceleration limits A,B and a time horizon ep, that the stopping distance computed as xᵢ + vᵢ²/(2·B) exceeds the current position xᵢ, i.e. each vehicle can brake in time; this is expressed with non‑linear bit‑vector arithmetic (multiplication of variables, division) and a single existential quantifier over a time variable ts.  The instance therefore tests a non‑linear BV safety invariant, featuring many conjuncts, deep term nesting (depth 21) and mixed arithmetic, making it a challenging verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267053.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example‑simple” from KeYmaera).  It asserts, using 32‑bit bit‑vector arithmetic, that under a set of linear and non‑linear constraints on velocities (v1, v2), accelerations (A, B), positions (x1, x2, xI1, xI2) and a time interval (ts1240uscore0 ≤ t1240uscore0), the system cannot reach a state violating the safety invariant (e.g., the approaching vehicle’s position exceeds a bound derived from the other vehicle’s motion).  The formula is a single negated existential quantifier, involving nested conjunctions, multiplications and a division, which makes it a non‑linear bit‑vector verification problem with moderate term depth (19) and a handful of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272436.smt2",
    "description": "This instance is a safety‑verification condition derived from the KeYmaera hybrid‑systems prover for a simple road‑intersection scenario. It asserts, using 32‑bit bit‑vector arithmetic, that under given bounds on velocities (v1, v2), accelerations (A, B), a positive time horizon (ep) and the relationship between positions (x1, x2) and their derivatives, there does **not** exist a timestamp ts that satisfies a conjunction of equalities and inequalities representing a potential safety violation; the formula is a single existential quantified block preceded by a negation. The problem contains 19 bit‑vector variables, a moderate term depth of 19, and only one quantifier (no alternations), but encodes non‑linear arithmetic (products of variables) translated into bit‑vectors, which can be challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254296.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple traffic‑intersection scenario. It asserts (via a negated existential) that no values of the time variables ts1182uscore0, t1182uscore0 and the system parameters (positions x1, x2, velocities v1, v2, constants A, B, V, ep, etc.) can satisfy a collection of linear and non‑linear 32‑bit bit‑vector constraints—non‑negativity of parameters, bounds on velocities, a quadratic term (v2·v2)/(2·B) representing distance covered, and ordering relations that model the hybrid dynamics. The problem is essentially a bounded‑model‑checking / verification task with one quantified block, mixed arithmetic (multiplication, division) and a moderate term depth, which makes it a challenging bit‑vector non‑linear arithmetic benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287914.smt2",
    "description": "This instance encodes a verification condition from the Keymaera hybrid‑system verifier for a “safe intersection” scenario.  It asserts, via a single existentially‑quantified time variable, that a collection of 32‑bit bit‑vector constraints—mixing linear relations, non‑linear multiplications, a division, and numerous ordering predicates on variables representing positions, velocities, and parameters—cannot be satisfied, i.e., the safety property must hold.  The formula features a deep term structure (depth 20), a mix of arithmetic and relational operators, and a single quantifier alternation, making it a challenging non‑linear bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601561.smt2",
    "description": "This instance encodes a safety verification condition from the KeYmaera hybrid‑systems tool, translated into 32‑bit bit‑vector arithmetic. It asserts (the negation of) the existence of a time stamp `ts2857uscore0` that simultaneously satisfies a collection of signed inequalities and non‑linear relationships (multiplications and a signed division) among parameters such as velocities (`v1`, `v2`), distances (`A`, `B`), and a bound `V`, while also respecting positivity constraints on `A`, `B`, `V` and a deadline `ep`. The solver must prove unsatisfiability of this quantified formula, i.e., that no counterexample to the safety property (the intersection scenario) exists; the presence of non‑linear bit‑vector arithmetic and a quantifier makes the check non‑trivial despite a moderate number of variables and term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348040.smt2",
    "description": "The benchmark encodes a safety verification condition for the “intersection‑example” hybrid system used in KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts that, for all admissible time steps ts, the positions \\(x_1,x_2\\) of two vehicles (with velocities \\(v_1,v_2\\) bounded by a common speed limit \\(V\\)) remain safely separated—expressed via non‑linear constraints involving products \\(v_i·v_i\\), divisions and linear bounds on auxiliary parameters \\(A,B,ep\\). The formula is a negated existential (hence an unsat check) containing a single quantifier, several non‑linear BV operations, and a moderate term depth (20), making the instance a challenging bit‑vector verification problem rather than a pure arithmetic or SAT‑style test.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389810.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera.  It asserts—via a negated existential— that there exists no time ts where the state variables (positions xI1, xI2, velocities v1, v2, and parameters A, B, V, ep) satisfy a collection of non‑linear constraints: non‑negativity and upper‑bound V for the velocities, positivity of the parameters, and safety‑margin inequalities that involve quadratic terms (v1², v2²) divided by a linear expression (2·B).  The problem is thus a bounded‑model‑checking style verification of a hybrid‑system invariant, translated to 32‑bit bit‑vector arithmetic; its difficulty stems from the single existential quantifier combined with deep (depth 21) non‑linear BV multiplications/divisions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193953.smt2",
    "description": "This benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example used in the KeYmaera prover.  The formula asserts, via a single existential quantifier over a 32‑bit time variable, that a set of arithmetic constraints—non‑negative bounds on velocities (v1,v2), a speed limit V, positivity of parameters A, B, ep, and a quadratic update law `xI1 > x1 + v1²/(2·B)` together with ordering constraints on the two cars’ positions (xI1, xI2, x1, x2)—cannot be satisfied; the whole statement is negated, so the SMT query checks that no counterexample exists.  The problem therefore tests bit‑vector reasoning with non‑linear (multiplicative and division) terms and a single quantifier, featuring moderate-sized term depth (≈21) and 18 declared constants, making it a representative industrial verification instance for hybrid‑system safety.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349276.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a simple traffic‑intersection hybrid system, translated into 32‑bit bit‑vector arithmetic.  The formula asserts that, given initial positions x₁, x₂, velocities v₁, v₂, and non‑negative acceleration/deceleration bounds A, B together with a speed limit V and a time horizon ep, there is **no** time ts (0 ≤ ts ≤ t) at which the computed positions (using the non‑linear terms v₁·v₁/(2·B) and v₂·v₂/(2·B)) would violate the required separation – i.e., the safety distance is always respected before the deadline.  The instance features a single existential quantifier, deep (≈21) term nesting and non‑linear bit‑vector multiplications, making it a non‑linear BV verification problem of moderate size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292487.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example‑simple” proof).  All state variables (positions x₁, x₂, velocities v₁, v₂, constants A, B, a bound V, etc.) are represented as 32‑bit bit‑vectors, and the property to be proved is expressed as the negation of an existential witness (time ts₁₃₆₅) that would violate a set of linear and non‑linear constraints (including multiplications, a division, and several ordering bounds such as non‑negativity, upper bound V, and a collision‑avoidance inequality).  Thus the solver must decide the unsatisfiability of a quantified, non‑linear bit‑vector formula with moderate depth (≈20) and about twenty variables, typical of industrial hybrid‑system verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559637.smt2",
    "description": "The instance encodes a safety verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic.  It asserts that no valuation of the existential time variable `ts2666_0` can violate a chain of nonlinear constraints (multiplications, a division, and several order relations) that model bounds on positions, velocities, and system parameters (e.g., `A`, `B`, `V`) under the assumption that all quantities are non‑negative and respect the hybrid dynamics of a road‑intersection scenario.  The formula consists of a single quantified block (¬∃ …) with deep (depth 22) non‑linear BV terms, producing a ∀‑style safety check that is challenging for solvers because of the combination of quantifiers, nonlinear arithmetic, and the relatively large number of bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node93152.smt2",
    "description": "This instance encodes a safety verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple”.  It asserts (by negating an existential) that there is **no** 32‑bit time value `ts430uscore0` for which a set of linear and non‑linear (multiplication of a variable with the time) bit‑vector constraints—capturing non‑negative parameters `A`, `B`, `V`, `ep`, initial positions/velocities `x1`, `x2`, `v1`, `v2`, and mode indices `I1`, `I2`—can simultaneously satisfy the hybrid‑system dynamics and violate the bounded‑velocity safety invariant (`v1, v2 ≤ V`).  The problem is a single‑existential, quantifier‑free BV formula with moderate term depth (19) and a handful of nonlinear multiplications, making it a typical industrial verification benchmark that tests BV solvers’ ability to handle non‑linear arithmetic and intricate conjunctive safety constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node150970.smt2",
    "description": "This instance encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera.  The formula asserts (after negating an existential witness) that, under a set of linear and non‑linear bounds on velocities, accelerations (variables A, B), a maximal speed V, and a positive safety margin ep, the positions xI1, xI2 computed after a time step ts satisfy the required separation inequalities (e.g., xI1 > x1 + v1²/(2·B) and xI2 < x2).  The problem is thus a bounded‑model‑style safety check for a hybrid system, expressed as a single quantified bit‑vector assertion with moderate depth (≈20) and a handful of variables, but involving non‑linear multiplications that make it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54847.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a one‑lane intersection scenario: it asserts that there is **no** 32‑bit time value `ts113uscore0` for which a vehicle’s position `xI` can violate a bound expressed in terms of other positions (`x`, `xuscore4dollarskuscore88`), velocities (`v`), and parameters (`A`, `B`, `V`, `ep`).  The condition is formulated as a quantified bit‑vector formula with non‑linear arithmetic (products and divisions of 32‑bit variables), numerous linear inequalities and equalities, and a final disjunction that captures the unsafe region (`xI < … ∨ xI > …`).  Because it mixes multiplication/division with bit‑vector semantics and contains a single existential quantifier over a deep term (depth 24), the instance is a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190266.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a traffic intersection (the “intersection‑example” from KeYmaera).  After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts that there is **no** assignment to the time variable `ts884uscore0` (and the related state variables) that simultaneously satisfies a set of bounded non‑linear constraints—including products such as `A*ts884uscore0`, a quadratic term `v1*v1/(2*B)`, and several linear inequalities on positions (`xI1`, `xI2`) and velocities (`v1`, `v2`)—while violating the safety invariant that the vehicle positions remain within prescribed limits.  The presence of multiplication, division and a quantified bit‑vector variable makes the instance a challenging non‑linear BV verification problem typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673414.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera proof of a “safe‑intersection” hybrid‑system example. The goal is to show that, under a set of linear and non‑linear bounds on 32‑bit bit‑vector variables (including squares bvmul v₁ v₁, bvmul v₂ v₂, and products bvmul A t), the negated condition is unsatisfiable; formally it checks the unsatisfiability of a single quantified formula that combines arithmetic inequalities ( bvsgt, bvsge, bvsle ) with additions, multiplications and signed divisions. The instance features one existential quantifier, 19 declared bit‑vectors, deep term nesting (depth 21) and a mixture of linear and non‑linear constraints, making it a representative industrial non‑linear arithmetic verification problem translated to the BV logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551029.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier for a simple traffic‑intersection scenario, translated into 32‑bit bit‑vector arithmetic. It asserts, via a negated existential quantifier over a time variable, that no assignment can satisfy a conjunction of signed inequalities and non‑linear expressions (multiplications, a division and a linear combination involving the parameters A, B, V, ep and vehicle variables) that would violate the required bounds on positions, velocities and indices. Thus the instance checks the unsatisfiability of a quantified BV formula containing non‑linear arithmetic, a typical challenge for industrial‑scale verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704546.smt2",
    "description": "The instance encodes a safety‑verification condition for the “safe intersection” hybrid‑system example from KeYmaera.  It asserts (as a negated existential) that there is no assignment to a time variable ts (and the associated 32‑bit variables modelling positions x₁,x₂, velocities v₁,v₂, constants A,B,V, ep, etc.) that simultaneously satisfies the hybrid‑system dynamics (e.g., x₁ > x₁₀ + v₁²⁄(2·B), v₂ – B·ts ≥ 0, all variables bounded between 0 and V, and positivity of B, A, V, ep) while violating the safety predicate.  The formula uses non‑linear bit‑vector arithmetic (multiplication, division) together with a single existential quantifier, 19 32‑bit variables, and a term depth of 20, making it a moderately sized, quantifier‑rich BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682293.smt2",
    "description": "This benchmark encodes a KeYmaera safety verification condition for a vehicle‑intersection hybrid system, translated into 32‑bit bit‑vector arithmetic.  The formula asserts that, assuming non‑negative constants A, B, V, ep and initial bounds on variables I₁, I₂, xI₁, xI₂, v₁, v₂, every reachable state respects the interval [0,V] for the linear‑non‑linear expressions bvmul A·t + v₂₁₈₄₀ and ‑B·t + v₁₈₄₀, while also satisfying timing constraints (0 ≤ ts ≤ t ≤ ep).  The instance features a single existential quantifier, non‑linear bit‑vector multiplication, and a moderate depth of nested arithmetic and relational constraints, making it a challenging industrial non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251841.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts, in 32‑bit bit‑vector arithmetic, that there is **no** reachable state (quantified over the time variable ts1171uscore0) satisfying a set of nonlinear constraints: non‑negative positions and velocities, bounds v₁,v₂ ≤ V, positive safety parameters A, B, ep, the braking‑distance condition xI2 > x2 + v₂²/(2·B), and several equalities fixing model constants (e.g., I₁ = I₂ = 2).  The problem therefore tests a solver’s ability to handle quantified, non‑linear bit‑vector arithmetic with moderate term depth and a mixture of arithmetic, comparison, and logical operators typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17882.smt2",
    "description": "This benchmark encodes a safety‑verification condition from the KeYmaera proof of a one‑lane intersection, translated into 32‑bit bit‑vector arithmetic. It states that there must not exist a time‑stamp `ts39uscore1` satisfying a conjunction of linear bounds on positions, velocities, and timing constants together with a quadratic relation `vuscore2dollarskuscore62 * vuscore2dollarskuscore62` (and a division by `2*B`). Thus the instance is a single‑existential, non‑linear BV verification problem that mixes many linear inequalities with one non‑linear multiplication, giving a moderate term depth (24) and posing a typical challenge for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39751.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a one‑lane traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It states that for all admissible time values ts (bounded between 0 and t₁) and under a collection of linear and quadratic constraints on the vehicle’s position xI, speed v, maximal speed V, accelerations A, B, and a safety margin ep, the position must stay outside an unsafe interval – expressed as a disjunction of two bit‑vector inequalities involving non‑linear terms such as (v·v) and (ts·B)².  The problem therefore is a non‑linear bit‑vector verification task with one existential quantifier, deep arithmetic terms (max term depth 24) and a moderate number of variables, which makes it hard for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349694.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “safe‑intersection” example from KeYmaera).  It asserts that there is **no** choice of a timestamp `ts1629uscore0` (the existential variable) for which a collection of nonlinear bit‑vector arithmetic constraints—relating positions `x1`, `x2`, velocities `v1`, `v2`, acceleration `A`, braking `B`, a safety bound `V`, and a time‑margin `ep`—can simultaneously hold; the constraints essentially state that the vehicles would violate a minimum‑distance invariant.  The benchmark therefore tests BV solvers on a single‑quantifier, non‑linear arithmetic verification problem with moderate term depth (21) and several dozen quantified arithmetic expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294860.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts the negation of an existentially quantified time‑step `ts` together with a large conjunct of 32‑bit bit‑vector constraints that model vehicle positions, velocities (`v1`, `v2`), acceleration `A`, braking `B`, and a quadratic braking distance term `v2·v2/(2·B)`, all required to stay within given bounds (`0 ≤ … ≤ V`, `ep > 0`, etc.).  The problem is thus a quantified non‑linear bit‑vector verification query, featuring one existential quantifier, many arithmetic multiplications/divisions, and a deep term structure (depth 18), which makes it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532235.smt2",
    "description": "The benchmark encodes a safety verification condition from the Keymaera hybrid‑system proof “intersection‑example‑simple”, modeling a road‑intersection scenario.  It asserts that there is **no** 32‑bit time value `ts2518_0` for which a set of arithmetic constraints—non‑negative velocities `v1`, `v2` bounded by a maximum speed `V`, positive accelerations `A`, `B`, a quadratic braking‑distance term `v1·v1`, and relational position inequalities such as `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`—can all hold together with auxiliary index conditions (`I2 = 2`).  Thus the instance is a single‑existential quantified BV problem containing both linear and non‑linear (multiplicative) relations, moderate term depth (21) and a handful of variables, typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673526.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a vehicle intersection (the “KeYmaera” intersection example).  It asserts the negation of an existential time `ts3210uscore0` such that, under bounds `0 ≤ v1,v2 ≤ V`, non‑negative parameters `A,B,ep`, and kinematic relations like  \n\n```\nxI1 > x1 + v1²/(2·(2·B)) ,   xI2 > x2 + v2²/(2·(2·B))\n```  \n\nthe system would violate a safety predicate (e.g. be too close to the crossing).  The formula is expressed in BV‑logic, using bit‑vector multiplication and signed division to model the non‑linear arithmetic, and contains a single quantifier; the combination of non‑linear bit‑vector arithmetic and the quantified time variable makes the instance challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node367444.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the KeYmaera “intersection‑example‑simple” proof).  The formula asserts the negation of an existential reachability query over a 32‑bit time variable, requiring that, for non‑negative speeds v1, v2 and parameters A, B, the future positions xI1, xI2 satisfy quadratic motion bounds (e.g., xI1 > x1 + v1² · ts/(2·B)) while all variables stay within the interval [0,V] and a global deadline ep.  The problem is thus a bounded‑reachability/invariant check involving non‑linear bit‑vector arithmetic (multiplication and signed division) with one quantifier, making it a difficult BV instance for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/to_left-node1505.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (a train‑control case study) after translation to 32‑bit bit‑vectors.  It asserts that, under a set of linear bounds on variables such as velocity (v), distance (d), braking coefficient (b), and time (t₂), no assignment to the existential time variable ts₂ can make a non‑linear inequality (involving products like b·t₂², v·t₂ and quadratic terms v² – d²) violate the safety bound expressed by d ≤ b·t₂ + v.  The problem is a purely BV satisfiability check with a single existential quantifier, deep nesting (term depth 18) and many non‑linear multiplications, which makes it a hard instance for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node14896.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover (binary driver example). It asserts the negation of an existentially quantified formula over a 32‑bit time variable, consisting of a large conjunction of non‑linear bit‑vector constraints: inequalities, squares (e.g., v·v ≤ ...), and mixed products of constants and variables (e.g., b·ts8 + v ≥ 0). The task is to prove the VC universally true (i.e., show the asserted formula is unsatisfiable), which requires reasoning about many intertwined multiplications and comparisons over 15 32‑bit variables, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11162.smt2",
    "description": "This benchmark encodes a safety verification condition taken from the KeYmaera proof of a one‑lane intersection hybrid‑system model.  After translating the continuous dynamics into 32‑bit bit‑vector arithmetic, it asserts that for every admissible time ts23 (subject to bounds on speeds, accelerations A, B, a maximal speed V and a positive epsilon ep) the vehicle’s position xI must stay outside a forbidden interval defined by a quadratic expression (involving the term ?v_3² / (2·B)).  The solver is asked to prove that the negation of this existential condition is unsatisfiable, i.e., the safety invariant holds for all reachable states; the instance features non‑linear bit‑vector operations and deep term nesting, which contribute to its difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194936.smt2",
    "description": "This instance encodes a safety verification condition extracted from the KeYmaera hybrid‑systems proof “intersection‑example‑simple” and translated into 32‑bit bit‑vector arithmetic.  The formula asserts, via a single existentially quantified time variable, that under a collection of non‑negative parameters (v₁, v₂, A, B, V, ep) and relational constraints (e.g., v₂ = V, I₂ = 0, signed inequalities on positions xI1, xI2, and a nonlinear expression bvmul A·ts + v₁), no reachable state can violate the safety predicate (which reduces to a disjunction on the integer flags I₁ and I₂).  The problem features non‑linear bit‑vector arithmetic (multiplication, division) and a deep term structure (depth 21), making it a challenging industrial verification benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190475.smt2",
    "description": "The instance is a safety‑verification condition extracted from the KeYmaera hybrid‑system model of a simple road‑intersection scenario. It asserts that, under a collection of linear and non‑linear relationships between 32‑bit quantities (velocities v₁,v₂, bounds V, constants A,B, positions x₁,x₂, and a time variable ts), together with positivity and range constraints, there exists **no** admissible time ts that violates the safety predicate; the formula is expressed as the negation of an existential quantifier over ts with many conjunctive constraints involving addition, multiplication and signed division. The query features a single quantified variable but a deep term structure (depth 20) and non‑linear bit‑vector arithmetic, making it a challenging instance for BV solvers despite the modest number of declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2442.smt2",
    "description": "The formula is a safety‑verification condition generated from a KeYmaera hybrid‑systems proof (the “vsli‑alert” example).  It asserts, via a negated existential over a time variable `ts0uscore1`, that no reachable state of the (translated) system can make the Boolean flag `alerted$2$` become 1 while a number of non‑linear constraints on the system’s parameters and state variables (positions `x…`, velocities `v…`, constants `A,B,D,ep`, and a minimum speed `vmin`) are satisfied.  The constraints involve quadratic terms (e.g., `v^2`, `x^2`), integer divisions, and a mixture of lower/upper bounds, all encoded as 32‑bit bit‑vector operations.  The instance therefore encodes a non‑linear arithmetic invariant‑checking problem with a single existential quantifier, a deep term structure (depth 26) and many mul/div operations, which together make the BV solving task challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172682.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of two vehicles approaching an intersection (the “intersection‑example‑simple” from KeYmaera).  It asserts that, for all admissible parameters (non‑negative speeds v₁,v₂ bounded by a maximal speed V, non‑negative acceleration A, positive safety distance B, and a positive time horizon ep), the braking distance computed as v₁²/(2·B) plus the current position x₁ exceeds the intersection point xI₁ while the other vehicle’s position stays before its own intersection point xI₂, even after a time step ts (where the new velocity is A·ts+v₂).  The formula is a single quantified (∃ ts) bit‑vector constraint with non‑linear multiplications and a signed division, making it a non‑linear BV verification problem of moderate size (19 variables, depth‑20 terms).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37008.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑onelane” case) as a quantifier‑free bit‑vector formula with a single existentially‑quantified time variable. The asserted property states that, under a collection of linear bounds on the 32‑bit variables (e.g., non‑negativity of A, B, V, ep and ordering constraints among timestamps) and a non‑linear relationship involving a quadratic term v·v divided by 2·B, there cannot exist a time ts₈₂ that satisfies all the conjuncts; equivalently, the original hybrid‑system invariant must hold. The instance features non‑linear BV arithmetic (multiplication, division), a moderate depth of nested terms (depth 23) and an existential quantifier, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269426.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a road intersection (a KeYmaera proof obligation). It asserts, via a quantified bit‑vector formula, that no execution time ts can satisfy a conjunction of non‑linear arithmetic constraints over positions, velocities, and timing parameters (all represented as 32‑bit unsigned integers), while also respecting bound and positivity conditions. The problem is a single existential‑quantified BV query with many non‑linear multiplications/divisions and deep nested Boolean structure, typical of industrial hybrid‑system verification benchmarks and therefore challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270758.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts, via a negated existential over a time variable `ts1261uscore0`, that no reachable state can violate a set of signed 32‑bit arithmetic constraints linking vehicle positions, velocities (`v1`, `v2`), distances (`x1`, `x2`), and system parameters (`A`, `B`, `V`, `ep`).  The condition involves non‑linear operations (multiplication, division) and a mixture of signed inequalities, making the bit‑vector instance challenging despite its modest size (18 constants, depth 20) and a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254500.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example‑simple” from KeYmaera).  It asserts that there is **no** assignment to a time‑step variable `ts1183uscore0` that satisfies a collection of arithmetic constraints describing the kinematics of two vehicles (positions `x1`, `x2`, velocities `v1`, `v2`, accelerations `A`, `B`) together with mode‑switch conditions and bounds (`V`, `ep`).  The formula uses 32‑bit bit‑vector arithmetic with non‑linear multiplications, a single existential quantifier, and nested Boolean structure, which makes it a non‑linear BV verification problem of moderate size but with a non‑trivial quantifier‑alternation and term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488451.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, under a set of linear and non‑linear arithmetic constraints on 32‑bit quantities such as velocities (v1, v2), maximal speed (V), acceleration parameters (A, B), and a time variable (ts 2318), no reachable state violates the required separation (expressed by a collection of BV inequalities).  The formula is a negated existential (i.e., a universal property) that involves non‑linear multiplications and a signed division, yielding a modest‑size but non‑linear BV problem with a single quantified variable and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531822.smt2",
    "description": "The file encodes a safety verification condition for the “safe‑intersection” hybrid‑system example used in the KeYmaera tool chain.  After translating the continuous dynamics into 32‑bit bit‑vector arithmetic, the VC asserts that for all admissible time variables (`ts2516uscore0`) the linear‑and‑non‑linear relations among positions, velocities (`v1`, `v2`), accelerations (`A`, `B`) and bounds (`V`, `ep`) satisfy a series of non‑negative and ordering constraints; the outer `not (exists …)` formulation forces the solver to prove the condition universally (i.e., the existential witness cannot exist).  The problem features a single quantified variable, deep (depth ≈ 20) nested let‑expressions, and non‑linear operations (`bvmul`, `bvsdiv`) over 32‑bit bit‑vectors, which together make it a challenging industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603436.smt2",
    "description": "This instance encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera). It asserts the negation of an existential witness for a time variable that would violate a collection of bounds on velocities, accelerations, positions and a collision‑avoidance distance, all expressed as 32‑bit bit‑vector arithmetic with non‑linear multiplications (e.g., v₂·v₂ and B·t). The problem is thus a non‑linear BV verification query with a single quantified variable and several conjunctive linear‑ish constraints, making the solving challenging due to mixed arithmetic and the need to reason about bit‑vector overflow‑free ranges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46589.smt2",
    "description": "This benchmark encodes a safety verification condition for a one‑lane traffic‑intersection hybrid system (the “intersection‑example‑onelane” from KeYmaera).  The single assertion states that, for all admissible values of the time variable ts104uscore0, a set of linear and non‑linear bit‑vector constraints on positions, velocities, accelerations (A, B, V, v, vu) and derived quantities cannot lead to the vehicle’s position xI falling inside a critical interval (expressed by the final disjunction).  The problem is thus a universally‑quantified safety check involving non‑linear BV arithmetic (multiplications, divisions) with a moderate number of variables (13) but a deep term nesting (depth 26) and one existential quantifier inside a negation, which makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732160.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a vehicle intersection: given non‑negative bounds \\(V\\) on velocities, positive acceleration parameters \\(A, B\\) and a positive time horizon \\(ep\\), it asserts that no reachable state (quantified over a time step \\(ts\\)) can violate the positional safety inequalities \\(xI1 > x1 + v1^2/(2B)\\) and \\(xI2 > x2 + v2^2/(2B)\\) while respecting all bound constraints. The formula is expressed in bit‑vector logic, using non‑linear arithmetic (squared velocities and divisions) and a single existential quantifier, resulting in a moderately deep term structure (depth 21) with 18 variables, which makes it a challenging BV‑based verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171004.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that there is **no** choice of a time‑stamp `ts791` (the only existential variable) for which a set of non‑linear safety constraints can be violated: all physical parameters (`v1`, `v2`, `A`, `B`, `V`, `ep`) must be non‑negative, the stopping‑distance relation `xI1 > x1 + v1²/(2·B)` and similar bounds on positions (`xI2 < x2`) must hold, and the computed position update `?v_0 = A·ts791 + v1` stays within `[0,V]` while the overall time stays below `ep`.  \n\nThe problem is a bounded‑model‑checking/verification VC translated to 32‑bit bit‑vectors, featuring a single existential quantifier, non‑linear arithmetic (quadratic term via `bvmul` and division), and a moderate depth (≈21) with 18 declared constants, making it a typical industrial‑scale benchmark for bit‑vector‑based nonlinear arithmetic solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345732.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example‑simple” from Keymaera).  It asserts that, given non‑negative parameters A, B, V and bounded velocities v1, v2 (0 ≤ v1,v2 ≤ V) together with position variables x1, x2, the computed future positions (using quadratic terms v1² and v2² divided by 2·B) always remain ahead of the current positions and respect the timing bounds expressed by the existentially quantified time ts1609uscore0.  The formula is a negated existential, so the solver must prove the implication holds for all admissible values.  The encoding uses 32‑bit bit‑vectors with several multiplications, a division and deep nested arithmetic constraints, making it a non‑linear bit‑vector verification problem with one quantifier and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54859.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a single‑lane intersection (the “Keymaera” benchmark).  It asserts, over 32‑bit bit‑vectors, that under a set of linear bounds on time, speeds, positions and parameters (A, B, V, v, ep, x, xI, …) and non‑linear relationships (quadratic terms such as A·t², v², B·v⁴), a vehicle’s position xI must lie outside a forbidden interval defined by two quadratic expressions.  The formula is a single quantified (∃ ts) implication wrapped in a negation, with deep (depth 23) nested arithmetic, many multiplications/divisions and one existential quantifier, making it a challenging BV non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node363688.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that under the given bounds on velocities (v1, v2), accelerations (A, B), a maximum speed V and a time horizon ep, no reachable state (quantified by ts1692) can violate the safety inequality that involves the non‑linear terms \\(v_i^2/(2B)\\) (expressed with bit‑vector multiplication and signed division).  The formula is a single quantified (∃ ts) check wrapped in a ¬, so the solver must prove unsatisfiability of a counterexample; the difficulty stems from the 32‑bit non‑linear arithmetic, several signed comparisons, and a term depth of 21 with one quantifier‑alternation level.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node3023.smt2",
    "description": "This benchmark encodes a safety verification condition extracted from the KeYmaera proof of the “ETCS‑essentials” hybrid‑system model (node 3023).  The formula asserts the negation of an existential witness for a 32‑bit variable `ts1uscore0` that would satisfy a large conjunction of non‑linear bit‑vector constraints (multiple multiplications, divisions and linear inequalities over parameters such as `v`, `b`, `A`, `m`, `z`, `ep`).  Hence the solver must prove the unsatisfiability of a non‑linear arithmetic fragment with a single quantifier, a relatively deep term structure (depth 17) and many `bvmul` occurrences, which makes the instance challenging for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node265077.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts that there is **no** assignment to the time‑parameter `ts1231uscore0` (and consequently to the state variables such as positions `x1`, `x2`, velocities `v1`, `v2`, accelerations `A`, `B`, etc.) that violates a set of linear and non‑linear bit‑vector constraints expressing non‑negativity, bounded speeds, acceleration limits, and a collision‑avoidance predicate (`bvsgt xI2 (bvadd x2 …)`).  Solving this instance amounts to proving the safety invariant of the intersection model; the presence of a single existential quantifier, nested BV multiplications/divisions, and a term depth of 20 makes it a non‑trivial non‑linear arithmetic challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269538.smt2",
    "description": "The formula is the negated verification condition of a KeYmaera hybrid‑system proof (the “safe intersection” example). It asserts that there is **no** 32‑bit time value `ts1254uscore0` for which a collection of non‑linear bit‑vector constraints—non‑negative velocities `v1`, `v2`, bounds by a maximum `V`, linear relationships among positions `x1`, `x2`, and a quadratic term `bvmul v2 v2` divided by `2*B`—can be satisfied together with several invariant inequalities (e.g., `xI1 < x1`, `xI2 > x2 + …`). Proving unsatisfiability therefore verifies the safety property; the instance is difficult because it mixes quantification with non‑linear BV arithmetic (multiplication, division) and deep nesting (term depth 20) despite having only one existential quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251490.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (the “simple intersection” example from KeYmaera). It asserts, in 32‑bit bit‑vector arithmetic, that under non‑negative bounds on velocities (v1, v2), acceleration (A), braking coefficient (B), and a maximal distance (V), no time instant ts in the interval [0, t] can satisfy the combined constraints (including the non‑linear relation xI2 > x2 + v2²/(2 B) and the position update v1 + A·ts) that would violate the safety limits; the formula is the negation of an existential counterexample. The problem features a single existential quantifier, mixed linear and non‑linear bit‑vector operations (multiplication, division, and quadratic terms), and several nested arithmetic inequalities, making it a typical industrial BV non‑linear verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476763.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  After translating the real‑valued dynamics to 32‑bit bit‑vectors, the formula asserts (via a negated existential) that no reachable state exists in which the time‑step variable ts7110 violates the combined bounds on positions xI1, xI2, velocities v1, v2, and parameters A, B, V, ep (all required to be non‑negative and satisfy several non‑linear relations such as xI1 > x1 + v1²/(2 B) and v1 ≤ V).  Hence the solver must prove unsatisfiability of the quantified bit‑vector constraints, a non‑linear BV problem with a single existential quantifier, moderate term depth (22) and many arithmetic comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267578.smt2",
    "description": "The benchmark encodes a safety‑verification condition taken from the KeYmaera hybrid‑systems prover (the “intersection‑example” for a traffic‑intersection scenario).  A set of 32‑bit bit‑vector variables models positions (x1, x2, xI1, xI2), velocities (v1, v2), accelerations (A, B) and timing parameters (ts1243uscore0, ep, V).  The asserted formula states, under a collection of non‑negativity, bound and dynamical relations (including non‑linear multiplications bvmul and a division bvsdiv), that **no** existential timestamp can be found that violates the safety constraints (e.g., positions remain within limits and the elapsed time stays below a deadline).  Consequently the instance is a quantifier‑free‑BV verification problem with one existential quantifier (negated) and moderate term depth (≈20) that tests the solver’s ability to handle non‑linear arithmetic and quantifier reasoning in an industrial‑style safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189817.smt2",
    "description": "The formula encodes a safety verification condition for a hybrid‑system model of two vehicles approaching an intersection (the “intersection‑example” from the KeYmaera benchmark).  All continuous dynamics (positions x₁, x₂, velocities v₁, v₂ and parameters A, B) are represented as 32‑bit bit‑vectors, and the asserted negated existential quantifier states that there is **no** time ts ≥ 0 at which the vehicles violate a set of nonlinear constraints (quadratic terms v₁·v₁, bounds by V, positivity of A, B, ep, etc.) while respecting the transition‐relation ?v₀ = A·ts+v₁₍₃₉₈₎ and ?v₁ = –B·ts+v₂₍₃₉₈₎.  The solver is asked to prove unsatisfiability, i.e., that the safety invariant holds for all reachable states; the instance features a single existential quantifier, moderate term depth (20) and a mixture of linear and non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node167638.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula asserts that, under given bounds on velocities ( v₁, v₂ ), accelerations ( A, B ), a maximum speed V, and a positive time horizon ep, no choice of the intermediate time variable ts775₀ can lead to an unsafe state where the computed positions (e.g., xI₁ = x₁ + v₁²/(2·B) ) violate the prescribed ordering and range constraints.  The instance is a quantifier‑free‑after‑elimination BV problem featuring non‑linear multiplications and a signed division, with a single existential quantifier and moderate term depth, making it a typical industrial verification challenge for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288026.smt2",
    "description": "This benchmark encodes a safety verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, translated from real arithmetic to 32‑bit bit‑vector arithmetic.  The formula asserts that, for all admissible initial states (non‑negative positions xI₁, xI₂, velocities v₁, v₂ bounded by a maximum V, and positive parameters A, B, ep), there exists a time‑step ts such that the continuous dynamics (given by the non‑linear updates v₁+ A·ts and v₂–B·ts) stay within the safety bounds and respect a deadline ep; the condition is wrapped in a negated existential to be refuted.  The instance is challenging because it combines a quantified bit‑vector variable with non‑linear arithmetic (multiplication, division) and deep nested expressions, leading to a single, highly coupled assertion over 19 variables with term depth 19.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171462.smt2",
    "description": "The file encodes a single verification condition from the KeYmaera hybrid‑systems benchmark “safe intersection”, translated into 32‑bit bit‑vector arithmetic. It asserts that no assignment to the auxiliary time variable ts794₀ can satisfy a conjunction of non‑linear constraints (quadratic products, a division, and several linear bounds) describing vehicle speeds, distances, and braking limits, together with positivity and range conditions on parameters such as A, B, V and an overall time bound ep. Thus the solver must prove unsatisfiability of an existentially quantified, deeply nested, non‑linear BV formula – a typical industrial‑style safety‑verification problem that is challenging because of the mixed arithmetic, the single quantifier, and the high term depth (≈21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node23307.smt2",
    "description": "The instance encodes a safety verification condition for the “one‑lane intersection” hybrid‑system model used in the KeYmaera benchmark suite: it asserts that there is **no** 32‑bit value ts52 (a time variable) that simultaneously satisfies a collection of range constraints on positions, velocities (v, V), acceleration (A, B), and a derived quadratic term (vuscore²)/(2·B) together with ordering requirements (e.g., xI > x + … , bvsle ts52 t92, bvsle ts52 ep).  \n\nThe formula is a single existential quantifier over ts52, wrapped in a negation, and involves non‑linear bit‑vector arithmetic (multiplications, a division, and a negation), several linear inequalities, and a depth‑22 term structure, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476753.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover for a simple intersection scenario.  The formula asserts (via a single existentially‑quantified time variable) that, under a collection of non‑negative and bounded constraints on positions, velocities and interval parameters (including non‑linear terms such as v₁·v₁ and B·ts), a contradiction cannot be reached—i.e., the negated existence of a counterexample must be unsatisfiable.  The problem is therefore a bit‑vector verification task with moderate size (18 variables, depth 20) but featuring non‑linear arithmetic translated into 32‑bit BV operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479629.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example”).  After translating the continuous dynamics into 32‑bit bit‑vector arithmetic, it asserts—via a negated existential—that no assignment to the auxiliary time variable ts can violate a set of non‑linear constraints involving non‑negative parameters (A, B), bounded velocities (v₁, v₂ ≤ V), and quadratic expressions (v₁·v₁/(2·B)), while also respecting ordering constraints on positions (x₁, x₂, xI₁, xI₂).  The formula contains a single existential quantifier, a handful of deep (depth ≈ 20) non‑linear BV terms (multiplication, division, addition), and thus tests the solver’s ability to handle bit‑vector non‑linear arithmetic arising from a real‑world hybrid‑system verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268901.smt2",
    "description": "This benchmark encodes a safety verification condition for a simple road‑intersection hybrid system (the “intersection‑example” from KeYmaera) that has been translated into 32‑bit bit‑vector arithmetic. The formula asserts the non‑existence of a time step `ts1250uscore0` that simultaneously satisfies a host of bounds (e.g., all variables non‑negative and ≤ V) and nonlinear relationships among positions, velocities and accelerations (multiplications, a division, and additions) together with a positive safety distance `ep`. Thus the solver must prove an unsatisfiable existential query involving a single quantifier, several non‑linear BV operations, and moderate term depth, typical of non‑linear arithmetic verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250605.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection taken from the KeYmaera tool. It asserts (via a negated existential) that there exists a time step `ts1166uscore0` and 32‑bit vector values for positions, velocities (`v1`, `v2`), bounds (`A`, `B`, `V`) and a safety margin `ep` that satisfy a collection of linear and non‑linear (multiplicative) inequalities describing the system’s dynamics and safety requirements; the outer negation makes the query an unsatisfiability check. The instance features a single existential quantifier, moderate term depth (≈20) and non‑linear bit‑vector arithmetic, typical of industrial verification problems from the Preiner‑keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54892.smt2",
    "description": "The instance encodes a safety‑verification condition for the “intersection‑example‑onelane’’ hybrid system from KeYmaera: it asserts that there is **no** 32‑bit time instant `ts48` for which a series of linear, quadratic and division constraints on the state variables (`xI`, `x`, `A`, `B`, `V`, `v`, `ep`, …) can be satisfied.  The formula contains a single existential quantifier over a bit‑vector, many non‑linear multiplications (e.g., `A·t85²`, `B·vuscore²`), a division by the constant 2, and deep nested arithmetic expressions (depth 23), making it a challenging BV non‑linear arithmetic verification problem.  The overall goal is to prove the unreachable region of the state space (i.e., the safety invariant) for the traffic‑intersection model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490353.smt2",
    "description": "The instance encodes a safety verification condition from the KeYmaera hybrid‑system benchmark “intersection‑example‑simple”, asking whether there exists a time step `ts2328uscore0` that violates the intended collision‑avoidance property of two vehicles.  All variables (positions, velocities, accelerations, time bounds, and mode indicators) are represented as 32‑bit bit‑vectors and are constrained by non‑negativity, upper bounds (`V`), and nonlinear arithmetic (`bvmul`, `bvsdiv`) that model the vehicles’ motion and timing; the formula asserts that under these assumptions no violating assignment exists.  Consequently the solver must decide a quantified bit‑vector formula with a moderate term depth (≈20) and a mix of linear and nonlinear constraints, typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287501.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system prover: it asserts that no assignment of the quantified time variable `ts1339uscore0` can make a set of arithmetic constraints (non‑negative bounds on velocities `v1`, `v2`, a maximum speed `V`, positive parameters `A`, `B`, and a collision‑avoidance inequality `xI2 > x2 + v2²/(2·B)`) hold simultaneously. The constraints are expressed in 32‑bit bit‑vector arithmetic with nonlinear operations (multiplication and signed division) and a single quantifier, giving a relatively deep term structure (depth 20) and a mix of linear and non‑linear relationships that make the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node688713.smt2",
    "description": "This benchmark is a **verification condition** taken from the KeYmaera proof of a “safe‑intersection” hybrid‑system example, translated into 32‑bit bit‑vector arithmetic.  It asserts that there exists a time instant `ts3302uscore0` for which the linear expressions  \n  `?v_0 = –B·ts + v1′` and `?v_1 = A·ts + v2′` (derived from accelerations `A`, `B` and initial velocities) lie within the speed limit `[0, V]`, while a collection of positivity and bound constraints on the parameters (`A ≥ 0`, `B > 0`, `V > 0`, `ep > 0`, etc.) and fixed index values (`I1 = I2 = 2`, `I2′ = 2`) must also hold.  The solver’s task is to determine whether these combined arithmetic constraints are satisfiable, i.e., whether the safety property of the intersection model can be violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151296.smt2",
    "description": "The formula is a safety verification condition for the “safe‑intersection” hybrid‑system example used in the KeYmaera proof suite. It asserts that, under non‑negative bounds on the vehicle speeds \\(v_1,v_2\\) (both ≤ \\(V\\)), positive acceleration/deceleration parameters \\(A,B\\), and a positive time horizon \\(ep\\), it is impossible to find a timestamp \\(ts\\) (the existential variable) that satisfies the linear‑and‑non‑linear bit‑vector constraints encoding the braking distance inequality  \n\\(x_{I1} > x_1 + \\frac{v_1^2}{2B}\\), the ordering \\(x_{I2}<x_2\\), and the evolution \\(x_{I1}=x_1 + A\\cdot ts + v_{2,221}\\).  \n\nThus the instance checks that no unsafe state (both cars crossing simultaneously) is reachable; it contains a single quantifier, several multiplications and a division, 19 BV‑32 variables, and terms of depth 21, making it a moderate‑size industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17304.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a one‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  The formula asserts, via a negated existential quantifier over a time stamp ts37, that no reachable state violates a set of nonlinear relationships among vehicle positions, velocities, and timing parameters (e.g., non‑negativity, bounds V, B, A, and quadratic expressions involving vuscore²/B).  The problem is a quantifier‑free bit‑vector encoding with a single ∃‑quantifier, deep arithmetic (multiplication, division) and a term depth of 23, making it a challenging industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node20269.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑systems model of a one‑lane traffic intersection (the “intersection‑example‑onelane” from KeYmaera).  It asserts the negation of an existential statement over a 32‑bit time variable `ts44uscore0`, requiring a conjunction of linear and non‑linear bit‑vector inequalities (including multiplications, a division, and several bounds on positions, velocities and parameters such as `A`, `B`, `V`, `ep`).  The goal is to show that no assignment to the variables can satisfy all those constraints, i.e., that the safety property holds; the problem is challenging because it mixes quantified reasoning with non‑linear BV arithmetic and has a relatively deep term structure (depth 22) despite a modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368539.smt2",
    "description": "This benchmark encodes a safety verification condition for the “safe intersection” hybrid‑system example from KeYmaera.  The formula asserts (via a negated existential) that no reachable state violating the distance‑invariant (expressed with non‑linear constraints on positions x₁,x₂, velocities v₁,v₂, a safety bound V and timing parameters) exists; all arithmetic is encoded as 32‑bit bit‑vectors with multiplications and divisions.  The instance therefore tests a non‑linear arithmetic‑heavy verification problem, featuring a single quantified block, deep term nesting (depth 20) and a moderate number of bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368193.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a simple two‑vehicle intersection scenario (the “intersection‑example” from KeYmaera).  Signed 32‑bit bit‑vector variables model positions, velocities, braking acceleration \\(B\\), a distance bound \\(V\\) and a time bound \\(ep\\); the core constraints assert that, for any admissible time \\(ts\\), the stopping distance \\(v^2/(2B)\\) plus the current position stays within the safe corridor \\([0,V]\\) for both vehicles, together with basic bounds on all parameters.  The instance checks unsatisfiability of an existentially quantified time that would violate these inequalities, which yields a non‑linear bit‑vector formula containing multiplications, a division, many nested signed comparisons, and a single quantifier, making it a relatively deep (term‑depth 20) non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151408.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example‑simple” from KeYmaera).  It asserts, via a single existential quantifier over a time variable, that no reachable state can violate a set of nonlinear constraints on positions, velocities, accelerations (A, B), and a safety margin ε – expressed as 32‑bit bit‑vector arithmetic with multiplications, a division, and several inequality bounds (e.g., v₁≥0, v₁≤V, A≥0, B>0, xI₁ > x₁ + v₁²/(2·B), xI₂ < x₂).  The problem is thus a bounded‑model‑checking / verification task that features non‑linear BV operations, a quantified variable, and relatively deep term nesting, making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node95128.smt2",
    "description": "The benchmark encodes a verification condition for a hybrid‑system safety proof (the “safe intersection” example from KeYmaera).  Under pre‑conditions that the velocities v1, v2 are non‑negative and bounded by a common limit V, the parameters A, B are non‑negative, and indices I1 = I2 = 2 with ordering constraints xI1 < x1, xI2 < x2, the formula asserts that there is **no** choice of a time variable ts (represented by the quantified bit‑vector ts439uscore0) satisfying the linear‑in‑ts update equations  \n\n v1′ − B·ts ∈ [0,V] and v2′ + A·ts ∈ [0,V]  \n\ntogether with 0 ≤ ts ≤ ep.  The instance therefore checks unsatisfiability of a single existential quantifier over 32‑bit bit‑vectors with several non‑linear multiplications (bv‑mul), moderate term depth (19) and a handful of variables, making it a non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48396.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems proof “intersection‑example‑onelane”, asking whether there exists a concrete valuation of the time variable `ts108uscore1` that can violate a set of numeric bounds on positions, velocities and timers.  The formula is the negation of an existential witness and consists of a conjunction of linear and non‑linear (quadratic) 32‑bit bit‑vector constraints, including multiplications (`v·v`, `vuscore4…·vuscore4…`), a signed division, and many inequality relations (≥ 0, ≤ V, etc.).  Solving it amounts to proving that no such counterexample exists; the difficulty stems from the single‑quantifier, deep (depth 23) non‑linear arithmetic over fixed‑size bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node173665.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts the negation of an existential formula over a time‑step variable, describing constraints on positions x₁, x₂, velocities v₁, v₂, and parameters A, B, V, ep that capture bounds on acceleration, speed limits, and a timing window; the formula combines linear and non‑linear bit‑vector arithmetic (multiplication, signed division, and comparisons).  The instance therefore tests a BV‑solver’s ability to discharge a quantified safety VC with moderate term depth (20) and a handful of variables but with mixed arithmetic and a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node602111.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  The formula asserts that, under non‑negative parameters A, B, positive bounds V and ep, and with vehicle positions and velocities (xI1, xI2, v1, v2) satisfying the geometric and kinematic constraints (including the non‑linear term v2²/(2·B)), there is **no** time ts for which the safety predicate fails – the model is expressed as a single existential quantifier over ts and a large Boolean combination of BV arithmetic.  The problem therefore tests BV solvers on a non‑linear arithmetic verification task with several 32‑bit variables, mixed linear and multiplicative constraints, and a moderate term depth (≈21), making it a representative industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node30209.smt2",
    "description": "The benchmark encodes a safety verification condition for a one‑lane traffic‑intersection hybrid system (the “intersection‑example‑onelane” from KeYmaera).  A single existentially quantified time variable `ts66uscore0` is used in a long implication that imposes non‑negativity, upper‑bounds and relational constraints on 32‑bit position, velocity and acceleration variables (e.g., `xI`, `v`, `A`, `B`), including several non‑linear multiplications and divisions.  Thus the instance is a **verification** problem that checks whether the encoded hybrid‑system invariant ever fails; its difficulty stems from deep (depth 23) non‑linear bit‑vector arithmetic, many conjuncts, and a single quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264195.smt2",
    "description": "The benchmark encodes a safety‐verification condition for the “intersection‑example” hybrid system used in KeYmaera (a safe crossing scenario).  It asserts, via a single existential quantifier over a time variable `ts1226`, that there is **no** reachable state in which the velocities `v1`, `v2` (bounded by `V`), the acceleration `A`, the braking coefficient `B`, and the positions `xI1`, `xI2` violate the safety inequalities (e.g., non‑negative values, `xI2` staying ahead of `x2 + v2²/(2·B)`, and the linear evolution `A·ts + v1_290` staying within `[0,V]`).  The problem is a bit‑vector encoding of a non‑linear arithmetic verification condition, featuring multiplication, division and several nested comparisons, with modest depth (≈21) but many inter‑dependent variables, making it a typical industrial verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node14050.smt2",
    "description": "The benchmark encodes a safety‑lemma from the KeYmaera verification of a European Train Control System: it asserts that no assignment to the system variables (speeds, distances, parameters A, b, d, m, z, …) can satisfy a complex set of non‑linear bit‑vector constraints that would violate the safety condition. The formula is a negated existential (i.e., a universally quantified safety property) involving many multiplications, squares, and divisions over 32‑bit vectors, with deep term nesting (depth 23) and a large amount of arithmetic interference, making the instance a hard non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550289.smt2",
    "description": "This benchmark encodes a safety verification condition for the KeYmaera hybrid‑system model of a road‑intersection scenario. The formula asserts (via a negated existential) that there is no time‑step value `ts1232uscore0` for which a collection of nonlinear bit‑vector constraints—bounds on velocities `v1`, `v2`, parameters `A`, `B`, and relational conditions such as `bvadd (bvmul A ts) v2` and a division `bvsdiv (bvmul v2 v2) (bvmul 2 B)`—can all hold while violating the safety invariant (e.g., `xI2 > x2 + …`). The instance therefore tests the ability of BV solvers to handle a single quantifier together with non‑linear arithmetic (multiplication/division) and deep term nesting, which are typical sources of difficulty in industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561425.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The formula states, via an existentially quantified time variable, that the positions and velocities of two vehicles (represented by bit‑vector variables such as x1, x2, v1, v2) evolve under linear dynamics with acceleration bounds A and B, and asserts that a collision‑avoidance invariant (e.g., a minimum separation distance) is violated only if impossible constraints hold.  The encoding uses non‑linear bit‑vector arithmetic (multiplications, a division, and several linear inequalities) together with a single quantifier and a maximal term depth of 20, making it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290206.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  The asserted formula is the negation of an existential check over a time variable ts1352₀, stating that, under a collection of bounds (e.g. 0 ≤ v₁,v₂ ≤ V, A,B,ep > 0) and geometric relations (positions xI₁, xI₂, x₁, x₂, and a quadratic term bvmul v₂ v₂ / (2·B)), either a specific position equality holds or a timing inequality involving ts1352₀ is satisfied; the formula also fixes the mode identifiers I₁=I₂=2.  The problem is a bounded‑model‑checking/verification task that mixes linear and non‑linear (multiplication/division) bit‑vector arithmetic, featuring a single existential quantifier inside a negation and a relatively deep term structure (depth ≈ 20), which makes it a challenging BV non‑linear verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45106.smt2",
    "description": "The instance encodes a safety verification condition for the “intersection‑example‑onelane” hybrid‑system model from KeYmaera.  It asserts (via a single existential quantifier) that there is **no** assignment to the time variable `ts101uscore0` and the other 32‑bit bit‑vector state variables (positions, velocities, bounds A, B, V, etc.) that simultaneously satisfies a collection of non‑linear arithmetic constraints – notably quadratic terms (`v*v` and `vuscore4dollarskuscore58*...`) and divisions – together with the usual non‑negativity and ordering conditions for time and physical quantities.  The problem is thus a non‑linear arithmetic verification task translated into 32‑bit BV, featuring one quantifier, several nested let‑bindings, and a moderate term depth (24) that can make bit‑vector solving challenging.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node198058.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a vehicle intersection (the “intersection‑example” from KeYmaera).  It asserts the negation of an existential formula over a 32‑bit time variable `ts927uscore0`, together with a large conjunction of arithmetic constraints on velocities (`v1`, `v2`), bounds (`V`, `A`, `B`), positions (`x1`, `x2`, `xI1`, `xI2`) and other parameters.  The constraints enforce non‑negativity, upper bounds, and relational inequalities derived from the continuous dynamics (e.g., quadratic terms `bvmul v1 v1` and divisions by `B`), as well as timing conditions involving `ep`.  The check‑sat query therefore asks whether the safety condition can be violated; unsatisfiability would prove the intersection is safe.  The problem is a non‑linear arithmetic verification encoded in 32‑bit bit‑vectors, with a single existential quantifier, deep term nesting (depth 21), and several multiplications/divisions, making it a challenging BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365013.smt2",
    "description": "The benchmark encodes a safety verification condition for the “intersection‑example‑simple” hybrid‑system model from KeYmaera, checking that two vehicles with non‑negative speeds v1, v2 bounded by a common limit V and moving with positive parameters A, B remain within safe positional bounds before a deadline ep.  The condition is expressed as a quantified bit‑vector formula (32‑bit BV) that contains non‑linear arithmetic (quadratic terms v1·v1, v2·v2 and a signed division), several linear order constraints and a single existential variable ts1699uscore0.  The instance tests BV solvers on a relatively small but non‑linear, quantified encoding typical of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10280.smt2",
    "description": "This instance checks the safety of a hybrid‑system model (the “binary_driver” benchmark from KeYmaera) by encoding a verification condition as a single quantified bit‑vector formula. The asserted formula states that **no** 32‑bit value `ts3uscore1` can satisfy a conjunction of linear and non‑linear constraints—positivity of variables, bounds on products and divisions, and quadratic relationships such as `v·v – d·d ≤ …`—all expressed with BV arithmetic (multiplication, division, addition, subtraction). The problem therefore amounts to proving unsatisfiability of an existential BV formula with deep non‑linear terms and several arithmetic comparators, which makes it a challenging non‑linear BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490015.smt2",
    "description": "The file encodes a safety verification condition from the KeYmaera hybrid‑system proof of a simple traffic‑intersection scenario. After translation to 32‑bit bit‑vectors, the formula states (under a single existential quantifier) a conjunction of non‑linear arithmetic constraints—multiplications of variables, a signed division, and numerous signed inequality bounds on positions, velocities, and parameters—together with auxiliary conditions such as non‑negativity and a fixed tolerance ep. The solver must decide the unsatisfiability of the negated existence claim, which is challenging because it combines quantified BV reasoning with non‑linear operations and a moderate number of variables (19) and term depth (20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node52492.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, via a negated existential quantifier over a time variable, that for all non‑negative parameters A, B, V, ε and for all bounded positions x₁,x₂ and velocities v₁,v₂ (all 32‑bit bit‑vectors), the linear and quadratic inequalities derived from the system dynamics cannot be simultaneously satisfied—i.e., a collision cannot occur.  The formula lives in quantifier‑free BV with non‑linear multiplication (bvmul) and several nested arithmetic constraints, making it a moderately sized (≈18 variables, depth 19) industrial‑level verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12481.smt2",
    "description": "This benchmark encodes a verification condition for the “one‑lane intersection” hybrid‑system model used in the KeYmaera suite: it asserts that no 32‑bit time value `ts26uscore0` can satisfy a large conjunction of safety constraints that involve non‑linear bit‑vector arithmetic (multiplications, a division, and many inequalities) together with fixed equalities such as `I1 = 2` and `I1uscore2dollarskuscore39 = 1`. The formula is a single existential quantifier wrapped in a negation, so the solver must prove the unsatisfiability of the existential witness, i.e., that the safety invariant holds for all reachable states. The problem is challenging because it combines quantified reasoning with non‑linear BV operations and a deep term structure (depth 24) despite having only a moderate number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347816.smt2",
    "description": "This instance encodes a verification condition from the KeYmaera hybrid‑system proof of a safe traffic‑intersection scenario.  It asserts, using 32‑bit bit‑vector arithmetic, that given non‑negative bounds V, A, B, ep and initial positions/velocities (x₁,x₂,v₁,v₂), the safety inequalities  \n\n xI₁ > x₁ + v₁² / (2·B) and xI₂ > x₂ + v₂² / (2·B)  \n\nhold together with interval constraints I₁ = I₂ = 2, and that a time variable ts1620uscore0 exists satisfying linear bounds and a non‑negative derived term ?v₁ = v₁·(−2·B·ts + v₁).  The formula thus checks a non‑linear arithmetic safety invariant (involving multiplication, division and a quantified time) within a bit‑vector encoding, featuring a single existential quantifier, deep term nesting (depth 21) and many conjuncts, making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252840.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, in 32‑bit bit‑vector arithmetic, that no assignment to the time variable `ts1175uscore0` can satisfy a conjunction of linear and non‑linear constraints (including multiplications, a signed division and several bounds on positions, velocities `v1`, `v2`, accelerations `A`, `B`, and a deadline `ep`).  The formula is a single existential quantifier over `ts1175uscore0` wrapped in a negation, so the solver must prove unsatisfiability of a non‑linear BV problem with moderate term depth (21) and many conjuncts, which is typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289202.smt2",
    "description": "This benchmark encodes a KeYmaera safety verification condition for a simple traffic‑intersection hybrid system, translated into 32‑bit bit‑vector arithmetic. The (negated) existential query asserts the existence of a time stamp `ts1347uscore0` together with concrete integer values for positions, velocities and parameters (`v1`, `v2`, `A`, `B`, etc.) that satisfy a collection of bounds (non‑negativity, upper limits `V`), a non‑linear relationship involving multiplication and division (`bvmul`, `bvsdiv`), and ordering constraints on the hybrid‑system state (e.g., `xI1 < x1`, `xI2 > x2 + v2*v2/(2*B)`). Proving the formula unsatisfiable amounts to showing the safety invariant holds; the problem is challenging because it combines a single quantified block with deep (depth 21) non‑linear bit‑vector terms and many intertwined inequality constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673088.smt2",
    "description": "This benchmark encodes a verification condition from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, translated into 32‑bit bit‑vector arithmetic.  It asserts (negated) that there exists a time stamp ts₀ satisfying a collection of nonlinear constraints: non‑negative constants A, B, V, ep; bounds on velocities v₁, v₂ and their squares divided by 2·B; safety inequalities such as xI₁ > x₁ + v₁²/(2B) and xI₂ > x₂ + v₂²/(2B); and temporal bounds linking ts₀, t₀, and ep.  The problem thus tests the ability of BV solvers to handle a single existential quantifier together with non‑linear multiplications and divisions, moderate term depth (19) and a handful of variables, making it a challenging industrial non‑linear arithmetic verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605043.smt2",
    "description": "The file encodes a safety verification condition for the “simple intersection” hybrid‑system example used in the KeYmaera tool suite.  All continuous variables (positions x₁,x₂, velocities v₁,v₂, accelerations A,B, timing parameters t, ts, etc.) are represented as 32‑bit bit‑vectors, and the asserted formula states that no choice of the time‑step ts (the existentially‑quantified variable) can satisfy a conjunction of linear and non‑linear (multiplication and division) arithmetic constraints that would make the unsafe predicate true (collision at the intersection).  Consequently the solver must prove unsatisfiability of the existential sub‑formula, a non‑linear BV verification problem with a deep term structure (depth 20) and a single quantifier, typical of industrial hybrid‑system VCs translated to bit‑vector logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node29839.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a single‑lane intersection (the “intersection‑example‑onelane” from KeYmaera).  The formula asserts the negation of the existence of a time instant `ts65uscore2` satisfying a collection of nonlinear bit‑vector constraints that model vehicle positions (`x`, `xI`), velocities (`v`, `V`), and parameters (`A`, `B`, `I1`, etc.), including quadratic terms (e.g., `v*v`) and divisions.  The solver must decide whether the encoded safety invariant holds; the instance is challenging because it contains a single quantified variable, deep nesting (term depth 23), and extensive non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node47513.smt2",
    "description": "The benchmark encodes a safety‑verification condition for the “safe intersection – one lane” hybrid‑system example from KeYmaera: it asserts that no assignment to the existential time variable `ts106uscore1` can satisfy a large conjunction of non‑linear arithmetic constraints (bounds on positions, velocities, times and derived quantities such as `v·v` or `vuscore4dollarskuscore69·vuscore4dollarskuscore69` divided by `2·B`).  All variables are 32‑bit bit‑vectors, so the original real‑valued polynomial constraints have been translated into bit‑vector arithmetic, producing a single‑quantifier, deep (depth 22) non‑linear BV formula that challenges solvers with multiplications, divisions and many inequality relations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal6-node8607.smt2",
    "description": "The file encodes a safety verification condition for the “train_goal6” hybrid‑system case study from KeYmaera.  After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the solver must show that no value of the time variable ts6 can satisfy a large conjunction of linear and quadratic inequalities that model non‑negative speeds, distances, acceleration limits, braking forces and other train‑control constraints (e.g., b ≥ 0, d ≥ 0, v² − d² ≤ … , ausc₄·ts6 + vusc₀ ≥ 0, etc.).  Hence the benchmark is a universally quantified (¬∃) non‑linear bit‑vector verification problem with many multiplications (≈21) and nested arithmetic, characteristic of industrial hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43393.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof). It asserts the negation of an existential‑quantified time variable ts₉₇ such that, under a collection of linear and quadratic 32‑bit bit‑vector constraints on positions, velocities, and timing parameters (e.g., \\(bvsge\\,v\\,0\\), \\(bvsgt\\,V\\,0\\), \\(bvsgt\\,xI\\,(x+\\frac{v·v}{2·B})\\)), the vehicle’s longitudinal coordinate xI must lie either below a computed quadratic bound ?v₂ or above a symmetric upper bound, thereby guaranteeing that the unsafe interval is never reachable. The instance uses non‑linear multiplication and division encoded as BV operations, with a moderate number of variables (13) but deep term nesting (depth 23), making it a challenging non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560442.smt2",
    "description": "This benchmark encodes a safety verification condition for the “intersection‑example” hybrid system used in KeYmaera.  The formula asserts that, under a collection of linear bounds on speeds (v1,v2), positions (x1,x2) and parameters (A,B), together with a non‑linear constraint involving a quadratic term (v2·v2) divided by (2·B), there is no choice of the time‑step variable ts2670uscore0 that violates the safety invariant (the negated existential).  The problem is therefore a quantifier‑free‑except‑for‑one‑existential BV encoding of a non‑linear arithmetic verification condition, featuring 20 32‑bit variables, a quadratic term, and a moderate term depth (≈21), which makes it representative of industrial hybrid‑systems verification challenges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488920.smt2",
    "description": "This benchmark encodes a safety‑property verification condition for the “intersection‑example” hybrid system (a traffic‑intersection scenario) that was originally proved in KeYmaera. The property is expressed as a single quantified assertion: the negation of an existential over the time variable `ts2319uscore0` together with a chain of linear and non‑linear bit‑vector constraints (e.g., `bvmul A ts`, `bvmul v1 v1`, `bvsdiv …`) that bound positions, velocities (`v1`, `v2`), accelerations (`A`, `B`) and enforce relational conditions such as `xI1 > x1 + v1²/(2·B)`. The solver must show the formula is unsatisfiable, i.e., the safety invariant holds. Difficulty arises from the combination of 32‑bit non‑linear arithmetic, a single quantified variable, and deep term nesting (max depth 22).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561875.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑systems verifier for a simple traffic‑intersection scenario, translated into 32‑bit bit‑vector arithmetic. The formula asserts (via a negated existential) that there is **no** choice of a time‑step variable `ts2679uscore0` for which the vehicle positions, velocities (`v1`, `v2`), accelerations (`A`, `B`) and derived quantities (e.g., `bvmul` and `bvsdiv` terms) simultaneously satisfy a set of linear and non‑linear inequalities describing the hybrid dynamics while violating the safety bound. The instance therefore tests quantifier elimination over bit‑vectors with mixed multiplication/division and many conjunctive constraints, a pattern that is known to be hard for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264307.smt2",
    "description": "This instance encodes a safety‑verification condition for a hybrid‑systems model of a vehicle intersection, translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential over a time variable `ts1227uscore0`, requiring that a set of non‑linear constraints (including products `A*ts`, `‑B*ts` and a term `v2*v2/(2*B)`) keep the state bounds `v1`, `v2` within a safety limit `V`, enforce positivity of parameters (`A,B,ep,V`) and respect a deadline `ep`. The problem therefore asks a BV solver to prove the universal property that no such `ts` can violate these arithmetic and ordering constraints, featuring a single quantifier block, moderate term depth (20) and a mixture of linear and non‑linear bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node295273.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple hybrid‑system model of a road intersection taken from the KeYmaera proof library.  It asserts, using 32‑bit bit‑vector arithmetic, that under a collection of linear inequalities (non‑negativity, bounds by a maximal speed V, ordering of positions) together with a non‑linear quadratic term `bvmul(v2,v2)` and a division, no choice of the existential time variable `ts1381uscore0` can falsify the invariant that the two vehicles remain within safe limits.  Thus the problem is a single‑quantifier, non‑linear bit‑vector safety‑verification query with moderate term depth and a handful of variables, typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551337.smt2",
    "description": "The formula is a safety‑verification condition extracted from a KeYmaera proof of a vehicle‑intersection scenario: it asserts that there is **no** 32‑bit timestamp ts2630uscore0 for which a collection of linear and non‑linear (multiplication, division) constraints on positions, velocities (v1, v2), acceleration A, braking distance B, and a time horizon ep can be simultaneously satisfied.  The constraints encode bounds (non‑negativity, upper limits V), relational conditions such as xI1 < x1, xI2 > x2 + (v2²)/(2·B), and the evolution equation A·ts + v2' ≥ 0, together with case distinctions on discrete variables (e.g., I1 = 2, I2 = 2).  Thus the instance checks the unsatisfiability of an existential counter‑example to the intersection safety property, featuring bit‑vector non‑linear arithmetic and a moderate term depth (≈20) that makes it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/controllability-lemma-disturbed.proof-node770.smt2",
    "description": "This benchmark encodes a controllability‑lemma from the Keymaera verification of a disturbed European Train Control System, checking that a certain quadratic inequality between the parameters v, d, b, u, m and z holds under a set of linear bounds.  The property is expressed as an ∃ t₀ ∀ ts₀ formula that combines non‑linear bit‑vector multiplications (e.g., t₀·t₀, v·v, d·d) with additions, a division by 2, and several ordering constraints, and the outer “not” asserts that no such t₀ can satisfy the universally quantified conditions.  The presence of one existential‑universal quantifier alternation, deep term nesting (depth 21), and many 32‑bit multiplications makes the instance a hard industrial‑style BV non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369759.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts the negation of an existential witness for a time ts in which two vehicles, whose positions x₁, x₂ and velocities v₁, v₂ are bounded by the constant V and parameters A, B, would violate a distance invariant expressed with non‑linear arithmetic (quadratic terms v·v and divisions).  The task is to prove unsatisfiability of this quantified BV formula, which features one existential quantifier, several nested conjuncts, and non‑linear bit‑vector operations, making it a moderately deep (depth ≈ 20) industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291850.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system traffic‑intersection model (the “intersection‑example” from KeYmaera). It asserts, via a single existential quantifier, that there exists a time `ts1361uscore0` and a set of 32‑bit variables (positions, velocities, constants such as A, B, V, ep) satisfying a collection of linear and non‑linear bit‑vector constraints (e.g., multiplications, a division, and numerous inequality bounds) that would violate the safety invariant. The problem is thus an industrial‑style BV verification query with a moderate term depth (21) and a mixture of arithmetic and relational constraints that make quantifier handling and non‑linear reasoning the main sources of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal3-node5717.smt2",
    "description": "This instance encodes a safety verification condition from the Keymaera train‑control case study, translated into 32‑bit bit‑vector arithmetic.  It asserts that no assignment to the time variable ts3 satisfies a large conjunction of range bounds (e.g., non‑negative variables, upper‑ and lower‑limits on ts3, ep, A, b) together with several non‑linear inequalities that involve quadratic terms such as (v·v – d·d) ≤ 2·b·(m – z) and mixed products of auscore, t3, vuscore, zuscore, etc.; the final condition is a disjunction between a state‑equivalence test and another quadratic inequality.  The problem is a single‑existential (negated) query containing many nested let‑bindings, a mixture of addition, multiplication, subtraction and unsigned division, and a relatively deep term structure (depth 21), making it a challenging non‑linear bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node169818.smt2",
    "description": "The benchmark is a verification condition generated by the KeYmaera hybrid‑system prover for a simple traffic‑intersection safety example; it has been translated to 32‑bit bit‑vectors and contains non‑linear arithmetic (a quadratic term bvmul(v1,v1) and a division by 2·B). The single‑quantifier assertion states that under the given bounds on speeds (v1, v2), positions (x1, x2, xI1, xI2), and parameters (A, B, V, ep) there is **no** choice of the time variable ts785uscore0 that can lead to a safety violation, i.e., the negated existential must be unsatisfiable. Consequently the instance checks a safety‑property of an industrial hybrid‑system model, and its difficulty stems from the combination of quantification, non‑linear bit‑vector arithmetic, and multiple range constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node155401.smt2",
    "description": "The file encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from the KeYmaera tool suite.  All real‑valued variables (positions, velocities, parameters A, B, V, etc.) are represented as 32‑bit bit‑vectors and combined with non‑linear operations (multiplication, division) to express constraints such as non‑negativity, a quadratic stopping distance \\(v^2/(2B)\\), and bounds on a time‑step \\(ts\\); the formula asserts that no value of \\(ts\\) can falsify the invariant that the leading vehicle’s position stays ahead of the following one.  The instance features a single existential quantifier, deep nested Boolean structure (depth 21) and several non‑linear BV terms, making it a non‑linear arithmetic verification problem that is challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631276.smt2",
    "description": "The benchmark encodes a safety verification condition for the “simple intersection” hybrid‑system example from KeYmaera. It asserts the negation of an existential formula over a time step ts, requiring that, under non‑negative bounds on positions (x₁,x₂), velocities (v₁,v₂), acceleration parameters (A,B), and a global speed limit V, the reachable positions xI₁ and xI₂ (computed with non‑linear terms v₁²/(2·B) and v₂²/(2·B)) stay ahead of the current positions and that a deadline ep is respected; additionally it forces I₂ to equal 2. The instance therefore checks unsatisfiability of a conjunction of linear and non‑linear bit‑vector arithmetic constraints (including multiplications and signed divisions), with a single quantifier and moderate term depth, making it a typical industrial verification problem for hybrid‑system safety.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/FTRM-entry-tang-feasible-node1796.smt2",
    "description": "The instance encodes a verification condition generated by the KeYmaera hybrid‑system verifier for the “FTRM entry tangential‑feasible” maneuver in a flight‑collision‑avoidance case study. It asks whether there exist 32‑bit positions h₁₀, h₂₀ that satisfy a set of nonlinear algebraic constraints—including quadratic equalities (e.g., (r·r)·r = d₁²+d₂²) and linear relationships between the variables x₁, x₂, d₁, d₂, and a time parameter—while also meeting a non‑negativity condition on a time bound. The formula is presented as the negation of an existential block, so the solver must prove unsatisfiability of the existential constraints; the presence of nested exists, non‑linear bit‑vector multiplication, and quadratic equations makes it a challenging BV‑non‑linear arithmetic benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548277.smt2",
    "description": "This benchmark is a safety verification condition extracted from the KeYmaera hybrid‑system model of a vehicle intersection.  It asserts, via a single existentially quantified timestamp `ts2612uscore0`, that a collection of linear and non‑linear 32‑bit‑vector constraints (involving positions `x1,x2`, velocities `v1,v2`, bounds `A,B,V`, and a small‑positive constant `ep`) cannot be satisfied; the outermost `not` therefore checks the unsatisfiability of a potential counter‑example.  The formula contains one quantifier, several multiplications and a division, 18 declared constants and a maximum term depth of 19, making it a non‑linear BV verification problem that is moderately sized but computationally challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606132.smt2",
    "description": "This benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  The formula asserts, via a single existentially‑quantified time variable, that a set of non‑linear 32‑bit arithmetic constraints on positions, velocities (v1, v2), accelerations (A, B) and safety margins (ep, V) can never be satisfied; the outer negation turns the check into a universal safety property.  The instance features non‑linear bit‑vector operations (multiplication, division) together with many bounded‑integer inequalities, a deep term structure (depth ≈ 20) and a single quantifier, making it a challenging industrial‑style VC for non‑linear arithmetic solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node362512.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a road intersection (the KeYmaera “intersection‑example‑simple” proof).  The formula asserts that **no** 32‑bit time value `ts1687uscore0` can violate a collection of arithmetic constraints that model vehicle positions (`xI1`, `xI2`), velocities (`v1`, `v2`), acceleration bounds (`A`, `B`), a speed limit `V`, and a horizon `ep`; the constraints involve non‑linear bit‑vector terms such as `v1*v1`, `v2*v2`, and divisions.  The problem is thus a quantifier‑free (apart from a single existential) bit‑vector safety‑invariant check with mixed linear/non‑linear arithmetic, a moderate term depth (20) and 19 declared constants, making it a representative industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288860.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems intersection scenario taken from the KeYmaera proof suite.  The formula asserts (by negating an existential over the time variable ts1346uscore0) that no reachable state can violate a set of bounds on positions (xI1, xI2), velocities (v1, v2), and parameters (A, B, V, ep), where the bounds involve non‑linear relationships such as products and a division of 32‑bit bit‑vectors.  The instance therefore tests SMT solvers on a universally quantified safety property with a single quantifier alternation, deep (≈20) term nesting, and mixed linear/non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live-range2.proof-node577.smt2",
    "description": "The file encodes a verification condition originating from the KeYmaera hybrid‑system proof of the European Train Control System (ETCS). It asserts (negated) that there exists a 32‑bit integer `dollarnuscore0` satisfying a set of signed‑greater‑zero constraints on several variables and a non‑linear inequality involving signed multiplication and addition (`z + (dollarnuscore0 * ep) * vo ≤ puscore0dollarskuscore0`). Thus the solver must decide the (un)satisfiability of a quantified bit‑vector formula that combines existential quantification, signed comparisons, and non‑linear BV arithmetic, a pattern that is known to be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53901.smt2",
    "description": "The benchmark encodes a safety verification condition extracted from a KeYmaera hybrid‑system proof about a single‑lane intersection (the “intersection‑example‑onelane”).  After translating the continuous dynamics into 32‑bit bit‑vector arithmetic, it asserts the negation of an existential formula over a time variable, containing non‑linear terms (e.g., v·v and A·t) together with numerous bounds (non‑negativity, upper limits V, ep, etc.) and relational constraints such as  xI > x + v²/(2·B).  The problem is thus a non‑linear arithmetic verification task with a single quantifier, moderate term depth (22) and 13 bit‑vector variables, which makes it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294748.smt2",
    "description": "The instance encodes a safety‑verification condition for a hybrid‑system model of a traffic intersection, taken from the KeYmaera proof “intersection‑example‑simple”.  The formula asserts (via a negated existential) that no reachable state violates a set of linear‑and‑non‑linear (multiplication, division) constraints over 32‑bit bit‑vectors representing positions (x1, x2), velocities (v1, v2), accelerations (A, B), time variables (ts, t) and bounds (V, ep).  The verification problem checks that, under non‑negativity and upper‑bound assumptions (e.g., 0 ≤ v1, v2 ≤ V, A, B > 0, ep > 0) and specific mode identifiers (I1 = I2 = 2), the safety implication holds for all time steps; the encoding features a single existential quantifier, several non‑linear bit‑vector arithmetic operations, and a relatively deep term structure (depth 19) with 18 declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174885.smt2",
    "description": "The file encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts that, under the assumptions that all speeds v₁,v₂ are non‑negative and bounded by a maximum V, the braking constant B>0, and the positions x₁,x₂ satisfy the stopping‑distance inequality  \n xᵢ > xᵢ₀ + vᵢ² / (2·B),  \nthere is **no** time ts (quantified existentially) for which the derived state violates the bounds (e.g., speeds exceed V, positions cross, or a deadline ep is missed).  The condition is expressed as a single quantified bit‑vector formula over 32‑bit words, featuring non‑linear multiplications, a division, and several linear bounds, giving a moderate‑size (≈18 constants, depth 20) but non‑linear BV problem that tests a solver’s ability to handle quantified, arithmetic‑heavy verification queries.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171778.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection, originally generated by the KeYmaera prover and then translated to 32‑bit bit‑vector arithmetic. It asserts, via a negated existential over a time variable, that no reachable state can simultaneously satisfy a collection of linear and non‑linear constraints on positions (x1, x2, xI1, xI2), velocities (v1, v2, V), and parameters (A, B, ep) – including a quadratic term (v1·v1) and a division – together with bounds and ordering relations that capture the intended safe‑intersection behavior. The instance therefore poses a non‑linear bit‑vector satisfiability problem with a single quantifier and deep term structure, typical of industrial hybrid‑system verification challenges.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346919.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example‑simple” proof).  The formula asserts, under a set of bounded 32‑bit variables (velocities v₁,v₂, positions x₁,x₂, constants A,B,V, time bounds t₁₆₁₆, ep, etc.), a conjunction of linear and non‑linear (multiplication and signed division) inequalities that must hold for all admissible timestamps; it is expressed as the negation of an existential statement, so the solver must show the universally quantified safety property is unsatisfiable.  The instance is challenging because it mixes bit‑vector non‑linear arithmetic with several inequality constraints, a moderate term depth (≈20) and a single quantified variable, leading to a hard industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2761.smt2",
    "description": "The benchmark encodes a safety‑verification condition from the KeYmaera hybrid‑system prover that has been translated to 32‑bit signed bit‑vectors. It asserts (under a single existential quantifier over a time variable ts3) a conjunction of linear bounds on parameters (A, B, ep ≥ 0), affine relations involving products such as a₁·ts3, a₁·t₁₂², and a non‑linear disjunction that compares the square of the expression a₁·t₁₂+v₁ with a quadratic term involving vsl and a division by B. The instance features deep non‑linear arithmetic (multiplications, a square, division) within a quantified formula, making quantifier elimination over bit‑vectors the primary source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node175109.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof for a simple traffic‑intersection scenario: it asserts that there is **no** assignment to the time variable `ts816uscore0` that simultaneously satisfies a collection of bounds on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), braking distances (`v1²/(2·B)`), and system parameters (`A`, `B`, `V`, `ep`).  All variables are 32‑bit bit‑vectors and the formula contains non‑linear arithmetic (multiplication of variables, a signed division) together with many linear inequality constraints, a single existential quantifier and a surrounding negation, making it a difficult industrial BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node387850.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid traffic‑intersection model (the “intersection‑example” from KeYmaera).  It asserts, for all admissible parameter values (non‑negative velocities v₁,v₂ bounded by V, accelerations A,B, and a positive time horizon ep), that no intermediate time ts (0 ≤ ts ≤ t₁₈₀₉) can make the position inequalities  \n\\(x_{I1} > x_1 + \\frac{v_1^2}{2B\\,ts - 2B\\,t_{s}}\\) and   \n\\(x_{I2} > x_2 + \\frac{v_2^2}{2B\\,ts - 2B\\,t_{s}}\\)  \nfail, i.e., the vehicles always keep a safe distance.  The formula is a single quantified (∃ ts) BV constraint with non‑linear multiplication and signed division, several nested conjunctions, and a depth of 19, making it a typical industrial non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531710.smt2",
    "description": "This instance is a safety‑verification condition extracted from the KeYmaera hybrid‑systems proof of a “safe intersection” example. It asserts (by negating an existential) that no time instant ts₍₂₅₁₅₎ satisfying a set of nonlinear relationships—quadratic term (v₁·v₁), linear terms A·ts, B·ts, and a signed division—can violate the bounds on positions, velocities (v₁, v₂), accelerations (A, B), and a global speed limit V while respecting the prescribed ordering of indices I₁, I₂ and positivity of constants such as ep. The formula involves a single existential quantifier over a 32‑bit bit‑vector, many multiplications and one division, and a moderate term depth (20), making it a non‑linear bit‑vector verification problem of industrial size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197625.smt2",
    "description": "The instance encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example‑simple” from KeYmaera).  It asserts the negation of an existential formula over a 32‑bit time variable, conjoining a large set of linear and non‑linear bit‑vector constraints that capture bounds on positions (x1, x2, xI1, xI2), velocities (v1, v2), parameters (A, B, V, ep) and time‑dependent expressions such as bvadd (bvmul (‑1)·B·ts) + v1₍₄₃₈₎.  The problem is a quantified bit‑vector safety check with a single ∃‑quantifier, many multiplications (non‑linear arithmetic) and a maximal term depth of 20, making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node480617.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts, via a single negated existential quantifier over a time variable `ts2284uscore0`, that no reachable state can violate a set of linear and non‑linear bit‑vector constraints such as `xI1 > x1 + v1²/(2·B)`, non‑negativity and upper bounds on velocities (`v1,v2 ≤ V`), positivity of braking and acceleration parameters (`B, A, V, ep > 0`), and a derived relation `?v_0 = -B·ts + v2`.  The problem is thus a BV‑encoded verification/task for a hybrid system with non‑linear arithmetic, a single quantifier alternation, deep term nesting (depth 20) and multiple multiplications/divisions, making it a challenging instance for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250172.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model of a road‑intersection, translated from the KeYmaera proof “intersection‑example‑simple”.  It asserts (by negating an existential) that, under a set of pre‑conditions on positions, velocities, time and parameters \\(A,B,V,ep\\) (all non‑negative, with velocity bounds and a quadratic distance term \\(v_2^2/(2B)\\)), no combination of the variables can lead to an unsafe state where the car’s position violates the required separation.  The problem is thus a non‑linear bit‑vector satisfiability check (single existential quantifier, ~20‑deep term nesting, 19 variables) that tests the inductive invariant of the intersection controller.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11136.smt2",
    "description": "This benchmark is the negated safety‑property proof obligation from the KeYmaera hybrid‑systems example “intersection‑example‑onelane”. It asks whether there exists a 32‑bit time value `ts23uscore1` that simultaneously satisfies a suite of bounded‑integer constraints on positions, velocities, distances and timing parameters (including a non‑linear term `B * ts23uscore1`) together with several ordering and positivity conditions; the outer `not` makes the solver prove that no such assignment exists. The formula features an existential quantifier, many conjuncts, and a multiplication inside bit‑vector arithmetic, yielding a relatively deep term structure (depth 23) that can be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347928.smt2",
    "description": "The benchmark encodes a safety verification condition from the KeYmaera hybrid‑system proof of a traffic‑intersection scenario. It asserts, after negating an existential over a time variable, that no assignment to the 32‑bit variables (positions x₁,x₂, velocities v₁,v₂, bounds A,B,V, etc.) can satisfy a conjunction of non‑linear kinematic inequalities (e.g., xI₁ > x₁ + v₁²/(2·B)) together with non‑negativity and upper‑bound constraints; the condition is expressed with bit‑vector multiplication, signed division and a mixture of ≤, ≥, > relations. The instance therefore tests nonlinear bit‑vector reasoning with one quantified variable, a moderate number of constants (≈ 19) and a deep term structure (depth 20), making it a challenging verification‑condition check for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271565.smt2",
    "description": "The benchmark encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera, translated into 32‑bit bit‑vector arithmetic. It asserts the negation of an existential counter‑example: given non‑negative variables representing positions, velocities, timing constants (v1, v2, A, B, V, ep, etc.) and linear/non‑linear relations among them (including a product B·ts and a division (v2·v2)/(2·B)), the solver must show that no assignment can satisfy the conjunction of bounds and the extra requirement that a derived quantity ?v_0 exceeds the allowed interval [0, V] while the time bounds hold. The problem thus tests BV solvers on a single‑quantifier, moderately deep (depth 19) formula with several non‑linear multiplications and a division, typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674535.smt2",
    "description": "This benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “simple intersection” example from KeYmaera). The formula asserts the negation of an existential counter‑example: it requires that, for any admissible time step, the vehicle speeds v₁,v₂ stay within a bound V, are non‑negative, and that the positions after braking (expressed by non‑linear terms v₁²/(2·B) and v₂²/(2·A)) exceed the current positions, while various interval and positivity constraints on the parameters hold. The instance therefore checks a non‑linear arithmetic safety invariant using bit‑vector encodings, featuring a single existential quantifier, multiplications, divisions, and a relatively deep term structure (depth 20) that makes it a challenging BV‑based verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node459232.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts that, under the assumed bounds on positions x₁,x₂, velocities v₁,v₂, constants A,B,V and a positive time‑step ep, there is **no** choice of a 32‑bit time variable ts that makes the updated velocities (A·ts+v₁₀) and (–B·ts+v₂₀) violate the invariant “all velocities stay in [0,V]” while also respecting the time budget (ts+0 ≤ ep).  The problem is a bit‑vector non‑linear arithmetic check with a single existential quantifier, several linear inequalities, and a few multiplications, making it a non‑linear BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384691.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems “intersection” model (the KeYmaera example “intersection‑example‑simple”).  All system parameters (A, B, V, ep, …) and state variables (x₁, x₂, xI₁, xI₂, t) are represented as 32‑bit bit‑vectors, and the VC contains non‑linear arithmetic (multiplication and signed division) together with several linear ordering constraints and an existential quantifier over a time variable ts1794₀.  The outer “not‑exists” asserts that no assignment can violate the safety bounds, so the solver must prove the VC unsatisfiable; the mix of bit‑vector non‑linear operations, quantification and deep term nesting (depth 20) makes the problem particularly challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node57081.smt2",
    "description": "This benchmark encodes a safety‑verification condition for the “safe‑intersection” hybrid system described in the KeYmaera examples. It asserts that there is no 32‑bit time value `ts259uscore0` for which a set of linear‑ish bit‑vector constraints—bounds on positions `xI1`, `xI2`, velocities `v1`, `v2`, parameters `A`, `B`, a maximal speed `V`, and a positive deadline `ep`—can be simultaneously satisfied; the constraints involve additions and multiplications of the symbolic parameters (e.g., `A·ts` and `–B·ts`). The problem therefore amounts to proving a universally quantified safety invariant over 19 bit‑vector variables, featuring a single quantified variable, moderate term depth (20) and non‑linear (variable‑by‑variable) multiplication, which makes the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384936.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera). It asserts that there is **no** 32‑bit time value `ts1795uscore0` for which a collection of non‑linear bit‑vector constraints—quadratic terms such as `v1·v1` and `v2·v2`, divisions, and a mixture of upper‑ and lower‑bound inequalities on positions (`x1`, `x2`), velocities (`v1`, `v2`, `V`), and constants (`A`, `B`, `I1`, `I2`, `ep`)—can all hold simultaneously. The presence of an existential quantifier together with nonlinear multiplication/division over 32‑bit vectors makes the instance a challenging industrial‑style BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node25171.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑systems model of a single‑lane intersection (the “intersection‑example‑onelane” proof from KeYmaera).  After translating the original real‑valued dynamics into 32‑bit bit‑vectors, the formula asserts the negation of an existential over a time variable, together with a large conjunction of linear and non‑linear constraints (multiplications, a division, and several bounds on positions, velocities, and timing parameters).  Consequently, the problem tests a solver’s ability to handle quantified, non‑linear bit‑vector arithmetic with relatively deep terms (depth 23) and a moderate number of variables (13).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347403.smt2",
    "description": "The file encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example‑simple” proof from KeYmaera). It asserts that, assuming non‑negative parameters A, B, V, ep and the discrete mode indices I1 = I2 = 2, no state exists (the outer not ∃…) in which the positions xI1, xI2 exceed the current positions x1, x2 by more than the stopping distances v1²/(2·B) and v2²/(2·B) while all variables stay within the bounds 0 ≤ v1,v2 ≤ V and 0 < V, ep. The condition is expressed as a quantified bit‑vector formula that uses several non‑linear multiplications (e.g., v1·v1, A·t) and a division by a constant term (2·B), with a single existential quantifier and a moderate nesting depth (≈19). Consequently the instance tests a BV solver’s capability to handle non‑linear arithmetic and a modest quantifier structure in an industrial‑style safety‑verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node6246.smt2",
    "description": "The benchmark encodes a safety verification condition for the “adaptive cruise control” hybrid system (KeYmaera example dccs‑example‑simple).  It asserts that, under a set of pre‑conditions (non‑negativity of parameters, ordering of positions x₁ < x₂, velocities v₁ ≤ v₂, and a time bound ts₄), a nonlinear inequality involving quadratic terms (t₄²) and mixed products (e.g., B·t₄·t₄, A·ε·v₁) must hold; this is expressed as the negation of an existential formula over 32‑bit bit‑vectors.  The instance therefore tests a non‑linear arithmetic verification problem with a single quantifier block and moderate term depth (≈20) but with several multiplications/divisions, making it a challenging case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189374.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the “intersection‑example” from KeYmaera).  After translation to 32‑bit bit‑vectors it asserts the negation of an existential formula that describes the evolution of positions, velocities ( v₁, v₂ ), accelerations ( A, B ) and timing variables ( ts₈₈₀, t₈₈₀, ep ), together with a collection of linear and non‑linear inequalities (including multiplications and a signed division) that capture the required separation and positivity constraints.  Solving the instance amounts to proving that no assignment to the quantified time variable can violate the safety invariant, which is challenging because of the single quantifier, deep term nesting (depth 21) and the presence of non‑linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192767.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑systems intersection example (the “intersection‑example‑simple” from KeYmaera).  It asserts that there is **no** choice of a time‑step variable `ts896uscore0` that can satisfy a conjunction of linear and non‑linear (multiplication, division) bit‑vector constraints on positions (`x1,x2,xI1,xI2`), velocities (`v1,v2`), bounds (`A,B,V,ep`) and mode indices (`I1,I2`), together with the required ordering and positivity conditions; in other words, it checks that the safety property (e.g., no collision) holds for all reachable states.  The formula contains a single existential quantifier (under a negation), about 19 32‑bit variables, mixed arithmetic and comparison operators, and a moderate term depth (≈20), making it a typical bit‑vector encoding of a non‑linear arithmetic verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388939.smt2",
    "description": "The file encodes a safety verification condition for a hybrid‑system model of two cars approaching an intersection (the “intersection‑example” from KeYmaera).  All state variables (velocities v₁,v₂, positions x₁,x₂, braking constants A,B, speed bound V, a small positive ε, etc.) are represented as 32‑bit bit‑vectors, and the condition asserts that, under the non‑linear dynamics (e.g., xI₁ > x₁ + v₁²/(2·B) and similar for the second car), no time ts can violate the safety bounds (non‑negativity, upper bound V, positive constants, and a deadline ε).  The problem is thus a quantified non‑linear bit‑vector verification task with a single existential quantifier, deep term nesting (≈20) and many multiplications/divisions, which makes it a hard industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node620306.smt2",
    "description": "This instance encodes a safety verification condition for a hybrid‑system model of a road‑intersection, taken from the KeYmaera proof “intersection‑example‑simple”.  It asserts (via the negated existential) that no 32‑bit time value ts can satisfy a conjunction of bounds on positions x₁,x₂, velocities v₁,v₂, accelerations A,B and a derived quadratic term (v·v) divided by a linear combination of B and ts, together with non‑negativity and upper‑limit (V) constraints.  The formula features non‑linear bit‑vector arithmetic (multiplication, signed division) and a single quantified variable, with a relatively deep term structure (depth 20), making it a challenging BV‑solver benchmark for industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391142.smt2",
    "description": "This benchmark encodes a safety verification condition for a hybrid‑systems model of two vehicles crossing an intersection (the “intersection‑example” from Keymaera).  It asserts, via the negation of an existential quantifier over a time variable, that no reachable state can violate the prescribed bounds on speeds ( v₁, v₂ ), positions ( x₁, x₂ ) and a global speed limit V, where the dynamics involve non‑linear bit‑vector arithmetic (squared velocities, products with time, and divisions).  The formula contains a single quantified block with many chained inequalities, non‑linear BV multiplications/divisions, and a depth‑20 term structure, making it a representative industrial verification benchmark that tests solvers on quantified, non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385140.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that **no** execution time `ts` exists that simultaneously satisfies a collection of non‑linear relationships among 32‑bit bit‑vector variables representing positions (`x1`, `x2`), velocities (`v1`, `v2`), accelerations (`A`, `B`), a speed bound `V`, and a time horizon `ep`; the relationships include quadratic terms (`v*v`) and division, together with bounds such as `0 ≤ v ≤ V`, `A,B ≥ 0`, and the post‑state position constraints `xI1 > x1 + v1²/(2*A·ts+… )`, `xI2 > x2 + v2²/(2*B·ts+… )`.  \n\nThe instance is a **BV‑encoded non‑linear arithmetic verification problem** featuring a single existential quantifier, deep nested arithmetic expressions (term depth 21), and many bit‑vector operations, making it a challenging industrial case for solvers handling quantified non‑linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node51016.smt2",
    "description": "The benchmark encodes a safety verification condition for a one‑lane traffic‑intersection hybrid system (the “intersection‑example‑onelane” from KeYmaera).  It asserts, via a negated existential quantifier over the time variable ts105uscore2, that no choice of the system’s parameters (positions x, xI, velocities v, V, accelerations A, B, etc.) can violate the safety inequality that bounds the vehicle’s position xI against a computed reachable‑set expression.  The condition is expressed entirely in 32‑bit bit‑vector arithmetic and involves non‑linear operations (multiplication, division, negation) together with several linear inequalities, a single quantifier and a nesting depth of 25, making it a representative industrial verification benchmark that is hard for solvers because of the combination of non‑linear bit‑vector reasoning and quantified constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476004.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple road‑intersection hybrid system (the “intersection‑example” from KeYmaera).  It asserts, for all non‑negative 32‑bit parameters and for any time ts within a run, that the positions and velocities of two vehicles (variables xI1, xI2, v1, v2) satisfy the braking‐distance inequalities derived from acceleration A, deceleration B and speed limit V, while also respecting bounds on the elapsed time and a deadline ep.  The check therefore tests a quantified, non‑linear bit‑vector arithmetic property (multiplications, division, and several inequality constraints) typical of hybrid‑system safety VCs, with a relatively deep term structure and a single existential quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605258.smt2",
    "description": "This instance encodes a safety verification condition for the “intersection‑example” hybrid‑system model from KeYmaera, translated into 32‑bit bit‑vector arithmetic.  It asserts that there is **no** 32‑bit time value `ts2880uscore0` for which a collection of non‑linear constraints (involving multiplications, a division, and several linear inequalities) — which model bounds on velocities, accelerations, positions and a collision‑avoidance condition `xI2 > x2 + (v2·v2)/(2·B)` — can be satisfied together with positivity and range assumptions on all parameters.  The formula therefore checks a safety invariant using a single existential quantifier within a negated context, featuring deep nested Boolean structure and non‑linear bit‑vector operations, making it a challenging industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632840.smt2",
    "description": "The benchmark encodes a safety verification condition for a simple intersection scenario taken from a KeYmaera hybrid‑system proof. It asserts—by negating an existential over a time variable—that, assuming non‑negative parameters (accelerations A, B, speed bound V, a positive margin ep) and the kinematic relations xI1 > x1 + v1²/(2·B) and xI2 > x2 + v2²/(2·B), no reachable time exists that violates these distance constraints for the two vehicles; the condition is expressed with nonlinear bit‑vector arithmetic (multiplication, signed division) and several inequality constraints. The single existential quantifier together with multiple nonlinear operations and a term depth of 20 makes it a non‑linear BV verification problem of moderate size but considerable solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287705.smt2",
    "description": "The file encodes a safety verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example”). After translating the real‑valued dynamics to 32‑bit signed bit‑vectors, the assertion states that **no** value of the existential time variable `ts1340uscore0` can satisfy a conjunction of signed‑inequality constraints that capture non‑negative parameters (A, B, V, ep), bounds on velocities `v1`, `v2` (both ≤ V), position relations (`xI1 < x1`, `xI2 > x2 + v2²/(2·B)`), and a linear motion expression `?v_0 = A·ts1340uscore0 + v1uscore3dollarskuscore400`. The formula mixes linear and non‑linear bit‑vector arithmetic (multiplication, division) within a single existential quantifier, yielding a deep (depth 21) and highly conjunctive BV problem that tests the solver’s ability to handle non‑linear arithmetic and quantified reasoning in an industrial‑style verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8746.smt2",
    "description": "The benchmark encodes a safety verification condition for the “binary driver” hybrid‑system example from KeYmaera.  It asserts that no 32‑bit signed time‑offset `ts1uscore1` can satisfy a large conjunction of signed inequalities that involve linear terms (e.g., `amax·ts1 + vuscore2dollarskuscore2 ≥ 0`) together with several quadratic and division expressions such as `v·v – d·d ≤ (2·b)·(m – z)` and a compound bound on a mixed term built from `amax`, `b`, `ep`, `vuscore2dollarskuscore2`, etc.  Thus the problem is a non‑linear arithmetic verification task translated into bit‑vector logic, featuring many nested `bvmul`, `bvsdiv`, and signed comparison operators, a deep term structure (depth 22) and fifteen 32‑bit variables, which together make the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561079.smt2",
    "description": "This instance is a safety verification condition generated by the KeYmaera hybrid‑systems prover for a simple traffic‑intersection example.  It asserts, with a single existential quantifier over a time variable, a set of nonlinear 32‑bit‑vector constraints (additions, multiplications, a signed division) that capture bounds on velocities, positions, and a safety margin, and then negates the condition to check unsatisfiability.  The formula therefore tests a hybrid‑system safety property using QF_BV with non‑linear arithmetic, a moderate number of variables, and a term depth of 20, which makes it a non‑trivial quantified bit‑vector challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548891.smt2",
    "description": "The benchmark encodes a safety verification condition generated by the KeYmaera hybrid‑system prover for a simple traffic‑intersection scenario.  All real‑valued quantities (speeds v₁,v₂, positions x₁,x₂, bounds A,B,V, a small ε, etc.) are represented as 32‑bit bit‑vectors, and the formula asserts that there is **no** assignment to the time variable ts that satisfies a conjunction of linear and a few nonlinear (e.g., v₂·v₂, multiplication by B) relationships describing the motion of two vehicles and the required separation constraints.  The instance therefore checks the unsatisfiability of an existentially‑quantified reachability condition, featuring a single quantifier, moderate term depth (≈20) and non‑linear bit‑vector arithmetic, which makes it representative of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli.proof-node2282.smt2",
    "description": "The formula is a verification condition extracted from the KeYmaera hybrid‑system proof (node 2282 of *vsli.proof*). It asserts the non‑existence of a 32‑bit time variable `ts0` that satisfies a large conjunction of polynomial (quadratic) equalities and inequalities over bit‑vectors—mixing multiplications, divisions, and addition/subtraction of parameters such as velocities, positions, and safety margins. Thus the instance encodes an industrial safety‑property check as a single quantified, highly non‑linear BV constraint with deep term nesting, which is challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node11384.smt2",
    "description": "This benchmark encodes a safety verification condition arising from the KeYmaera hybrid‑system model “binary_driver” (node 11384). It asks whether there exists a 32‑bit time variable `ts4uscore1` (restricted to 0 ≤ ts4uscore1 ≤ t4uscore0dollarskuscore1) that simultaneously satisfies a large conjunction of linear bounds (non‑negativity of velocities, distances, etc.) and several quadratic bit‑vector inequalities such as `v·v – d·d ≤ 2·b·(m – z)` and `vuscore2dollarskuscore6·vuscore2dollarskuscore6 – duscore2dollarskuscore6·duscore2dollarskuscore6 ≤ 2·b·(muscore2dollarskuscore6 – zuscore2dollarskuscore6)`. The formula contains a single existential quantifier, 15 declared 32‑bit variables, deep nesting (term depth 21) and multiple `bvmul` terms, making it a challenging non‑linear bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361987.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑system model of a road intersection (the “intersection‑example” from KeYmaera).  It asserts that, under given bounds on the vehicles’ velocities (v1, v2), accelerations (A, B) and a global speed limit V, the positional updates xI1 = x1 + (v1²)/(2·B) and xI2 = x2 + (v2²)/(2·B) always stay ahead of the current positions (i.e., no collision) for every admissible time ts, with all constraints expressed as signed 32‑bit‑vector inequalities and involving non‑linear operations (multiplication, division).  The formula is a single quantified (existential) BV constraint that is negated, so the solver must prove its unsatisfiability; the presence of bit‑vector non‑linear arithmetic, several dozen variables and a nesting depth of 21 makes the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node478879.smt2",
    "description": "The benchmark encodes a safety‑verification condition for a hybrid‑systems model of a road intersection (the “intersection‑example” from KeYmaera).  All variables are 32‑bit bit‑vectors representing real‑valued quantities such as positions, velocities, time and constants; the asserted formula is the negation of an existential witness for a violation of the safety invariant, which is expressed as a conjunction of non‑linear arithmetic constraints (squares, products and a signed division) together with ordering constraints on positions and time.  Hence the solver must prove the formula unsatisfiable, i.e. that no reachable state can breach the invariant, a task made challenging by the presence of non‑linear bit‑vector arithmetic and a relatively deep term structure despite the single‑quantifier block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2416.smt2",
    "description": "The instance encodes a safety verification condition for a hybrid‑system model (originating from a KeYmaera proof) in which the variables denote time, positions, velocities, and system parameters such as acceleration limits (A, B), minimum speed (vmin) and a threshold distance (D). It asserts that there is **no** 32‑bit time value `ts0uscore0` satisfying a conjunction of linear and non‑linear bit‑vector constraints—including quadratic terms (`v1²`), divisions, and several derived expressions—together with the requirement that an “alerted’’ flag remains zero, thereby checking that a bad state (e.g., the vehicle breaching a safety distance) cannot be reached. The formula features a single existential quantifier, deep nesting (max term depth 26), and many multiplicative/division operations, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-inv-node6249.smt2",
    "description": "This benchmark encodes the safety‑invariant proof for the classic “bouncing ball” hybrid system (Keymaera example bouncing‑ball‑inv, node 6249).  All real‑valued dynamics (position h, velocity v, gravity g, time t, etc.) are translated into 32‑bit bit‑vectors, yielding a set of non‑linear arithmetic constraints that involve quadratic terms (e.g., t², t·v), divisions by 2, and a number of inequality bounds (non‑negativity of heights, velocities, and time).  The single assertion asserts the negation of an existential condition over an auxiliary time variable, so the solver must show that no counterexample exists; the problem features a moderately deep term nesting (depth 24), a handful of quantified variables, and a dense mixture of BV multiplications, additions and signed comparisons, making it a representative industrial instance of BV‑encoded non‑linear verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605722.smt2",
    "description": "This benchmark encodes a safety verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof). The formula asserts, via a negated existential over a time variable, that no assignment to 32‑bit bit‑vector variables representing velocities (v1, v2), positions (x1, x2), parameters (A, B, V, ep) and intermediate terms can simultaneously satisfy a mixture of equalities, linear inequalities and non‑linear operations (multiplication, division, and signed comparisons). Hence the solver must prove unsatisfiability of a single quantified clause containing non‑linear bit‑vector arithmetic, a typical industrial verification problem with moderate variable count and a term depth of 20.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268667.smt2",
    "description": "The file encodes a single safety‑verification condition derived from the KeYmaera theorem prover (the “intersection‑example‑simple” hybrid‑systems benchmark).  After translating the original real‑valued dynamics to 32‑bit bit‑vectors, the VC asserts that there is **no** assignment to the existential time variable `ts1249uscore0` that can satisfy a collection of linear and non‑linear arithmetic constraints (including products such as `A*ts` and `B*ts`, and a division by `2*B`).  The formula therefore checks the validity of a safety invariant for a vehicle‑intersection scenario, and its difficulty stems from the presence of a single quantified variable together with non‑linear bit‑vector multiplication and mixed inequality constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632728.smt2",
    "description": "This instance encodes a safety verification condition for the “safe‑intersection” hybrid‑system example from KeYmaera: given non‑negative parameters \\(A,B,V,ep\\) and vehicle states (positions \\(x_1,x_2\\), velocities \\(v_1,v_2\\) bounded by \\(V\\)), the formula asserts that the stopping distances \\(\\frac{v_i^2}{2B}\\) keep the two cars separated by the safety margin \\(V\\) for any elapsed time \\(ts\\).  The benchmark is a bit‑vector translation (32‑bit signed) of the original real‑valued proof obligation, featuring non‑linear multiplications (e.g., \\(v_i\\*v_i\\)) and signed division, a single existential quantifier over the time variable, and deep nested conjuncts, which together make it a challenging industrial‑style verification query for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node249484.smt2",
    "description": "The benchmark encodes a safety verification condition for a hybrid‑system model of a traffic intersection (the KeYmaera “intersection‑example”).  It asserts the negation of an existentially quantified time variable `ts1160uscore0` together with a large conjunction of linear and non‑linear bit‑vector arithmetic constraints (e.g., products `bvmul v2 v2`, divisions and mixed additions) that describe bounds on vehicle positions, velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`).  The solver must show that no assignment to the quantified time can satisfy all these constraints, i.e., that the safety property holds; the presence of a single quantifier, deep term nesting (depth ≈ 20) and several non‑linear multiplications makes the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-d-braking-node1346.smt2",
    "description": "The instance encodes a safety verification condition for the ETCS (European Train Control System) braking model exported from KeYmaera. It asserts the negation of a property that must hold for all admissible time‑instants `ts1uscore0` given the existence of an initial time `t1uscore0`, relating the vehicle’s speed `v`, distance `d`, braking coefficient `b`, and other parameters (`m`, `z`) through a non‑linear combination of signed bit‑vector inequalities (including squares, products and a division by 2). The formula features a single ∃ ∀ quantifier alternation, extensive signed‑comparison and multiplication constraints, and a term depth of 19, making it a challenging nonlinear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_673.smt2",
    "description": "The file contains a verification condition generated by Ultimate Automizer for the C benchmark *Primes_true‑unreach‑call.c*. It asserts that the function’s 32‑bit return value equals its input n and that there exist two auxiliary 32‑bit variables \\(v_{35},v_{34}\\) satisfying a small system of signed linear inequalities (including \\(f_1 + 2·v_{35}+2·v_{34}+1 \\le ret\\), \\(f_1 \\le v_{35}\\le v_{34}\\) and \\(n \\le 2\\)). A second assertion negates the conjunction of the same existential constraints together with \\(n \\le 2\\), so the solver must determine the (un)satisfiability of these contradictory requirements. The problem is a classic software‑model‑checking reachability check, featuring a handful of quantified bit‑vectors, shallow term depth (≤ 8) and simple linear arithmetic, which together make it a modest‑size BV instance with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_2207.smt2",
    "description": "The file encodes a safety‑property check generated by the Ultimate Automizer tool for a C benchmark (a “prime” program).  It translates a reachability condition into 32‑bit bit‑vector arithmetic: the first assertion searches for a witness `v_nnf_107` such that the doubled current loop counter (`c_mult_~n`) plus a doubled auxiliary value plus one does not exceed a result bound `c_mult_#res`, while respecting the ordering constraints `c_mult_#in~n ≤ c_mult_~n ≤ v_nnf_107`.  The second assertion negates a similar existential condition (over `mult_~n` and `v_nnf_108`) and together they form a single SAT query that is unsatisfiable exactly when the program’s unsafe state is unreachable.  The problem is a small‑scale BV verification task with only two existential quantifiers, shallow term depth (≤ 8) and simple linear arithmetic (multiplication by a constant), making it a relatively lightweight instance for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1070.smt2",
    "description": "The instance encodes a safety‑property check for a small C‑like program: it asserts the pre‑conditions \\(k\\le i\\), \\(2·i\\le j\\) and \\(i\\ge 4\\) on three 32‑bit variables, and then negates a property that would require the existence of a value \\(v\\) with \\(k\\le v+3\\), \\(2·v\\le j\\) and \\(v\\ge 4\\) (together with trivial bounds on \\(i\\)).  The solver is asked whether the pre‑conditions can be satisfied while the existential condition is *not* true; thus the formula is satisfiable iff the original safety property is violated.  The benchmark features a single existential quantifier, three bit‑vector variables, shallow term depth (max 7) and a modest number of assertions, making it a typical industrial verification query generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_678.smt2",
    "description": "The instance encodes a safety‑property check for the C benchmark *Primes_true‑unreach‑call.c*: it models the program’s arithmetic with 32‑bit bit‑vectors and uses two existentially quantified variables to represent possible loop‑iteration counts. The asserted formula demands both the existence of values satisfying a set of linear bit‑vector inequalities (relating the variables f1, n, a computed return value, and the quantifiers) and simultaneously the non‑existence of such values, while also tying the Boolean flag short13 to the equality “return == n”. Proving the formula unsatisfiable (i.e., that the contradictory existential and its negation cannot hold) establishes that the asserted error state is unreachable, a typical verification task generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_670.smt2",
    "description": "The instance encodes a software‑verification safety check using 32‑bit signed bit‑vectors. It asserts the existence of three program variables i, j, k that satisfy simple linear bounds ( k ≤ i, 2·i+1 ≤ j, i ≥ 3 ) and then negates a property stating that, for the same i, j, k, all integers v ≥ 3 also satisfy k ≤ v+2 and 2·v+1 ≤ j (the negated property is expressed with an inner existential under a surrounding not, yielding an implicit ∀‑quantifier). The solver must decide whether the conjunction of the first constraints with the negated invariant is satisfiable, i.e., whether a reachable state violates the intended loop invariant. The presence of a quantified subformula (∃ v inside a not) creates a quantifier alternation, and the problem involves several signed comparisons and multiplications, making it a non‑trivial BV‑verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_597.smt2",
    "description": "The benchmark encodes a safety‑property check for the C function *c_mult* (originating from the SV‑COMP 2015 “Primes” program). It asserts that the input size |c_mult_#in~n| is bounded by a global limit c_mult_~n, and then requires the existence of two 32‑bit numbers v₁, v₂ (with c_mult_~n ≤ v₁ ≤ v₂) such that 2·v₁ + 2·v₂ + 1 ≤ |c_mult_#t~ret1|; immediately afterwards the same existential condition is negated. Hence the formula is satisfiable only if the existential can both hold and fail, which forces the solver to show the property is unreachable (the instance is expected to be **unsat**). The problem is a pure bit‑vector verification task with only three declared constants and two quantified variables, shallow term depth (7) and no large quantifier alternations, making it relatively easy for solvers that support quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1770.smt2",
    "description": "The file encodes a safety‑verification condition for a small C‑like program (the SV‑COMP benchmark *nested9*).  Three 32‑bit variables `i`, `j`, `k` model loop counters, and the constraints express linear relationships among them together with two existentially‑quantified auxiliary counters (capturing possible loop iterations).  The solver is asked to check the satisfiability of a conjunction of these relationships together with the negation of a slightly weaker version, i.e. whether a state exists that satisfies the detailed invariant but violates the simpler one—exactly the kind of reachability/inductive‑invariant check performed by Ultimate Automizer.  The instance contains only three bit‑vector variables, shallow terms (depth ≤ 8), and a couple of existential quantifiers, making it a modest‑size BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_187.smt2",
    "description": "The instance is a verification condition generated by Ultimate Automizer for the “true‑unreach‑call” benchmark of a C program (Primes). It asserts that the return value of main equals a variable n and that there **exists** 32‑bit values v₁, v₂ satisfying a small system of linear bit‑vector inequalities ( 2·v₁ + 2·v₂ + 1 ≤ ret, f₁ ≤ v₁, n ≤ 2, v₁ ≤ v₂ ), while a second assertion simultaneously states that **no** such pair can exist. Consequently the solver must prove unsatisfiability of a formula that combines a single‑existential quantifier with its negation, using only shallow arithmetic terms and a handful of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_473.smt2",
    "description": "The script encodes a safety‑property (unreachability) check for a small C‑style program that uses three 32‑bit integer variables i, j, k (likely loop counters) together with an existentially quantified auxiliary variable modeling a loop iteration bound. The first assertion states that i is at least 0, 1, 2 and 3 and that there exists a value v such that k ≤ v+1, v ≥ 3 and 2·v ≤ j, while also requiring 2·i ≤ j; the second assertion negates a similar condition where the bound is v+2, thus the overall formula asks whether both the “original” and the “shifted” constraints can hold simultaneously. The problem is a bounded‑model‑checking/verification query in the BV logic that features a few (two) existential quantifiers, simple arithmetic (addition, multiplication by 2) and shallow term depth, making quantifier handling the main source of difficulty despite the tiny variable count.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_9.smt2",
    "description": "This instance is a software‑verification condition generated by Ultimate Automizer for a SV‑COMP 2023 “heapsort” benchmark.  It asserts the existence of 32‑bit values n such that n/2 (signed division) satisfies two separate relations with the constants c_l and c_j (and stays within the bound 0 … 1 000 000), while simultaneously demanding that no n in the same range makes (n/2)+1 equal c_l.  The formula therefore checks a quantified arithmetic invariant (∃n … ∧ ¬∃n …) over bit‑vectors, with a small number of variables but a quantifier alternation that makes the problem non‑trivial for quantifier‑aware BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_0.smt2",
    "description": "The script is a safety‑verification condition produced by Ultimate Automizer for a C benchmark (SV‑COMP 2023). It first equates three 32‑bit return values of the program’s `main` and then asserts—via a negated existential—that no pair of 32‑bit integers exists whose signed 64‑bit sum (truncated to the low 32 bits) equals this common return value; in other words, the observed result must be unrepresentable as a signed addition of two 32‑bit numbers. The problem is a small BV formula (three constants, one quantified block) with a single quantifier alternation and simple arithmetic, typical of automated software‑verification checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_2.smt2",
    "description": "This SMT‑LIB script encodes a safety‑verification condition generated by Ultimate Automizer for a C benchmark from SV‑COMP 2023. It asserts that for all nondeterministic 32‑bit values v₆, v₅, v₄ the linear bit‑vector expression  \n\n  x + z + 8·v₆ + 4·v₄ + 4·v₅ + y  \n\ncannot equal the constant 1, while simultaneously asserting (via a negated universal) that there exist two sets of such nondeterministic values (including primed copies) for which the same expression, extended with the additional terms 4·v₅′, 4·v₄′, 8·v₆′, does equal 1.  In other words, the instance checks whether a particular arithmetic invariant (the sum never being 1) holds across all loop iterations, using quantified bit‑vector arithmetic with only shallow terms (depth ≤ 7) and a small, fixed number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_3.smt2",
    "description": "The file encodes a small bit‑vector verification condition generated by Ultimate Automizer for a SV‑COMP benchmark.  It introduces a current counter `c` (and its “next‑state” primed version) and asserts that `c` is larger than 1 and equals the primed value plus 1.  It then states that there must exist an integer `n` in the range [1, 1 000 000] such that `c` equals `n/2 + 1`, and finally negates the existence of a same‑range `n` that would make the primed counter equal `n/2 + 1`.  The solver therefore checks whether these three constraints are mutually consistent (i.e., whether the transition from `c` to its primed version can be realised by the same arithmetic relation on some bounded `n`).  The problem involves only a handful of bit‑vector variables, shallow terms, and a single existential quantifier, making it a lightweight instance of a software‑verification safety check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_2.smt2",
    "description": "This instance encodes a safety‑checking condition for a small C program: it asserts that a linear combination of three program variables x, y, z and several nondeterministic 32‑bit inputs (scaled by small constants) can never equal the constant 4. The property is expressed with a universal quantifier (for all possible nondet values the equality does not hold) together with the negation of another universal quantifier, which is equivalent to an existential claim that some choice of nondet values makes the same (slightly larger) expression equal 4. The resulting quantifier alternation over bit‑vectors produces a contradictory set of constraints, which the solver must refute to prove the original program safe. The benchmark features only a handful of variables but non‑trivial quantifier structure and mixed linear BV arithmetic, making it a typical industrial verification query generated by Ultimate Automizer for SV‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_8.smt2",
    "description": "The script encodes a software‑verification condition generated by Ultimate Automizer: it asserts that a program variable `cond` is non‑zero and that, for every choice of several nondeterministic 32‑bit inputs, a linear bit‑vector expression involving the program’s inputs `x`, `y`, `z` never equals the constant 4, while a second clause simultaneously requires the existence of a choice making that same expression equal to 4. The resulting formula is a quantified bit‑vector check (one universal quantifier, no alternations) with a modest term depth (≤ 7) and only a few constants and quantified variables, typical of industrial C‑program assertion‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_5.smt2",
    "description": "This instance encodes a software‑verification condition generated by Ultimate Automizer for a C benchmark, asserting that a particular 32‑bit arithmetic expression (a weighted sum of several nondeterministic variables together with the program’s inputs x, y, z) can never equal the constant 4. The formula combines a universally quantified “for all” clause stating the inequality with a negated universal (i.e., an existential) clause demanding a witness where the equality holds, together with the simple condition that the program’s assert variable equals 1. Thus the solver must resolve quantified bit‑vector arithmetic (a handful of quantified variables, term depth 7) to determine whether the contradictory constraints make the whole set unsatisfiable, which corresponds to proving the original C assertion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_0.smt2",
    "description": "This instance checks a verification condition for a software routine that performs a 32‑bit floating‑point addition.  The bit‑vector formulas construct the mantissa part of two floating‑point numbers (by masking the low 23 bits and setting the hidden‑bit) and then combine them with a shift that models the alignment of the second operand; an additional constraint forces a specific high‑order bit of the first constructed mantissa to be zero.  The final assertion negates a conjunction of two existentially quantified equalities, thereby asking the solver to prove that no choice of the underlying 32‑bit words can simultaneously satisfy both the alignment equation for the second operand and the mantissa‑construction equation for the first operand—i.e., that the encoded floating‑point addition invariant holds.  The problem involves only existential quantifiers, a modest number of variables (six 32‑bit bit‑vectors), shallow term depth (≤ 8), and thus represents a relatively small but non‑trivial BV‑verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_10.smt2",
    "description": "This SMT‑LIB file encodes a safety‑verification task for a bakery‑algorithm based lock (as suggested by the filename *bakery*). The model represents the program’s control‑state bits, input bytes and bit‑masks as 8‑ and 32‑bit vectors and uses a series of quantified constraints to capture the transition relation and bit‑wise masking of thread flags; the final assertion negates the desired invariant (that two particular state bits never become equal), so the solver must show the conjunction is unsatisfiable. The instance is therefore a pure‑BV verification problem with many nested zero‑extend, extract and bvand operations, ten universal quantifiers and a term depth of 129, which makes it a demanding benchmark for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/psyco_abp_1-2.c_2.smt2",
    "description": "This instance is a tiny software‑verification query generated by Ultimate Automizer for a C benchmark (psyco_abp). It fixes a 32‑bit constant `expect` to the value 6 and then asserts the negation of an existential condition that would require a 32‑bit variable `v` to satisfy `-v + 1 = buffer_empty`; i.e., it asks whether there is **no** such `v`. The formula contains only two bit‑vector constants, a single shallow arithmetic constraint, and is therefore a simple UNSAT check that validates the encoded safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_11.smt2",
    "description": "The script encodes a safety‑verification problem for a small C function that manipulates three 32‑bit variables x, y and z. The first conjunct describes the transition relation: each variable is incremented by a linear combination of three nondeterministic 32‑bit inputs (scaled by 4 or 8), and an auxiliary Boolean variable records whether the sum x′+y′+z′ equals 1. The following quantified assertions express the intended invariant that, for all possible nondeterministic choices, this sum never equals 1 (hence the assert of `__VERIFIER_assert` should never fail), while the final negated ∀‑formula asserts the existence of a counter‑example. The instance therefore checks the unsatisfiability of reaching an assertion violation, using bit‑vector arithmetic, a moderate number of variables (12 constants) and two shallow forall‑quantifiers, which makes quantifier reasoning the main difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_0.smt2",
    "description": "The script encodes a verification condition generated by Ultimate Automizer for a heap‑sort benchmark: it asserts that there exists a 32‑bit integer n (0 ≤ n ≤ 1 000 000) whose signed division by 2 yields a value c, while simultaneously requiring that no (possibly different) integer n in the same range satisfies (n ÷ 2) + 1 = c. This amounts to checking an off‑by‑one property of the “divide‑by‑two then increment” computation using bit‑vector arithmetic. The problem involves only a handful of variables and shallow terms (max depth 7) but contains an existential quantifier inside a negated existential, effectively creating an ∃ ∀ quantifier pattern that can be challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_1.smt2",
    "description": "The script encodes a verification query generated by Ultimate Automizer for an SV‑COMP benchmark. It asserts that three uninterpreted 32‑bit return values of the program’s `main` are all equal, and then asks whether there exists any pair of 32‑bit bit‑vectors whose signed‑extended sum (truncated back to 32 bits) equals this common value; the outer `not` makes the query true only if such a pair does **not** exist. Consequently the problem is a single‑quantifier existence check over bit‑vectors (no alternations), with a shallow term depth (max 9) and only three declared constants, so the instance is a tiny, purely arithmetic SAT/UNSAT test rather than a large‑scale industrial verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_9.smt2",
    "description": "The instance encodes a safety‑checking condition for a tiny floating‑point addition routine (the “addflt” function) generated by Ultimate‑Automizer.  It asserts that a non‑zero control flag holds, that two 32‑bit words can be interpreted as the hidden‑bit mantissas of the two operands (by fixing the top mantissa bit to 1 via `bvor`/`bvand`), and then negates the existence of any operands and a shift amount (`delta`) that would make the computed shifted sum equal a particular mantissa value (`c_addflt_~ma~0#1`).  Thus the solver must decide a quantified bit‑vector verification condition with only three existential variables (depth ≤ 9), making the problem a relatively small but quantifier‑rich BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_2.smt2",
    "description": "This instance checks the correctness of a software‑implemented floating‑point addition (the “soft_float” benchmark). It asserts that there exist 32‑bit bit‑vectors representing the mantissas of the two operands and a shift amount such that the intermediate bit‑vector constructions of the mantissa‑add‑and‑shift algorithm match the pre‑computed constants, and then negates the existence of a triple of operands for which the final shifted sum equals the expected result – i.e., it searches for a counterexample to the addition routine. The problem is a quantifier‑only (existential) BV formula with three variables, moderate term depth (9) and a handful of bit‑vector operations, typical of verification tasks generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_2.smt2",
    "description": "This instance encodes a safety‑property check for a small concurrent program (the “bakery” lock) generated by Ultimate Automizer.  The bit‑vector constraints describe the program’s initial state, input bytes, mask‑based updates and arithmetic on a shared counter (|ULTIMATE.start_main_~var_46|), while the final assertion asserts the negation of a disjunction of two quantified invariants – one ensuring that a mask‑controlled multiplication stays zero, the other imposing a complex bitwise relationship among many input and intermediate variables.  The problem is therefore a bounded software‑verification task with many universally quantified variables, deep term nesting (depth ≈ 130) and a heavy use of zero‑extension, extracts and bitwise operators, which together make the instance difficult for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_6.smt2",
    "description": "This instance encodes a bounded‑model verification condition for a small C benchmark (linear‑inequality‑inv‑a.c) generated by Ultimate Automizer.  A 32‑bit bit‑vector constant |c_…| is defined (via an existential quantifier) as the sum of two zero‑extended 8‑bit variables, and the script then asserts that this same constant cannot also be expressed as the sum of three or more zero‑extended 8‑bit terms (the negated conjunction of several existential alternatives).  Thus the solver is asked to decide whether the linear‑inequality invariant “c equals exactly the sum of two bytes” holds, i.e., whether any alternative decomposition exists; the formula contains only shallow quantified terms (no alternation, max depth 7) and a modest number of bit‑vector variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_7.smt2",
    "description": "The script encodes a software‑verification condition for a small floating‑point addition routine, generated by Ultimate Automizer from an SV‑COMP benchmark.  It defines two normalized 32‑bit representations (setting the exponent bit 0x0100 0000 and copying the low 24 mantissa bits) for symbolic inputs a and b, asserts that the verifier flag equals the signed‑greater‑or‑equal test on the original operands, and then checks that **no** choice of a “delta’’ value and inputs a, b can make the normalized result ma equal the right‑shifted sum of the two normalized operands (i.e., it universally validates a rounding/overflow property).  The problem is a pure bit‑vector safety verification with a single quantifier alternation (¬∃… ) and modest term depth, but the presence of existential quantifiers inside a negated context makes it a non‑trivial quantified SAT problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_9.smt2",
    "description": "This benchmark encodes a software‑verification condition for a soft‑float addition routine (the “start_addflt” function).  A 32‑bit bit‑vector constant representing the computed mantissa is constrained to have a specific bit cleared (via a mask with 2³²‑25), and the instance asks whether there exist 32‑bit inputs a, b and a shift amount δ such that the mantissa equals a certain bit‑wise‑and/‑or/‑add expression, while simultaneously **no** such inputs can make the same expression equal its one‑bit right‑shifted version.  Thus the formula checks a safety property (essentially that a particular rounding/overflow cannot occur) and features a pair of existential quantifiers together with a negated existential (i.e., an implicit universal), moderate term depth (9) and several bit‑vector operations, making it a non‑trivial BV‑verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_7.smt2",
    "description": "The instance encodes a safety‑verification task for a small C program that manipulates three 32‑bit integers x, y, z and makes several nondeterministic updates (the “nondet” variables).  The first assertion defines the program’s transition relation (updates of x, y, z) together with the condition of a `__VERIFIER_assert`; the final clause asserts the negation of that condition after the transition, so the solver is asked to find a reachable state violating the assert.  The problem is therefore a bounded‑model‑checking / software‑verification query expressed in the BV logic, featuring a handful of bit‑vector variables, arithmetic expressions of depth 8 and two universally‑quantified blocks that model the nondeterministic choices, which makes the core difficulty the handling of quantified bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_10.smt2",
    "description": "The file encodes a software‑verification query generated by Ultimate Automizer for an SV‑COMP benchmark: it asserts that a program’s `__VERIFIER_assert` condition (`cond ≠ 0`) holds for all nondeterministic 32‑bit inputs, while simultaneously requiring the existence of a concrete assignment to several nondet variables (`nondet4`, `nondet5`, `nondet6`) that makes a specific bit‑vector linear combination of the program constants (`x`, `y`, `z`) equal the constant 4. This creates a contradictory pair of quantified constraints—a universal “for all … the sum ≠ 4” together with its negation expressed as an existential “there exists … the sum = 4”—forcing the solver to detect the unsatisfiability that corresponds to a reachable assertion failure. The difficulty stems from quantified bit‑vector arithmetic with multiple nondeterministic variables and moderate term depth (≈7), but no deep quantifier alternation beyond the single universal/existential split.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_3.smt2",
    "description": "This instance encodes a software‑verification condition for a floating‑point addition routine generated by Ultimate Automizer.  It defines two 32‑bit constants that hold the masked mantissa‑plus‑implicit‑bit of two abstract inputs a and b (using the masks 0x1000000 and 0x00FFFFF), and then asserts that there is **no** choice of a, b and a delta value such that, after adding the masked b with delta, shifting right by one, and OR‑ing with the masked a, the result equals the previously stored masked value of a.  In other words, the formula checks a universal property (via a negated existential) about the correctness of the soft‑float addition implementation; it involves only bit‑vector operations, a few existential quantifiers, modest term depth (≤ 9) and a small number of variables, making it a typical bounded verification query rather than a large‑scale synthesis or scheduling problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_9.smt2",
    "description": "This instance encodes a verification condition for a software implementation of single‑precision floating‑point addition (the “soft‑float” routine).  The bit‑vector formulas extract the hidden‑bit and mantissa (using the constants 0x0100000 and 0x00FFFFF), model the alignment of the second operand by a logical right‑shift by an arbitrary delta, and then express that the computed result `c_addflt_~ma~0` must **not** equal the right‑shift‑by‑1 of the sum of the two aligned mantissas.  The query is a single SAT check with a negated existential (equivalently a universal) over three 32‑bit variables, involving only shallow term depth (≤9) but quantifier alternation, typical of bit‑vector‑based software model‑checking problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_9.smt2",
    "description": "The instance encodes a safety‑verification query for a small C benchmark generated by Ultimate Automizer: three concrete 32‑bit inputs x, y, z and several nondeterministic 32‑bit variables model the program’s state, while a `__VERIFIER_assert` condition is required to be non‑zero. The formula asserts that a certain linear combination of these variables never equals the constant 4 for all nondeterministic choices, but simultaneously asserts the negation of that universal claim (i.e. that there exists a choice making the sum equal 4), thereby checking whether the original assertion can be violated. The problem features a handful of bit‑vector variables, moderate term depth (≤ 7), and a single alternation of quantifiers (∀ inside a ¬∀), which makes it a concise yet quantifier‑intensive BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_4.smt2",
    "description": "This instance encodes a safety‑verification problem for a C implementation of a bakery‑style mutual‑exclusion algorithm, generated by Ultimate Automizer from an SV‑COMP benchmark.  The desired invariant (that two threads never simultaneously hold the lock) is expressed as a series of universally quantified bit‑vector equalities involving extensive masking, zero‑extensions, extracts and Boolean combinations, and the final check asserts the negation of that universal property.  The formula features deep term nesting (depth ≈ 130), a large number of quantified variables (10 ∀‑blocks) and thousands of bit‑vector operations, making it a challenging industrial‑scale verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_9.smt2",
    "description": "This instance is a bit‑vector verification condition generated by Ultimate Automizer for a C program that implements a “soft‑float’’ addition.  The formula models the extraction of the 23‑bit mantissa of two floating‑point values (by masking with 0x00 FF FF FF and OR‑ing the hidden‑bit 0x01 00 00 00), relates a shifted version of the second mantissa to a primed copy, and then asserts that there is **no** choice of a delta and two original mantissas for which the shifted sum (after a right‑shift by 1) equals the first mantissa.  The problem therefore checks an unsafe‑state condition of the addition routine; it contains three nested existential quantifiers, bit‑wise AND/OR, logical right shifts, and a single addition, with a moderate term depth (9) and a handful of 32‑bit variables, making it a typical BV‑encoded software‑verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.fischer.1.prop1-back-serstep.c_2.smt2",
    "description": "The file is a verification condition generated by Ultimate Automizer for an SV‑COMP C benchmark: it describes a transition relation over several 8‑bit inputs, a 32‑bit program variable and a state flag, and asserts that whenever the state is non‑zero a complex masked bit‑wise expression (built from zero‑extensions, extracts, bv‑and, bv‑not and arithmetic) must evaluate to 0, together with constraints that masked multiples of the 32‑bit variable (3·var₁₃₂ and 2·var₁₃₂) are zero. The final assertions force particular inputs to be non‑zero and negate the universal conditions, turning the check into the search for a reachable unsafe state. The formula therefore encodes a safety‑property verification problem with deep nested BV terms, many forall‑quantifiers over 8‑bit variables, and non‑trivial arithmetic, which makes it a hard quantifier‑heavy BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_4.smt2",
    "description": "This instance is a bit‑vector safety‑verification condition produced by Ultimate Automizer for a SV‑COMP 2023 C benchmark. It asserts that a linear combination of the program’s 32‑bit variables x, y, z and several nondeterministic inputs never equals 1 (universal quantifier), while simultaneously asserting that there exists a choice of nondeterministic inputs for which the same sum does equal 1 (existential quantifier), together with the program’s explicit assertion variable set to 1. The formula therefore encodes an attempt to prove or refute an assert‑failure, featuring a small set of BV variables but a quantifier alternation that drives the solving difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_4.smt2",
    "description": "The instance encodes a safety‑verification condition for a software routine that implements a simplified floating‑point addition using 32‑bit bit‑vector operations. Two constants model the intermediate “mantissa‑adjusted” results of the operands ( c_addflt_~ma~0#1 and c_addflt_~mb~0#1 ); the first two existential conjuncts define these constants from symbolic inputs a, b and a shift amount δ by masking, setting the hidden‑bit (2²⁴) and logical right‑shifts. The final assertion states that there is **no** choice of a, b, δ (and a) such that, after adding the two adjusted values and right‑shifting once, the result equals the first adjusted constant, i.e. it checks that a certain overflow/rounding situation cannot arise. Hence the problem is a quantifier‑free bit‑vector verification query (a single outer negated existential) with modest term depth (≈9) and a handful of variables, typical of the Ultimate Automizer’s software model‑checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_0.smt2",
    "description": "The script is a safety‑verification condition generated by Ultimate Automizer for a 32‑bit C benchmark. It asserts that for **all** possible nondeterministic values of four 32‑bit variables the linear expression  \n\n`x + 2·nondet4_9 + 2·nondet5_9 + 2·nondet5_10 + 2·nondet4_10 + y`  \n\nnever equals the constant 1, while simultaneously requiring that **there exists** a pair of nondeterministic values for which the simpler expression  \n\n`x + 2·nondet5_10 + 2·nondet4_10 + y`  \n\ndoes equal 1. The problem is thus a quantifier‑rich bit‑vector verification query (two top‑level universal quantifiers, one negated) with shallow term depth and only a handful of variables, typical of the automated software model‑checking tasks used in SV‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_3.smt2",
    "description": "This benchmark encodes a verification condition for a 32‑bit software implementation of floating‑point addition (the “addflt” routine). The first assertion defines the relationships between the raw 32‑bit inputs a, b and their extracted exponent and mantissa fields using shifts, masks, and bias adjustments; the second asserts the negation of an existential property that would witness a mismatch between the computed aligned mantissa ma and a particular shifted combination of the original operands and a delta term. Hence the instance checks, via a single quantified block over three bit‑vectors, that the alignment step of the soft‑float addition never violates the intended invariant, a typical safety‑verification query with modest term depth and a small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_3.smt2",
    "description": "The script encodes a safety‑verification condition for a C benchmark (jain_7‑1.c) generated by Ultimate Automizer. It asserts that for all possible nondeterministic 32‑bit values the linear bit‑vector expression  \n\n`z + 4194304·v4 + 4194304·v4′ + 4·x – (4194304·v5′ + 2·y + 4194304·v5) + 4194304·v6 + 4194304·v6′`  \n\ncan never equal the constant 1048576, while simultaneously asserting the existence of values that make this equality hold (via a negated universal). The instance therefore checks the unsatisfiability of a contradictory assertion, using quantified BV arithmetic with large constants, a modest term depth (9) and a handful of quantified variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.protocols.1.prop1-func-interl.c_0.smt2",
    "description": "This instance is a bit‑vector safety‑verification problem generated by the Ultimate Automizer tool from an SV‑COMP 2023 C benchmark.  It models a program with dozens of 8‑ and 32‑bit variables (including a set of “state_ ” flags) and their primed next‑state versions, using a large conjunction of bit‑wise (and, or, not) and arithmetic (add, shl) expressions to capture the program’s transition relation; the property being checked is a `VERIFIER_assert` that a particular 32‑bit condition (`c_ULTIMATE.start___VERIFIER_assert_~cond#1`) must hold in every reachable state.  The formula contains three top‑level asserts (one asserting the safety condition, one asserting the mask constant, and one negating the conjunction to look for a counter‑example), a handful of existentially‑quantified helper variables, and exhibits a high term depth (≈80) with 715 declared constants, making it a heavyweight industrial verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_5.smt2",
    "description": "The file encodes a bounded‑model‑checking instance for a C benchmark (the function `main` together with a `VERIFIER_assert`) where the 32‑bit variables x, y and z are updated by nondeterministic values multiplied by large constants (e.g. 2 048 576, 4 194 304).  The safety property is that a derived expression—essentially z + 4·x − 2·y + ⋯—must never equal the constant 1 048 576, which is expressed by a universally quantified clause and an assertion that the monitor variable cond equals 1.  The query thus checks whether the assertion can be violated; it features several nested `forall` quantifiers over nondeterministic bit‑vector inputs, many large‑scale multiplications, and a term depth of 10, making the solving effort dominated by quantifier reasoning over bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-2.c_1.smt2",
    "description": "This instance is a safety‑verification condition produced by Ultimate Automizer for a C benchmark. It states, with universally quantified nondeterministic 32‑bit variables, that a linear combination of the program’s inputs x, y, z (scaled by the constants 2, 4 and 4 194 304) can never equal the constant 1 048 576; the second assertion negates this universal claim, demanding an existential witness that makes the equality true, thus encoding a reachability‑of‑error check. The formula consists of a small set of bit‑vector variables but features quantified arithmetic and nested multiplications, giving it moderate term depth (9) and typical difficulty for BV‑solvers handling SV‑COMP verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_2.smt2",
    "description": "The script encodes a safety‑verification condition for a tiny C program that manipulates three 32‑bit variables x, y and z.  Each variable is initialized as a nondeterministic value multiplied by a fixed power‑of‑two constant (1048576, 2097152, 4194304) and is then updated by adding another nondeterministic multiple of the same constants; the verifier assert checks that the post‑state expression z + 4·x − 2·y is not equal to 1048576 (the condition is encoded as a 0/1 bit‑vector).  The final “(not …)” clause asks whether, after one transition, the primed variables can still be expressed as those same scaled multiples – i.e. it searches for a reachable state that violates the invariant that each variable remains a constant‑multiple, thereby proving or disproving the asserted safety property.  The problem involves only existential quantifiers (no alternation) over a handful of bit‑vector terms (max depth 9), so the difficulty stems mainly from the quantified arithmetic rather than the size of the formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_11.smt2",
    "description": "This instance models a single‑step transition of a C program (jain_6‑1.c) that manipulates three 32‑bit variables x, y, z and updates them with nondeterministic “aux” values; the primed symbols represent the post‑state.  The assertions encode the program’s safety claim (`__VERIFIER_assert`) as a bit‑vector condition that must stay non‑zero for all possible nondeterministic choices, and the final formula negates a universal property, thereby asking whether a counterexample (an assertion violation) exists.  The problem is a bounded software‑verification query expressed in BV logic with quantified arithmetic, featuring moderate term depth (8) and several quantified variables, making it a non‑trivial safety‑property check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_7.smt2",
    "description": "The script encodes a safety‑verification task for a small C program in which three 32‑bit variables x, y, z are updated in one step by adding 4·nondet₄, 4·nondet₅ and 8·nondet₆ respectively, after which an assertion checks that the sum x + y + z is **not** equal to 1.  The transition relation is expressed with primed/unprimed bit‑vector variables, and two universally quantified blocks state that for *all* possible nondeterministic values the summed expression never equals 1, while the final query asks whether the asserted condition can become false after the step.  This BV instance combines arithmetic, ite, and nested quantifiers, leading to a non‑trivial quantified bit‑vector safety check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_10.smt2",
    "description": "This instance models a verification condition for a small C program (jain_2‑2.c) in which the 32‑bit variables x and y are each incremented by twice a nondeterministic value.  The SMT encoding captures the transition (primed) state, the assertion “x′+y′ ≠ 1” (implemented via an ite that yields 1 or 0), and a universal clause stating that for all possible nondeterministic choices the sum can never equal 1; the outer ​(not (forall …)) asks whether a counter‑example exists.  Consequently the problem is a BV‑based software‑verification query with quantified bit‑vector arithmetic, moderate term depth (7) and a mix of universal quantifiers and arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_0.smt2",
    "description": "The instance encodes a verification condition generated by Ultimate Automizer for a C benchmark that reasons about a linear‑inequality invariant on 8‑bit values. It declares a 32‑bit bit‑vector c and asserts that **there exists a tuple of four 8‑bit variables whose zero‑extended values sum (via bvadd) to c**, while simultaneously asserting **that no tuple of five 8‑bit variables can produce the same sum** (the second clause is the negation of an existential, i.e., a universal‑over‑negated condition). Hence the solver must decide the satisfiability of an ∃ ∧ ¬∃ (equivalently ∃ ∀ ¬) formula over bit‑vectors, a small‑scale but quantifier‑alternating problem that tests the tool’s ability to handle linear bit‑vector arithmetic and simple quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_3.smt2",
    "description": "The instance encodes the verification condition of a C program where an assertion (represented by `|ULTIMATE.start___VERIFIER_assert_~cond#1| = 1`) must hold for all possible nondeterministic 32‑bit inputs. It asserts that for every pair of nondeterministic values the expression `y + x + 2·v₅ + 2·v₄` can never equal 1, while simultaneously requiring that there exists a quadruple of nondeterministic values making a larger sum (`y + x + 2·v₄₉ + 2·v₅₁₀ + 2·v₅₉ + 2·v₄₁₀`) equal to 1, thus checking the consistency of the original program’s assert. The problem is a pure‑BV verification query with two universal quantifiers (no alternation) and shallow term depth, making quantifier reasoning the primary source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_9.smt2",
    "description": "The benchmark encodes a safety‑verification task for a small C program (variables x, y, z) where an `__VERIFIER_assert` is required to hold. The model uses 32‑bit bitvectors and asserts that for all nondeterministic inputs the linear combination  \n\n```\n‑(2·y + 4·x + 4194304·nondet5 + 4194304·nondet4 + 4194304·nondet6) + z\n```  \n\ncan never equal the constant 1048576, while simultaneously demanding that the program’s assertion condition is non‑zero (i.e., the original `assert` would fail). A second, negated universal quantifier forces the existence of a concrete assignment violating the equality, turning the whole query into a check for a counterexample. Hence the instance is a quantifier‑heavy bit‑vector safety verification problem that tests the solver’s ability to handle universally quantified arithmetic constraints with several large constant multiplications.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_1.smt2",
    "description": "The script encodes a safety‑property check for the C benchmark *jain_6‑1.c*: it asserts that for **all** possible nondeterministic 32‑bit inputs the weighted sum  \n`2·y + 8·nondet5_9 + 8·nondet4_10 + z + 8·nondet6_10 + 8·nondet5_10 + 4·x + 8·nondet6_9 + 8·nondet4_9` can never equal the constant 4, while simultaneously asserting that **there exists** a choice of three nondeterministic inputs making the smaller sum  \n`2·y + 8·nondet4_10 + z + 8·nondet6_10 + 8·nondet5_10 + 4·x` equal 4.  \n\nThus the problem is a BV verification query with mixed universal and existential quantifiers (∧ ∀ … ∧ ∃ …) over linear arithmetic with constant multiplications; the moderate term depth (7) and presence of quantified bit‑vector multiplications make it a non‑trivial instance for automated solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.cambridge.1.prop2-func-interl.c_2.smt2",
    "description": "This instance is a safety‑verification query generated by Ultimate Automizer for an SV‑COMP benchmark: it encodes a C program’s transition in 8‑bit bit‑vectors, where a large nested expression of bitwise masks, extracts, zero‑extensions and logical operations computes the next state from a collection of input bytes. The formula asserts that either a universally quantified condition over all possible inputs holds or the computed expression equals zero, while it simultaneously forces the universal condition to be false and the two state variables (`state_23` and `var_166`) to be unequal, thus checking that the “zero‑output” case cannot occur. The problem features a single ∀‑quantifier but a very deep term (depth ≈ 192) with hundreds of bit‑vector operations, making it a demanding bit‑blasting verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_11.smt2",
    "description": "This SMT‑LIB instance encodes a bit‑vector safety verification problem generated by Ultimate Automizer for a C implementation of the bakery mutual‑exclusion algorithm (the “bakery” benchmark from SV‑COMP 2023).  The formula asserts that, for all possible nondeterministic 8‑bit inputs and intermediate variables, the encoded transition relation never reaches a state where the two key state variables |state_18| and |var_165| become equal (or, equivalently, that a mask‑based invariant involving the 32‑bit variable |var_46| and a multiplication by 2 holds), and it checks the unsatisfiability of the negated property.  The problem features a deep term structure (max depth ≈ 130), extensive use of zero‑extension, extracts and bitwise operations, and ten quantified blocks over dozens of variables, making it a demanding BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_10.smt2",
    "description": "The script encodes a bit‑vector verification condition for a small floating‑point addition routine.  It introduces symbolic 32‑bit values for the mantissas of the two operands ( |addflt_~a#1|, |addflt_~b#1|), extracts the low‑order mantissa bits and the hidden‑bit ( 0x01000000) using masks (bvand/bvor), models a right‑shift by a variable delta, and then asserts that there is **no** choice of inputs and delta for which the shifted sum of the two operands (plus a constant 1) equals the pre‑computed result |c_addflt_~ma~0#1|.  In other words, the instance checks the unreachability of a particular erroneous relation in the soft‑float addition implementation, using only existential quantifiers (wrapped in a negation) and shallow bit‑vector arithmetic.  The problem is a bounded‑model‑checking style safety query with moderate term depth and a small number of quantified variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_5.smt2",
    "description": "The script encodes a software‑verification condition for a C benchmark: it asserts that the 32‑bit linear expression `z + y + x + 8·n6 + 4·n4 + 4·n5` can never equal 1 for any nondeterministic values `n4, n5, n6` (first universally quantified clause), while simultaneously demanding the existence of values (including additional copies of the same nondeterministic variables) that make the same expression equal 1 (the negated universal clause). The condition flag of the original `__VERIFIER_assert` is forced to true, so the instance checks the consistency of the generated verification condition. It is a bit‑vector bounded‑model‑checking problem featuring a small quantified formula (one alternation of ∀/∃) with modest term depth (7) and a handful of 32‑bit variables, making quantifier handling the main source of difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.vis_arrays_vsa16a_p6.c_5.smt2",
    "description": "This instance encodes a bit‑vector safety verification problem generated by Ultimate Automizer for a small C benchmark: it models a sequence of 8‑bit arithmetic and bit‑wise operations (addition, right‑shift, masking, conjunction/disjunction) and asks whether a particular masked expression can ever equal a given state variable. The property is expressed with several universally quantified variables and a negated conjunct, so the solver must find a counter‑example to the claimed invariant; the formula contains deep nesting (term depth 54) and many zero‑extensions/extractions, making it quantifier‑intensive and challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_6.smt2",
    "description": "The file encodes a verification condition for a 32‑bit software floating‑point addition routine (the benchmark *soft_float_4-2.c*).  The constraints extract exponent and mantissa fields from two input words using shifts, masks (0x00FFFFFF) and inserts (0x01000000), relate these to “primed’’ intermediate values, and finally assert that no assignment to auxiliary variables (representing alternative mantissas and a delta) can make the computed mantissa `c_addflt_~ma~0#1_primed` equal to a particular shifted sum expression; i.e., it checks an invariant that a certain combination of mantissa/ exponent bits cannot be reached.  The problem is a BV verification query with a single negated existential quantifier, modest term depth (≤9) and only a handful of bit‑vector operations, making it a small but non‑trivial instance typical of software model‑checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_4.smt2",
    "description": "This instance encodes a safety‑verification condition generated by Ultimate Automizer for the C benchmark *jain_6‑1.c*.  It asserts that a linear combination of several 32‑bit program variables (the inputs x, y, z) and three nondeterministic values multiplied by small constants can never equal the constant 4, and simultaneously checks whether this universally‑quantified property can be falsified (i.e., whether there exists a valuation making the sum = 4).  The problem is a pure bit‑vector satisfiability check with two quantified formulas (one universal and one negated universal), modest term depth (7) but a non‑trivial amount of multiplication and addition, typical of software‑verification invariant/Assertion‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_1.smt2",
    "description": "The script encodes a verification condition for a C program where three 32‑bit inputs x, y, z are fixed constants and several nondeterministic 32‑bit values are introduced. It asserts that for **all** possible nondet values the weighted sum  \n\n\\(x+z+8·n_6^{10}+4·n_4^{10}+4·n_5^{10}+4·n_5^{9}+4·n_4^{9}+8·n_6^{9}+y\\)  \n\nnever equals the bit‑vector constant 1, and simultaneously asserts the **negation** of an analogous universal claim (i.e., that there exists a choice of nondet values making the sum equal 1). The problem is thus a software‑verification check reduced to quantified bit‑vector arithmetic, featuring a single quantifier alternation (∀ followed by an implicit ∃ via the negated ∀) over a modest number of variables and shallow term depth, which makes the main difficulty the handling of quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_8.smt2",
    "description": "This instance encodes a safety‑property verification of a 32‑bit software floating‑point addition routine. The constraints model the extraction and normalization of the 24‑bit mantissas (by masking with 0x00FFFFFF and OR‑ing with 0x01000000), compute a delta = ea − eb, shift one operand by that delta, and then check that the normalized result cannot equal the right‑shift‑by‑1 of the sum of the two normalized mantissas. The formula is a quantifier‑free BV problem (only existential quantifiers appear in the premises) with a moderate term depth (≈9) and a small number of 32‑bit bit‑vector variables, making it a typical industrial verification task generated by Ultimate Automizer for the SV‑COMP benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-2.c.cil.c_6.smt2",
    "description": "The instance encodes a verification condition for a software implementation of floating‑point addition generated by Ultimate Automizer from the SV‑COMP 2023 benchmark *soft_float_1‑2.c*. It asserts that, under the non‑zero guard `c_ULTIMATE.start_assume_abort_if_not_~cond#1`, there exist 32‑bit words a and b whose mantissa parts are forced to have the implicit leading‑one bit (by masking with 0x00FFFFFF and OR‑ing 0x0100000), and then checks that no choice of a, b and a shift amount δ makes the normalized result of the addition (`(ma + (mb>>δ))>>1`) equal the pre‑computed constant `c_ULTIMATE.start_addflt_~ma~0#1`. Thus the problem is a quantifier‑heavy bit‑vector verification task that tests an invariant of the soft‑float addition algorithm; its difficulty stems from three nested existential quantifiers combined with bitwise and shift operations of depth 9.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_2.smt2",
    "description": "The instance is a bounded‑integer verification query generated by Ultimate Automizer from a SV‑COMP benchmark (heapsort). It encodes a simple arithmetic condition over a 32‑bit variable n: n must lie between 1 and 1 000 000, and auxiliary variables are defined as r = n and l = ⌊n/2⌋+1. The formula then asks whether it is possible that l > 0 while **no** value n′ ≤ 1 000 000 exists with l = ⌊n′/2⌋, i.e., it checks the reachability of a contradictory bound. The problem consists of only a few bit‑vector constraints, a single existential quantifier within a negated conjunction, and shallow term depth, making it a small‑scale, quantifier‑rich verification check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_7.smt2",
    "description": "The script encodes a verification condition for a C program that manipulates “soft‑float” values using 32‑bit bit‑vector operations. It first defines an assertion that a Boolean flag (`c___VERIFIER_assert_#in~cond`) must equal the result of a signed‑greater‑or‑equal test between two encoded floating‑point operands, then relates the operands to bit‑patterns that set a specific exponent bit (0x01000000) while masking the mantissa (0x00FFFFFF). Finally it asserts that no choice of the original operands and a shift‑delta can produce a particular shifted‑addition result, i.e., it checks the absence of a specific overflow/rounding bug. The problem is a pure BV satisfiability check with three existential quantifiers, moderate term depth (≤ 9) and a mix of bitwise, shift, and addition operations, typical of industrial software‑verification instances generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_6.smt2",
    "description": "This instance encodes a safety‑verification query for a small C program: it checks that a `VERIFIER_assert` condition involving three integer variables x, y, z and several nondeterministic inputs never becomes false. The property is expressed as a universal quantified constraint over the nondet variables (ensuring a certain linear bit‑vector expression never equals 4) and linked to the program’s next‑state equations; the final assertion negates this universal, so the solver must find a concrete assignment that violates the assertion. The problem is a quantified bit‑vector verification task with moderate term depth (≈8) but a dense use of multiplications and additions, making it a non‑trivial quantified‑BV challenge for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_6.smt2",
    "description": "The script encodes a small arithmetic verification problem over 32‑bit signed bit‑vectors. It asks whether there exists a number n (1 ≤ n ≤ 1 000 000) such that a constant l equals n / 2 + 1, while simultaneously guaranteeing that no number n within the same bound satisfies l = n / 2. This quantified‑BV formula tests a subtle property of integer division (the “+ 1” offset creates a value that is reachable by the first division but not by the plain division), and its difficulty stems mainly from the two alternating existential quantifiers rather than from term size or depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_1.smt2",
    "description": "The instance encodes a verification condition for a small soft‑float routine, translated by Ultimate Automizer into a quantifier‑rich bit‑vector formula.  It asserts a relationship between state variables (e.g. `ea`, `eb`, `ma`) and two abstract 32‑bit values (`addflt_a`, `addflt_b`) that must respect a non‑ordering property (`¬(addflt_a < addflt_b)`) both before and after a transition that increments `ea` and right‑shifts `ma`.  The goal is to prove that the ordering invariant is preserved across the transition; the formula contains only existential quantifiers (no alternation) and shallow term depth, making it a typical industrial software‑verification VC with moderate size but non‑trivial quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_10.smt2",
    "description": "The instance encodes a verification condition for a software implementation of a soft‑float addition routine. It models the 32‑bit floating‑point representation with bit‑vector operations that extract and shift mantissa fields (using the constant 2²⁴ = 16777216), and asserts that the computed result (`c_ULTIMATE.start_addflt_#res#1`) must equal the value returned by the main function while also checking that no choice of input mantissas `a`, `b` and shift amount `delta` can make the normalized mantissa `ma` equal the rounded sum of the two shifted mantissas. The formula contains only existential quantifiers (no alternation) and a shallow term depth, making it a relatively small BV‑only verification problem typical of SV‑COMP benchmarks generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_9.smt2",
    "description": "The script encodes a safety‑verification problem generated by Ultimate Automizer for a C benchmark from SV‑COMP 2023.  It asserts that, for all possible nondeterministic 32‑bit values involved in the computation of x and y, a certain linear combination (built with additions and multiplications by 2) can never equal 1, while simultaneously requiring the program’s assertion condition (represented by c_ULTIMATE.start___VERIFIER_assert_~cond#1) to be non‑zero.  Hence the solver must decide the (in)validity of a quantified bit‑vector invariant, a quantified SAT check with a modest number of variables but non‑trivial quantifier structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_10.smt2",
    "description": "The script encodes a verification condition for a software implementation of floating‑point addition (the benchmark *soft_float_4-2a.c*).  It models the mantissa construction using the 0x01000000 mask and the 24‑bit mantissa mask 0x00FFFFFF, relates three existentially quantified 32‑bit variables (the raw operands, a shift amount Δ, and the resulting bit‑vector c_addflt_~ma~0) through a sequence of bit‑wise OR, AND, logical right‑shifts and a bvadd, and then asserts that no choice of the same variables can make the double‑shifted sum equal the original result (i.e., it checks a rounding/normalisation property).  The instance is a pure‑BV verification problem with only existential quantifiers, moderate term depth (9) and a handful of bit‑vector operations, typical of automata‑based software model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_5.smt2",
    "description": "This instance encodes a BV‑based verification condition that asks whether a 32‑bit constant (the program’s abstract state) can be obtained as the sum of three 8‑bit variables (zero‑extended to 32 bits) while it cannot be expressed as the sum of six 8‑bit variables.  Formally it contains one existential clause asserting the three‑term equality and a negated existential clause forbidding any six‑term equality, yielding a simple quantified linear‑arithmetic problem.  The formula has only a handful of bit‑vector variables (nine in total), shallow terms (depth ≤ 6) and two quantified blocks, making it a small but quantifier‑rich benchmark typical of invariant‑checking conditions generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_8.smt2",
    "description": "The file encodes a software‑verification condition for a soft‑float addition routine: three 32‑bit bit‑vector constants model the normalized mantissas of two operands and a delta, with constraints that enforce IEEE‑754‑style normalization (setting the hidden leading 1 via a mask) and that the delta is bounded by 2³².  The final assertion states that no choice of operand mantissas and delta can make the computed, right‑shifted sum equal a given target mantissa, i.e. it checks the correctness of the rounding/shifting step of the addition.  The problem is a pure BV verification query with three existential quantifiers inside a negated formula, shallow term depth (≤9) but non‑trivial quantified bit‑vector arithmetic, typical of bounded model‑checking instances generated by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_0.smt2",
    "description": "The file encodes a safety‑property check for a C program compiled by Ultimate Automizer for the SV‑COMP benchmark suite. It asserts that for **all** possible 32‑bit nondeterministic values of the variables v\\_… the linear combination  \n\n```\n1048576 ≠ 4194304·v4 + z + 4194304·v4' – (2·y + 4194304·v5 + …) + 4·x + 4194304·v6 + 4194304·v6'\n```  \n\ncannot hold, and simultaneously asserts the **negation** of this universal claim (i.e. that there exists a choice of the nondet variables making the equality true). The combination of a universal and an existential quantifier over bit‑vectors creates a classic reachability/verification query: the solver must show the formula is unsatisfiable, proving the safety invariant. The instance features a modest number of variables (three concrete constants and several nondet inputs) but uses quantified bit‑vector arithmetic with a term depth of 9, which can be challenging for solvers due to the quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_4.smt2",
    "description": "The formula encodes a safety‑verification task produced by Ultimate Automizer for a C benchmark: it asserts that a linear combination of the program variables x, y, z and three nondeterministic 32‑bit inputs never equals the constant 1048576. This is expressed by a universally quantified inequality, while the final clause is the negation of a similar universal statement, which is equivalent to asking whether there exist concrete values for the nondet inputs that make the equality hold (i.e., a counterexample to the `VERIFIER_assert`). The problem involves only bit‑vector arithmetic (with several large‑scale multiplications) but requires reasoning across quantifier alternation (∃ over nondet variables inside a universal context), making it a non‑trivial quantified BV verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_6.smt2",
    "description": "The script encodes a verification condition for a 32‑bit software implementation of floating‑point addition (the benchmark *soft_float_1‑1.c*).  Using bit‑vector operations it models the extraction of mantissa bits (mask 0x00FFFFF and the hidden 1 at 0x0100000), aligns the second operand by a logical shift, and asserts that, under the precondition that the second operand’s mantissa is zero and the program’s return value equals the first operand, there is **no** choice of input mantissas and shift amount that makes the computed mantissa `ma` equal the right‑shifted sum of the two aligned mantissas.  Thus the instance checks a safety property of the addition routine (absence of a specific overflow/normalisation bug) and consists of a small quantified BV formula with three existential quantifiers and shallow term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/Primes.c_3.smt2",
    "description": "The instance encodes a verification condition on 32‑bit arithmetic: it defines a result as `c_res = 4·c_in + 1` and then asserts that there is **no** 32‑bit value `mult` such that the same result can also be written as `6·mult + 1`. In other words, it checks that a number of the form `4·n+1` cannot simultaneously be expressed as `6·m+1` (a simple divisibility/property check extracted from the *Primes.c* benchmark). The problem is a quantifier‑free BV verification query with only two constants, shallow term depth (≤6), and a single existential quantifier under a negation, making it a small‑scale arithmetic invariant‑checking instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.unsafe_arbitrated_fifos_n2d8w8.c_1.smt2",
    "description": "The script encodes a bounded‑model‑checking proof obligation for the C program *unsafe_arbitrated_fifos_n2d8w8.c* (an arbitrated FIFO with 8‑bit data words).  It asserts that, for all possible 8‑bit input values, a complex masked combination of the current abstract state ( |c_…state_83| ) and the inputs never yields a non‑zero result—i.e., a safety invariant of the FIFO is preserved.  The formula is a universally‑quantified bit‑vector constraint with deep nesting of zero‑extension, extraction, and bitwise and/or/not operations (max term depth 48), making it a challenging BV‑only verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_4.smt2",
    "description": "The instance encodes a consistency check for a bit‑wise interval defined by two 4‑bit masks `xlo` and `xhi`.  After asserting that the masks are compatible ( `(bvnot xlo) ∨ xhi = 1111` ), it requires that there is **no** 4‑bit value `x` satisfying the mask (the predicate `mcb`) together with a literal of the form `x + s = t` for some 4‑bit `s` (expressed by the existential quantifier).  Hence the solver must verify that the interval described by `xlo`/`xhi` is empty; the problem features a small 4‑bit domain, several helper bit‑vector functions, nested ite/extracts, and a single existential quantifier, giving a modest term depth but a non‑trivial quantified constraint.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_32.smt2",
    "description": "This instance verifies a bit‑precise consistency condition (named CC) for the 32‑bit arithmetic right‑shift operator bvashr. It asserts that there exists a tuple (t, xlo, xhi) satisfying a syntactic interval mask ( (bvor (bvnot xlo) xhi) = all‑ones ) for which the derived condition CC differs from the direct existence of a value x and shift amount s such that x lies inside the interval (captured by mcb) and x >> s equals t; the solver is asked to find a concrete counterexample or prove none exists. The formula combines deep nested ite‑chains for count‑leading/trailing‑zero/one functions, several existential quantifiers and bit‑vector extracts, yielding moderate term depth (≈35) but a relatively small quantified search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_32.smt2",
    "description": "The instance verifies a consistency condition on two 32‑bit mask bounds `xlo` and `xhi`. It asserts that the bounds are bit‑wise compatible (no bit where `xlo` is 1 and `xhi` is 0) and then checks that the Boolean “`xlo` is not all‑ones” differs from the existence of some value `x` satisfying the mask interval (`mcb xlo xhi x`) and an unrelated unsigned‑less‑than relation (`x < s`). Because the existential is always true under the compatibility constraint, the formula forces `xlo` (and consequently `xhi`) to be the all‑ones constant, making the problem a crafted bit‑vector verification task with a single existential quantifier and moderate term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_32.smt2",
    "description": "The instance verifies a consistency condition for a 32‑bit mask operator. It introduces constants tx, ts, xlo, xhi and defines `mcb` to require a value v to lie between the lower and upper mask bounds (`xlo ⊑ v ⊑ xhi`). The formula asserts that the mask condition on tx (`CC`) is *distinct* from the existence of a pair (x,s) such that the same mask holds for x and the concatenation `(s‖x)` equals `(ts‖tx)`. The check thus asks whether the mask‑containment predicate is equivalent to the existence of a matching concatenated literal, featuring a single existential quantifier, deep nested ite definitions (for `ctz`/`clz`, though unused), and a moderate term depth (≈35) that challenge bit‑vector quantifier solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_32.smt2",
    "description": "The instance checks a consistency property of 32‑bit left‑shift operations. It defines a mask‑range predicate *mcb* (requiring a value v to lie between low xlo and high xhi in a bitwise sense) and a condition *CC* that there exists a shift amount i (bounded by the count‑of‑trailing‑zeros of a target term t) such that the shifted bounds still contain t. It then asks whether this condition is equivalent to the simpler formulation “there is some mask x inside the original bounds that can be left‑shifted by some amount s to obtain t”, asserting the two are distinct; thus the solver must find a counter‑example or prove none exists. The problem involves quantified bit‑vector arithmetic, deep nested ite‑based definitions of ctz/clz, and a single quantifier alternation, making it a crafted verification benchmark for bit‑precise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvxor_x_s_32.smt2",
    "description": "The benchmark verifies a consistency condition for a bit‑vector interval: the 32‑bit masks `xlo` and `xhi` must satisfy the inclusion `xlo ⟹ xhi` (expressed by `(bvor (bvnot xlo) xhi) = ones`), and the formula then asserts that **no** value `x` inside this interval (checked by `mcb`) can be paired with a witness `s` such that `x xor s = t`. Since any non‑empty interval always yields an `x` (e.g., `x = xlo`) and a corresponding `s = x xor t`, the `distinct(true, …)` constraint forces the existential part to be false, making the whole instance unsatisfiable.  The problem tests solvers’ handling of quantified existence together with deep nested `ite` chains (e.g., the `ctz`/`clz` definitions) that increase term depth despite having only a few variables and a simple logical structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_64.smt2",
    "description": "This instance checks a consistency condition for a 64‑bit mask pair (xlo, xhi).  After enforcing that the pair represents a valid “lower/upper” mask ( (bvor (bvnot xlo) xhi) = all‑ones ), it asks whether there can exist a value x and a “size” s such that x respects the mask ( (bvand xhi x) = x ∧ (bvor xlo x) = x ) and simultaneously satisfies the ordering s ≥ x (bvuge).  The query is expressed with a single existential quantifier and a deep, nested ite‑chain used to define auxiliary bit‑count functions (ctz, clz, etc.), giving a term depth of 67 and a large number of extracts, which makes the problem a challenging quantified‑bitvector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_4.smt2",
    "description": "The benchmark encodes a verification condition for 4‑bit bit‑vectors: it asserts that a simple inclusion test `CC(t,xlo,xhi)` (i.e. `t` is a subset of `xhi`) is *not* equivalent to the existence of a value `x` lying between `xlo` and `xhi` (enforced by `mcb`) together with a “literal’’ `s` such that `x ∧ s = t` (`LIT`).  The instance also forces the pair `xlo/xhi` to be monotone (`xlo ⊆ xhi`).  The solver must decide whether a counter‑example exists to this equivalence; the problem features a single existential quantifier over two 4‑bit variables and a handful of small helper definitions, making it a crafted, bit‑precise consistency‑check benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_64.smt2",
    "description": "The file encodes a verification condition on 64‑bit bit‑vectors: after asserting that two bounds `xlo` and `xhi` form a valid interval (every 1‑bit of `xlo` is also a 1‑bit of `xhi`), it checks that the trivially true predicate `CC` is **distinct** from the existence of a value `x` inside that interval (`mcb xlo xhi x`) together with a signed‑greater‑or‑equal witness `s` (`bvsge s x`). Because such an `x` (e.g., `x = xlo`) and a suitable `s` always exist, the distinctness constraint forces unsatisfiability, thus the instance tests the consistency of the bit‑mask interval definition with a signed‑inequality property. The problem is a pure BV SAT/UNSAT check with a single existential quantifier, but it contains very deep auxiliary definitions of `ctz`/`clz` (nesting over 64 bits) that increase term depth without affecting the core constraint, making it a crafted, potentially hard instance for solvers that fully inline definitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_32.smt2",
    "description": "The file encodes a bit‑vector consistency check: given two 32‑bit bounds `xlo` and `xhi`, it asserts that they form a valid interval (every 1‑bit of `xlo` is also 1 in `xhi`) and then requires that the always‑true predicate `CC(t,xlo,xhi)` be *distinct* from the existence of a value `x` that lies inside the interval (the “mask‑contain‑between” relation `mcb`) and equals some literal `s`. Because a valid interval always admits at least one such `x` (e.g., `x = xhi`), the distinctness constraint is unsatisfiable. The instance is a crafted verification problem that stresses solvers with deep nested `ite` expressions for `ctz`/`clz` (term depth 35) and many bit‑extracts, although these functions are not needed for the core unsat proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_64.smt2",
    "description": "This crafted BV instance checks a consistency condition for a masked interval: given 64‑bit bounds xlo and xhi that satisfy (bvor (bvnot xlo) xhi) = ones, it asserts that there cannot exist two distinct 64‑bit values x and s with x in the interval (i.e. mcb xlo xhi x) and x ≠ s. In other words, it verifies whether the interval defined by the bitwise mask can contain more than one element. The problem is a quantifier‑free verification query but is made hard by the extremely deep term structure (nested ite chains for ctz/clz using 64 extracts) and a large number of bit‑extract and ite operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_32.smt2",
    "description": "The file encodes a quantified bit‑vector consistency check: it declares two 32‑bit masks `xlo` and `xhi` that must satisfy the complement condition `(bvor (bvnot xlo) xhi) = 0xFFFFFFFF`, and then asserts that there is **no** pair `(x,s)` such that `x` lies inside the mask (i.e., `x` is both a subset of `xhi` and a superset of `xlo`) and `s` is signed‑greater‑or‑equal to `x`.  This is expressed as a `distinct` between the always‑true predicate `CC` and an existential formula, forcing the existential to be false.  The instance features deep, nested `ite` chains for `ctz`/`clz` (unused elsewhere) and a single quantifier, making it a crafted BV‑logic verification problem that challenges solvers’ handling of quantifier elimination and large term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_x_s_32.smt2",
    "description": "The file checks a consistency condition for a 32‑bit mask‑range abstraction: it asserts that the always‑true predicate `CC` must be distinct from the existence of a 32‑bit value `x` that fits inside the bitwise interval defined by masks `xlo`/`xhi` (each bit is forced either low or high) and that is signed‑greater‑or‑equal to some bound `s`. The additional constraint `bvor (bvnot xlo) xhi = ones` guarantees complementary masks, and the final `distinct` forces the solver to prove that no such `x` and `s` can exist, which renders the instance unsatisfiable. The problem contains a single existential quantifier, deep nesting of `ite`/`extract` terms (term depth 35), and several custom bit‑vector functions, making it a crafted verification benchmark that tests quantifier handling and bit‑precise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_4.smt2",
    "description": "The instance checks a consistency condition for 4‑bit bit‑vector operators: it defines masks xlo/xhi that together cover all bits, a predicate CC(t,xlo,xhi) that holds when either t is zero or there exists a value i bounded by the leading‑zero count of t and lying between the masks, and a second condition that there exist x (and a shift amount s) such that x respects the same masks and a logical right‑shift of s by x produces t. The final assertion requires these two Boolean conditions to differ, i.e., it searches for a counter‑example to their equivalence. The problem is a small‑scale verification task with nested uninterpreted functions, ite‑based bit‑counting definitions, and two existential quantifiers, which makes it non‑trivial for bit‑vector solvers despite the tiny 4‑bit domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_32.smt2",
    "description": "The file encodes a verification condition for a bit‑vector interval representation: given 32‑bit bounds `xlo` and `xhi` that satisfy the mask constraint `bvor (bvnot xlo) xhi = 0xffffffff`, it checks that there does **not** exist a value `x` inside this interval (`mcb xlo xhi x`) together with some `s` such that the trivial inequality `s ≥ x` holds (the predicate `LIT`). This is expressed by asserting the inequality `distinct true (exists ((x) (s)) (and (mcb xlo xhi x) (LIT x s)))`, i.e. the existential must be false, which forces the solver to prove that the interval encoding is inconsistent with the inequality. The instance is a crafted BV problem with a single existential quantifier, a deep chain of bit‑extractions (used in auxiliary `ctz`/`clz` definitions) and moderate term depth, making it a test of a solver’s ability to handle quantified bit‑vector masks and simple arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_s_x_4.smt2",
    "description": "The instance encodes a verification condition for 4‑bit shift‑left (`bvshl`). It asserts that for any mask pair `xlo ⊆ xhi` (enforced by `bvor (bvnot xlo) xhi = 1111`) the predicate  \n\n```\nCC(t,xlo,xhi) ≜ (t = 0) ∨ ∃i≤ctz(t) . (i respects the mask xlo/xhi)\n```  \n\nis *different* from the existence of a shift amount `x` (also respecting the same mask) and a source value `s` such that `s << x = t`. The formula therefore checks the consistency of a count‑trailing‑zeros based characterization of shift results against the concrete definition of `bvshl`, using two existential quantifiers and bit‑vector operations (extract, ite, and, or, not). The problem is a small‑scale (4‑bit) quantified bit‑vector verification task, whose difficulty stems from the nested ite/​extract definitions and the need to reason about quantified mask constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_32.smt2",
    "description": "The formula checks whether a derived “interval condition” CC for a 32‑bit logical right‑shift (`bvlshr`) is equivalent to the concrete existence of a shift amount that lies within a bit‑wise interval `[xlo,xhi]` (captured by `mcb`) and actually produces the target result `t`.  It asserts that the two predicates – `CC t xlo xhi` and “∃ x,s · mcb xlo xhi x ∧ (bvlshr s x)=t” – are distinct, i.e. it looks for a counter‑example to the consistency of the condition.  The instance is a crafted BV‑verification problem with deep nested `ite` definitions for `ctz`/`clz`, a single quantifier alternation, and a maximum term depth of 35, making it a non‑trivial bit‑vector reasoning challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_s_x_32.smt2",
    "description": "The file encodes a bit‑vector consistency check: it defines a mask predicate `mcb` over two 32‑bit masks `xlo`/`xhi`, overflow predicates for addition and multiplication, and a bespoke condition `CC` that depends on a target word `t`. The final assertion asks the solver to show that `CC t xlo xhi` is **not** equivalent to the existence of a value `x` (constrained by the same mask) together with a dividend `s` such that the unsigned division `s ÷ x` equals `t`.  This verification problem involves quantified (existential) formulas, a deep manually‑expanded definition of `ctz`/`clz`, and several nested `ite`‑chains, giving a term depth of about 35 and a moderate number of 32‑bit variables, which makes it a challenging crafted BV‑logic instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_32.smt2",
    "description": "The instance checks a consistency condition for a bit‑vector interval predicate.  It declares a 32‑bit lower bound `xlo`, upper bound `xhi` (constrained so that `bvor (bvnot xlo) xhi` = all‑ones, i.e., they form a valid mask) and a Boolean predicate `mcb` that holds exactly for values `v` lying between the two bounds bit‑wise.  The formula asserts that the always‑true predicate `CC` is *distinct* from the existence of a value `x` inside that interval together with a literal condition `LIT` (`bvuge x s`).  Hence the query asks whether there is a model where the interval contains a value that is ≥ some `s`; if so the two sides would be equal and the `distinct` would be false.  The problem is a small quantified SAT check but includes very deep `ite` chains for `ctz`/`clz` (term depth 35), many bit‑extractions, and a single existential quantifier, making it a crafted verification benchmark for bit‑precise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_32.smt2",
    "description": "This instance encodes a verification condition for a 32‑bit unsigned‑division operator. It defines a mask predicate `mcb` that characterises values between two bit‑vectors `xlo` and `xhi`, overflow predicates for addition and multiplication, and a complex predicate `CC` that captures a case‑analysis on a candidate quotient `t`. The final assertion checks whether `CC(t,xlo,xhi)` is logically equivalent to the existence of a dividend `x` (constrained by the mask) and a divisor `s` such that `bvudiv x s = t`; the solver must find a model where the two differ, thus proving (or disproving) the consistency of the handcrafted division condition. The problem involves nested ite chains for bit‑counts, several quantifier‑alternations, and bit‑vector arithmetic, giving a moderately deep term structure (depth ≈ 35) with a handful of quantified variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_4.smt2",
    "description": "The instance checks a consistency condition for a 4‑bit bit‑vector range operator: it forces the lower‑bound/upper‑bound pair `xlo,xhi` to satisfy a bitwise monotonicity property, then asserts that the Boolean predicate  \n\n```\nCC(t,xlo,xhi)  ≡  (xlo = xhi) → (xlo ≠ maxs)\n```  \n\nis *distinct* from the existence of a value `x` inside that range (`mcb xlo xhi x`) that is signed‑less‑than some other 4‑bit value `s`.  In effect the formula verifies whether the simple “lo=hi ⇒ lo≠maxs” clause correctly captures the existence of a larger signed literal, requiring the solver to handle a shallow existential quantifier together with bit‑wise constraints and signed comparison.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_s_x_32.smt2",
    "description": "The benchmark encodes a consistency‑check for a bit‑vector interval: it asserts that the Boolean predicate CC, which only fires when the lower and upper masks are equal (and not the most‑negative value), must differ from the existence of a value x lying between the masks ( mcb ensures xlo ⊆ x ⊆ xhi bitwise) and simultaneously satisfying a signed‑less‑than literal (s < x).  The formula contains a single existential quantifier, a handful of 32‑bit constants, and several deeply nested ite definitions for counting‑trailing/leading zeros that inflate the term depth (≈35) but are otherwise unused, making the core reasoning relatively small yet syntactically challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_x_s_4.smt2",
    "description": "The formula verifies a consistency condition for a 4‑bit logical right‑shift operation under a bit‑mask constraint.  It defines a relation CC(t,xlo,xhi) that requires the existence of a shift amount i (bounded by the leading‑zero count of t) such that the masked interval [xlo≫i, xhi≫i] still contains t, and compares it to the direct existential statement that there is some x in the mask interval [xlo, xhi] whose logical right‑shift by some s yields t.  The final `distinct` assertion asks whether these two characterisations can disagree, thereby checking the correctness of the derived CC condition for the shift operator.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_64.smt2",
    "description": "This instance encodes a verification check on a consistency condition for a pair of 64‑bit masks `xlo` and `xhi`. The first assertion forces a bit‑wise inclusion (`xlo`‑bits are a subset of `xhi`‑bits) and the second asserts that the Boolean predicate “`xlo` is different from the all‑ones value” is **distinct** from the existence of a bit‑vector `x` that satisfies the mask bounds (`mcb xlo xhi x`) and is not maximal (i.e., there is some `s` with `x < s`). In other words, it tests whether the simple mask‑inequality correctly captures the existence of a non‑maximal value within the interval. The formula contains a single existential quantifier but features extremely deep nested `ite`/`extract` definitions (e.g., `ctz`/`clz`), giving a maximal term depth of 67 and making it a crafted, bit‑precise reasoning benchmark that can be hard for solvers despite the small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_64.smt2",
    "description": "This instance verifies a consistency condition for a custom predicate CC that relates a target value t and a pair of bit‑vector masks xlo/xhi to the existence of a dividend x and divisor s such that the unsigned division x ÷ s yields t while x respects the mask interval (encoded by mcb).  The check asserts that the truth value of CC differs from the existence of such a division pair, thereby testing whether CC accurately characterises the division‑reachability property.  The formula combines deep nested ite structures for bit‑level functions (e.g., ctz/clz) and two nested existential quantifiers, leading to high term depth (≈ 67) and a non‑trivial search space for the bit‑vector solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_64.smt2",
    "description": "This instance encodes a bit‑precise verification problem that checks whether two characterisations of a left‑shift operation are consistent on 64‑bit vectors. The first characterisation, CC, asserts that the target value t can be obtained by shifting the bounds xlo and xhi by some amount i up to the trailing‑zero count of t; the second characterisation directly existentially quantifies a value x inside the mask [xlo,xhi] that left‑shifts by some s to t. The formula asserts that, under the validity constraint (bvor (bvnot xlo) xhi) = all‑ones, these two predicates must differ, testing the consistency of the mask‑based propagation versus the literal shift existence. The problem features deep nested ite chains for ctz/clz (up to depth ≈ 67) and two existential quantifiers, making it a crafted, quantifier‑heavy BV challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_32.smt2",
    "description": "The instance verifies a purported equivalence between two bit‑vector predicates on 32‑bit words: the simple mask condition \\((bvand\\;t\\;xhi)=t\\) (i.e., t is a subset of the high‑mask xhi) and the richer existential condition that there exists a value x respecting the interval constraints \\((bvand\\;xhi\\;x)=x\\) and \\((bvor\\;xlo\\;x)=x\\) together with a side‑mask s such that \\((bvand\\;x\\;s)=t\\). By asserting the distinctness of these two Boolean results, the solver is asked to find a counterexample to the claimed consistency of these definitions, thereby checking the correctness of the bit‑vector operator encoding used in the cited verification work. The formula contains a deep nesting of ite expressions for counting trailing/leading zeros/ones (term depth 35) and a single existential quantifier, making the search for a satisfying assignment non‑trivial despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_4.smt2",
    "description": "The file encodes a bit‑vector consistency check: after forcing the 4‑bit masks xlo and xhi to satisfy xlo ⊆ xhi (by asserting (bvor (bvnot xlo) xhi)=ones), it asserts that the always‑true predicate CC(t,xlo,xhi) must be distinct from an existential statement that there exist x and s with x lying in the mask interval ( bvand xhi x = x ∧ bvor xlo x = x ) and simultaneously satisfying the unsigned inequality x ≥ s. Because such an x (e.g. x = xhi) and a suitable s always exist, the distinctness forces a contradiction, making the query unsatisfiable. The problem is a crafted verification condition with a single‑level existential quantifier and modest term depth (≤7), typical of bit‑precise reasoning benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_64.smt2",
    "description": "The benchmark checks a consistency condition for the 64‑bit arithmetic right‑shift bvashr: it asserts that the derived predicate CC(t,xlo,xhi) – which combines a mask‑containment test ( mcb ) with bounds obtained from count‑leading‑zero and count‑trailing‑zero functions – is *not* equivalent to the concrete existential definition that there exists a value x satisfying the mask ( mcb xlo xhi x) and some shift amount s such that (bvashr x s)=t.  The instance therefore encodes a verification problem (non‑equivalence of two specifications) using only a few existential quantifiers but very deep terms (nested ite over 64 bit extracts for ctz/clz) and many bit‑wise operations, which makes it a crafted, bit‑precise challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_x_s_32.smt2",
    "description": "The instance encodes a verification condition that a 32‑bit mask predicate `mcb` (requiring a value `v` to have all 1‑bits of `xhi` and no 0‑bits outside `xlo`) is inconsistent with the existence of a split of a 64‑bit concatenation `(tx‖ts)` into a high part `x` and a low part `s` that also satisfies the same mask. Formally it asserts that for any well‑formed mask `(xlo,xhi)` (i.e. `(bvnot xlo) ∨ xhi = 0xffffffff`) the Boolean formula  \n\n```\nCC(tx,ts,xlo,xhi)   ≜   mcb xlo xhi tx\n```\n\nis distinct from  \n\n```\n∃x,s.  mcb xlo xhi x  ∧  (x‖s) = (tx‖ts) .\n```  \n\nThus the solver must decide whether a counter‑example exists where a value obeying the mask cannot be recovered as the high half of the concatenated word. The problem features a single existential quantifier and very deep nested `ite`‑chains (from the unused `ctz`/`clz` definitions), yielding high term depth and many bit‑extractions, which makes it a crafted, bit‑precise consistency‑checking benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_32.smt2",
    "description": "The instance checks a consistency property of a bit‑mask interval defined by two 32‑bit vectors `xlo` and `xhi`. It asserts that the pair must satisfy the bit‑wise inclusion condition `(~xlo) | xhi = 0xFFFFFFFF` (i.e., every bit set in `xlo` is also set in `xhi`) and simultaneously requires that there be **no** 32‑bit value `v` lying inside that interval (captured by the predicate `mcb`). Since any such pair always admits at least the value `v = xlo`, the existential clause is inevitably true, making the `distinct` constraint unsatisfiable; thus the formula is UNSAT. The benchmark features only a single existential quantifier but includes deep nested‑ite definitions for `ctz`/`clz` (term depth ≈ 35) which inflate the syntactic size without affecting the core logical difficulty.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_64.smt2",
    "description": "The file encodes a consistency check for a pair of 64‑bit masks `xlo` and `xhi`: the assertion `(= (bvor (bvnot xlo) xhi) ones)` forces every bit to be either allowed by the lower mask (`xlo=1`) or by the upper mask (`xhi=1`). A quantified existential then asks whether there exists a bit‑vector `x` that simultaneously respects both masks (`mcb xlo xhi x`) and equals an arbitrary value `s`; the outer `distinct` forces this existential to be false, which contradicts the mask compatibility and makes the whole formula unsatisfiable. The benchmark stresses solvers with deep ite‑chains used to define `ctz`/`clz` (term depth 67), a single quantifier, and many bit‑extracts, highlighting difficulties in handling large term structures rather than combinatorial explosion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_4.smt2",
    "description": "This instance encodes a **consistency‑check** for a bit‑vector remainder (`bvurem`) operation under interval constraints.  It defines an interval predicate `mcb` (requiring a value v to lie between the lower bound `xlo` and upper bound `xhi` bitwise), a literal predicate `LIT` that asserts `x % s == t`, and a derived condition `CC` that attempts to capture the same property using only bit‑wise tests, extracts and arithmetic on 4‑bit vectors.  The final assertion asks the solver to find a model where the derived condition `CC(t,xlo,xhi)` is **not equivalent** to the existence of a concrete pair `(x,s)` satisfying the interval and remainder constraints, thereby verifying (or refuting) the correctness of the `CC` approximation.  The problem features a small 4‑bit domain but includes nested `ite`s, bit‑extractions, and an existential quantifier, making it a crafted, quantified bit‑vector verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_4.smt2",
    "description": "The instance encodes a tiny bit‑vector consistency check: it defines a “mask‑containment” predicate mcb that requires a value v to lie between a lower and an upper mask (xlo ⊆ v ⊆ xhi) and a literal‑matching predicate LIT that forces a pair of 4‑bit vectors (s,x) to equal the concrete concatenation (ts,tx). It then asserts that (i) the masks form a valid interval (¬xlo ∨ xhi = all‑ones) and (ii) the Boolean result of applying mcb directly to tx differs from the result of an existential formulation that combines mcb with LIT; this tests whether the two encodings are logically equivalent. The problem is a crafted verification of a simple equivalence, involving only four 4‑bit variables, shallow term depth (≤ 7) and a single existential quantifier, making it easy for bit‑vector solvers but useful for probing subtle encoding bugs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_64.smt2",
    "description": "The instance checks a consistency condition for 64‑bit addition under a “masked‑bits” constraint. After declaring t, xlo, xhi, and a mask‑checking function mcb, it asserts that xlo and xhi form a complementary pair (their bvor with not xlo equals all‑ones) and then requires that the always‑true predicate CC be distinct from the existence of a pair (x, s) satisfying both the mask constraint (mcb xlo xhi x) and the equation x + s = t. In effect the solver must prove that no such x, s can exist, i.e., verify the unsatisfiability of the masked‑addition condition. The problem is a crafted bit‑vector verification query with a single existential quantifier but very deep term‑depth (≈ 67) due to explicit definitions of ctz and clz using long nested ite chains, which makes the reasoning bit‑precise and challenging for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_32.smt2",
    "description": "This instance verifies a consistency condition for 32‑bit mask operators.  It declares two mask bounds `xlo` and `xhi` that must satisfy the “complement‑or” invariant `(bvor (bvnot xlo) xhi) = 0xffffffff`, and then checks whether the conditional property  \n\n  `CC(t,xlo,xhi) ≡ (xlo = xhi → xlo ≠ maxs)`  \n\nis logically distinct from the existence of a signed‑less‑than literal `x < s` that also respects the mask (captured by `mcb xlo xhi x`).  The formula asserts the inequivalence of these two predicates, so the solver must decide the satisfiability of a quantified existential (over `x` and `s`) together with a few deep ite‑defined bit‑vector helpers (ctz, clz, etc.), yielding a crafted bit‑vector verification problem with moderate term depth but only one quantifier block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_32.smt2",
    "description": "This instance checks the correctness of a *consistency condition* (the CC function) that was derived for the 32‑bit unsigned remainder operator (**bvurem**).  The formula asserts that the condition CC(t, xlo, xhi) is *distinct* from the concrete specification “∃ x s. x respects the bit‑mask bounds xlo ≤ x ≤ xhi (captured by mcb) and bvurem x s = t”.  Thus it is a verification task: prove that the derived ternary‑propagation constraint is equivalent to the existential definition of a remainder value.  The problem features a single existential quantifier, several deep nested ite/​extract chains (e.g., in the unused ctz/clz definitions), and a moderate number of 32‑bit bit‑vector variables, which together create a non‑trivial bit‑precise reasoning challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_64.smt2",
    "description": "The benchmark encodes a verification task for an “invertibility condition” of the signed‑greater‑or‑equal bit‑vector predicate (`bvsge`).  It introduces a signed constant `s` and interval bounds `xlo`, `xhi` (constrained by `bvor (bvnot xlo) xhi = ones` so that every bit is either forced to 0 in the lower bound or 1 in the upper bound) and defines the candidate condition `IC` that should characterize the existence of a value `x` in the interval satisfying `s ≥ x` (signed).  The final assertion checks that `IC` is *distinct* from the actual existential formula `∃x. mcb xlo xhi x ∧ (s ≥ x)`, thus testing whether the proposed invertibility condition is correct.  The instance features deep nested ite chains for `ctz`/`clz`, an existential quantifier, and a mix of signed/unsigned bit‑vector operations, making it a crafted, quantifier‑heavy BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_x_s_4.smt2",
    "description": "This instance encodes a verification problem for an **invertibility condition** of a 4‑bit‑vector operator: it asserts that the mask‑check condition `IC(s,t,xlo,xhi)` (which ensures `s` lies within a bit‑mask interval defined by `xlo` and `xhi`) is *not* equivalent to the existence of a concrete value `x` (restricted by the same mask) that equals the literal `s`.  The formula also enforces that `xlo` and `xhi` form a valid complementary mask (`bvor (bvnot xlo) xhi = 0b1111`).  Thus the solver must decide the (un)satisfiability of a small quantified Boolean‑BV formula containing an `exists` quantifier, bitwise operations, and a `distinct` comparison—typical of bit‑precise verification of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_1_4.smt2",
    "description": "The instance encodes a verification task for the invertibility condition of a 4‑bit sign‑extend operation. It defines a mask‑coverage predicate `mcb` that forces a candidate value `v` to lie between lower and upper bit‑vector bounds (`xlo`, `xhi`), and a literal predicate `LIT` that requires the sign‑extension of `v` to match the concatenation of a sign bit `tn` and a 4‑bit word `tx`. The final query checks that the condition `IC` (which ties `tn` to the sign bit of `tx` and enforces the mask) is *not* equivalent to the existence of a mask‑compatible `x` satisfying `LIT`, thereby testing the correctness of the derived invertibility condition; the problem involves only small 4‑bit vectors, a single existential quantifier, and shallow terms (depth ≤ 7).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_4.smt2",
    "description": "This instance verifies an **invertibility condition** for a 4‑bit sign‑extension operator (`sext`) that is split into a 3‑bit high part `tn` and a 4‑bit low part `tx`.  It asserts that a mask pair `xlo/xhi` (with `xlo ≤ xhi` bitwise) together with the condition “if `tn` is zero then the MSB of `tx` is 0, otherwise it is 1” (the `IC` predicate) is **not equivalent** to the existence of a 4‑bit value `x` that both respects the mask (`mcb`) and whose sign‑extension equals the concatenation `tn‖tx` (`LIT`).  The formula contains a single existential quantifier, bit‑wise mask constraints, and a sign‑extension equality, making it a small but quantifier‑rich bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_4.smt2",
    "description": "The instance verifies the correctness of an invertibility condition for the 4‑bit left‑shift operator `bvshl`.  It defines a mask‑condition (`mcb`) that bounds a candidate operand `x` between `xlo` and `xhi`, an “inverse‑check” (`IC`) that composes a right‑shift and a left‑shift to test whether `t` can be obtained from some `x`, and a literal condition (`LIT`) that directly asserts `bvshl x s = t`.  The solver is asked to find a model where the abstract condition `IC` differs from the concrete existence of an `x` satisfying both the mask and the literal (expressed with a single existential quantifier), thereby checking the soundness of the proposed invertibility condition.  The formula involves only five 4‑bit variables, shallow term depth (≤ 7) and a single quantifier block, making it a small but non‑trivial verification problem for bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_4.smt2",
    "description": "The instance encodes a **verification of an invertibility condition (IC) for the signed‑greater‑or‑equal bit‑vector operator `bvsge`** on 4‑bit words.  The predicate `IC(s,t,xlo,xhi)` is a case‑distinguished formula that should be equivalent to the existence of some value `x` satisfying the mask‑constrained interval (`mcb xlo xhi x`) and the literal `bvsge x s`.  The model asserts that the pair `(xlo,xhi)` is well‑formed (`bvor (bvnot xlo) xhi = ones`) and then checks whether `IC` and the existential formulation are **distinct**, i.e., whether the proposed IC is unsound.  The problem involves a single existential quantifier, several piecewise bit‑vector functions, and a modest term depth (7), making it a small‑scale but non‑trivial bit‑precise verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_4.smt2",
    "description": "The instance encodes a verification task for a derived *invertibility condition* (IC) of the 4‑bit left‑shift operation (`bvshl`).  It defines auxiliary bit‑vector utilities (count‑trailing‑zeros, masks, interval‑membership) and then asserts that, for arbitrary 4‑bit vectors `s`, `t` and a mask interval `[xlo,xhi]` (where `xlo` ⊆ `xhi`), the Boolean formula `IC(s,t,xlo,xhi)` is **different** from the existence of a concrete shift amount `x` inside the interval satisfying `s << x = t`.  The check therefore verifies that the IC precisely captures the existence of such a shift, a typical correctness proof for bit‑vector operator invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_64.smt2",
    "description": "The instance verifies an invertibility condition for the 64‑bit concatenation operator.  It asserts that the simple condition IC ( s = ts and tx lies within the bit‑mask defined by xlo/xhi ) is *distinct* from the existence of a concrete 64‑bit value x such that x also satisfies the mask ( mcb ) and the concatenation equality concat x s = concat tx ts.  The formula involves only five 64‑bit constants but contains very deep nested‑ite definitions of ctz and clz (used only for completeness), giving a high term‑depth (≈ 67) while the core verification task remains a quantifier‑free check of logical equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_32.smt2",
    "description": "The file encodes a verification task for a manually derived **invertibility condition (IC)** of the signed‑greater‑or‑equal bit‑vector operator (`bvsge`).  It asserts that the predicate `IC(s,t,xlo,xhi)`—which combines a signed‑comparison of `s` with a low bound `xlo` (or with a sign‑extended variant when the high bound’s most‑significant bit is set) and a validity condition on the interval `[xlo,xhi]`—must be equivalent to the existence of some `x` inside that interval (captured by `mcb`) that also satisfies `bvsge(s,x)`.  The solver therefore checks whether a counterexample exists where the abstract IC differs from the concrete existential condition, a typical bit‑precise verification problem that involves a single existential quantifier, deep nested `ite` chains (term depth ≈ 35), and many bit‑extractions, making it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_32.smt2",
    "description": "The formula checks the correctness of an **invertibility condition** (IC) for the signed‑greater‑than‑or‑equal (bvsge) operator on 32‑bit vectors. It asserts that the condition IC (s,t,xlo,xhi) – which relates the sign of the lower bound xlo and the signed comparison of xhi with s – is **distinct** from the existential statement that there exists a concrete value x lying in the interval specified by the masks xlo / xhi (and satisfying x bvsge s). The benchmark therefore encodes a crafted verification task with a single quantifier, deep nested ite chains (from the auxiliary ctz/clz definitions) and moderate term depth, testing whether the derived invertibility condition faithfully captures the existence of a satisfying element.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_32.smt2",
    "description": "This instance checks the correctness of a manually derived *invertibility condition* for the 32‑bit unsigned remainder operator (`bvurem`).  It introduces four bit‑vector constants `s`, `t`, `xlo`, `xhi` (defining a bitwise interval for a candidate divisor) and asserts that the condition `IC(s,t,xlo,xhi)`—which encodes arithmetic constraints such as `(2·t−s) & s ≥ t` and the existence of a divisor `y` that exactly divides `s−t`—must be equivalent to the factual existence of some `x` in the interval (`mcb xlo xhi x`) satisfying `s % x = t`.  The problem is a crafted verification task with a single quantifier alternation, a deep term structure (nested `ite`/`extract` for `ctz`/`clz`), and a moderate number of bit‑vector operations, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_64.smt2",
    "description": "This instance encodes a verification task for a 64‑bit bit‑vector invertibility condition of a concatenation operation. It asserts that the “mask‑constrained” condition IC (requiring s = ts and tx to lie within the interval [xlo, xhi]) is **distinct** from the existence of some x satisfying the same mask and the equation concat s x = concat ts tx, while also enforcing a consistency property on xlo/xhi. The formula contains a single existential quantifier and deep, nested term constructions (e.g., explicit ctz/clz definitions), making it a crafted, quantifier‑heavy BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvadd_x_s_32.smt2",
    "description": "This instance verifies the correctness of an interval‑based invertibility condition for 32‑bit addition. It encodes the condition “\\(t-s\\) lies inside the mask defined by \\(x_{lo},x_{hi}\\)” (via the mcb predicate) and asks whether this Boolean condition is equivalent to the existence of a concrete word \\(x\\) (with \\(s+x=t\\)) that also satisfies the same mask; the solver must find a model where the two differ. The formula combines a deep ite‑based definition of trailing/leading‑zero count (raising term depth) with a single existential quantifier and a validity constraint on \\(x_{lo},x_{hi}\\), making it a crafted bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_4.smt2",
    "description": "This instance formalises a verification condition for the invertibility of the bit‑vector concatenation operator. It asserts that, for 4‑bit vectors s, ts, tx and a mask given by xlo ⊆ xhi, the conjunction IC (s = ts ∧ mcb xlo xhi tx) is **distinct** from the existence of a masked value x such that concatenating s with x equals the concatenation of ts with tx; the solver is asked to find a model where the two statements differ. The problem involves a single existential quantifier, bitwise‑and/or, bit‑extraction, and ite‑based counting functions, but only a handful of 4‑bit variables, resulting in modest term depth while still exercising quantifier reasoning over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_4.smt2",
    "description": "The instance encodes a verification task for an **invertibility condition (IC) of the 4‑bit remainder operator (`bvurem`)**.  It defines a mask predicate `mcb` that restricts candidate divisors to a bit‑wise interval \\([x_{lo},x_{hi}]\\) and a condition `IC` that should be equivalent to the existence of an `x` (within the mask) satisfying \\((s \\bmod x)=t\\).  The final assertion checks that the two formulations are **distinct**, i.e., it asks the solver to find a counterexample where the proposed IC does not correctly characterize the existence of such an `x`.  The problem involves quantified bit‑vector arithmetic (two separate existential quantifiers), several bit‑wise extracts, ite‑terms and overflow predicates, but remains small‑scale (4‑bit vectors, depth 7), making it a crafted bit‑precise verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_32.smt2",
    "description": "The file encodes a verification task that checks the invertibility condition for a 32‑bit sign‑extension operator.  Two formulas are compared: (i) IC, which constrains a 2‑bit “sign‑bit” tn and a 32‑bit value tx to be mutually consistent (tn must be either 0 with the high bit of tx 0, or −1 with the high bit 1) and to lie inside a user‑provided interval [xlo,xhi] (the mcb mask condition); and (ii) the existence of a 32‑bit x inside the same interval that satisfies the literal LIT, i.e. that sign‑extending x by 2 bits yields concat tn tx.  The benchmark asserts that these two specifications are distinct, thus requiring a solver to handle a quantified existential query together with deep, nested ite chains (used in the helper definitions of ctz, clz, …) over 32‑bit bit‑vectors, making it a crafted bit‑vector verification instance with moderate size but high term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_4.smt2",
    "description": "The file checks the correctness of a manually derived invertibility condition (IC) for the 4‑bit sign‑extension operator. It asserts that the Boolean IC – which ties the sign‑extension bits tn and the operand’s high bit tx to a mask defined by xlo/xhi – must be equivalent to the existence of a concrete 4‑bit value x (lying within the mask, i.e., mcb xlo xhi x) whose sign‑extended 8‑bit result equals the concatenation tn‖tx. Thus the instance is a small verification query (five 4‑bit constants, one existential quantifier, moderate term depth) that tests whether the IC exactly captures the solvability of the sign‑extension constraint under the given bit‑mask bounds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvashr_x_s_4.smt2",
    "description": "This instance checks the correctness of a manually derived invertibility condition (IC) for the arithmetic‑right‑shift operator on 4‑bit vectors. It asserts that the condition  \n\n\\[\n\\text{IC}(s,t,x_{\\text{lo}},x_{\\text{hi}})\n\\]  \n\n(which combines a range‑mask property (mcb) with a case split on the shift amount s) is *distinct* from the specification that there exists a concrete value x (satisfying the same mask) such that \\( \\text{bvashr}(x,s)=t\\). The problem is a small‑scale verification task involving bit‑vector arithmetic, a single existential quantifier, and a few nested ite‑expressions, aimed at exposing any mismatch between the derived condition and its intended semantic meaning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_s_x_4.smt2",
    "description": "The instance formalizes a verification of an “invertibility condition’’ for the 4‑bit logical right‑shift operator (`bvlshr`). It defines a mask‑range predicate (`mcb`) together with count‑leading‑zero helpers, and then checks whether the condition `IC(s,t,xlo,xhi)`—which relates the shift amount `y = clz(t)‑clz(s)` to the masks—exactly captures the existence of a concrete shift amount `x` such that `s >> x = t` while respecting the mask bounds. The formula asserts that a valid mask pair `(xlo,xhi)` is given and then requires the truth values of `IC` and the existential `∃x (mcb xlo xhi x ∧ s>>x = t)` to differ, i.e., it tests the correctness (or a counter‑example) of the proposed invertibility condition. The problem involves bit‑vector arithmetic, nested `ite`s, a single existential quantifier, and moderate term depth, making it a succinct crafted verification query.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_32.smt2",
    "description": "This benchmark checks the **invertibility condition** for a 4‑bit sign‑extension into a 32‑bit word.  It asserts that the handcrafted predicate IC (which relates the 4‑bit tag tn, the 32‑bit payload tx, and mask bounds xlo/xhi) is *not* equivalent to the actual existence of a 32‑bit value x that satisfies the mask constraints (via mcb) and whose sign‑extension equals the concatenation tn ∥ tx.  The problem is a pure BV‑logic verification task with a single existential quantifier, deep nested ite‑chains for trailing/leading‑zero counts, and a moderately large term depth (≈35).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_4.smt2",
    "description": "The instance encodes a bit‑vector verification query that checks whether a particular invertibility condition (IC) for a 4‑bit operator is *distinct* from the existence of a concrete literal satisfying a mask‑constraint (mcb) and being different from a distinguished constant `s`.  After asserting that the low/high mask pair `xlo`/`xhi` is complementary (their OR with the complement of `xlo` yields all‑ones), it asks the solver to prove that the Boolean formula `IC(s,t,xlo,xhi)` is not equivalent to the existential statement  \n  ∃x. (mcb xlo xhi x ∧ x ≠ s).  The problem features a single existential quantifier, several user‑defined bit‑vector functions (e.g., count‑trailing/leading‑zero helpers), and a modest term depth (7) on a 4‑bit domain, making it a crafted, quantifier‑heavy BV verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_64.smt2",
    "description": "The instance checks a crafted invertibility condition on 64‑bit vectors: it asserts that the Boolean predicate  \n\n\\[\nIC(s,t,x_{lo},x_{hi}) \\;=\\; (x_{hi}\\neq x_{lo})\\;\\lor\\;(x_{hi}\\neq s)\n\\]\n\nmust differ from the existence of a bit‑vector \\(x\\) that lies inside the interval \\([x_{lo},x_{hi}]\\) (encoded by the bit‑wise mask‑check `mcb`) and is distinct from the constant `s` (`LIT`).  The interval variables are constrained by the “valid pair’’ clause `bvor (bvnot xlo) xhi = ones`, i.e. every bit set in xlo is also set in xhi.  \n\nThe formula contains a single existential quantifier but a very deep term structure (nested `ite`s for `ctz`/`clz`, many extracts) leading to high term depth (≈ 67) and a large number of bit‑wise operations, which makes the solving non‑trivial despite the small number of assertions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_64.smt2",
    "description": "The file encodes a bit‑vector verification of an invertibility condition for the 4‑bit sign‑extension of a 64‑bit value. It defines a predicate IC that checks (i) the sign‑extension pattern (the most‑significant bit of the 64‑bit part tx matches the 4‑bit sign bits tn) and (ii) that tx respects a mask given by xlo/xhi (via mcb), and then asserts that this predicate must be **distinct** from the concrete existence of a value x that (a) also satisfies the mask and (b) whose sign‑extension exactly equals the concatenation tn‖tx; a satisfying assignment would constitute a counter‑example to the proposed invertibility condition. The instance is a pure BV problem with deep nested ite chains (defs of ctz, clz) that inflate term depth, but only two main assertions and a single existential quantifier, making it a crafted verification benchmark with high syntactic complexity yet a small logical core.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_32.smt2",
    "description": "The instance checks the **invertibility condition (IC) for the 32‑bit left‑shift operator (bvshl)**: for given bit‑vectors `s` and `t` it asserts that the predicate `IC(s,t,xlo,xhi)` (which uses the count‑trailing‑zeros functions and a mask‑between constraint `mcb`) is *distinct* from the existence of a concrete shift amount `x` (restricted by the same mask) such that `s << x = t`. In other words, it tries to find a counter‑example showing that the analytically derived IC does not exactly capture the existence of a valid shift amount, while the encoding features deep nested‑ite definitions for `ctz`/`clz` and a single existential quantifier, leading to a high term depth (≈35) but only a modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_64.smt2",
    "description": "The instance verifies the invertibility condition for the 64‑bit remainder operator bvurem.  It encodes a logical equivalence between a hand‑crafted condition IC (which uses bitwise interval masks xlo/xhi, a bound check, and an existential witness y) and the existence of a divisor x that satisfies (bvurem s x) = t while also respecting the same interval masks.  The formula contains two nested existential quantifiers, deep ite‑chains for bit‑count functions (ctz/clz), and a high term depth (≈ 67), making it a challenging bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_64.smt2",
    "description": "The file encodes a verification task for an “invertibility condition’’ of a sign‑extension operation on 64‑bit bit‑vectors. It asserts that the simple mask‑based predicate IC (relating a 3‑bit flag tn, the high bit of tx and a bitwise mask xlo/xhi) is **not** equivalent to the existence of a concrete 64‑bit value x that lies inside the mask ( mcb xlo xhi x ) and satisfies the sign‑extension constraint (the top three sign bits of x equal tn and its low 64 bits equal tx). The instance features very deep nested ite structures (ctz/clz definitions) and many bit‑extracts, yielding a high term‑depth formula that stresses BV solvers’ handling of large quantified/bit‑wise expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_32.smt2",
    "description": "This instance encodes a **verification of an invertibility condition** for the 32‑bit left‑shift operator (`bvshl`).  It defines the predicate `IC(s,t,xlo,xhi)` that combines a shift‑equality `(bvshl (bvlshr t s) s) = t` with a mask‑cover condition `mcb`, and it asks whether `IC` is *distinct* from the existential formula “there exists an `x` such that the mask covers `x` and `bvshl x s = t`”.  In other words, it checks whether the proposed sufficient condition for solving `bvshl x s = t` is actually equivalent to the existence of a solution.  The problem is a single‑quantifier check over five 32‑bit vectors, but the surrounding definitions (e.g., `ctz`, `clz`) contain deep nested `ite` chains (term depth ≈ 35) and many bit‑extractions, making the formula heavy for bit‑vector solvers despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_s_x_64.smt2",
    "description": "This benchmark encodes a verification of an invertibility condition for the 64‑bit unsigned‑greater‑or‑equal operator. It declares a 64‑bit interval [xlo, xhi] (enforced by a bitwise “mask‑covers‑both” constraint) and asks whether the simple predicate xlo ≤ s is logically equivalent to the existence of a value x in that interval satisfying s ≥ x; the formula asserts the two predicates are distinct and checks satisfiability. The problem involves only a handful of variables but features deeply nested ite/extract terms (e.g., explicit ctz/clz definitions) that give a high term‑depth (≈ 67), making it a crafted, bit‑precise challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvxor_x_s_32.smt2",
    "description": "This benchmark checks the **invertibility condition (IC)** for the bit‑vector XOR operator under a mask interval.  It declares 32‑bit constants `s`, `t`, `xlo`, `xhi` and defines a mask‑constraint predicate `mcb` (requiring a value `v` to lie between `xlo` and `xhi`).  The IC is `mcb xlo xhi (s xor t)`, i.e. the mask must contain the XOR of the two given operands.  The instance then asserts that the mask is well‑formed (`bvor (bvnot xlo) xhi = all‑ones`) and that the IC is **distinct** from the existential statement “∃ x . mcb xlo xhi x ∧ (x xor s) = t”.  Thus it asks the solver to find a counter‑example where the IC does **not** correctly capture the existence of a solution to `x xor s = t` within the mask.  The problem is a crafted verification query with a single existential quantifier, a modest number of variables, but a deep term structure (nested ite chains for auxiliary `ctz`/`clz` functions), making it a bit‑precise reasoning challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_x_s_64.smt2",
    "description": "The instance checks the invertibility condition for the unsigned‑less‑than (bvult) operator on 64‑bit vectors: it asserts that the predicate “\\(s\\neq0\\) and \\(x_{lo}<s\\)” is **distinct** from the existence of a value \\(x\\) that both lies inside a mask‑defined interval \\([x_{lo},x_{hi}]\\) (encoded by `mcb`) and satisfies \\(x<s\\). The problem is a crafted verification query that searches for a concrete assignment to the constants `s, xlo, xhi` (with the mask‑validity constraint \\((\\neg x_{lo})\\lor x_{hi}=1\\) for every bit) that makes the two formulas differ. Although only two top‑level assertions are present, the file contains very deep term definitions (e.g., `ctz`/`clz` built from 64 nested `ite`/`extract`s), yielding a maximum term depth of 67 and a large number of bit‑extractions, which can make the instance challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_32.smt2",
    "description": "The instance checks the soundness of an **invertibility condition (IC)** for the 64‑bit concatenation operator on 32‑bit bit‑vectors.  It asserts that the mask‑pair (xlo,xhi) is well‑formed (xlo ⊆ xhi) and that the IC — “s = ts and the candidate tx respects the mask” — is *distinct* from the existence of a concrete x (also respecting the mask) such that concat s x = concat ts tx; a satisfying model would provide a counter‑example to the IC’s equivalence.  The problem is a pure BV verification task with a single existential quantifier and very deep nested ite chains (the hand‑written ctz/clz functions), giving moderate syntactic depth but a small number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_32.smt2",
    "description": "The file encodes a bit‑vector verification task that checks whether a syntactic “invertibility condition’’ IC(s,t,xlo,xhi) correctly predicts the existence of a 32‑bit value x lying between the masks xlo and xhi (i.e. bvand xhi x = x and bvor xlo x = x) and different from a distinguished constant s.  The model asserts that the Boolean IC and the existential statement “∃x · mcb(xlo,xhi,x) ∧ x ≠ s’’ must have different truth values, while also requiring the masks to satisfy the bitwise inclusion xlo ⊆ xhi.  Although only two top‑level assertions are present, the instance contains very deep nested ite terms for count‑trailing/leading‑zero functions, many bit‑extractions, and a quantified sub‑formula, making the reasoning non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_x_s_64.smt2",
    "description": "The file formalises a verification of an invertibility condition for the 64‑bit unsigned‑greater‑than‑or‑equal (bvuge) operator.  It defines a bitwise interval predicate mcb that characterises all values v lying between two bit‑vectors xlo and xhi (using bitwise and/or constraints) and a simple bound predicate IC that just requires xhi ≥ s.  The single assertion claims that, for any s, xlo and xhi forming a valid interval (i.e. (bvor (bvnot xlo) xhi) = all‑ones), the truth of IC is *distinct* from the existence of an x in the interval that also satisfies x ≥ s, thereby asking the solver to find a counter‑example to the proposed equivalence.  The problem involves only five 64‑bit variables, one existential quantifier, but deep nested ite chains (from the unused ctz/clz definitions) that raise the term‑depth to 67.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_32.smt2",
    "description": "The file encodes a verification of an invertibility condition for the 32‑bit unsigned‑less‑than operator (`bvult`). It asserts that the predicate `IC(s,t,xlo,xhi)`—which demands `s` be different from all‑ones and the upper bound `xhi` be greater than `s`—is *not* equivalent to the existence of a concrete value `x` that satisfies the mask constraints (`mcb`) defined by `xlo` and `xhi` and also fulfills `s < x`; the solver must find a model witnessing this discrepancy. The problem features a single existential quantifier, deep nested `ite` definitions for `ctz`/`clz`, and moderate term depth (≈35) but only a handful of bit‑vector variables, typifying a crafted, quantifier‑rich invertibility‑condition check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_4.smt2",
    "description": "The instance verifies an invertibility condition for the 4‑bit sign‑extension operator: it checks whether, for a given 4‑bit target value tx, a 2‑bit selector tn and mask bounds xlo/xhi (satisfying (bvor (bvnot xlo) xhi)=ones), the existence of a 4‑bit source x that both respects the mask ( mcb xlo xhi x ) and satisfies (sign_extend x = concat tn tx) is equivalent to a handcrafted Boolean condition IC. The formula contains a single existential quantifier, nested ite‑based definitions of trailing/leading‑zero counts, and bit‑mask constraints, leading to a modest term depth (7) but non‑trivial interaction between quantifiers and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_4.smt2",
    "description": "This SMT‑LIB file encodes a verification task for an **invertibility condition** of a 4‑bit concatenation operation.  It declares five 4‑bit variables `s, tx, ts, xlo, xhi` and defines helper predicates (e.g., `mcb` to enforce that a value lies between the bit‑wise lower and upper masks, and `LIT` that requires `concat(x,s) = concat(tx,ts)`).  The core assertion checks that the proposed condition `IC(s,tx,ts,xlo,xhi)` (which fixes `s = ts` and masks `tx`) is **distinct** from the existence of a concrete `x` satisfying both the mask constraints and the concatenation equality, thereby testing the soundness of the invertibility condition.  The instance involves a single existential quantifier, moderate term depth (7), and only 4‑bit bit‑vectors, but the combination of bit‑wise masking, concatenation, and the `distinct` comparison makes it a non‑trivial crafted verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_x_s_32.smt2",
    "description": "The instance checks the correctness of an **invertibility condition** for the 32‑bit logical right‑shift operator `bvlshr`.  It introduces a shift amount `s`, a target value `t`, and mask bounds `xlo`, `xhi`; the condition `IC(s,t,xlo,xhi)` states that (i) shifting `t` left by `s` and then right by `s` restores `t` (i.e., the top `s` bits of `t` are zero) and (ii) `t` lies inside the mask obtained by right‑shifting the bounds.  The formula asserts that this condition is **not** equivalent to the direct existential statement “there exists an `x` within the mask such that `bvlshr x s = t`”, together with a validity constraint on the masks.  Consequently the problem is a quantifier‑free bit‑vector verification task (single existential inside a `distinct`), with a moderate number of variables, several deep nested `ite` definitions (used for auxiliary count‑zero/one functions) and a term depth of 35, making it a crafted benchmark for reasoning about bit‑precise invertibility of shift operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvslt_x_s_64.smt2",
    "description": "This instance checks the *invertibility condition* for the signed‑less‑than operator (`bvslt`) on 64‑bit vectors. It asserts that the handcrafted predicate IC — which relates a signed bound `s` to a pair of masks `xlo`/`xhi` — must be equivalent to the existence of a concrete value `x` within the interval defined by `mcb` that also satisfies `x < s`; the formula asserts that the two are distinct and asks the solver to find a model. The problem involves a single existential quantifier, many nested `ite` expressions (depth ≈ 67) for bit‑scan functions, and extensive use of extracts, making it a demanding quantified bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_64.smt2",
    "description": "This benchmark verifies an *invertibility condition* for the signed‑greater‑or‑equal (`bvsge`) bit‑vector operation on 64‑bit words.  It asserts that a candidate condition `IC(s,t,xlo,xhi)`—built from the sign bit of a lower bound and a signed comparison with `s`—is equivalent to the existential statement “there exists a value `x` whose bits lie between `xlo` and `xhi` (mask condition `mcb`) and that satisfies `bvsge x s`”.  The solver must decide whether the two formulas are distinct, i.e., whether the proposed invertibility condition is sound, while handling a large term depth (nested `ite`s and bit‑extracts) but only a handful of quantified variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_4.smt2",
    "description": "The instance verifies an **invertibility condition (IC)** for the 4‑bit unsigned‑less‑than (`bvult`) operator. It defines a mask‑range predicate `mcb` (requiring a candidate `x` to lie between lower and upper masks `xlo`, `xhi`) and a literal predicate `LIT` (`s < x`). The solver checks that the manually derived condition `IC(s,t,xlo,xhi)`—which demands `s` be distinct from the all‑ones constant and `xhi` be greater than `s`—is logically **distinct** from the existence of a concrete `x` satisfying both `mcb` and `LIT`, under the side constraint that `xlo` and `xhi` form a complementary mask pair. This constitutes a small‑scale, quantifier‑rich verification task for bit‑vector invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_x_s_64.smt2",
    "description": "The instance verifies an **invertibility condition for the 64‑bit remainder operation** (`bvurem`). It defines a predicate IC(s,t,xlo,xhi) that captures when, for given divisor `s` and remainder `t`, there is (or is not) a value `x` in the interval described by the mask‑pair `xlo/xhi` satisfying `x % s = t`, while also checking that addition and multiplication do not overflow; the final assertion demands that this condition be logically equivalent to the existence of such an `x`. The formula contains a deep chain of nested `ite` expressions (for `ctz`/`clz`) and a single existential quantifier, resulting in very high term depth (≈ 67) but only a modest number of variables, making the difficulty stem mainly from the bit‑precise reasoning required for the overflow predicates and the exhaustive case analysis encoded in the mask functions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_4.smt2",
    "description": "This instance encodes a verification task for a proposed invertibility condition of the signed‑greater‑or‑equal bit‑vector operator (`bvsge`). It asserts that a mask‑based interval predicate (`mcb`) together with the literal condition `s ≥ x` is **not** equivalent to a specialized conditional bound (`IC`) that depends on the sign bit of the interval’s upper mask (`xhi`). The solver must find a 4‑bit assignment to `s`, `xlo`, `xhi` (satisfying the complementary‑mask invariant) that witnesses a discrepancy, involving a single existential quantifier over a masked variable and a handful of bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_64.smt2",
    "description": "The instance encodes a bit‑vector verification problem that checks the **invertibility condition (IC)** for 64‑bit multiplication `(bvmul s x = t)`.  The formula asserts that the predicate `IC(s,t,xlo,xhi)`—which requires a modular inverse of `s` (or of `s` shifted by its trailing‑zero count) together with a mask‑cover‑by‑bounds condition `mcb` on the transformed product—is **distinct** from the existence of a concrete solution `x` that both satisfies the same mask bounds and the literal equation `bvmul x s = t`.  The encoding features deep nested ite‑chains for exact `ctz`/`clz` definitions, several bitwise operations, and existential quantifiers, resulting in a relatively high term depth (≈ 67) that makes the instance challenging for solvers despite the modest number of variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_64.smt2",
    "description": "The instance encodes a bit‑vector verification task that checks the correctness of an invertibility condition (IC) for the 64‑bit left‑shift operator.  It asserts that the analytically derived condition IC on the shift amount y (derived from the count‑trailing‑zeros of s and t and constrained by a bit‑mask [xlo,xhi]) is *not* equivalent to the concrete existence of some shift x within the same mask that actually satisfies (bvshl s x) = t.  The formula involves deep nested ite‑chains for ctz/clz, a single existential quantifier, and numerous bit‑extractions, making it a crafted BV problem with high term depth and non‑trivial bit‑mask reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvudiv_s_x_4.smt2",
    "description": "The file encodes a verification task for the unsigned‑division operator on 4‑bit bit‑vectors: it defines an “invertibility condition” (IC) that should characterize exactly when a value x exists such that bvudiv s x = t, with auxiliary masks xlo and xhi describing a valid interval (enforced by bvor (bvnot xlo) xhi = ones). The final assertion checks that the IC is *not* equivalent to the existential statement (∃ x · mcb xlo xhi x ∧ bvudiv s x = t), thereby testing the correctness of the derived condition. The problem involves quantified bit‑vector arithmetic with nested ite, extracts, and zero‑extensions, but remains small (four‑bit vectors) and crafted to stress invertibility reasoning rather than raw scale.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_4.smt2",
    "description": "The instance encodes a verification task for a bit‑vector invertibility condition of the multiplication operator.  It defines the condition IC(s,t,xlo,xhi) that, depending on whether s is odd, requires the existence of a modular inverse of s (or of s shifted by its trailing‑zero count) together with a “mask‑containment” predicate mcb on the candidate solution, and then asserts that this condition is **distinct** from the simpler existence of a concrete value x (with‑in the interval [xlo,xhi] given by mcb) satisfying bvmul x s = t.  The query therefore checks whether the derived invertibility condition correctly characterises all solutions for 4‑bit multiplication, involving quantified bit‑vector arithmetic, nested ite/shift/and/or constructs and a moderate term depth.",
    "is_truncated": false
  }
]