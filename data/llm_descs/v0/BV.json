[
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_15.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) SMT‑LIB 2.6 problem (logic BV) that originates from the Scholl et al. 2008 paper on redundant linear constraints in non‑convex polyhedra, converted to bit‑vectors by Mathias Preiner.  It declares only three 32‑bit variables `x1`, `y2` and `y3`, but the single large assertion contains several nested quantifiers (four ∀ and four ∃) that quantify fresh auxiliary variables and express a mix of linear inequalities (`bvslt`, `bvsle`, `bvsge`) and equalities after translating integer arithmetic into bit‑vector operations (`bvadd`, `bvmul`, `bvneg`).  The core property being checked is the satisfiability of a highly non‑convex conjunction of these constraints, effectively asking whether a certain polyhedral region (described by the encoded linear constraints) is empty.  The instance is relatively small in terms of source size (≈ 3 KB, 44 multiplications, maximum term depth 13) but dense in arithmetic operations, making it a good stress test for BV solvers that support quantifier reasoning.  It is classified as a “random” benchmark in the Preiner‑Scholl‑smt08 family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_13.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the “Preiner‑scholl‑smt08” random family, taken from the SMT‑08 paper on removing redundant linear constraints in non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner; it contains 5 free bit‑vector constants (y3, y4, y6, x1, y5) and a single top‑level assertion of size ≈ 7.5 KB with a maximum term depth of 20. The assertion is a massive quantified formula that mixes eight universal quantifiers and four existential quantifiers, each ranging over 32‑bit variables, and then combines them with nested disjunctions and conjunctions of linear (constant‑times‑variable) arithmetic constraints expressed via `bvmul`, `bvadd`, and signed comparisons (`bvsge`, `bvslt`, etc.). The core property being checked is whether there exists a valuation for the free constants such that, for every choice of the quantified variables, the specified system of linear inequalities and equalities is satisfied (i.e., the quantified formula is true). Because only constant‑coefficient multiplications appear, the encoding represents a quantified linear arithmetic problem over signed 32‑bit integers, but the heavy quantifier alternation and deep nesting make it a challenging instance for SMT solvers. Notably, the benchmark contains a rich mixture of `or`, `and`, and `not` patterns, 150 `bvmul` occurrences and dozens of relational atoms, which exemplifies the kind of randomly generated, heavily quantified BV problems used to stress‑test interpolation‑based solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_16.smt2",
    "description": "**Overview** – The file is a single‑assertion benchmark in the SMT‑LIB 2.6 format, using the **BV** logic (32‑bit signed bit‑vectors). It was generated for the 2008 SMT‑LIB competition (family *Preiner‑scholl‑smt08*), labelled “random”, and contains 7 declared constants (x1 and y1…y6). The instance is relatively large (≈14 k characters, max term depth 24) and features 278 bit‑vector multiplications, 204 additions, and many signed comparisons.\n\n**Structure** – The sole assertion is a huge quantified formula that mixes **alternating ∀/∃ quantifiers** (35 universal and 19 existential binders) over the same 32‑bit variables. Inside the quantifier blocks the constraints are linear combinations of the variables and the constant x1, built with `bvadd`, `bvmul`, and `bvneg`, and then compared with signed relational operators (`bvslt`, `bvsle`, `bvsgt`, `bvsge`) or equality/inequality.\n\n**Key constraints** – Each conjunct or disjunct expresses a **linear inequality or equality** of the form  \n`Σ_i c_i·v_i  ≺  k`  \nwhere the coefficients `c_i` are small signed constants (e.g., –53, 77, 51) and `k` is a constant bit‑vector (e.g., `_bv79 32`). The formula essentially asks whether there exists an assignment to x1 and the universally quantified y‑variables that satisfies a large collection of such signed linear constraints, possibly encoding a non‑convex polyhedral region.\n\n**Notable characteristics** – The benchmark is deliberately dense: it contains deep nesting (up to 4‑level quantifier alternation), many redundant‑looking constraints, and a handful of `let` bindings that reuse intermediate linear forms. This makes it a strenuous test for solvers’ quantifier handling and interpolation capabilities, which is why it was used in the cited paper on detecting and removing redundant linear constraints in non‑convex polyhedra.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_30.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) taken from the 2008 SMT‑Workshop paper by Scholl et al.; it was later translated to bit‑vectors by Mathias Preiner and belongs to the *Preiner‑Scholl* random family (size ≈ 11 k characters, 4 declared constants, max term depth 18).  \n\nThe asserted formula is a giant quantified block that mixes **10 universal** and **6 existential** quantifiers over the three “y” variables ( y₁, y₂, y₃ ) while the fourth constant x₁ remains free.  \n\nInside the quantifier nesting are only **linear‑arithmetic** bit‑vector constraints: a mixture of `bvadd`, `bvmul` with constant coefficients, and comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) together with a handful of equalities.  The constraints form a dense network of inequalities that resemble a non‑convex polyhedral region encoded over bit‑vectors.  \n\nThe benchmark therefore tests an SMT solver’s ability to handle deep quantifier alternation, large numbers of arithmetic literals (≈ 240 multiplications, 155 additions), and the interaction of linear BV constraints with quantifiers rather than any concrete application.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_24.smt2",
    "description": "This benchmark is a single, large quantified formula in the **BV** (fixed‑size bit‑vector) logic, taken from the Scholl‑et‑al. 2008 paper on using SMT and Craig interpolation to prune redundant linear constraints. It contains four 32‑bit variables `x1, y1, y2, y3` and one top‑level assertion that is a massive Boolean combination of linear (affine) bit‑vector inequalities and equalities built from constant‑multiplied variables, additions, and negations. The formula features alternating blocks of existential and universal quantifiers (up to three nesting levels) and a rich mixture of `bvslt`, `bvsle`, `bvsge`, `bvsgt` and equality atoms, with a maximum term depth of 20 and more than two hundred multiplications. Its purpose is to ask whether there exists a concrete assignment to the four variables that satisfies all the quantified linear constraints – a typical “satisfiability of a quantified linear bit‑vector system” query used to stress‑test solvers. The instance is classified as *random* in the Preiner‑Scholl 2008 benchmark family, has size ≈ 12 KB, 1 top‑level assert, 4 declared constants, and a high density of Boolean connectives (≈ 55 `and`, 46 `or`).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_6.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) originating from the 2008 SMT‑08 paper on detecting redundant linear constraints; it was later translated to bit‑vectors by Mathias Preiner and belongs to the “Preiner‑scholl‑smt08” random family (size ≈ 5.8 k characters, 7 declared constants, max term depth 21).  \nThe assertion is a massive quantified formula that mixes many alternating **∀** and **∃** blocks (23 universals, 12 existentials) over auxiliary variables ?y₁ … ?y₆ and the primary variable x₁, forming a hierarchy of nested scopes.  \nInside each quantifier block the constraints are purely linear bit‑vector arithmetic built from `bvadd`, `bvmul`, and `bvneg`, combined with signed comparisons (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) and a few equalities; the coefficients are concrete 32‑bit constants (e.g., 53, ‑56, 77, ‑94, 90, …).  \nThe overall problem asks whether there exists an assignment to the declared constants (especially x₁) such that **all** these universally quantified linear inequalities and equalities can be satisfied together with the existential witnesses, i.e., it checks the satisfiability of a highly constrained, non‑convex polyhedral region encoded in bit‑vector arithmetic.  \nBecause of the deep quantifier alternation, the large number of linear terms (≈ 90 `bvmul`s) and the mixture of strict and non‑strict signed bounds, the instance is meant to stress quantifier‑handling and interpolation capabilities of SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_14.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. “SMT08” paper and translated to bit‑vectors by Mathias Preiner; it belongs to the random family *Preiner‑scholl‑smt08* (file RND_4_14.smt2, size ≈ 7.4 KB, 4 declared constants).  The whole instance consists of a single, massive quantified formula that nests ten universal and seven existential quantifiers and reaches a term‑depth of 18.  Inside the quantifiers the model encodes a large system of linear‑algebraic constraints, all of the form `bvslt`, `bvsle`, `bvsge`, `bvsgt`, or equality between a linear combination of the quantified variables and a concrete 32‑bit constant, each combination built with `bvmul` (by constant coefficients) and `bvadd`.  The primary check is whether there exists an assignment to the free variable `x1` such that **for every** choice of `y1` (and in many sub‑cases for every `y3`/`y4`) the whole conjunction of these signed‑inequalities and equalities holds, i.e., a global satisfaction of a highly constrained non‑convex polyhedral region.  Notably, the benchmark stresses solvers with heavy quantifier interaction, a dense use of multiplication by constants, and a large number of similar arithmetic literals (139 `bvmul`, 89 `bvadd`), making it a demanding test of quantifier‑instantiation and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_25.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 file written for the **BV** logic, originating from the Scholl et al. 2008 paper on redundancy removal in non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner.  It declares seven 32‑bit bit‑vector variables (six auxiliary yᵢ and one main x₁) and builds a huge quantified formula that alternates **existential** and **universal** quantifiers (22 ∀ and 23 ∃ blocks) with a nesting depth of up to 24.  The core of the formula is a conjunction of dozens of linear arithmetic constraints of the form bvmul · bvadd ≤ / < / ≥ / = a constant, each comparing a weighted sum of the y‑variables and x₁ against signed 32‑bit constants.  These constraints collectively encode a highly non‑convex polyhedral region; the SAT check asks whether there exists an assignment to the outermost variables that satisfies all the nested universally‑quantified linear inequalities.  The instance is classified as “random” in the Preiner‑Scholl 2008 family, contains 33531 characters, 720 multiplications, 582 additions and over 100 logical connectives, making it a stress test for solvers’ handling of deep quantifier alternation and bit‑vector linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_23.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic, using 32‑bit signed bit‑vectors; it contains 4 declared constants ( y1, y2, y3, x1 ) and one huge quantified formula of size ≈ 9 KB (max term depth 19). The formula has an **∃ y1 ∃ y2 … ∃ y3** prefix (three nested existential quantifiers) followed by a **∀ y3** block and an additional inner **∃ y3**, yielding an alternation pattern ∃∃∀∃ that makes the problem non‑trivial for quantifier‑handling solvers. Inside the quantifier scopes the benchmark encodes a large conjunction of linear constraints: equalities, signed inequalities ( bvsle, bvslt, bvsge, bvsgt ) and disjunctions, all built from **bvadd**, **bvmul** with many constant coefficients and occasional **bvneg**. The constraints are essentially a system of linear arithmetic over bit‑vectors, with many “or” branches that model alternative polyhedral facets, reflecting the original application of detecting redundant linear constraints in non‑convex polyhedra. As a “random” instance from the Preiner‑Scholl 2008 family, it is intended to stress SMT solvers’ handling of deep term nesting, heavy use of multiplication, and mixed quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_4.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 paper on detecting redundant linear constraints; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑scholl‑smt08” random family (size ≈ 2.2 KB, 4 declared constants, 1 top‑level assertion, max term depth 13).  \nThe formula quantifies over four 32‑bit variables x₁, y₁, y₂, y₃ and consists of a single massive conjunct that mixes existential and universal quantifiers in an ∃‑∀‑∃‑∀ pattern.  \nAll constraints are linear combinations of the variables multiplied by fixed constants, combined with signed comparisons (bvslt, bvsle, bvsge) and occasional equalities, e.g. bvmul (‑54)·?y₂ < 79 and bvmul 61·x₁ = ‑18.  \nThe core question is whether there exists an assignment to x₁ (and the outermost existential ?y₁) such that, for every choice of the universally‑quantified variables, the nested linear inequalities and equalities can be simultaneously satisfied.  \nBecause of the alternating quantifiers, the instance exercises the solver’s ability to handle quantified bit‑vector arithmetic, deep nesting (depth 13), and a mixture of strict and non‑strict signed bounds—characteristics typical of benchmarks derived from non‑convex polyhedral redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_2.smt2",
    "description": "This benchmark is a 4 770‑character BV‑logic file (logic BV, category random) that declares five 32‑bit bit‑vector constants `x1, y1, y2, y3, y4`.  The single top‑level assertion is a massive quantified formula built from alternating blocks of ∃ and ∀ quantifiers (13 existentials, 11 universals) over auxiliary variables `?y1 … ?y4`, and it consists exclusively of linear bit‑vector arithmetic (addition, multiplication by concrete constants, and signed comparisons).  The core constraints encode a system of linear (in)equalities such as `bvsge(... )`, `bvsle(... )`, `bvslt(... )`, and equalities, many of which are negated or combined with Boolean connectives, mimicking the redundancy‑removal conditions for non‑convex polyhedra described in the cited paper.  Because the formula contains deep nesting (max term depth 15) and many quantified alternations, it serves as a stress test for SMT solvers’ handling of quantified bit‑vector arithmetic rather than a specific application problem.  The solver is asked simply to decide `sat`/`unsat` for this quantified linear‑BV conjunction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_1.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the SMT‑08 paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, subsequently translated to bit‑vectors by Mathias Preiner (file RND_3_1.smt2, 2 kB, 1 top‑level assertion, 4 declared constants). It asks whether there exists a valuation for the free variables y1, y2, y3 and x1 that satisfies a single large disjunction, each side of which contains nested quantified linear constraints over additional bound variables (8 ∃‑quantifiers and 3 ∀‑quantifiers). The left‑hand disjunct is an ∃y₁ ∀y₂ ∀y₃ formula that combines signed‑less‑than inequalities and equality constraints built from linear combinations such as 69·y₂ < 4 and 48·y₃ + 49·y₂ – 11·y₁ < 0. The right‑hand conjunct consists of two blocks: one mixes a universal inequality on x₁ (e.g., 42·x₁ ≤ 0 ∨ –46·x₁ ≥ 0) with an existential equality 42·y₃ + 68·y₂ + 20·x₁ = 45, and the other combines existential inequalities/equalities involving x₁ and the quantified y‑variables (e.g., –21·x₁ ≥ 70 ∨ … ≠ –39). The formula is a heavily quantified, bit‑vector encoding of a piecewise linear non‑convex polyhedral condition, typical of random‑category benchmarks used to stress quantifier handling in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_21.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the 2008 SMT‑08 paper by Scholl et al. and later translated to bit‑vectors by Mathias Preiner; it belongs to the **Preiner‑Scholl‑smt08 random** family (file BV/2017‑Preiner‑scholl‑smt08/RND/RND_6_21.smt2), contains about **43 k characters**, 7 declared constants, and one gigantic quantified formula (depth 24) that mixes **74 existential** and **54 universal** quantifiers.\n\nThe formula encodes a large system of linear constraints over the seven 32‑bit variables (y₁,…,y₆, x₁) by means of **bvmul, bvadd, bvneg** and signed comparison operators (bvslt, bvsgt, bvsle, bvsge).  It is essentially a quantified conjunction of many affine inequalities and disequalities, arranged in a deep nesting of `let` bindings, `or`/`and` combinations and equalities to constants.\n\nThe solver is asked to decide **satisfiability** of this quantified conjunction – i.e., whether there exist integer‑valued 32‑bit assignments to the variables that satisfy all the mixed‑sign linear bounds simultaneously.  The benchmark is deliberately difficult: it stresses quantifier handling, instantiation heuristics, and the ability to reason about large numbers of bit‑vector multiplications (≈ 917 bvmul occurrences) within a single assertion.\n\nBecause the constraints are randomly generated but stem from a polyhedral‑redundancy removal experiment, the instance is used to evaluate SMT solvers’ performance on **non‑convex polyhedral encodings** and on generating Craig interpolants for such quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_11.smt2",
    "description": "The file is a single‑assertion benchmark written in the BV logic (32‑bit bit‑vectors) with 5 declared constants \\(x1, y1, y2, y3, y4\\); it comes from the “Preiner‑Scholl smt08” random family (source: Scholl et al., 2008, translated to BV by Mathias Preiner) and contains 9 153 characters, 170 multiplications, 114 additions and a maximum term depth of 18.  \n\nThe asserted formula is a huge quantified Boolean combination of linear bit‑vector inequalities and equalities: nested ∃ and ∀ blocks over fresh copies of the y‑variables are interleaved with many conjunctive/disjunctive sub‑formulas that involve expressions such as \\(bvmul(c, ?yi)\\) and \\(bvadd(…, x1)\\) compared with concrete bit‑vector constants.  \n\nIts overall purpose is to ask whether there exists a valuation for the free variables (in particular \\(x1\\)) that makes the entire quantified matrix true – i.e., it checks the satisfiability of a highly non‑convex, quantified linear‑arithmetic region over 32‑bit integers.  \n\nNotable characteristics are the heavy use of alternating quantifiers (17 ∀, 16 ∃), a dense mixture of inequalities (bvsle, bvsge, bvslt, bvsgt) and equalities, and a deliberately random layout that stresses solvers’ handling of quantified bit‑vector arithmetic and interpolation‑based redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_26.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the 2008 SMT‑Workshop paper on removing redundant linear constraints from non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner (family *Preiner‑scholl‑smt08*).  It declares seven 32‑bit constants ( x1 and y1…y6 ) and then asserts a huge quantified formula that alternates ∀ and ∃ quantifiers over fresh auxiliary variables (up to six levels deep) with a maximum term depth of 26.  The core of the constraint is a system of linear arithmetic over bit‑vectors: dozens of equalities and signed inequalities ( bvslt, bvsgt, bvsle, bvsge ) built from bvadd, bvmul and bvneg, expressing a complex polyhedral region that must be simultaneously satisfied for all choices of the quantified variables.  The benchmark therefore checks the **satisfiability** of a highly quantified, non‑convex linear‑inequality system—essentially a quantifier‑alternation “game” that tests an SMT solver’s ability to handle deep nesting, large numbers of arithmetic operations (≈ 800 multiplications, 600 additions) and many quantifier instantiations.  At ≈ 37 KB and 1 assertion, it is a deliberately challenging random instance used to evaluate interpolation‑based redundancy detection techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_22.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (bit‑vector) logic, taken from the 2008 SMT‑08 paper by Scholl et al. on using Craig interpolation to prune redundant linear constraints in non‑convex polyhedra; it was later translated to bit‑vectors by Mathias Preiner (family *Preiner‑scholl‑smt08*, file *RND_4_22.smt2*).  \nThe formula declares five 32‑bit constants (the free variables x1, y1…y4) and then builds a massive quantified conjunct that mixes **existential** and **universal** quantifiers over auxiliary 32‑bit variables. Inside the quantifier nesting it expresses a large set of linear‑arithmetic style constraints – equalities, signed‑less‑than/greater‑than and non‑strict inequalities – all formed with `bvadd`, `bvmul` and `bvneg`.  \nThe overall check asks whether there exists a valuation of the free variables such that **all** the quantified inequalities can be satisfied simultaneously; in other words it is a satisfiability question for a highly non‑convex, quantified integer‑polyhedron encoded as bit‑vectors.  \nThe instance is relatively large (≈ 23 k characters, 5 declared constants, 1 top‑level assert, max term depth 21) and contains hundreds of arithmetic terms (≈ 500 `bvmul`, 335 `bvadd`), making it a stress test for solvers’ handling of deeply nested quantifiers and linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_36.smt2",
    "description": "**What the file encodes** – This SMT‑LIB 2.6 benchmark is a single‑assertion formula in the **BV** (32‑bit bit‑vector) logic, taken from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al., SMT‑08) and later translated to bit‑vectors by Mathias Preiner. It belongs to the **Preiner‑Scholl 2008** family of random benchmarks (file RND_6_36.smt2) and contains **106 951** symbols, **2230** multiplications, **1957** additions and **66** universal/​**62** existential quantifiers, with a maximum term depth of 27.\n\n**Main structure** – The formula declares seven 32‑bit variables (x₁, y₁…y₆) and then asserts a gigantic Boolean combination of nested `forall` and `exists` quantifiers. Inside the quantifiers are linear arithmetic constraints built from `bvadd`, `bvmul`, `bvneg`, and relational operators (`bvsle`, `bvsge`, `bvslt`, `bvsgt`, `=`). The body consists mainly of large conjuncts and disjuncts of inequalities such as `bvsge(bvadd(...), 0)` and equalities of the form `bvadd(bvmul(...), …) = const`.\n\n**Key constraints** – All constraints are **linear** over the bit‑vectors (multiplication by constant coefficients only) and encode a dense system of upper‑ and lower‑bounds on linear forms like `37·y₅ + 43·x₁ + …`. The quantifier alternation (`∃y₂ ∀y₃ ∀y₄ …`) creates a classic decision‑problem of checking whether there exist assignments to the outer variables that satisfy the whole guarded polyhedral region defined by the inner universally quantified constraints.\n\n**Notable characteristics** – The instance is deliberately “hard” for SAT/SMT solvers: it mixes a large number of quantified linear constraints, many redundant or contradictory inequalities, and a deep nesting of logical connectives, making quantifier reasoning and interpolation challenging. The benchmark is used to evaluate solvers’ ability to handle quantified bit‑vector arithmetic and to detect/remedy redundant linear constraints in non‑convex polyhedral representations. The script finishes with a simple `(check‑sat)` call, leaving the actual satisfiability result to the solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_19.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark (size 13 784, 7 declared 32‑bit bit‑vectors, 282 bvmul and 224 bvadd terms) written in the **BV** logic and labelled as a random instance from the *Preiner‑Scholl‑smt08* family.  \nThe top‑level assertion is a massive quantified formula that mixes **23 existential** and **19 universal** quantifiers, with the free variables `x1 , y1 … y6` appearing in dozens of linear‑integer‑style expressions over 32‑bit bit‑vectors.  \nAll constraints are built from linear combinations of the variables (constant · variable) together with **signed comparisons** (`bvslt`, `bvsgt`, `bvsle`, `bvsge`) and a few **equality** tests, often combined with `or`, `and`, and `not`.  \nThe purpose of the benchmark is to ask the solver whether there exists a valuation of the free variables that simultaneously satisfies the whole quantified conjunctive‑disjunctive system—essentially a satisfiability check for a highly non‑trivial quantified linear‑arithmetic fragment.  \nNotably, the formula features deep nesting (max term depth 22), many alternating quantifier blocks, and a few `let` bindings to share intermediate products, making it a challenging test for quantifier handling and interpolation‑based redundancy detection techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_23.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 file in the **BV** logic, generated for the Preiner‑Scholl 2008 random family (file RND_4_23.smt2). It declares three 32‑bit bit‑vector variables `x1`, `y3` and `y4` and then asserts a huge quantified formula: a universal quantifier over `y3` that contains an existential quantifier over `y4`, followed by a second universal quantifier over `y4`. Inside the quantifiers the formula is a massive Boolean combination (≈ 56 or‑clauses and 48 and‑clauses) of **linear** bit‑vector constraints built with `bvmul` of constants, `bvadd`, signed comparisons (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) and equalities. The constraints encode the correctness conditions of a non‑convex polyhedral representation (as described in the cited paper), essentially asking whether there exists a value for `x1` such that all those signed linear inequalities hold for **every** possible `y3` and `y4`. The instance is relatively large (≈ 11 k characters, max term depth 17) and contains 219 multiplications, 137 negations and 136 additions, making it a stress test for quantifier handling and bit‑vector arithmetic in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_28.smt2",
    "description": "**Overview** – The file is a single‑assertion SMT‑LIB 2.6 benchmark in the *BV* logic (32‑bit bit‑vectors). It originates from the 2008 SMT‑Workshop paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and was translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08). The instance is fairly large (≈ 38 k characters, 7 declared constants, 32 existential and 26 universal quantifiers, max term depth 26) and is classified as a random benchmark.\n\n**Structure** – The formula quantifies over six auxiliary variables `y1…y6` (and repeatedly re‑binds them as fresh quantified names) together with a single free variable `x1`. Inside the top‑level existential it builds a deep alternation of `exists`/`forall` scopes, each containing large linear expressions formed with `bvadd`, `bvmul`, and `bvneg`. The constraints are essentially systems of linear inequalities ( `bvslt`, `bvsle`, `bvsge`, `bvsgt` ) and equalities over those linear combinations.\n\n**Key constraints** – Each quantified block asserts that certain affine combinations of the `yi`’s and `x1` are bounded above or below by concrete bit‑vector constants (e.g., `bvadd … ≤ 0`, `bvadd … > -42`). Some disjunctive branches (`or`) allow alternative linear conditions, and a few equalities test whether a combination equals a constant (often `0`). The overall assertion asks whether there exists an assignment to `x1` such that **all** universally‑quantified choices of the `yi`’s can satisfy the nested disjunctions of these linear bounds.\n\n**Purpose / notable traits** – The benchmark is designed to stress solvers with heavy quantifier alternation and a large number of similar linear constraints, mimicking the redundant‑constraint detection problem from the source paper. Its random nature yields many duplicated patterns (e.g., repeated coefficients) and a high count of arithmetic operators (`bvmul` 867, `bvadd` 706), making it a good test for quantifier‑instantiation heuristics and interpolation‑based simplification techniques. The final `check-sat` asks the solver to decide satisfiability of this quantified linear‑arithmetic‑over‑bit‑vectors problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_14.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the 2008 SMT‑08 paper by Scholl et al. and translated to bit‑vectors by Mathias Preiner; it belongs to the “random” family Preiner‑scholl‑smt08 and contains 11 414 characters, 6 declared constants and a single top‑level assertion.  \nThe assertion is a huge Boolean combination of quantified sub‑formulas, with quantifier alternations such as ∀…∃…∀ and nesting depths up to 21, but it only uses linear bit‑vector arithmetic (bvadd, bvmul by constant coefficients, bvneg) and relational operators (bvslt, bvsle, bvsge, bvsgt, =).  \nEach quantified block encodes a system of linear inequalities or equalities over the 32‑bit variables x1, y1, y3, y4, y5, y6, mirroring the redundancy‑checking constraints for non‑convex polyhedra described in the paper.  \nThe problem therefore asks whether there exists an assignment to the six bit‑vector variables that simultaneously satisfies all of these universally and existentially quantified linear constraints.  \nIts notable features are the extreme quantifier nesting, the large number of constant multiplications (218 bvmul occurrences) and the lack of any uninterpreted functions, making it a stress test for solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_40.smt2",
    "description": "The benchmark is a single `check‑sat` query in the 32‑bit bit‑vector logic (BV) that was translated from a linear‑inequality encoding of a non‑convex polyhedron (see Scholl et al., SMT‑08).  It declares seven 32‑bit variables (`x1`, `y1`‑`y6`) and asserts one gigantic quantified formula: a top‑level disjunction that contains alternating blocks of universal and existential quantifiers, each nesting dozens of linear constraints written as combinations of `bvadd`, `bvmul`, and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`).  The constraints are essentially a random, highly redundant mixture of linear inequalities over the variables, with many auxiliary let‑bindings (`?v_*`) that reuse common sub‑expressions.  The instance tests whether there exists any assignment to the outer variables such that the quantified conjunction of all these signed linear constraints can be satisfied, i.e., whether the encoded non‑convex polyhedron is non‑empty.  Its size (≈ 85 k characters, 1 874 AST nodes, depth 27) and the sheer number of arithmetic and Boolean operators (∼ 1 900 `bvmul`, 1 500 `bvadd`, 100+ signed comparisons) make it a stress test for SMT solvers’ quantifier handling and interpolation‑based redundancy elimination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_30.smt2",
    "description": "**Overview.** This benchmark is a single‑assertion SMT‑LIB 2.6 file in the *BV* logic (32‑bit bit‑vectors), originating from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08) and later translated to bit‑vectors by Mathias Preiner. The instance (≈ 28 kB, 6 declared constants, 1 assert, 21 ∀‑quantifiers and 24 ∃‑quantifiers, maximum term depth 22) belongs to the “random” category of the Preiner‑Scholl‑SMT08 family.\n\n**Structure.** The lone assertion is a massive quantified formula built from nested `forall`/`exists` blocks that introduce fresh temporary variables `?y2 … ?y6`. Inside each block the constraints are linear combinations of the six free variables (`x1`, `y2`, `y3`, `y4`, `y5`, `y6`) expressed with `bvadd`, `bvmul` (constant coefficients), and `bvneg`. The quantifier alternation pattern is essentially *∀‑∃‑∀‑…* and is repeated many times, creating a deep alternation hierarchy.\n\n**Key constraints.** All atomic predicates are signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equalities over those linear expressions, e.g.  \n```\nbvslt (bvadd (bvadd (bvmul (_ bv5 32) ?y5) … ) (bvneg (_ bv17 32)))\n```  \nThese encode a system of linear (in)equalities that must hold for every choice of the universally‑quantified variables while there exist witnesses for the existentially‑quantified ones. In effect the benchmark asks whether the underlying non‑convex polyhedron, after being encoded as a bit‑vector formula, is empty (unsatisfiable) or not.\n\n**Notable characteristics.** The formula is deliberately crafted to stress quantifier reasoning: it contains over 600 `bvmul` and 400 `bvadd` terms, many different constant coefficients, and a rich mixture of conjunctions, disjunctions, and negations. The heavy use of quantified linear arithmetic turned into bit‑vector arithmetic makes the instance challenging for solvers that rely on quantifier instantiation or interpolation, and it is typically used to benchmark the effectiveness of Craig‑interpolation‑based redundancy detection techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_12.smt2",
    "description": "The file is a single‑assertion BV benchmark (logic BV, 4 declared 32‑bit bit‑vector variables x1, y1, y2, y3) originating from the Scholl et al. “Detecting Redundant Linear Constraints in Non‑Convex Polyhedra’’ paper and translated to bit‑vectors by Mathias Preiner.  It encodes a highly quantified consistency check: a large nest of ∃ and ∀ quantifiers builds a conjunction of linear inequalities (each inequality is a sum of constant‑scaled variables compared with a constant, all expressed with `bvadd`, `bvmul`, `bvneg` and signed comparison operators).  The outermost formula asks whether there exists an assignment to the free variables such that all these quantified sub‑constraints – a mixture of implication‑style clauses, equalities, and strict/ non‑strict bounds – can be simultaneously satisfied.  The benchmark is deliberately random (category “random”, size ≈ 4.8 KB, 4807 characters, 15‑deep term tree) and is intended to stress SMT solvers’ abilities to handle deep quantified bit‑vector arithmetic rather than to model a concrete application.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_13.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic **BV**) taken from the Scholl et al. SMT‑08 paper on detecting redundant linear constraints; it was translated to bit‑vectors by Mathias Preiner and is listed in the *Preiner‑scholl‑smt08* random family (file RND_3_13.smt2, 3397 bytes, 1 top‑level assertion, 4 declared constants). The formula consists of a quantified block with two outer existential variables ?y1, ?y2, an inner universal quantifier over ?y3, and a later existential quantifier over a second ?y3, all combined with a large conjunction of linear equalities and signed inequalities (≤, ≥, <, >) built from constant‑scaled bit‑vector multiplications and additions. The constraints encode a system of signed linear relations among the three unknown vectors y1, y2, y3 and a free variable x1, including several disequalities and conditional disjunctions that must hold for **all** ?y3 while the outer existentials may be chosen to satisfy them. The instance therefore checks the satisfiability of a non‑convex polyhedral description expressed in bit‑vector arithmetic, featuring deep terms (max depth 15) and a dense mix of ≠, =, and relational operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_15.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) taken from the Scholl et al. “SMT‑based removal of redundant linear constraints” paper, translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, random category).  It declares seven 32‑bit constants x1, y1‑y6 and then builds a giant conjunctive formula that mixes **linear** arithmetic operations (addition, multiplication by constant coefficients, negation) with signed comparisons ( ≤, ≥, <, >) inside a deep alternation of quantifiers (≈18 ∃ and 14 ∀ blocks, nesting depth up to 21).  The core of the problem is to decide whether there exists an assignment to the free variables (especially x1) such that a highly interwoven set of linear inequalities holds for all choices of the quantified y‑variables, i.e. whether the quantified linear‑inequality system is satisfiable.  The instance is relatively large (≈12 k characters, 257 bvmul, 192 bvadd, 176 bvneg) and stresses the solver’s quantifier handling, interpolation, and reasoning about non‑convex polyhedral constraints encoded as bit‑vector arithmetic.  No additional helper definitions or axioms are used; everything is expressed directly through the built‑in BV operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_24.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) taken from the Scholl et al. 2008 study on redundant linear constraints, later translated to bit‑vectors by Mathias Preiner.  It declares four 32‑bit constants `x1`, `y1`, `y3` and `y4` and then asserts a massive quantified formula: an outer universal quantifier over `y1`, a nested universal over `y3`, an existential over `y4`, followed by a large conjunction of linear (in)equalities built from constant‑multiplications, additions and signed comparisons.  The core property being checked is whether there exists a value for `x1` that makes the universally quantified constraints on all possible `y1` (and for each such `y1` all `y3`) satisfiable—i.e., the overall formula is **sat** or **unsat**.  The benchmark is deliberately “random”: it contains 355 `bvmul`, 231 `bvadd`, 227 `bvneg` occurrences, 13 `forall` and 7 `exists`, with a maximum term depth of 20, making it a stress test for SMT solvers handling deep quantifier alternations and heavy linear arithmetic over bit‑vectors.  Its size is 17 721 characters, with 4 declared constants and a single top‑level assertion, and it belongs to the Preiner‑Scholl‑smt08 random family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_8.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (fixed‑size bit‑vector) logic, taken from the Scholl et al. 2008 SMT‑08 paper and translated to bit‑vectors by Mathias Preiner (family *Preiner‑scholl‑smt08*).  It contains 6 declared 32‑bit variables, 48 `bvmul`, 36 `bvadd` and 30 `bvneg` occurrences, and a nesting depth of 17, for a total size of about 3 KB.  \n\nThe assertion is a quantified formula that combines three outer universal quantifiers (`forall`) with five existential quantifiers (`exists`).  Inside the quantifier blocks the constraints are pure linear‑integer relations over the bit‑vectors, written as inequalities (`bvsgt`, `bvsge`, `bvslt`) and equalities, all built from weighted sums of the variables (e.g., `bvadd (bvmul C ?y6) (bvmul D ?y4) …`).  \n\nSemantically the benchmark encodes the satisfiability of a non‑convex polyhedral region after it has been converted to a bit‑vector representation: the solver must decide whether there exist assignments to the existentially quantified variables that satisfy all the linear inequalities for every choice of the universally quantified ones.  \n\nBecause the problem mixes alternating quantifiers with many linear bit‑vector constraints, it is a stress test for quantifier handling and interpolation techniques rather than a concrete application‑specific instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_33.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Preiner‑Scholl 2008 suite on redundant linear‑constraint detection and subsequently translated to bit‑vectors by Mathias Preiner. It declares five 32‑bit variables x1, y3, y4, y5 and y6 and contains a single massive assertion built from a hierarchy of universal (∀) and existential (∃) quantifiers over these variables. Within the quantifiers the formula is a conjunction/disjunction of signed linear inequalities—bvslt, bvsle, bvsge and bvsgt—applied to weighted sums of the variables, where the weights are encoded as bvmul constants and the sums as bvadd expressions. The problem asks whether there exists an assignment to the free variables that satisfies the whole quantified combination of inequalities, i.e., a SAT/UNSAT check for a highly quantified linear‑integer problem encoded in bit‑vector form. Notable characteristics are its extreme size (≈57 k characters, 1 204 bvmul, 917 bvadd), a term depth of 25, and a dense quantifier structure (13 ∀, 12 ∃), making it a demanding stress test for SMT solvers' quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_1.smt2",
    "description": "This benchmark is a single‑assertion BV problem (32‑bit bit‑vectors) taken from the 2008 SMT‑08 paper on eliminating redundant linear constraints in non‑convex polyhedra, translated to bit‑vectors by Mathias Preiner.  It declares five free constants (x1 and y1…y4) and then asserts a large disjunction of two quantified blocks; each block contains alternating ∃/∀ quantifiers over additional 32‑bit variables and only linear arithmetic built from constant‑multiply, add, and signed comparisons ( bvslt, bvsle, bvsgt, bvsge ).  The constraints encode families of linear inequalities and equalities such as bvmul c ?v + bvmul c x1 ≤ c and similar equalities to a constant, together with logical combinations (∧, ∨, ¬).  Satisfiability is asked for the existence of an assignment to the free variables (in particular x1) that makes at least one of the two quantified conjunctions true.  The instance is relatively small (≈3.8 KB, 57 bvmul, 36 bvadd, depth 17) but features a deep quantifier alternation pattern that stresses solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_3.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (set‑logic BV) taken from the 2008 SMT‑08 paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, and was later translated to BV by Mathias Preiner (family Preiner‑scholl‑smt08).  It is a relatively small instance (≈1.9 KB, 3 declared constants and a single top‑level assertion) but has a deep term structure (max depth 12) with many linear‑arithmetic‑like operations (24 bvmul, 15 bvneg, 13 bvadd).  The core formula is a pair of universally quantified variables ( ?y3 and ?y4 ) that contain a nested existential quantifier over ?y4, and the body is a large disjunction of signed comparisons (bvslt, bvsle, bvsgt, bvsge) and equalities, each built from linear expressions of the form c·?y + d·x1 + e.  Semantically the encoding tests the satisfiability of a system of linear constraints (some of which are contradictory) that model a non‑convex polyhedron after being encoded as bit‑vector arithmetic.  Because the constraints involve many constant multiplications and mixed quantifiers, the instance is used to stress‑test BV solvers and interpolation procedures on quantified, arithmetic‑heavy formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_12.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the “Preiner‑Scholl SMT‑08” random family (≈9 k characters, 5 declared constants and a single gigantic assertion).  It encodes a quantified SAT problem that alternates ∃ and ∀ quantifiers several times (e.g. ∃y₁ ∀y₂ ∃y₃ …) and mixes them with many linear‑integer‑style constraints expressed as signed comparisons (bvsge, bvslt, bvsgt, bvsle) over expressions built from constant‑multiplications, additions and negations.  All arithmetic is purely linear in the sense that every term is a sum of a constant‑scaled variable (e.g. (· 86 y₃) + … + (· 20 x₁)) plus a constant, but the quantifier nesting creates a non‑convex region that the solver must decide whether it is empty.  The benchmark was generated by Mathias Preiner as a translation of a redundancy‑removal task for non‑convex polyhedra (the original paper uses Craig interpolation), hence the prevalence of “redundant‑looking” equalities and disequalities such as bvmul(−98,y₁)=69 ∨ bvmul(−94,y₁)=63.  Its notable characteristics are the high number of arithmetic operators (≈177 bvmul, 118 bvadd), a maximum term depth of 18, and a heavy use of let‑bindings and Boolean combinations, making it a challenging test for solvers that support quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_4.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Scholl et al. SMT‑08 paper on redundant linear‑constraint removal and translated to bit‑vectors by Mathias Preiner (file RND_4_4.smt2, size ≈ 3 KB, 4 declared constants, 1 top‑level assertion). The core formula is a single, highly nested quantified statement that mixes four universal quantifiers (over ?y1, ?y3, ?y4) with two existential quantifiers, all of which range over 32‑bit bit‑vectors. Inside the quantifier blocks the problem asserts a conjunction of linear inequalities and equalities built from bit‑vector addition, multiplication by constant coefficients and signed comparisons (bvslt, bvsle, bvsge, bvsgt), together with a let‑binding that re‑uses the term bvmul(‑78, x1). Effectively the benchmark checks the satisfiability of a system of linear constraints that represent a non‑convex polyhedron, stressing the solver’s handling of quantified bit‑vector arithmetic, deep term nesting (depth 14) and a large number of arithmetic operations (44 bvmul, 25 bvadd, etc.).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_10.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of moderate size (≈1.4 KB, 1 quantified assertion, 3 declared constants) taken from the SMT‑08 paper on using Craig interpolation to prune redundant linear constraints in non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner. The single top‑level formula quantifies universally over a fresh variable ?y2 and, inside that, both an existential over ?y3 and another universal over ?y3, mixing them with a final existential clause, so the problem has a ∀∃∀∃ quantifier pattern. All constraints are linear combinations of the three program variables (x1, y2, y3) multiplied by constant 32‑bit coefficients, together with signed inequalities (bvslt, bvsgt) and equalities to concrete constants or to zero. The solver is asked simply to decide sat/unsat, i.e., whether there exist 32‑bit values for x1, y2, y3 that satisfy the intertwined universally‑ and existentially‑quantified linear relations. Compared with typical BV benchmarks, the instance is notable for its deep (depth 12) nesting of arithmetic operations and quantifiers, reflecting a non‑convex polyhedral redundancy check rather than a straight‑forward arithmetic puzzle.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_23.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 file in the **BV** logic, taken from the Scholl et al. 2008 paper on redundant linear constraints and translated to bit‑vectors by Mathias Preiner (file BV/2017‑Preiner‑scholl‑smt08/RND/RND_6_23.smt2).  It declares five 32‑bit uninterpreted constants ( x1, y3, y4, y5, y6 ) and then poses a huge quantified formula that mixes **∀** and **∃** quantifiers (11 ∀, 10 ∃) over additional fresh 32‑bit variables.  The body consists of a massive conjunction of linear‑arithmetic‑style constraints formed from constant‑multiplied variables (≈ 421 `bvmul` and 301 `bvadd` occurrences) combined with inequalities (`bvsle`, `bvslt`, `bvsgt`, `bvsge`) and equality tests, all wrapped in nested `or`/`and`/`not` structures.  The overall goal is simply **satisfiability** (`check‑sat`), and the instance is deliberately “random” – it contains no domain‑specific structure, but stresses solvers with deep term nesting (max depth 23) and a large variety of linear bit‑vector relations.  Because of its size (≈ 20 k characters) and high logical complexity, it is used to benchmark the performance of BV‑solvers on heavily quantified, non‑convex polyhedral‑like encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_1.smt2",
    "description": "The file is a 7 KB BV‑logic benchmark (logic BV, 7 declared 32‑bit bit‑vector constants y1…y6, x1) taken from the Scholl et al. 2008 paper on using SMT and Craig interpolation to prune redundant linear constraints of non‑convex polyhedra; it was later translated to pure bit‑vectors by Mathias Preiner.  The single top‑level assertion is a huge quantified Boolean combination that alternates ∃ and ∀ quantifiers (21 each) over fresh 32‑bit variables and mixes linear equalities, disequalities and signed inequalities built from constant‑multiplied variables, additions and negations.  Semantically the formula encodes a set of linear constraints over the variables that represent a polyhedral region, and the query asks whether there exists a concrete assignment to the declared constants (the “outer” variables) such that all quantified constraints hold – i.e. whether the region is non‑empty after the intended redundancy elimination.  The benchmark is deliberately difficult: it contains 127 bvmul, 86 bvadd and deep nesting (max term depth 18), making quantifier‑instantiation and interpolation the primary challenges for an SMT solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_20.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the Scholl et al. 2008 paper on redundant linear constraints in non‑convex polyhedra and automatically translated to bit‑vectors by Mathias Preiner.  It declares five 32‑bit variables (x1, y1…y4) and contains one large assertion that is a disjunction of three quantified sub‑formulas, each of the form “∀ y ∃ z ∀ w …”, built from many linear expressions of the shape c·v (constant multiplication) combined with additions and signed comparisons (≤, ≥, <, >).  The constraints encode a dense system of signed linear inequalities over the variables, effectively describing a (randomly generated) non‑convex polyhedral region that must be shown either empty or non‑empty.  The benchmark is relatively small in source size (≈ 6.5 KB, 123 bvmul, 85 bvneg, depth 18) but syntactically heavy, making it a stress test for solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_8.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Scholl et al. 2008 SMT‑08 paper on removing redundant linear constraints; it was later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08).  It declares four 32‑bit variables x₁, y₁, y₂ and y₃ and contains a single, large assertion that is a disjunction of two quantified sub‑formulas.  The first sub‑formula is ∀y₂ ∃y₃ · [ (bvslt (‑44·y₃) ‑47) ∨ ¬(… = ‑85) ∨ ( bvsgt (‑86·y₃ ‑74·y₂ ‑44·x₁) ‑43 ∧ bvslt (59·y₃ ‑45·y₂) ‑86 ) ], i.e., a mixture of linear inequalities and an equality over bit‑vector arithmetic.  The second sub‑formula is ∀y₁ ∃y₃ · [ (bvsgt (61·x₁) ‑31 ∨ (‑27·y₃ ‑86·x₁)= 69) ∧ (bvslt (‑60·y₃ ‑74·y₁) 67 ∧ bvsle (32·y₃ + 67·y₁ ‑18·x₁) 0) ], encoding another set of linear constraints with alternating quantifiers.  Thus the benchmark asks whether there exists a value for x₁ such that, for every choice of y₂ (resp. y₁), a suitable y₃ can be found to satisfy all the listed linear bit‑vector constraints; its size is 1,711 characters, depth 12, and it is classified as a random‑category test.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_29.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic, generated by Mathias Preiner from the Scholl et al. 2008 paper on redundant linear constraints in non‑convex polyhedra and placed in the *Preiner‑Scholl‑smt08* random family (path BV/2017‑Preiner‑scholl‑smt08/RND/RND_6_29.smt2).  It declares seven 32‑bit bit‑vector constants (x1, y1–y6) and then asserts a massive quantified formula with an outer **or**, a block of nested **forall/exists** alternations (13 ∀ and 15 ∃), and many auxiliary **let** bindings.  The core of the formula is a conjunction of linear‑arithmetic‑style constraints built from `bvadd`, `bvmul`, and `bvneg`, compared with signed relations (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equalities, essentially encoding a large system of linear inequalities over the bit‑vectors.  With 29 688 characters, 675 multiplications, 520 additions, and a maximum term depth of 24, the benchmark stresses quantifier handling and arithmetic reasoning in bit‑vector solvers rather than representing a concrete application problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_28.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit signed bit‑vectors) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner.  It declares four free variables `x1`, `y1`, `y2`, `y3` and then builds a massive quantified formula that alternates existential and universal quantifiers over auxiliary variables (≈ 27 ∃ and 17 ∀), each quantified variable ranging over the same 32‑bit domain.  The body consists of a dense conjunction of linear‑integer‑style constraints—encoded with `bvadd`, `bvmul`, `bvneg` and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`)—with many integer coefficients (e.g., −99, 84, ‑48) and numerous equality/inequality disjunctions, essentially modelling a randomly generated system of linear inequalities over the four main variables.  The benchmark asks whether there exists an assignment to `x1`, `y1`, `y2`, `y3` such that **all** the quantified sub‑formulas hold, i.e. it checks the satisfiability of a highly quantified, deeply nested linear‑arithmetic‑like BV formula.  With 12  k characters, 12509 nodes, a maximum term depth of 17 and over two hundred bit‑vector multiplications, the instance is deliberately hard for solvers that must handle both quantifier alternation and heavy arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_20.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 paper on redundant linear constraints; it was translated to bit‑vectors by Mathias Preiner and placed in the “random” category of the Preiner‑Scholl SMT‑08 family.  It declares three 32‑bit constants x₁, y₂ and y₃ and asserts a single, highly quantified formula that mixes two universal quantifiers (over fresh copies of y₂ and y₃) with two existential quantifiers (also over fresh y₃).  Inside the quantifier nest the constraints are purely linear combinations of the variables multiplied by concrete constants, combined with signed comparisons (bvsge, bvsle, bvslt, bvsgt) and a few equalities.  The overall intent is to ask whether there exists a value for x₁ such that, for every possible choice of y₂ (and then for every y₃), the attached system of linear inequalities can be satisfied by some choice of the existentially‑bound y₃ variables.  The instance is modest in size (≈2.7 KB, 41 bvmul occurrences, max term depth 14) but it features a non‑trivial pattern of alternating quantifiers that makes it a good stress‑test for BV solvers’ quantifier‑instantiation and interpolation capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_4_27.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the 2008 SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, random category).  \nIt encodes a highly quantified “redundancy‑detection” problem: a nested combination of universal and existential quantifiers over four 32‑bit variables ( x₁, y₂, y₃, y₄ ) expresses that for every candidate vector y₃ there must exist witnesses y₄ (and sometimes y₂) satisfying a large conjunction of linear‑appearing inequalities ( ≤, ≥, <, >) that have been rewritten as bit‑vector additions, multiplications by concrete constants and signed comparisons.  \nThe core of the formula is a massive Boolean combination of about 300 `bvmul`, 190 `bvneg` and 166 `bvadd` terms, linked by ≈ 80 `or` and 68 `and` operators, resulting in a maximal term depth of 20.  \nIts purpose is to ask the solver whether the quantified system of linear constraints (representing a non‑convex polyhedron) is **satisfiable**, i.e. whether there exists an assignment to the free variable x₁ that makes all quantified conditions simultaneously true.  \nBecause the constraints are essentially linear arithmetic over bit‑vectors, the benchmark is a stress test for quantifier handling, interpolation, and bit‑vector arithmetic in modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_29.smt2",
    "description": "The file is a single‑assertion BV benchmark (32‑bit signed bitvectors) that originates from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper and was translated to bit‑vector arithmetic by Mathias Preiner.  It declares three free constants `x1`, `y2` and `y3` and then asserts a massive formula built from two universal quantifiers (over fresh copies of `y2` and `y3`) and two existential quantifiers, all intertwined with a dense mixture of linear expressions of the form `bvadd` and `bvmul` with constant coefficients, and signed comparisons (`bvsge`, `bvsle`, `bvslt`, `bvsgt`).  The core of the problem is to decide whether there exist 32‑bit values for the three variables that satisfy all of the nested linear (in)equalities under the quantified alternation, i.e. whether the encoded set of (possibly redundant) polyhedral constraints is jointly satisfiable.  The benchmark is classified as “random” in the Preiner‑Scholl‑smt08 family, contains 3 declared constants, 1 top‑level assertion, 6662 characters, a maximal term depth of 17 and a heavy use of multiplication (128 occurrences) and negation (88), making it a stress test for solvers’ handling of deeply nested quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_7.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of moderate size (≈1.9 KB, 4 declared constants and a single top‑level assertion) taken from the SMT‑08 paper *Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra* and translated to bit‑vectors by Mathias Preiner.  The formula contains three nested existential quantifiers (over ?y1, ?y2, ?y3) together with two universal blocks (over ?y3 and over ?y2, ?y3), yielding an ∃∃∃ ∧ ∀ ∧ ∀∃∃ quantifier pattern.  All constraints are linear arithmetic over signed 32‑bit bit‑vectors: they consist of constant‑scaled multiplications (e.g., bvmul (_ bv80 32) ?y3), additions, and signed comparisons such as bvsge, bvslt, bvsle, bvsgt, together with equalities and simple Boolean connectives.  The core question is whether there exists a valuation for the free variable x1 (and the existentially bound variables) that simultaneously satisfies the mixed “or/and” conditions and the universally quantified bounds, essentially encoding a redundancy‑checking problem for a non‑convex polyhedral representation.  The benchmark is labelled “random” in the Preiner‑Scholl SMT08 family and exhibits a relatively deep term structure (max depth 13) with many constant‑multiplied terms (22 bvmul occurrences), making it a typical stress test for quantifier‑handling capabilities of BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_9.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 paper on using SMT and Craig interpolation to prune redundant linear constraints; the original mixed‑integer formulation was mechanically translated to bit‑vectors by Mathias Preiner (file RND_6_9.smt2, 6 560 characters, 7 declared constants and a single top‑level assert).  \n\nThe core formula is a massive quantified conjunction: an outer existential over a fresh ?y1 is combined with a cascade of existential and universal quantifiers over auxiliary 32‑bit variables ( ?y2…?y6 ), each quantifier block containing linear arithmetic expressions built from constant‑multiplied variables, additions, and signed negations.  \n\nAll atomic predicates are simple signed comparisons ( bvslt, bvsle, bvsgt, bvsge ) or equalities, so the benchmark encodes a highly non‑convex polyhedral feasibility problem expressed in bit‑vector arithmetic.  \n\nBecause of the alternation of ∃ and ∀ quantifiers and the depth of term nesting (maximum depth 21), the instance challenges solvers’ handling of quantifier instantiation, interpolation, and linear bit‑vector reasoning rather than pure propositional SAT.  \n\nNo additional axioms or definitions are supplied; the solver must decide whether there exists an assignment to the free constants y1…y5, x1 that satisfies the entire quantified conjunction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_9.smt2",
    "description": "The file is a **BV** (32‑bit bit‑vector) benchmark of size ≈ 2.5 KB, taken from the Scholl et al. 2008 study on redundant linear constraints and translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, category random).  It contains a single, large quantified assertion that mixes **existential** and **universal** quantifiers over auxiliary variables y₁, y₂, y₃ while the only free constant is x₁.  All constraints are linear‑looking arithmetic expressed with `bvmul`, `bvadd`, `bvneg` and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`), forming a conjunction of several disjunctions that encode a system of linear inequalities and equalities.  The goal is simply to decide **sat** – i.e., whether there exists a 32‑bit value for x₁ such that the whole quantified formula holds.  The benchmark is notable for its deep nesting (term depth 13), multiple quantifier alternations (7 ∃, 5 ∀) and a dense use of arithmetic operators, making it a stress test for solvers’ quantifier‑handling and interpolation capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_3_18.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) taken from the Preiner‑Scholl SMT‑08 collection, originally derived from a paper on redundant linear constraints and then translated to bit‑vectors; it is 3 565 characters long, declares four free constants (x1, y1, y2, y3) and contains a single top‑level assertion.  \nThe assertion is a disjunction of two big quantified blocks, each of the form “∀ y ∃ y′ · ϕ”, where the inner formula ϕ consists of a dense conjunction of linear inequalities (bvslt, bvsle, bvsge, bvsgt) and disequalities over expressions built with bvadd, bvmul and bvneg of constant coefficients.  \nThe first block quantifies over ?y2 and ?y3 and relates them to the free variable x1 through many mixed‑sign linear constraints, while the second block quantifies over ?y1 (and again ?y3) and imposes a different set of linear relations on x1.  \nAll arithmetic is performed in 32‑bit two’s‑complement, so the constraints encode a piecewise linear region in the integer lattice modulo 2³², and the solver is asked simply whether this region is non‑empty (check‑sat).  \nBecause the benchmark is labelled “random”, the coefficients appear without semantic meaning, but the structure mimics the kind of quantified linear‑inequality problems that arise when detecting redundant constraints in non‑convex polyhedral representations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_27.smt2",
    "description": "**Overview.** This benchmark is a 32‑bit bit‑vector problem (SMT‑LIB 2.6, logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner. It contains six free constants ( x1, y2‑y6 ) and a single gigantic assertion that intertwines 25 universal and 18 existential quantifiers, yielding a quantifier prefix of the form ∀…∃…∀…∃… with a maximal term depth of 22.  \n\n**Structure.** The assertion is a conjunction of many quantified sub‑formulas, each built from linear‑ish bit‑vector arithmetic: constant‑scaled multiplications ( bvmul ) and additions ( bvadd ) combined with signed comparisons ( bvsge, bvsle, bvsgt, bvslt) and equalities. The constants are small 32‑bit literals (e.g., bv‑2, bv‑78, bv‑36) that encode the coefficients of the original linear constraints.  \n\n**Purpose.** The overall formula asks whether there exists an assignment to the six free variables that satisfies all the encoded linear relations – essentially checking the satisfiability of a highly redundant, non‑convex polyhedral description after it has been lifted into bit‑vector arithmetic.  \n\n**Notable characteristics.** The instance is deliberately “random’’ in the benchmark suite: it uses 521 bvmul, 370 bvadd, and over 200 boolean connectives, making it a severe stress test for quantifier‑instantiation and interpolation techniques in modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RND/RND_6_2.smt2",
    "description": "This benchmark is a single‑assertion BV‑logic formula (32‑bit signed bit‑vectors) taken from the SMT‑08 paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, file RND_6_2.smt2, 8 376 characters, 7 declared constants).  \nThe top‑level assertion is a large Boolean conjunction of many quantified sub‑formulas that alternate ∀ and ∃ quantifiers (25 universals, 21 existentials) and contain only linear arithmetic built from constant‑multiplications (142 bvmul occurrences), additions, negations and signed comparisons (≤, <, ≥, >, =).  \nSemantically the constraints describe a system of linear inequalities and equalities over the free variables x1, y1,…,y6, modelling the emptiness (or redundancy) of a non‑convex polyhedron after it has been encoded as a bit‑vector arithmetic problem.  \nKey properties being checked are whether there exists an assignment to the free variables that satisfies all the mixed ∀∃ conditions, i.e., whether the quantified linear system is SAT, which in turn corresponds to the absence of a contradictory polyhedral region.  \nBecause of its deep quantifier nesting (max term depth 18) and the heavy use of constant multiplications, the instance is a stressful test for SMT solvers’ quantifier‑instantiation and interpolation engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_36.smt2",
    "description": "**Basic information.** The file is a 12 k‑byte SMT‑LIB 2.6 benchmark in the *BV* logic, generated for the “Preiner‑Scholl smt08’’ random family (source: Scholl et al., SMT‑08; translated to bit‑vectors by Mathias Preiner). It declares four 32‑bit variables x₁,…,x₄ and contains a single top‑level assertion; the problem size is moderate (≈ 12 500 characters, 246 bvmul, 188 bvadd, depth 20).\n\n**Problem structure.** The asserted formula is a quantified alternation **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄** followed by a huge Boolean combination of linear‑arithmetic literals. All arithmetic is expressed as signed comparisons (`bvslt`, `bvsgt`, `bvsge`, `bvsle`) and equalities over expressions of the form “constant · xi + constant · xj + …”.\n\n**Key constraints.** Each branch of the outermost disjunction contains several conjuncts that constrain weighted sums of the variables to be either strictly less than, greater than, or equal to fixed 32‑bit constants (e.g., `bvslt (bvadd (bvmul (bvneg (_ bv53 32)) ?x1) …) (_ bv79 32)`). The let‑binding upfront pre‑computes all products of the four variables with a large set of integer constants (‑100 … 100) to keep the formula size manageable.\n\n**Notable characteristics.** The benchmark is deliberately random yet mimics the shape of redundancy‑checking problems for non‑convex polyhedra: many linear constraints, alternating quantifiers, and a deep nesting of Boolean operators. It is therefore a stress test for BV solvers’ handling of quantified bit‑vector arithmetic and for interpolation‑based techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_59.smt2",
    "description": "- The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic, using three 32‑bit bit‑vectors (`x1`, `x2`, `x3`).  \n- Its formula has an **∃ ?x1 ∀ ?x2 ∃ ?x3** quantifier prefix, and the body is a huge let‑binding that pre‑computes 348 constant‑multiplied terms (e.g., `bvmul (_ bv46 32) ?x3`) before forming a massive Boolean combination of linear equalities and signed inequalities.  \n- All constraints are essentially *linear* (each term is a constant times a variable, possibly negated) but are expressed in full 32‑bit bit‑vector arithmetic, with signed comparisons (`bvsle`, `bvsge`, `bvslt`, `bvsgt`) and equalities linked by dozens of `and`/`or` layers.  \n- The instance originates from the **Preiner‑Scholl 2008** random family (RNDPRE) and is intended to stress SMT solvers’ handling of quantified bit‑vector reasoning, quantifier alternation, and large term graphs (max term depth 21, > 300 multiplications).  \n- With a single top‑level `assert` and about 22 k characters, the benchmark is a typical “hard” random case used to evaluate interpolation and redundancy‑removal techniques in the cited paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_58.smt2",
    "description": "The file is a quantified bit‑vector benchmark in the **BV** logic (32‑bit vectors) that originates from the 2008 SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and was later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08).  It contains three declared constants x1, x2, x3 and a single, large formula of the form  \n\n\\[\n\\exists ?x1\\;\\forall ?x2\\;\\exists ?x3\\;.\\; \\Phi(?x1,?x2,?x3)\n\\]\n\nwhere Φ is a massive conjunction of mixed disjunctions of signed comparisons (bvslt, bvsle, bvsgt, bvsge) and equalities, each built from linear combinations of the three variables with constant integer coefficients (realised as `bvmul` with constant bit‑vectors).  The constraints essentially encode a highly redundant system of linear inequalities over a non‑convex polyhedron, with many “or‑and” nesting, to test a solver’s ability to handle quantified bit‑vector reasoning, quantifier alternation, and a large number of arithmetic terms (≈ 177 multiplications, 110 additions, depth 18).  The benchmark is classified as *random* (size ≈ 10 k characters, 55 ‘and’, 44 ‘or’, 36 ‘=’, 21 ‘bvslt’, 20 ‘bvsgt’) and is used to stress‑test interpolation‑capable SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_46.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) taken from the Scholl et al. 2008 paper on redundant linear constraints in non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner (file RNDPRE_3_46.smt2, size ≈ 6.8 KB, 1 assertion, 3 declared constants). The single top‑level assertion is a quantified formula of the shape **∃ x₁ ∀ x₂ ∃ x₃ …**, where a `let` introduces a large set of pre‑computed linear combinations (constant‑multiplications and negations) of the three variables. Inside the quantified block the body is a massive conjunction of disjunctions of signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equalities, i.e. a collection of linear inequalities over the three 32‑bit variables encoded as bit‑vector arithmetic. The instance therefore checks whether the (non‑convex) polyhedral region described by these constraints is non‑empty, and it is deliberately hard: it features deep terms (depth 18), 120 `bvmul` occurrences, many nested `or`/`and`, and a mixture of positive and negative constant multipliers. It belongs to the “Preiner‑scholl‑smt08” random family and is used to stress‑test SMT solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_31.smt2",
    "description": "The file is a single, large SMT‑LIB 2.6 benchmark in the **BV** (32‑bit signed bit‑vector) logic, taken from the “Preiner‑Scholl smt08” family. It declares four 32‑bit variables x₁…x₄ and asserts one quantified formula that alternates a universal quantifier over x₁, an existential over x₂, another universal over x₃ and a final existential over x₄. Inside the quantifier a `let` block introduces about two hundred temporary terms, each being a product of a constant coefficient (e.g., 90, ‑36) with one of the variables, so that the core of the formula is a massive Boolean combination of linear (in)equalities and equalities built from those products. The outer structure is a disjunction of many conjunctive clauses, each clause containing signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equalities, thus encoding a highly non‑convex polyhedral region over the four variables. The benchmark asks the solver to decide **satisfiability** of this quantified, alternating‑quantifier, linear‑arithmetic‑on‑bitvectors instance, and is intended to stress‑test interpolation‑ and redundancy‑removal techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_54.smt2",
    "description": "The file is a single‑assertion benchmark written in the bit‑vector logic (BV) of SMT‑LIB 2.6, taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (Scholl et al., SMT‑08) and later translated to bit‑vectors by Mathias Preiner; it belongs to the Preiner‑Scholl smt08 random family (file RNDPRE_3_54.smt2, 30 537 characters, 427 bvmul, 426 bvadd, 165 or, 162 and, 124 =).  \n\nThe asserted formula has the shape  \n\n```\n∃x1 . ∀x2 . ∃x3 .  let … in  (big‑disjunction of conjunctive clauses)\n```  \n\nwhere the let‑binding introduces more than two hundred intermediate terms, each of which is a constant‑times‑variable bit‑vector product (e.g., bvmul 45 ?x2).  \n\nEach clause is a conjunction of Signed‑less/greater/equal comparisons (bvslt, bvsle, bvsgt, bvsge) between linear expressions built from those products and constant bit‑vectors; the outermost connective is a disjunction, so the whole formula asks whether there exists a value for x1 such that for every x2 there is an x3 making **at least one** of the large sets of linear inequalities true.  \n\nThus the benchmark encodes a quantified non‑convex polyhedral feasibility problem (the “redundant‑linear‑constraint” setting) expressed entirely in bit‑vector arithmetic, with deep nesting (max term depth 21) and a mixture of positive and negated constants to stress the solver’s handling of quantifiers, arithmetic, and Boolean structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_12.smt2",
    "description": "This benchmark is a single‑sentence BV‑logic query (32‑bit bit‑vectors) extracted from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and later translated to bit‑vectors by Mathias Preiner. It contains three declared variables (x1, x2, x3) and one large quantified formula of the pattern **∃ x₁ ∀ x₂ ∃ x₃ …**, where the inner matrix of constraints is built from linear expressions of the form c·xᵢ + c·xⱼ + c·xₖ + c, using only constant‑coefficient `bvmul`, `bvadd`, and `bvneg`. The constraints are a mixture of signed inequalities (`bvsge`, `bvsle`, `bvslt`, `bvsgt`) and disequalities/equalities, heavily nested under `and`/`or` operators, and include several guarded “or‑of‑conjuncts” that model a non‑convex polyhedral region. With a file size of 3767 characters, a maximum term depth of 16, and 64 multiplication nodes, the instance is deliberately dense and stress‑tests solvers’ handling of quantifier alternation, bit‑vector arithmetic, and large Boolean combinations. It belongs to the “Preiner‑scholl‑smt08” random family, and the sole `check-sat` call asks whether there exists an assignment to the outer existential variable that makes the universally‑quantified inner constraints satisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_66.smt2",
    "description": "**Description**  \nThis benchmark is a single‑assertion quantified bit‑vector formula (logic BV) originating from Scholl et al.’s “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” (SMT‑08) and was later translated to bit‑vectors by Mathias Preiner (file RNDPRE_4_66.smt2, size ≈ 132 kB, 30 levels of nesting). It declares four 32‑bit variables x1, x2, x3, x4 and contains a ∀ x1 ∃ x2 ∀ x3 ∃ x4 prefix followed by a huge let‑bound expression that builds dozens of linear forms of the shape c·xi (· c ∈ {1..100}) and then combines them with addition, equality, and signed inequalities ( bvslt, bvsle, bvsge, bvsgt ). The core of the problem is to decide whether the quantified conjunction of these linear constraints is satisfiable, i.e., whether there exists a choice of x2 and x4 for every x1, x3 that satisfies all the signed‑inequality conditions. The instance is notable for its extreme term explosion (∼3 k bvadd, ∼800 bvmul, ∼800 boolean connectives) and depth 30, making it a stress test for solvers’ handling of quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_5.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Scholl et al. “redundant linear constraints” study and translated to BV by Mathias Preiner; it belongs to the Preiner‑Scholl smt08 family and contains 3 declared constants and a single, heavily quantified assertion. The core formula is a ∃ ?x₁ ∀ ?x₂ ∃ ?x₃ scoped expression that combines several affine constraints of the form *c·?xᵢ + d·?xⱼ + e·?xₖ ⊙ k*, where ⊙ is a comparison (=, <, ≤, ≥, >), using only constant bit‑vector multiplications, additions, and negations. These constraints are glued together with nested conjunctions, disjunctions and negations, producing a non‑convex polyhedral region that must contain a witness for the existential variables under all choices of the universal variable. The benchmark exercises the solver’s handling of quantified linear arithmetic over bit‑vectors, featuring a relatively deep term graph (depth 15) and a high density of bvmul/bvneg operations (31 and 25 occurrences respectively). Its purpose is to check whether the quantified system is satisfiable, i.e., whether the encoded polyhedral constraints are simultaneously realizable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_35.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) that declares four uninterpreted constants `x1…x4`.  The assertion is a quantified formula of the form  \n\n```\n∀x1 ∃x2 ∀x3 ∃x4 .  Φ(x1,x2,x3,x4)\n```  \n\nwhere Φ is a huge conjunction of signed inequalities (`bvslt`, `bvsle`, `bvsgt`, `bvsge`), equalities and disjunctions.  All atomic predicates are built from linear expressions of the shape `c·xi` (encoded with `bvmul` by a constant c) combined with `bvadd` and `bvneg`, so the whole formula represents a massive system of linear constraints over the four variables.  The benchmark originates from the Scholl et al. paper on detecting redundant linear constraints in non‑convex polyhedra and was translated to bit‑vectors by Mathias Preiner; it is classified as “random” in the Preiner‑Scholl smt08 family.  With 10 792 characters, 204 uses of `bvmul`, a maximal term depth of 20 and two alternations of quantifiers, it is a stress test for solvers’ handling of quantified bit‑vector arithmetic and interpolation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_37.smt2",
    "description": "This benchmark is a single BV‑logic formula (32‑bit bit‑vectors) generated for the Preiner‑Scholl “smt08” family; it declares four 32‑bit variables (x1…x4) and contains 4 868 characters with a maximal term depth of 19. The core of the instance is one huge quantified assertion of the shape  \n`∀x1 ∃x2 ∀x3 ∃x4 …`, i.e., a four‑alternation prefix followed by a conjunction of many linear‑arithmetic‑like constraints built from constant‑multiplications, additions, and signed comparisons (bvslt, bvsle, bvsge, bvsgt).  The constraints are expressed as a dense mixture of inequalities, equalities and disequalities, many of them grouped with `and`/`or` and a single `let` that introduces common sub‑expressions.  Conceptually the formula encodes a non‑convex polyhedral region (as in the cited paper on redundant linear constraints) and asks whether there exist choices for the existentially‑quantified variables that satisfy all the signed‑inequality conditions for every choice of the universally‑quantified ones.  The instance is classified as “random” and is used to stress‑test SMT solvers’ handling of deeply nested quantifiers, large numbers of arithmetic operations (87 bvmul, 62 bvadd, 59 bvneg), and the interaction of bit‑vector arithmetic with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_43.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Preiner‑Scholl smt08 collection; it contains three declared constants (x₁, x₂, x₃) and a single massive assertion of size 4671 characters. The formula has a quantifier prefix **∃ x₁ ∀ x₂ ∃ x₃**, and the quantified body is built from a huge conjunct of disjunctive clauses that each combine linear‑integer‑type constraints expressed with bit‑vector multiplication by fixed constants, addition, and signed comparisons (bvslt, bvsle, bvsge, bvsgt). Roughly half of the clauses are simple equalities or disequalities, while the rest are nested conjunctions/or‑structures that relate the three variables through inequalities such as bvadd(bvmul(c₁, x₁), bvmul(c₂, x₂), bvmul(c₃, x₃)) ≶ constant. The instance is labelled “random” and is intended to stress SMT solvers with deep term nesting (max depth 16) and a large number of arithmetic operations (≈80 multiplications, 53 negations, 47 additions). Its purpose is to test the solver’s ability to handle quantified bit‑vector arithmetic and to discover whether there exists an assignment to x₁ and x₃ that satisfies all the intertwined linear constraints for every possible x₂.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_57.smt2",
    "description": "The benchmark is a single‑assertion SMT‑LIB 2.6 problem in the **BV** logic, generated by Mathias Preiner from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08). It declares four 32‑bit bit‑vector variables (**x1…x4**) and contains one quantified formula with a **∀∃∀∃** quantifier pattern, i.e. two alternating blocks of universal and existential quantifiers. Inside the innermost scope a massive conjunction of linear bit‑vector constraints is built from constant‑multiplied terms (≈ 424 `bvmul` occurrences) and additions, combined with inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and many Boolean `and`/`or` branches. The whole formula tests whether there exists a choice of the existential variables for every choice of the universal ones that simultaneously satisfies all these linear inequalities, effectively encoding a highly non‑convex polyhedral feasibility problem. The instance is relatively large (≈ 23 k characters, depth 22) and highly random‑looking, with a single top‑level `assert` and no additional definitions or functions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_54.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) that declares four 32‑bit variables x₁,…,x₄ and contains a single assertion of the form  \n\n  ∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ … .  \n\nInside the quantifier block a massive `let` introduces hundreds of linear terms obtained by multiplying the variables with constant bit‑vectors (e.g., 45·x₂, ‑26·x₁, 33·x₃, …). The body of the assertion is a huge disjunction of conjunctive sub‑formulas that combine equalities and signed (in)equalities ( bvslt, bvsle, bvsgt, bvsge ) over those linear terms together with Boolean operators `and`, `or`, and `not`. The whole formula asks whether, for every choice of the universally quantified variables, the existential variables can be chosen so that this complex Boolean combination of linear arithmetic constraints holds. It originates from the “redundant linear constraints in non‑convex polyhedra” benchmark (Scholl et al., 2008) and has been translated to a random‑looking BV instance (≈ 40 k characters, 39579 nodes, term depth 23) to stress SMT solvers’ quantifier and arithmetic handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_53.smt2",
    "description": "**Basic information.** This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 paper on removing redundant linear constraints; it was automatically translated to bit‑vectors by Mathias Preiner and belongs to the “Preiner‑scholl‑smt08” random family (size ≈ 12 kB, 3 declared constants, 1 top‑level assertion).\n\n**Main structure.** The single assertion is a quantified formula of the shape  \n\\[\n\\exists ?x_1\\;\\forall ?x_2\\;\\exists ?x_3\\;.\\;\\Phi(?x_1,?x_2,?x_3)\n\\]  \nwhere \\(\\Phi\\) is a large Boolean combination (nested **or**/**and**) of linear equalities and signed inequalities over the three 32‑bit variables.\n\n**Key constraints.** Each atomic predicate is a signed comparison (`bvslt`, `bvsle`, `bvsge`, `bvsgt`, or `=`) of a linear expression built with `bvadd` and `bvmul` using constant coefficients (e.g., \\(5·?x_1-16·?x_3 < 34\\)). The whole formula essentially describes a non‑convex polyhedron in the three‑dimensional integer space, encoded as bit‑vector arithmetic.\n\n**Notable characteristics.** The instance contains an unusually high number of arithmetic terms (226 multiplications, 158 additions) and a nesting depth of 19, making the quantifier‑alternation (∃∀∃) and the dense combination of constraints a hard stress test for SMT solvers, especially for interpolation‑based redundancy detection techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_26.smt2",
    "description": "The file is a single‑assertion BV benchmark (logic BV, 3 declared 32‑bit bit‑vector variables, 2 822 characters, 42 bvmul occurrences) taken from the Scholl et al. “SMT08” paper and later translated to bit‑vectors by Mathias Preiner. Its sole assertion is a quantified formula of the shape  \n\n```\n∃x₁ ∀x₂ ∃x₃ .  Φ(x₁,x₂,x₃)\n```  \n\nwhere Φ is a large conjunction of linear bit‑vector inequalities (≤, ≥, <, >) and equalities, all built from additions, multiplications by constant bit‑vectors and negations. The constraints encode a non‑convex polyhedron: they mix upper and lower bounds on affine combinations of the three variables, include several disjunctions (or‑branches) and a few isolated equalities, thus testing the solver’s ability to handle alternating quantifiers together with mixed‑sign arithmetic on 32‑bit words. Because the benchmark was generated randomly (category “random”) but originates from a redundancy‑removal experiment, it features many redundant or contradictory sub‑clauses, making it a stress test for quantifier reasoning and interpolation in bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_27.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 file in the **BV** (32‑bit bit‑vector) logic, originating from the paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” (Scholl et al., SMT‑08) and translated to bit‑vectors by Mathias Preiner. The formula contains four 32‑bit variables (`x1…x4`) and an **alternating quantifier prefix** `∀x1 ∃x2 ∀x3 ∃x4`, making it a classic ∀∃∀∃ search problem. Inside the quantified block a large conjunction of linear‑integer‑like constraints is expressed with `bvadd`, `bvmul` (constant coefficients), `bvneg` and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`), together with a few disjunctions and an equality. The constraints model a system of linear inequalities that arise from the redundancy‑removal task for non‑convex polyhedra; satisfiability asks whether there exists a choice of the existential variables for every universal assignment that fulfills all those inequalities. The instance is relatively small (≈3.3 KB, 53 multiplications, max term depth 17) but dense, with many intertwined linear constraints, making it a challenging benchmark for quantifier‑handling procedures in bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_60.smt2",
    "description": "**Instance overview.**  \nThe file is a 44 KB SMT‑LIB‑2.6 benchmark in the **BV** logic (32‑bit bit‑vectors) that belongs to the *Preiner‑Scholl* random family (RNDPRE) used in the 2008 SMT‑C‑Workshop. It declares three free constants `x1`, `x2`, `x3` and contains a single gigantic assertion of the form  \n\n```\n∃?x1 ∀?x2 ∃?x3 .  (big‑conjunction of linear BV constraints)\n```\n\n**Main structure.**  \nInside the quantifier prefix, a `let` block defines more than five hundred intermediate terms of the shape `bvmul (bvconst k 32) ?xi`, i.e. scaled copies of the three quantified variables. The body then conjoins thousands of linear comparisons (`bvsge`, `bvsle`, `bvslt`, `bvsgt`) and equalities, combined with nested `and`/`or`/`not` operators.\n\n**Key property being checked.**  \nThe solver is asked whether there exists a value for `?x1` such that **for every** possible value of `?x2` one can pick a `?x3` making **all** those scaled linear inequalities simultaneously true. In other words, it tests the satisfiability of a quantified linear‑arithmetic region over 32‑bit bit‑vectors.\n\n**Notable characteristics.**  \nThe benchmark features a deep quantifier alternation (∃ ∀ ∃) together with a high term depth (22) and a dense mixture of multiplication and addition, which makes it a hard case for quantifier‑handling and interpolation techniques. It was originally derived from a non‑convex polyhedron redundancy‑removal experiment and then translated to bit‑vectors, so the constraints, while random‑looking, encode a large set of linear relationships that stress‑test modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_2.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic = BV, 32‑bit bitvectors) translated from a linear‐arithmetic encoding of a non‑convex polyhedron (Scholl et al., SMT‑08) by Mathias Preiner; it is listed in the “Preiner‑scholl‑smt08” random family.  \nIt contains a single quantified assertion of the form **∃ x₁ ∀ x₂ ∃ x₃ · Φ**, where Φ is a Boolean combination of linear equalities and (signed) inequalities over the three variables, each written with bit‑vector arithmetic (bvadd, bvmul, bvneg) and relational operators (bvsge, bvsle, bvslt, bvsgt).  \nThe constraints encode dozens of affine inequalities such as −50·x₁ − 80·x₂ − 86·x₃ ≥ 19, 63·x₂ + 15·x₃ ≠ 69, and disjunctions that mix bounds like −2·x₁ + 50·x₂ ≤ −4 ∨ −92·x₁ − 65·x₂ + 20·x₃ = −4, etc., together with several “or”‑branches that test non‑zero products and further linear relations.  \nThe benchmark therefore checks whether there exists a witness x₁ such that for **all** choices of x₂ a suitable x₃ can be found satisfying this intricate system—a typical formulation used to test interpolation and redundancy detection in SMT solvers.  \nNotably the instance features a quantifier alternation (∃∀∃), a maximum term depth of 14, and a dense use of bit‑vector multiplication and negation (34 bvmul, 24 bvneg), making it a challenging case for solvers that handle quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_52.smt2",
    "description": "This is a single‑assertion benchmark in the SMT‑LIB 2.6 format that uses the **BV** logic (32‑bit bit‑vectors) and belongs to the random “Preiner‑scholl‑smt08” family (file BV/2017‑Preiner‑scholl‑smt08/RNDPRE/RNDPRE_3_52.smt2, size ≈ 40 kB, 3 declared constants x1, x2, x3). The formula is a quantified conjunction of many linear arithmetic‑style constraints: an outer **exists ?x1**, a universal **forall ?x2**, and an inner **exists ?x3**, with all arithmetic expressed as a series of constant‑scaled multiplications (bvmul) and additions (bvadd) followed by signed comparisons (bvslt, bvsle, bvsge, bvsgt) and equalities. The let‑bindings introduce over 400 intermediate products, making the term depth reach 22 and yielding hundreds of occurrences of bvadd (≈ 576), bvmul (≈ 480) and logical connectives (≈ 500). The constraints encode the bit‑vector translation of a system of linear inequalities that arise in the paper’s method for detecting and removing redundant linear constraints from non‑convex polyhedral representations. Structurally, the benchmark stresses an SMT solver’s handling of large numbers of linear bit‑vector terms under alternating quantifiers, without any non‑linear (variable‑variable) multiplications.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_44.smt2",
    "description": "This benchmark is a single‑assertion formula in the **BV** logic (32‑bit bit‑vectors) containing three declared constants `x1`, `x2`, `x3`.  It originates from the 2008 SMT‑Workshop paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and was later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, random category).  The assertion is a quantified Boolean combination: an outer existential over a fresh variable `?x1`, a universal over `?x2`, and a nested existential over `?x3`, with all three variables instantiated in a massive let‑binding that creates over 190 `bvmul` terms (constant·variable) and many summed expressions.  The core of the formula consists of a long disjunction of conjunctive clauses that compare linear combinations of the three variables against constant bit‑vectors using signed relations (`bvsge`, `bvslt`, `bvsgt`, `bvsle`) and a handful of equalities/inequalities, effectively encoding a non‑convex polyhedral feasibility test.  Because of the deep nesting (max term depth 19) and the large number of arithmetic terms (≈135 `bvadd`, 194 `bvmul`), the instance is a stress test for SMT solvers’ ability to handle quantified bit‑vector arithmetic and interpolation‑based redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_16.smt2",
    "description": "The file is a single 4 KB BV‑logic benchmark (logic BV, 32‑bit vectors) taken from the SMT‑08 paper by Scholl et al., translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑scholl‑smt08” random family and contains four declared constants (x1–x4).  \nThe sole assertion is a quantifier block **∀x1 ∃x2 ∀x3 ∃x4** whose body is a massive Boolean combination of linear bit‑vector inequalities (bvslt, bvsle, bvsge, bvsgt) and equalities, all built from constant‑multiplied terms (bvmul with constants) and summed with bvadd.  \nEach conjunct typically states a simple linear bound such as “‑54·x1 + 62·x3 – 53·x4 + 79 < 0” or “51·x1 + 22·x2 – 35·x4 ≤ ‑49”, and the whole formula is true iff for every choice of x1 there exists an x2 that makes the inner ∀∃‑pair satisfy at least one of the many disjuncts.  \nThe benchmark therefore encodes a validity problem for a quantified non‑convex polyhedron: it asks whether the alternating‑quantifier description of a set of linear half‑spaces is universally satisfiable.  \nIts structure is notable for the depth of nesting (max term depth 18), the heavy use of constant multiplications (78 bvmul occurrences) and the dense mixture of ∧/∨/¬, making it a challenging instance for solvers that must handle quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_53.smt2",
    "description": "This benchmark is a single, quantified assertion in the **BV** (32‑bit bit‑vector) logic, taken from the 2008 SMT‑based study of redundant linear constraints in non‑convex polyhedra (Scholl et al., SMT‑08) and translated to bit‑vectors by Mathias Preiner.  The file contains 4 declared constants (x₁…x₄), a doubly‑nested alternation **∀x₁ ∃x₂ ∀x₃ ∃x₄**, and a huge Boolean combination of linear inequalities of the form `bvslt`, `bvsle`, `bvsge`, `bvsgt` over expressions built with **bvmul** (constant coefficients) and **bvadd**.  Roughly 300 multiplications, 250 additions and dozens of relational atoms are glued together by a deep lattice of `and`/`or`/`not` (term depth up to 21), thus encoding a highly non‑convex region that must contain a point for the quantifier prefix to be satisfied.  The goal of the check‑sat query is to decide whether there exists a choice of the existential variables for every universal assignment that meets **all** those linear constraints, i.e., whether the quantified system of bit‑vector linear inequalities is satisfiable.  With about 16 k characters, 1 top‑level assertion and 4 constants, the instance is representative of the “random” family of Preiner‑Scholl benchmarks that stress SMT solvers with large numbers of quantified linear arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_62.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the *BV* logic that declares four 32‑bit bit‑vector variables x1…x4 and then asserts one gigantic quantified formula.  The formula has a ∀ x1 ∃ x2 ∀ x3 ∃ x4 prefix and inside a huge `let` block builds thousands of linear expressions of the form c·xi (with constants c ∈ [0, 100]) which are combined with `bvadd`.  These expressions are then related by a dense mix of signed comparisons (`bvslt`, `bvsle`, `bvsgt`, `bvsge`) and equalities, together with many Boolean `and`/`or`/`not` connectors, forming a complex non‑convex polyhedral region encoded as bit‑vectors.  The benchmark asks whether this quantified conjunction of linear constraints is satisfiable – i.e., whether the encoded region is non‑empty.  It originates from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra’’ paper (Scholl et al., 2008) and was translated to bit‑vectors by Mathias Preiner, making it a challenging random stress test for modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_29.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the Scholl et al. 2008 paper on redundant linear constraints and translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑scholl‑smt08” random family and contains 5 404 characters, 3 declared constants and a single huge assertion.  The assertion is an ∃ x₁ ∀ x₂ ∃ x₃ quantified prefix that wraps a massive conjunction of linear equalities, inequalities and disequalities, each built from additions, multiplications by constant bit‑vectors and negations.  All constraints are essentially affine relations of the form c·xᵢ ± d·xⱼ ± e·xₖ ⪯ k, combined with a rich nesting of ∨ (and ∧) operators, so the problem tests the solver’s ability to reason about quantified linear arithmetic over 32‑bit integers encoded as bit‑vectors.  The formula contains 96 bvmul, 63 bvneg and 57 bvadd occurrences, with a maximum term depth of 16, making it a stress test for quantifier instantiation and arithmetic simplification heuristics.  No additional theory (e.g., arrays or uninterpreted functions) is used, so the focus is purely on quantified bit‑vector arithmetic and the handling of large, “random‑looking” conjunctive‑disjunctive structures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_33.smt2",
    "description": "The file is a 3 KB BV benchmark (logic BV, 32‑bit signed bit‑vectors) taken from the Preiner‑Scholl 2008 suite, which translates a non‑convex polyhedral redundancy problem into bit‑vector arithmetic. It contains three declared constants (x1, x2, x3) and a single top‑level assertion that is a quantified formula of the shape ∃?x1 ∀?x2 ∃?x3 · Φ, where Φ is a large Boolean combination of linear equalities, disequalities and signed inequalities built from constant‑multiplications, additions and negations. All arithmetic terms are of the form c·?xi + c′·?xj + c″·?xk with 32‑bit constants, and the predicates used are bvslt, bvsle, bvsge, bvsgt and =, wrapped in nested `and`, `or`, and `not` operators. The benchmark therefore checks whether there exists a choice of ?x1 such that for every ?x2 there is a ?x3 satisfying this intricate system of linear constraints, i.e., it tests the solver’s handling of mixed quantifiers, bit‑vector arithmetic, and deep term nesting (max depth 16). The instance is labeled “random” and is used to evaluate SMT solvers’ ability to deal with quantified bit‑vector formulas derived from polyhedral reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_20.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) coming from the SMT‑08 paper by Scholl et al., translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑scholl‑smt08” family and contains 3 declared variables and a single large quantified assertion of about 2 KB (2278 characters).  \nThe assertion has three quantifier alternations – ∃x₁ ∀x₂ ∃x₃ – and encodes a conjunction of several disjunctions of linear (affine) constraints, each built from constant‑scaled copies of the variables combined with signed‐comparison operators (bvsge, bvsgt, bvslt) and equalities.  \nAll arithmetic is reduced to bit‑vector multiplication by small constants, addition, and negation, so the constraints represent a non‑convex polyhedral region over the three 32‑bit variables.  \nThe solver is asked to decide whether there exists a value for the outer ∃‑variable such that for every choice of the middle variable there is a suitable inner ∃‑variable satisfying all the mixed inequality/equality clauses.  \nBecause of the deep nesting (max term depth 14) and the alternating quantifiers, the instance is a hard quantified‑BV benchmark used to test interpolation‑based redundancy‑removal techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_55.smt2",
    "description": "**Instance summary** – This SMT‑LIB 2.6 benchmark is a single, large quantified formula in the **BV** logic (32‑bit bit‑vectors). It contains 4 declared bit‑vector constants (x1…x4) and one top‑level assertion that nests two universal quantifiers and two existential quantifiers (∀x₁ ∃x₂ ∀x₃ ∃x₄ …). The formula was generated for the “Preiner‑Scholl 2008” family of random non‑convex‑polyhedron benchmarks (source: Scholl et al., SMT‑08) and has a size of about 51 kB, 93 939 bvadd, 645 bvmul, 501 bvneg occurrences, with a maximum term depth of 24.\n\n**Main structure** – Inside the quantifier block a massive conjunction of linear‑ish constraints is built from many let‑bound terms of the form `bvmul(_ bvC 32) ?xi`, i.e. constant multiples of the four variables. These terms are combined with `bvadd` and compared using signed comparisons (`bvslt`, `bvsle`, `bvsgt`, `bvsge`) or equalities.\n\n**What is being checked** – The solver must decide whether there exists a choice of x₂ for every x₁, and a choice of x₄ for every x₃, such that all the generated linear inequalities and equalities hold simultaneously; in other words, it tests the satisfiability of a highly constrained alternating‑quantifier linear arithmetic problem over 32‑bit bit‑vectors.\n\n**Notable characteristics** – The benchmark is deliberately dense and synthetic: it contains hundreds of distinct constant coefficients (e.g., 31, 47, 33, …) and many redundant or contradictory sub‑constraints, making the quantifier alternation hard for interpolation‑based or quantifier‑instantiation engines. Its random‑style construction, large number of arithmetic operators, and deep nesting of lets make it a stress test for SMT solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_6.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to BV by Mathias Preiner (file RNDPRE_3_6.smt2, 2 386 characters, 1 assertion, 3 declared constants).  \nIt encodes a quantified alternation **∃ x₁ ∀ x₂ ∃ x₃** that combines a large disjunction of conjunctive linear arithmetic constraints over the three bit‑vector variables, where each linear term is built from constant coefficients (e.g., 54, 62, ‑49) multiplied by the quantified variables and summed with constant offsets.  \nThe innermost conjuncts contain mixed signed‑comparison predicates (`bvsge`, `bvslt`, `bvsle`, `bvsgt`) together with equality disequalities (`not (= …)`) and logical connectives, effectively asking whether there exists an assignment to x₁ such that for every x₂ some x₃ can satisfy a non‑convex combination of linear inequalities.  \nBecause the formula is built from many small integer coefficients and deep nesting (max term depth 14) it stresses the solver’s handling of quantifier instantiation, bit‑vector arithmetic, and the interplay of disjunctions and conjunctions.  \nThe instance is classified as “random” in the Preiner‑Scholl‑SMT08 family, highlighting its use as a stress test rather than a domain‑specific benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_68.smt2",
    "description": "This benchmark is a quantified bit‑vector satisfiability problem in the BV logic (32‑bit signed integers) taken from the SMT‑08 paper on redundant linear constraints in non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner. It declares four 32‑bit variables x₁,…,x₄ and asserts a single formula of the form  \n\n```\n∀x₁ ∃x₂ ∀x₃ ∃x₄ .  Φ(x₁,x₂,x₃,x₄)\n```  \n\nwhere Φ is a massive conjunction (and) of linear inequalities (bvslt, bvsle, bvsgt, bvsge) and equalities built from constant‑scaled sums of the variables (bvmul by many constants, both positive and negative, and bvadd). The constraints are essentially a large random system of linear arithmetic relations encoded as bit‑vector operations, with 637 additions, 561 multiplications and 395 negations, reaching a term‑depth of 23. The instance (≈ 37 KB, 4 declared constants, 1 top‑level assert) is used to stress quantifier reasoning and interpolation in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_56.smt2",
    "description": "This benchmark is a single‐assertion SMT‑LIB 2.6 file for the **BV** (32‑bit bit‑vector) logic, taken from the Scholl et al. 2008 paper on redundant linear constraints and translated to bit‑vectors by Mathias Preiner.  The instance is classified as “random” (family Preiner‑scholl‑smt08) and contains 3 declared 32‑bit variables, one quantified formula with an **∃ x₁ ∀ x₂ ∃ x₃** prefix and a huge let‑binding that pre‑computes over 200 constant‑multiplications (bvmul) of the three variables.  Inside the quantifier the body is a massive Boolean combination (≈ 240 or‑clauses, 259 and‑clauses) of linear bit‑vector inequalities (bvslt, bvsle, bvsge, bvsgt) and equalities, essentially a randomly generated conjunctive‑normal‑form encoding of a non‑convex polyhedron.  The whole formula tests whether there exists an x₁ such that for every x₂ there is an x₃ satisfying all those arithmetic constraints; its size (≈ 43 k characters, max term depth 22) makes it a hard stress test for solvers’ quantifier handling and arithmetic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_10.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (`(set-logic BV)`) of size ≈2 KB, taken from the “Preiner‑scholl‑smt08” family that originates in a paper on detecting redundant linear constraints in non‑convex polyhedra. It declares three free 32‑bit variables (`x1`, `x2`, `x3`) but the single top‑level assertion is a quantified formula of the shape  \n\n```\n∃?x1 ∀?x2 ∃?x3 .  Φ(?x1,?x2,?x3)\n```  \n\nwhere `Φ` is a large conjunction of disjunctions built from signed bit‑vector linear inequalities (`bvsge`, `bvsle`, `bvslt`, `bvsgt`) and equalities, each involving linear terms constructed with `bvadd`, `bvmul` and `bvneg`. The constraints encode a non‑convex polyhedral region: they mix several mutually exclusive linear bounds (e.g., “‑94·?x1 + 44·?x3 ≥ ‑62” or “53·?x1 < ‑80”) together with disequalities and additional relational clauses linking the three quantified variables. Because the formula is highly nested (maximum term depth 13) and contains many multiplications (26 occurrences), it stresses the solver’s ability to handle quantified bit‑vector arithmetic and to reason about the interplay of existential and universal quantifiers. The benchmark asks the solver to determine whether any assignment to `?x1` can satisfy the whole quantified block for all possible `?x2`, which is typical of redundancy‑checking problems from the cited research.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_4.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem in SMT‑LIB 2.6 that comes from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08) and was later translated to BV by Mathias Preiner.  It contains three free 32‑bit constants (x1, x2, x3) and a single quantified assertion of the form  \n\n\\[\n\\exists ?x1\\;\\forall ?x2\\;\\exists ?x3\\;.\\; \\Phi(?x1,?x2,?x3)\n\\]\n\nwhere Φ is a Boolean combination of linear signed inequalities (bvslt, bvsgt, bvsge) and equalities built from additions, multiplications and negations of the variables.  The core constraints encode a system of intertwined linear relations (e.g., ‑60·?x1 + 30·?x2 ‑81·?x3 < 49, 76·?x1 + 94·?x2 + 24·?x3 < ‑8, … ) together with some disequalities, forming a non‑convex polyhedral region whose satisfiability is being tested.  The instance is relatively small (≈ 2 kB, 1951 characters) but features a deep term nesting (depth 13) and a heavy use of bvmul/bvneg (over 40 occurrences), making it a challenging case for solvers that must handle quantifiers and bit‑vector arithmetic simultaneously.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_9.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.9 KB, 3 declared constants and a single large assertion) taken from the Scholl et al. “non‑convex polyhedra” case study and translated to bit‑vectors by Mathias Preiner.  It encodes a quantified formula with the pattern **∃ x₁ ∀ x₂ ∃ x₃** that combines several linear‑integer‑style constraints, where each term is a sum of constant‑coefficient products (bvmul) of the three variables.  The outermost disjunction contains two large conjunctive branches; each branch consists of a mixture of inequalities (bvsge, bvsle, bvsgt) and equalities comparing affine combinations to concrete 32‑bit constants (e.g., bvadd … = bv83).  The constraints are essentially a SAT‑style check of whether there exists a choice of x₁ such that for every x₂ one can pick an x₃ making the prescribed polyhedral‑like conditions hold, i.e., it tests the satisfiability of a small non‑convex polyhedral region expressed in BV arithmetic.  Notably, the benchmark features a deep term nesting (depth 13) and a heavy use of constant multiplications and negations, but no uninterpreted functions or arrays, making it a pure arithmetic‑heavy BV instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_52.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic (32‑bit bit‑vectors), taken from the 2008 “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper and automatically translated to bit‑vectors by Mathias Preiner. It contains four uninterpreted 32‑bit constants x₁…x₄ and a quantified formula of the form  \n\n```\n∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄ .  (big conjunction of linear arithmetic constraints)\n```  \n\nwhere the body is built from a massive `let` that pre‑computes 660 `bvmul` terms (constant·variable products) and then combines them with about 960 `bvadd`s, signed comparisons (`bvsge`, `bvslt`, `bvsle`, `bvsgt`), equalities, and Boolean connectives. The overall goal is simply to ask the solver whether this quantified conjunction is satisfiable; the instance is deliberately synthetic and dense, with a depth of 24, 52 KB of text, 4 declared variables, 1 assert, and hundreds of arithmetic sub‑terms to stress quantifier instantiation and arithmetic reasoning. It is classified as a random benchmark in the Preiner‑Scholl 2008 family and is used to evaluate the performance of BV solvers on highly tangled quantified arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_39.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark for the **BV** logic, using three 32‑bit bit‑vector variables (`x1`, `x2`, `x3`).  Its quantifier prefix is **∃ x1 ∀ x2 ∃ x3**, after which a huge conjunctive formula is built from linear expressions of the form *c·xi* (implemented as `bvmul` with constant bit‑vectors) combined with `bvadd` and compared with constants using signed inequalities (`bvsge`, `bvsle`, `bvslt`, `bvsgt`) and equalities.  The constraints together encode a highly fragmented, non‑convex polyhedral region that was originally used to test Craig‑interpolation based redundancy elimination; in the BV encoding they become a dense mixture of about 176 multiplications, 120 negations and dozens of logical connectives.  The benchmark is taken from the “Preiner‑Scholl 2008” family, is classified as “random”, contains 9701 characters, a maximum term depth of 18, and is intended to challenge solvers on quantified bit‑vector reasoning rather than to model a concrete application.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_37.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the Scholl et al. 2008 paper on redundant linear constraints and translated to bit‑vectors by Mathias Preiner (family *Preiner‑scholl‑smt08*).  It declares three 32‑bit variables `x1`, `x2` and `x3` and asserts a quantified formula of the shape  \n\n```\n∃x1 ∀x2 ∃x3 · Φ(x1,x2,x3)\n```  \n\nwhere `Φ` is a large conjunction of linear‑type constraints built from constants multiplied by the variables (`bvmul` with concrete coefficients), summed (`bvadd`), and compared with signed inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) or equalities.  The constraints encode a non‑convex polyhedral region: many of the sub‑clauses are disjunctions of inequality bounds, and several equalities force specific affine combinations to particular constants, reflecting the redundancy‑elimination problem studied in the paper.  The benchmark is relatively small (≈ 3.9 KB, 62 multiplications, maximal term depth 17) but syntactically dense, with a single top‑level `assert` and a mixture of `let`, `or`, and `and` to compact the expression.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_38.smt2",
    "description": "The file is a quantified bit‑vector benchmark in the **BV** logic (32‑bit vectors) with four declared variables `x1…x4`.  It contains a single large assertion that is a **∀∃∀∃**‑quantifier alternation: for every value of the outermost variable there must exist a value for the next one, then for all values of a third variable there must exist a fourth, such that a conjunction of linear‐arithmetic constraints holds.  All constraints are built from constant multiplications, additions and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) together with a few equalities, and they are grouped with `and`/`or` in a nested `let`.  The benchmark originates from Scholl et al.’s 2008 work on detecting redundant linear constraints in non‑convex polyhedra and was translated to bit‑vectors by Mathias Preiner, hence the “random” category and the dense use of 32‑bit arithmetic constants.  With a size of about 2.5 KB, a maximum term depth of 16 and 32 occurrences of `bvmul`, the problem essentially asks whether the quantified linear system over 32‑bit integers is satisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_41.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al., SMT‑08) and was later translated to bit‑vectors by Mathias Preiner.  It contains a single, huge quantified assertion that alternates two universal and two existential quantifiers over four 32‑bit variables (x₁…x₄), and then builds a massive conjunction of linear arithmetic predicates involving only additions, multiplications by constant bit‑vectors and signed comparisons (≤, ≥, <, >).  \n\nThe core problem is to decide whether there exists a choice of the existentially‑bound variables for every choice of the universally‑bound ones such that all of the dozens of linear inequalities and equalities hold simultaneously.  The constraints are essentially a randomly generated but highly redundant set of affine relations (e.g., bvadd(bvmul(const, ?x), …) ≶ bvconst) that mimic the structure of redundant linear constraints in non‑convex polyhedra.  \n\nThe instance is fairly large (≈ 18 k characters, 325 bvmul, 284 bvadd, term depth 21) and showcases a challenging combination of quantifier alternation, many constant multiplications, and deep nesting, which makes it a good stress test for solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_12.smt2",
    "description": "This benchmark is a 32‑bit Bit‑Vector (BV) problem (logic BV) consisting of four free bit‑vector variables x1‑x4 and a single, deeply nested quantified assertion. The formula follows the pattern  \n\n```\n∀x1 ∃x2 ∀x3 ∃x4 . Ψ(x1,x2,x3,x4)\n```  \n\nwhere Ψ is a large Boolean combination of linear arithmetic constraints built from constant‑multiplied variables (e.g., bvmul bv‑constant ?x), additions, and signed comparisons (bvsge, bvslt, bvsgt, bvsle). The constraints encode a mixture of inequalities, disequalities and equalities, often grouped with “and”/“or” and a few “let” bindings to reuse intermediate products, aiming to capture the redundancy‑removal conditions described in Scholl et al.’s paper on non‑convex polyhedra. The instance is labelled “random”, originates from the Preiner‑Scholl smt08 family, and is relatively small (≈4.5 KB, 81 multiplications, depth 18) but syntactically dense, exercising quantifier handling and bit‑vector arithmetic in an SMT solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_50.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic BV) taken from the Preiner‑Scholl SMT‑08 collection; it contains three declared 32‑bit variables and a single, very large quantified assertion that is about 11 k characters long.  The assertion has the quantifier pattern **∃ x₁ ∀ x₂ ∃ x₃** and consists of a gigantic disjunction of conjunctive clauses, each clause being a Boolean combination of linear equalities and signed inequalities of the form bvslt, bvsle, bvsge, bvsgt over expressions that are only additions and multiplications by constant bit‑vectors.  All arithmetic atoms are built from constants (both positive and negative) multiplied by the quantified variables, so the constraints model a system of linear inequalities over the integers, but encoded in the bit‑vector domain with 32‑bit two’s‑complement semantics.  The purpose of the benchmark is to ask whether there is a value for x₁ such that, no matter which x₂ is chosen, one can find an x₃ making at least one of those linear “polyhedral” clauses true—essentially a satisfiability check for a non‑convex polyhedron after translation to bit‑vectors.  The instance is notable for its high density of bvmul (199 occurrences) and deep term nesting (depth 19), making it a hard stress test for solvers’ quantifier handling and bit‑vector arithmetic capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_55.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) that declares three uninterpreted constants `x1`, `x2` and `x3`.  The assertion is a quantified formula of the shape  \n\n```\n∃ ?x1 . ∀ ?x2 . ∃ ?x3 .  φ(?x1,?x2,?x3)\n```  \n\nwhere `φ` is a huge conjunction of linear bit‑vector constraints built from constant multiplications (e.g. `bvmul (_ bv31 32) ?x2`), additions, and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`).  The overall goal is to decide whether there exists a value for the outer existential variable such that **for all** choices of the middle variable an inner existential choice can satisfy the dense network of linear inequalities and equalities – a typical encoding of “redundant linear‑constraint detection” for non‑convex polyhedra.  The benchmark is relatively large (≈ 38 k characters, 554 `bvadd`, 473 `bvmul`, 400 `bvneg` nodes, depth 23) and was generated by Mathias Preiner as part of the Preiner‑Scholl 2008 random family.  It is labelled “random” and is intended to stress SMT solvers’ handling of many quantified bit‑vector arithmetic constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_48.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic **BV**) taken from the Scholl et al. 2008 paper on redundant linear constraints; it was translated to bit‑vectors by Mathias Preiner (family *Preiner‑scholl‑smt08*).  The file contains a single, large quantified assertion of the shape  \n\n```\n∃ ?x1 . ∀ ?x2 . ∃ ?x3 .  Φ(?x1,?x2,?x3)\n```  \n\nwhere Φ is a massive disjunction of conjunctive clauses built from signed linear expressions that are formed with constant‑multiplication ( bvmul ), addition, negation and signed comparisons ( bvslt, bvsle, bvsge, bvsgt ) together with equalities and disequalities.  \n\nThe overall property being checked is whether there exists a value for the first variable such that, no matter which value the universally‑quantified second variable takes, one can pick a third value satisfying **all** of the arithmetic constraints encoded in the disjunction.  In other words, it tests the validity of a quantified non‑convex polyhedral condition over 32‑bit signed integers.  \n\nThe instance is relatively large (≈ 8.5 k characters, 1, 153 bvmul, 104 bvneg, depth 19) and exhibits a dense mixture of linear arithmetic and Boolean structure, making it a stress test for solvers’ handling of quantifier alternations, bit‑vector arithmetic and interpolation‑style reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_16.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (fixed‑size bit‑vector) logic, generated for the SMT‑LIB 2.6 format and taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (SMT‑08).  It is a relatively large instance (≈ 3.5 k characters, 60  bvmul, 34  bvneg, 33  bvadd) with three 32‑bit variables (`x1`, `x2`, `x3`) and a quantifier pattern **∃ x₁ ∀ x₂ ∃ x₃** that nests a sizeable conjunctive‑disjunctive Boolean structure inside a `let`.  \n\nEach conjunct is a linear inequality over the bit‑vectors, expressed as signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) of affine expressions built from constant coefficients multiplied by the quantified variables.  The overall formula asks whether there exists a value for the outer variable such that, for every choice of the middle variable, some inner choice of the last variable can satisfy a complex combination of these linear constraints.  \n\nBecause the constraints originate from a translation of non‑convex polyhedral redundancy checks, the benchmark is deliberately “random” in shape but contains many redundant or contradictory linear relations, making it a challenging test for solvers’ handling of quantified bit‑vector arithmetic and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_51.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** (32‑bit bit‑vector) logic; it declares three 32‑bit variables `x1`, `x2`, `x3` and contains one huge quantified assertion (∃ x1 ∀ x2 ∃ x3 …) whose body is a massive let‑binding of almost five hundred `bvmul` terms (constants 1…100 multiplied by the three variables) followed by a giant disjunction of conjunctive linear constraints.  \n\nAll constraints are signed integer comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and equalities over expressions built from `bvadd`, the pre‑computed products and `bvneg`; essentially the formula asks whether there exist values for x1 such that, for every choice of x2, some x3 can be found to satisfy a complex system of linear inequalities.  \n\nThe benchmark originates from the Scholl et al. (SMT‑08) paper on removing redundant linear constraints in non‑convex polyhedra and was translated to bit‑vectors by Mathias Preiner, which explains the abundance of coefficient‑multiplications and the alternation of quantifiers that mirrors a Σ₂ ∀∃ polyhedral decision problem.  \n\nAlthough labeled “random”, the instance is deliberately dense: it features 549 `bvadd`, 497 `bvmul`, 398 `bvneg`, 221 `or` and 218 `and` operators, a maximum term depth of 20, and a size of about 39 KB, making it a stress test for SMT solvers’ quantifier handling and bit‑vector linear arithmetic capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_40.smt2",
    "description": "**Overview.** This benchmark is a single‑assertion SMT‑LIB 2.6 file in the **BV** logic, taken from the *Preiner‑Scholl* 2008 collection (category “random”). It declares four 32‑bit bit‑vector variables `x1 … x4` and contains one huge quantified formula whose size is about 12 kB (12371 characters, max term depth 20) with 238 `bvmul`, 190 `bvadd` and many signed comparisons.\n\n**Quantifier pattern.** The core of the instance is an alternation **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄** (two universal and two existential binders) that scopes a gigantic conjunctive‑disjunctive matrix of linear constraints.\n\n**Constraint shape.** All constraints are of the form  \n`bvsle / bvslt / bvsge / bvsgt (bvadd …) (bvconst)`  \nor equalities `=` between such linear combinations, where each term is a constant‑scaled variable (e.g., `bvmul (_ bv98 32) x3`). Thus the formula encodes a set of signed linear inequalities over the four variables, essentially a non‑convex polyhedron expressed in bit‑vector arithmetic.\n\n**Purpose.** The benchmark asks whether there exists a strategy for the existential variables (depending on the preceding universal choices) that makes every one of the many linear constraints true; in other words, it tests the solver’s ability to handle deep quantifier alternations, large numbers of arithmetic terms, and signed bit‑vector reasoning.\n\n**Notable features.** The instance is deliberately dense and synthetic: it mixes many `or`/`and` branches, uses a single `let` to share intermediate products, and contains a significant amount of constant negation (`bvneg`). This makes it a stress test for interpolation‑based and quantifier‑instantiation techniques in modern BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_32.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Preiner‑Scholl “RNDPRE” suite (size ≈ 11 k characters, 4 declared constants, 1 top‑level assertion).  The single assertion is a quantified ∀∃∀∃ formula: two outer universal variables (named ?x1, ?x3) and two existential variables (named ?x2, ?x4) range over 32‑bit vectors, and the body is a huge conjunction of linear arithmetic atoms built from constant‑multiplied variables (bvmul with small integer constants) and additions.  All atoms are simple signed comparisons (bvslt, bvsle, bvsge, bvsgt) or equalities, combined with Boolean connectives (and, or, not) and a single let‑binding that materialises the many intermediate products.  The formula encodes a set of linear inequalities that must hold for every choice of the universal variables and some choice of the existential ones – essentially a quantified feasibility check that was used in the paper on detecting redundant linear constraints in non‑convex polyhedra.  Because of the deep nesting (max term depth 19) and the large number of constant multiplications (over 200 bvmul occurrences), the instance is a stress test for solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_50.smt2",
    "description": "The file is a **BV‑logic** benchmark (32‑bit bit‑vectors) extracted from the Scholl et al. 2008 paper on removing redundant linear constraints from non‑convex polyhedra; the original arithmetic was translated to bit‑vector form by Mathias Preiner.  It contains a single quantified assertion of the shape  \n\n\\[\n\\forall x_1\\; \\exists x_2\\; \\forall x_3\\; \\exists x_4\\;.\\; \\Phi(x_1,x_2,x_3,x_4)\n\\]\n\nwhere \\(\\Phi\\) is a massive conjunction of mixed Boolean combinations of **linear‑integer‑like inequalities** ( bvsge, bvsle, bvslt, bvsgt ) and equalities, all built from additions, multiplications by constant 32‑bit coefficients, and negations.  The constraints encode a web of upper‑ and lower‑bound relations among the four variables, often of the form “\\(a\\cdot x_i + b\\cdot x_j + … \\ge 0\\)” or “\\(a\\cdot x_i + b\\cdot x_j \\neq c\\)”.  \n\nThe benchmark is relatively large for a quantified BV problem (about 17 k characters, 324 bvmul, 267 bvadd, maximum term depth 21) and features **four 32‑bit constants**, **two alternations of ∀/∃**, and a dense mixture of ∧/∨ nesting, making it a challenging instance for solvers that handle quantifier instantiation and bit‑vector reasoning.  It is classified as “random” within the Preiner‑Scholl‑smt08 family, but its structure directly mirrors the linear‑constraint redundancy checks described in the cited paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_21.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) with three declared constants x₁, x₂, x₃ and a single quantified assertion of the form  \n\n\\[\n\\exists x₁\\;\\forall x₂\\;\\exists x₃\\;.\\;Φ(x₁,x₂,x₃)\n\\]\n\nwhere Φ is a large Boolean combination (nested “or” and “and”) of signed linear constraints.  All atomic constraints are of the shape \\(bvslt\\), \\(bvsle\\), \\(bvsgt\\), \\(bvsge\\) or \\(=\\) applied to expressions built from constants multiplied by the variables (≈ 95 bvmul and 61 bvadd occurrences) and occasional negations, thus encoding a system of linear inequalities over 32‑bit signed integers.  The benchmark originates from the Scholl et al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra and was translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑scholl‑smt08” family of random benchmarks.  With a size of 5 331 characters, a quantifier alternation depth of 3, and a maximal term depth of 17, the instance tests an SMT solver’s ability to handle heavily nested quantified linear arithmetic in the bit‑vector theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_9.smt2",
    "description": "The file is a 2 251‑character BV benchmark (logic BV, 4 32‑bit bit‑vector variables) taken from the Scholl et al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra, translated to bit‑vectors by Mathias Preiner.  It contains a single, large quantified formula with an alternating quantifier prefix **∀x₁ ∃x₂ ∀x₃ ∃x₄**; the body is a disjunction of several conjunctive blocks that encode linear (in)equalities over the four variables using only `bvadd`, `bvmul` with constant coefficients, and signed comparisons (`bvsge`, `bvsle`, `bvsgt`).  The first block requires a signed‑greater‑or‑equal constraint on a linear combination of the variables together with a nested “or” that forces either a zero‑product condition, a specific equality, or a pair of equalities on other linear combinations.  The remaining blocks express additional bounds (e.g., a signed‑less‑equal inequality and an equality to a constant) and a mixed condition consisting of an equality or a conjunction of a strict positivity test and a disequality.  Overall the benchmark checks whether there exists an assignment to the existential variables that can satisfy at least one of these linear‑arithmetic cases for every universal choice, i.e., it tests the satisfiability of a quantified non‑convex polyhedral region encoded in 32‑bit bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_30.smt2",
    "description": "This benchmark is a single, quantified bit‑vector formula in the **BV** logic (32‑bit vectors) generated for the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and later translated to bit‑vectors by Mathias Preiner.  The file (≈ 7 KB, 6915 characters) declares four 32‑bit constants x₁…x₄ and asserts one massive predicate of the shape  \n\n\\[\n\\forall x_1\\;\\exists x_2\\;\\forall x_3\\;\\exists x_4\\;.\\; \\Phi(x_1,x_2,x_3,x_4),\n\\]\n\nwhere Φ is a conjunction of dozens of linear (in)equalities and equalities built from `bvadd`, `bvmul` with small integer coefficients, `bvneg`, and signed comparisons (`bvsle`, `bvslt`, `bvsgt`, `bvsge`).  The constraints essentially encode a system of mixed‑sign linear inequalities over the four variables, testing whether there exists a strategy for the existential variables that satisfies all the guarded arithmetic conditions for every choice of the universal variables.  The benchmark is classified as *random* (family Preiner‑scholl‑smt08), contains 132 `bvmul` and 95 `bvadd` nodes, has a maximum term depth of 18, and is intended to stress solvers’ handling of nested quantifiers, large linear arithmetic fragments, and quantifier‑alternation reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_30.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Scholl et al. 2008 paper on redundant linear constraints, later translated to bit‑vectors by Mathias Preiner.  It contains three declared bit‑vector constants (x1, x2, x3) that are not used directly; instead the formula works with three quantified variables ?x1, ?x2, ?x3.  \n\nThe single assertion is a quantified sentence of the form  \n\n\\[\n\\exists ?x1\\; \\forall ?x2\\; \\exists ?x3\\;.\\; \\Phi(?x1,?x2,?x3)\n\\]\n\nwhere Φ is a large disjunction of conjunctions of linear bit‑vector equalities and strict/ non‑strict inequalities, all built from constant multiplications, additions and negations.  In effect the benchmark encodes a non‑convex polyhedron in 3‑dimensional integer space and asks whether a “winning” assignment for ?x1 exists such that, no matter which ?x2 is chosen, a suitable ?x3 can be found to satisfy at least one of the polyhedral clauses.  \n\nThe instance is relatively small (≈3.4 kB, 1 top‑level assert, 3 declarations) but structurally dense: it contains 54 bvmul, 44 bvneg and 29 bvadd occurrences, with a maximum term depth of 16 and three quantifier alternations, making it a good stress test for BV quantifier handling and interpolation techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_4.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the “Preiner‑Scholl‑SMT08” family (size ≈ 2.3 KB, 4 declared constants, one huge quantified assertion).  It encodes a four‑alternation quantified formula  \n\\[\n\\forall x_1\\; \\exists x_2\\; \\forall x_3\\; \\exists x_4\\;.\\; \\Phi(x_1,x_2,x_3,x_4)\n\\]  \nwhere \\(\\Phi\\) is a Boolean combination of linear signed‑bit‑vector constraints built from additions, multiplications by constant coefficients (encoded with `bvmul`) and comparisons (`bvslt`, `bvsgt`, `bvsge`, equality).  The inner matrix \\(\\Phi\\) consists of several conjunctive clauses and disjunctions that require certain affine expressions to be below or above constant bounds, together with a few equalities and disequalities, modelling a non‑convex polyhedral region.  The benchmark thus asks whether the quantified statement is satisfiable – i.e. whether there exists a strategy for the existential variables that guarantees the linear constraints hold for every choice of the universal variables.  It originates from a paper on using SMT and Craig interpolation to detect redundant linear constraints, and was translated to bit‑vectors by Mathias Preiner.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_33.smt2",
    "description": "This file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** (32‑bit bit‑vector) logic, originating from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra’’ paper and later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08).  It contains four declared 32‑bit variables and one huge quantified formula with the pattern **∀ x₁ ∃ x₂ ∀ x₃ ∃ x₄**, i.e. a four‑alternation quantifier block of depth 4 and term depth 17.  Inside the quantifiers the formula is a massive Boolean combination of linear (signed) inequalities and equalities such as  \n`bvslt(bvadd(bvmul 91·x₁, …), 34)` and `bvsge(bvadd(bvmul –88·x₁, …), 88)`, together with many constant multiplications, additions and two’s‑complement negations (62 bvmul, 41 bvadd, 32 bvneg).  The overall constraint asks whether, for every choice of x₁, there exists an x₂ such that for all x₃ there exists an x₄ making the disjunction of these linear conditions true; thus the benchmark checks the satisfiability of a quantified linear‑arithmetic‑style problem encoded in pure bit‑vector arithmetic.  At 3 583 characters and 1 assertion, it is a relatively large, randomly generated instance meant to stress solvers’ handling of quantified BV arithmetic and quantifier alternation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_2.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (Logic BV) that declares four 32‑bit variables x1…x4 and contains a single, large quantified assertion of size 2776 characters. The formula has two alternating quantifier blocks (∀ x1 ∃ x2 ∀ x3 ∃ x4) and encodes a system of linear‑like constraints formed with constant‑coefficient multiplications, additions, and signed comparisons (bvsge, bvsle, bvslt, bvsgt). The constraints are combined with Boolean connectives (and, or, not) and essentially ask whether there exists a choice of the existential variables making all the linear inequalities and disequalities hold for every choice of the universal variables. It originates from the Scholl et al. 2008 paper on using SMT and Craig interpolation to detect redundant linear constraints in non‑convex polyhedra, and was translated to bit‑vectors by Mathias Preiner. The instance is classified as “random” in the Preiner‑Scholl SMT08 family and features a relatively deep term nesting (max depth 16) with 44 bvmul and 30 bvadd occurrences.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_59.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (Scholl et al., SMT‑08) and was later translated to bit‑vectors by Mathias Preiner.  It consists of a single quantified assertion of the form  \n\n```\n∀x₁ ∃x₂ ∀x₃ ∃x₄ · ϕ(x₁,x₂,x₃,x₄)\n```  \n\nwhere ϕ is a huge Boolean combination of linear bit‑vector equalities, inequalities (bvsle, bvsge, bvsgt, bvslt) and arithmetic expressions built from bvadd, bvmul and bvneg.  The formula encodes a gigantic system of linear constraints that model a non‑convex polyhedron; the alternating quantifiers are used to express a reachability‑style property (for every choice of x₁ there exists an x₂ … such that all the linear relations hold).  With 4 declared 32‑bit variables, about 30 k characters, 506 bvadd, 484 bvmul and a maximum term depth of 23, the instance is a stress test for quantified‑BV solvers, exercising both arithmetic reasoning and quantifier‑instantiation heuristics.  The benchmark asks the solver to decide SAT/UNSAT for this quantified conjunction/disjunction hierarchy, and it is classified as a “random” BV benchmark in the Preiner‑Scholl 2008 family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_58.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit signed bit‑vectors) that originates from the 2008 SMT‑08 paper of Scholl, Disch, … and was later translated to bit‑vectors by Mathias Preiner.  \nIt contains four quantified variables x₁,…,x₄ with the quantifier prefix **∀x₁ ∃x₂ ∀x₃ ∃x₄**, and the body is a huge conjunction of linear expressions built from constant‑multiplications (bvmul), additions (bvadd) and signed comparisons (bvslt, bvsle, bvsgt, bvsge) together with equalities and negations.  \nAll arithmetic terms are pre‑computed in a single `let`‑binding, resulting in 241 `bvmul` and 180 `bvadd` occurrences, and the constraints are mixed with many `and`/`or` combinations, forming a dense, non‑convex polyhedral condition over the four 32‑bit integers.  \nThe benchmark asks whether there exists a witness for the existential variables that satisfies **all** those signed inequalities and equalities for **every** choice of the universal variables – i.e. it checks the satisfiability of a highly constrained quantified bit‑vector formula.  \nWith 12 626 characters, 4 declared constants, a quantifier alternation depth of 2 and a maximum term depth of 20, it is a typical “random” yet deliberately intricate instance from the Preiner‑Scholl SMT08 family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_35.smt2",
    "description": "This file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) containing three declared constants `x1`, `x2`, `x3`.  The core formula is an **exists‑forall‑exists** pattern:  \n∃ x₁ ∀ x₂ ∃ x₃ ⋀ C, where C is a large conjunction of linear‐arithmetical constraints built from constant‑scaled multiplications (`bvmul`), additions (`bvadd`), signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) and a handful of disequalities.  The constraints encode a highly tangled system of inequalities that originates from the redundancy‑removal problem for non‑convex polyhedra, but have been mechanically translated into bit‑vector arithmetic, yielding 152 multiplications, 118 negations and a nesting depth of 18.  The benchmark is classified as “random” in the Preiner‑Scholl SMT08 family, has about 8 KB of text, 1 top‑level assertion, and is designed to stress solvers’ quantifier handling, bit‑vector arithmetic, and Boolean combination optimisations.  Its size (8422 characters, 45 `and`s, 32 `or`s) and the dense mixture of linear and non‑linear‑looking terms make it a particularly challenging case for interpolation‑based or model‑finding approaches.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_4_49.smt2",
    "description": "**Overview** – The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** (32‑bit bit‑vector) logic, generated by Mathias Preiner from the “scholl‑smt08” suite. It contains 4 declared constants, about 13 800 characters, 267 `bvmul`, 210 `bvadd` and a total of 58 `or`‑branches, with a maximal term depth of 20.\n\n**Structure** – The core formula is a quantified matrix  \n\\[\n\\forall x_{1}\\; \\exists x_{2}\\; \\forall x_{3}\\; \\exists x_{4}\\;.\\; \\Phi(x_{1},x_{2},x_{3},x_{4}),\n\\]  \nwhere `Φ` is a huge disjunction of conjunctions of linear (in)equalities built from additions, multiplications by constant bit‑vectors and signed comparisons (`bvslt`, `bvsle`, `bvsge`, `bvsgt`).\n\n**Key constraints** – Each conjunct is essentially a **linear inequality** of the form  \n\\(c_{1}\\*x_{i}+c_{2}\\*x_{j}+…\\; \\bowtie\\; k\\) (with `k` a concrete 32‑bit constant and \\(\\bowtie\\) a signed `<, ≤, ≥, >` or equality). The constants `c` range from −100 to +100, and many of the conjuncts also include equalities to zero or to other constants. The whole `Φ` is a big “or‑of‑and”‑pattern, so the quantified statement asks whether **every** choice of `x₁` can be matched by some `x₂`, **every** `x₃` can be matched by some `x₄` so that *at least one* of these linear clusters holds.\n\n**Purpose / characteristics** – The benchmark originates from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”*; after translation to bit‑vectors it serves as a stress test for quantifier handling and arithmetic simplification in BV solvers. Its random‑looking coefficients, heavy use of `bvmul` with constants, and deep nesting of quantifiers make it a particularly challenging instance for solvers that rely on instantiation or quantifier elimination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_34.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the SMT‑08 paper by Scholl, Disch, Pigorsch and Kupferschmid, later translated to bit‑vectors by Mathias Preiner. It contains three free 32‑bit variables x1, x2, x3 and a single quantified assertion of the form  \n\n\\[\n\\exists x_1\\;\\forall x_2\\;\\exists x_3\\;.\\; \\Phi(x_1,x_2,x_3),\n\\]\n\nwhere Φ is a large conjunction/disjunction of linear equalities and inequalities built from constant‑multiplied variables (bvmul with many different coefficients), additions, and signed comparisons (bvslt, bvsle, bvsge, bvsgt). The core of the formula encodes a tangled set of linear constraints that model a non‑convex polyhedral region; the quantifier alternation checks whether there is a choice of x1 that forces, for every x2, some x3 satisfying all those bounds. With 6 931 characters, 130 bvmul occurrences, a maximum term depth of 17 and 30 or/and connectives, the instance is deliberately “random” and highly non‑trivial for solvers that handle quantified bit‑vector arithmetic. It is used to stress‑test interpolation‑based and quantifier‑instantiation techniques on complex quantified BV formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/RNDPRE/RNDPRE_3_17.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) that originates from the SMT‑08 paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, subsequently translated to bit‑vectors by Mathias Preiner.  It contains three declared 32‑bit constants x1, x2, x3 (which are not used directly) and a single large quantified assertion of the form ∃ ?x1 ∀ ?x2 ∃ ?x3 …; the quantifier alternation (∃∀∃) makes the formula non‑quantifier‑free.  Inside the body the constraints are linear combinations of the quantified variables built with constant multiplications (bvmul) and additions (bvadd), together with signed inequalities (bvslt, bvsle) and a few equalities, all compared against concrete 32‑bit constants.  The structure is essentially a conjunction of several disjunctive (or) and conjunctive (and) linear inequalities, some of which are wrapped in a let‑binding to reuse a common term.  At 1 assert, 3 declared constants, 20 multiplications, a maximum term depth of 15 and a total size of 1 781 characters, the instance is a small but heavily quantified random‑looking BV formula that exercises the solver’s handling of quantified linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_42.smt2",
    "description": "The file is a single‑assertion benchmark written in the BV (32‑bit bit‑vector) logic, taken from the industrial “Preiner‑scholl‑smt08” suite (108 KB, 10 declared constants, 1 108‑deep term, 326 ∧, 274 ¬). It models a set of linear inequalities over the 32‑bit variables λ, λ′, x₃ and x₄ together with a collection of Boolean flags (bool.b17 … bool.b24) that encode the presence or removal of individual linear constraints in a non‑convex polyhedral representation. The core formula consists of a universal quantifier over a fresh λ and an existential quantifier over λ′, wrapped in a huge cascade of let‑bindings that combine many bvsle, bvslt, bvmul, bvadd and division constraints with intricate Boolean combinations, essentially asking whether there exists a value of λ (and a λ′ in the interval [0,λ]) that satisfies all the encoded bounds. Satisfiability of the whole assertion corresponds to the existence of a consistent assignment to the Boolean “redundancy” flags and the numeric variables, i.e., that no contradictory linear constraint remains after the intended redundancy elimination. The instance is notable for its extreme nesting depth (max term depth 112) and the sheer number of logical connectives, which makes it a stress test for bit‑vector solvers and for techniques such as Craig interpolation used in redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_5.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Scholl et al. SMT‑08 paper on eliminating redundant linear constraints in non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner and belongs to the “industrial” Preiner‑Scholl‑SMT08 family (≈1.7 KB, 1 assertion, 6 declared symbols). The sole assertion is a quantified formula that universally quantifies a 32‑bit variable λ and then splits into a disjunction of three parts: (i) an existentially quantified λ′ together with a conjunction of signed‑linear inequalities built from the two problem parameters x₃ and x₄, (ii) the simple bound λ < 0, and (iii) the negation of a conjunction of two mixed arithmetic‑Boolean conditions. The arithmetic constraints express bounds such as  \n\n  0 ≤ x₃ − 3·λ′ ≤ 45, 0 ≤ x₄ + 20·λ′ ≤ 4820  \n\nand additional “large‑negative” limits (‑4100, ‑4500, ‑4910) guarded by Boolean flags bool.b20 … bool.b19, modelling the presence or redundancy of particular linear inequalities. Hence the benchmark checks whether, for every λ, either a suitable λ′ exists respecting all guarded inequalities, λ is negative, or the guarded conjunction is violated—exactly the logical condition used to detect redundant constraints in the original polyhedral representation. Notable features are the deep nesting of quantifiers (forall–exists), extensive use of let‑bindings, and a high term‑depth (19), which make the instance a demanding test for BV‑solvers handling quantified arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_17.smt2",
    "description": "This benchmark is a BV‑logic instance (32‑bit bit‑vectors) from the Scholl et al. “Using an SMT Solver and Craig Interpolation …” paper (SMT‑08), translated to bit‑vectors by Mathias Preiner (file BV/2017‑Preiner‑scholl‑smt08/model_6_17.smt2, 2 485 characters, 12 declared constants, 1 top‑level assertion). The formula contains a single quantifier‑rich assertion: a universal ∀ λ over a 32‑bit variable and, inside it, an existential ∃ λ′ together with a network of Boolean flags (bool.b5, bool.b7, …) that guard several linear arithmetic constraints. The arithmetic constraints are simple BV‑linear inequalities (bvsle, bvslt, bvsle of expressions such as λ′, λ, x₄ + 30·λ′, x₅ + λ, etc.) combined with multiplications by –1 and constant bounds like ‑4100, ‑4500, ‑4910, ‑10 and 4820. The overall check asks whether the mixed Boolean‑arithmetic condition can hold for any λ, i.e., it encodes a redundancy‑detection problem for non‑convex polyhedral constraints. Notably, the instance features deep nesting (max term depth 29) and a high density of logical connectives (≈38 and, 35 not), making it a challenging industrial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_15.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner. It contains a single, highly‑nested quantified assertion (one ∀ over λ and one ∃ over λ′) that combines linear‑inequality‑style constraints—expressed with `bvmul`, `bvadd`, `bvsle`, `bvslt`, and `bvsdiv`—with a handful of Boolean flags (`bool.b22`, `bool.b7`, `bool.b5`, `bool.b6`). The core property being checked is whether there exists a λ′ within the interval [0, λ] such that a set of scaled and shifted versions of the constants x3, x4, x5 satisfy several signed‑less‑equal and signed‑less‑than relations, while simultaneously respecting a specific Boolean combination that encodes the presence or absence of certain linear constraints. The formula is essentially a reductive test for the redundancy of those constraints: it is unsatisfiable exactly when the Boolean combination forces an impossible conjunction of the arithmetic inequalities. The instance is relatively large for a BV benchmark (≈ 1.9 k characters, 7 declared constants, max term depth 19) and exhibits a deep nesting of `and`, `or`, and `not`, making it a challenging case for solvers that handle quantifiers and mixed arithmetic‑logic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_12.smt2",
    "description": "The file is a single‑assertion benchmark in the quantifier‑rich bit‑vector logic (BV) coming from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (SMT‑08), translated to bit‑vectors by Mathias Preiner.  It contains 7 declared constants (four 32‑bit vectors λ, λ′, x₃, x₄, x₅ and three Booleans) and one quantified formula that universally ranges over a 32‑bit variable λ and existentially over a 32‑bit λ′.  Inside the formula a series of linear‑inequality constraints (expressed with `bvsle`, `bvslt`, `bvadd`, `bvmul`, and `bvneg`) bound the values of the vectors and relate them to the Boolean flags, effectively encoding a non‑convex polyhedral region together with several optional linear constraints.  The core property being checked is whether, for every λ, there exists a λ′ satisfying a chain of nested “or‑not‑and” conditions that correspond to the presence or absence of redundant constraints; the outermost disjunction also tests a simple lower‑bound violation (`bvslt ?lambda 0`).  At 1855 characters, a depth of 19, and 22 occurrences of `and`, the instance is a small yet highly structured industrial example that stresses quantified reasoning and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_67.smt2",
    "description": "This benchmark is a single, large‑scale SMT‑LIB 2.6 query in the **BV** (32‑bit bit‑vector) logic, taken from the Scholl et al. 2008 paper on removing redundant linear constraints from non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner.  It declares twelve 32‑bit variables (one “λ”, one “λ′” and three auxiliary “x” parameters) together with eight Boolean flags (bool.b7 … bool.b23) and then asserts one massive quantified formula.  \n\nThe formula contains a universal quantifier over **λ** and an existential quantifier over **λ′**, and it builds a forest of nested `let`‑bindings that combine signed‑bit‑vector additions, multiplications and divisions with a dense Boolean network of `and`, `or` and `not`.  The arithmetic part encodes a collection of linear inequalities of the form  \n`bvsle (linear‑combination of x3, x4, x5, λ, λ′) const`  \n(e.g. “≤ 1150”, “≤ 30”, “≥ ‑10”, etc.), while the Boolean flags act as selectors that turn individual constraints on or off.  \n\nThe overall check is whether there exists a non‑negative λ (and a λ′ bounded by λ) such that **all** selected linear bounds can be satisfied simultaneously; in other words, the instance tests the consistency of a highly interdependent set of signed‑integer constraints that arise from a polyhedral redundancy‑removal problem.  \n\nWith 6137 characters, 130 `and`s, 127 `not`s, and a maximum term depth of 54, the benchmark exemplifies an industrial‑style, heavily nested encoding of a combinatorial arithmetic verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_9.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of moderate size (≈1.6 KB, 1 quantified assertion, 5 declared constants) taken from the Scholl et al. “Detect and Remove Redundant Linear Constraints in Non‑Convex Polyhedra” paper and translated to bit‑vectors by Mathias Preiner.  \nIt encodes a single quantified formula that models a segment of a non‑convex polyhedral description: a universal quantifier over a parameter λ and an inner existential quantifier over λ′, together with three auxiliary Boolean flags (bool.b17, bool.b18, bool.b19) that can enable or disable three different linear inequalities.  \nThe core constraints are linear inequalities expressed with signed‑less‑equal (bvsle) and signed‑less‑than (bvslt) over expressions of the form x₃ + (−1/20)·λ and x₄ + 40·λ, together with bounds on λ and λ′ (0 ≤ λ′ ≤ λ).  \nThe outer disjunction ensures that either the existential block (which also checks that the three guarded inequalities are not violated) holds for all λ, or λ is negative, or a combined inequality involving both x₃ and x₄ fails; the solver is asked simply to decide satisfiability of this whole condition.  \nThus the benchmark tests an SMT solver’s ability to handle mixed universal/existential quantification, bit‑vector arithmetic, and branching Boolean guards that arise when checking redundancy of linear constraints in a non‑convex polyhedral model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_39.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, coming from the 2008 SMT‑08 paper on removing redundant linear constraints in non‑convex polyhedra (translated to bit‑vectors by Mathias Preiner).  It declares ten constants (two 32‑bit variables x3, x4 and a handful of Boolean flags bool.b20 … bool.b24) and contains one quantified formula that mixes a universal quantifier over a parameter λ and an existential quantifier over λ′.  Inside the quantifiers a dense network of `and`, `or`, and `not` combines dozens of linear bit‑vector inequalities (e.g., `bvsle`, `bvslt`, `bvmul`, `bvadd`, `bvsdiv`) that encode the original linear constraints and their possible redundancy.  The solver is asked whether the whole conjunction of these Boolean‑guarded arithmetic conditions is satisfiable; essentially the instance checks consistency of a large, tightly interwoven set of linear bounds after they have been transformed into bit‑vector form.  With 14 254 tokens, a maximum term depth of 142, and hundreds of Boolean connectives, the benchmark is a stress test for BV solvers on industrial‑style, highly redundant constraint systems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_56.smt2",
    "description": "The benchmark is an industrial‑style BV (32‑bit signed bit‑vector) instance translated from the “redundant linear constraints in non‑convex polyhedra’’ paper (Preiner 2008). It declares three integer coefficients `x3`, `x4`, `x5`, two integer parameters `λ` and `λ′`, and a handful of Boolean flags that selectively enable individual linear constraints. The single top‑level assertion contains a universal quantifier over `λ` and, inside a large disjunction, an existential quantifier over `λ′` together with a conjunction of many signed inequalities (`bvsle`, `bvslt`) that encode bounds such as `0 ≤ λ′ ≤ λ`, `x3 + (‑1/5)·λ ≤ 30`, `x4 + 20·λ′ ≤ 4820`, `x5 + λ′ ≥ –10`, etc.; the Booleans appear only in negated form and therefore act as “constraint‑removal’’ selectors. The overall formula asks whether there exists a valuation of the integers and Booleans that satisfies all these piecewise linear constraints, i.e., whether the modeled non‑convex polyhedral region is non‑empty. Notable characteristics are the mixed universal/existential quantification, deep let‑binding nesting (term depth 42), and a very dense use of Boolean negations, making it a challenging benchmark for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_11.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, industrial category, 1 638 bytes, 1 assertion, 5 declared constants, max term depth 17).  \nThe sole assertion is a universally quantified formula over a bit‑vector λ, which contains an existentially quantified auxiliary variable λ′ and a `let`‑binding for a Boolean sub‑expression.  \nThe core of the constraint forces λ′ to lie between 0 and λ and then checks three guarded conditions (controlled by the Booleans bool.b17, bool.b18, bool.b19) that a certain inequality involving `x3`, `x4`, λ′, and large negative constants (‑20, ‑4100, ‑4500, ‑4910) does **not** hold.  \nIf λ is non‑negative, the formula requires that either λ < 0 (which is impossible) or that a final conjunct—negating a pair of linear inequalities on `x3+λ` and `x4+20·λ` against the constants 0 and 4820—holds.  \nThus the benchmark encodes a quantified consistency check for a set of piecewise linear (non‑convex) constraints translated into bit‑vector arithmetic, with many nested negations and a relatively deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_47.smt2",
    "description": "This benchmark is a single‑assertion BV problem (32‑bit vectors) taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper and translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08, size ≈ 2.9 KB, 12 declared constants and 41 ∧‑nodes). The assertion universally quantifies a parameter λ and combines three large disjuncts: (i) an existential sub‑formula that searches for a λ′ bounded between 0 and λ and satisfying a collection of scaled linear inequalities involving the other variables x3, x4, x5 and several Boolean control flags (bool.b5…bool.b23); (ii) a simple guard λ < 0; and (iii) a massive negated conjunction that encodes the main safety property, i.e. a conjunction of signed‑less‑or‑equal constraints (e.g., λ·40 + x4 ≤ 0, x3 + λ/2 ≤ 20, x5 + λ ≥ ‑10) gated by the same Boolean flags. The Boolean variables act as switches that enable or disable particular linear constraints, thereby modeling the redundancy‑removal conditions of a non‑convex polyhedral representation. Because the formula mixes quantifiers, arithmetic with non‑trivial coefficients, and deeply nested Boolean structure (max term depth 22), it serves as a challenging industrial benchmark for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_52.smt2",
    "description": "The file is a single‑assertion BV benchmark (logic = BV) of moderate size (≈ 4 k characters, 12 declared constants, 68 ∧, 59 ¬, 23 bvsle) taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper (SMT‑08, industrial category, translated to bit‑vectors by Mathias Preiner).  \nIt models a family of linear constraints over three 32‑bit integer variables x3, x4, x5 together with two quantified parameters λ (universal) and λ′ (existential), and a set of Boolean flags (bool.b5,…,bool.b23) that select which constraints are active.  \nThe core of the assertion is a massive conjunction of bounded linear expressions—e.g., bvsle (bvadd x3 – λ, bvconst), bvsle (bvadd x4 + 60·λ, bvconst), bvsle (bvadd x5 + λ, bvconst)—combined with divisional terms (bvsdiv 3 20, bvsdiv 3 40) and negated upper‑bounds, all nested inside a series of let‑bindings for readability.  \nAn outer universal quantifier requires that, for every λ, either a complex Boolean combination of the flags and arithmetic bounds holds, or a simpler condition (bvslt λ 0) is satisfied; similarly, an inner existential quantifier over λ′ enforces additional range checks (0 ≤ λ′ ≤ λ) together with further flag‑dependent inequalities.  \nThus the benchmark checks the satisfiability of a highly intertwined mix of quantified bit‑vector arithmetic and Boolean control variables, representing the verification that no redundant linear constraint remains in the encoded non‑convex polyhedral model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_26.smt2",
    "description": "This benchmark is a single‑assertion BV problem (logic BV) originating from the Scholl et al. 2008 paper on removing redundant linear constraints from non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner (file model_6_26.smt2, 2 618 bytes, 12 declared constants). The formula contains a universal quantifier over a 32‑bit variable λ and an inner existential quantifier over λ′, together with a handful of Boolean flag variables (bool.b5, bool.b6, …) that encode the presence or absence of specific linear constraints. Inside the quantified block the core property is a conjunction of signed‑bit‑vector inequalities such as  \n\n```\n0 ≤ λ′ ≤ λ,\n¬( λ′·(x3 + (−1/5)·λ′) ≤ 40 ),\n¬( λ′·(x3 + (−1/5)·λ′) ≤ 33 ),\n¬( λ′·(x4 + 60·λ′) ≤ –4100 ),\n…\n```  \n\ncombined with Boolean conditions that require certain flags to be true or false. Thus the instance asks whether there exists a λ (and a suitable λ′) satisfying a complex mix of linear‑inequality constraints and Boolean‑logic conditions, effectively testing the solver’s ability to handle quantified bit‑vector arithmetic and redundancy‑detection reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_31.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (2510 characters, 12 declared constants, 1 quantified assertion) taken from the Scholl et al. 2008 paper on removing redundant linear constraints in non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner and classified as an industrial instance.  \nThe sole assertion is a universally quantified formula over a 32‑bit variable **λ**, which contains an inner existential quantifier over **λ′** and a large conjunction of bit‑vector linear inequalities that relate **λ**, **λ′** with the three integer parameters **x3**, **x4**, **x5** and a handful of Boolean control flags (bool.b5 … bool.b23).  \nThe constraints enforce lower and upper bounds on **λ′** (0 ≤ λ′ ≤ λ) and encode several affine expressions such as  \n bvadd x4 + 40·λ′, bvadd x3 + (½)·λ′, bvadd x5 + λ′,  \nwhich are multiplied by –1 and compared with constant limits (e.g., –4100, –4500, –4910, –30, –10) using signed‑less‑or‑equal (bvsle) and signed‑less‑than (bvslt).  \nThe Boolean literals act as “guards” that switch different subsets of these inequalities on or off, effectively modelling the detection of redundant linear constraints via Craig interpolation.  \nBecause the formula mixes deep nesting of quantifiers, many Boolean auxiliaries, and non‑trivial bit‑vector arithmetic, it is a typical hard case for BV solvers handling industrial‑scale polyhedral reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_22.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) from the industrial suite *Preiner‑scholl‑smt08* (see Scholl et al., SMT‑08), translated to bit‑vectors by Mathias Preiner; it contains 9 declared constants (four BV variables and five Bool flags), a quantifier depth of two (a universal ∀ λ and an existential ∃ λ′) and about 3 kB of text (2920 characters, 50 ∧, 52 ¬, 11 bvsle, etc.).  \n\nThe formula models the detection of redundant linear constraints in a non‑convex polyhedron: the BV terms `x3 + (−3)*λ`, `x4 + 40*λ`, and their scaled combinations encode the affine inequalities of the polyhedral representation, while the Boolean variables `bool.b20 … bool.b23` act as switches that turn individual constraints on or off.  \n\nThe outer universal quantifier forces the “main” λ to satisfy a complex conjunction of bound checks (e.g., `0 ≤ λ`, `λ < 0` excluded, `bvsle(v0, 600)`, `bvsle(v0, 4820)`, etc.) together with numerous nested negated Boolean‑guarded sub‑formulas; the inner existential quantifier asserts the existence of a λ′ ≤ λ for which another set of guarded inequalities (e.g., `bvsle(v17,45)`, `bvsle(v19,‑4100)`, …) holds.  \n\nOverall the benchmark checks whether there is any λ that simultaneously respects all guarded linear bounds while the Boolean control bits can be chosen to make the whole quantified statement true, i.e., whether a given set of linear constraints contains a redundant one.  \n\nIts notable characteristics are the heavy use of bit‑vector arithmetic to simulate integer linear arithmetic, deep nesting of `let`‑bindings, and a dense mixture of Boolean guards and arithmetic conditions that make it a challenging instance for BV‑solvers and interpolation procedures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_36.smt2",
    "description": "The file is a single‑assertion benchmark written in the **BV** logic (32‑bit bit‑vectors) with a modest size of about 15 kB (14819 characters) and 10 declared constants (four bit‑vectors λ, λ′, x3, x4 and six Boolean flags bool.b17…bool.b24).  It originates from the 2008 SMT‑Workshop paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and was translated to bit‑vectors by Mathias Preiner, so it belongs to the industrial “Preiner‑scholl‑smt08” family.  \n\nThe core of the formula is a **forall λ** (universal) clause that builds a large conjunction of arithmetic inequalities (e.g., bvsle ( bvadd x4 + 60·λ , 4820 ), bvsle ( bvadd x3 – λ , … )) together with many Boolean literals bool.b17 … bool.b24 that act as switches for individual linear constraints.  Inside the universal clause an **exists λ′** sub‑formula checks that, for every λ in the interval 0 ≤ λ′ ≤ λ, the same family of guarded inequalities holds (including bounds such as λ′ ≤ 40, λ′ ≤ 33, and signed‑less‑than relations on the derived expressions).  \n\nThus the instance encodes the problem of deciding whether a set of parametrised linear constraints (representing facets of a non‑convex polyhedron) is simultaneously satisfiable, with the Boolean flags used to model redundancy elimination; the deep nesting of let, and, not (and a max term depth of 144) makes it a challenging case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_7.smt2",
    "description": "The file is an industrial benchmark translated to the bit‑vector logic (BV) and originates from the 2008 SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al.).  It is a single quantified assertion of size ≈ 1.7 kB (1725 characters) that contains one universal quantifier over a 32‑bit variable `?lambda` and an inner existential quantifier over a 32‑bit variable `?lambdaprime`.  The core of the formula encodes linear constraints on the parameters `x3` and `x4` by means of bit‑vector additions, multiplications and signed comparisons (e.g., `bvsle`, `bvslt`) against concrete constants such as 0, 40, 45, 4100, 4500 and 4910.  It also uses four Boolean flag variables (`bool.b17` … `bool.b20`) to conditionally enable or disable subsets of those bounds, forming a large conjunction of negated and nested Boolean‑and/or patterns.  The overall property being checked is whether, for every non‑negative `lambda`, either an admissible `lambdaprime` exists that satisfies all the guarded linear inequalities, or a simpler fallback inequality on the expressions involving `lambda` holds; the solver is asked to decide the satisfiability of this quantified bit‑vector condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_37.smt2",
    "description": "This benchmark is a single‑assertion BV‑logic problem (32‑bit bit‑vectors) taken from the 2008 SMT‑CAMP paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner.  The file contains 10 declared constants (four 32‑bit vectors λ, λ′, x₃, x₄ and eight Boolean flags bool.b17…bool.b24) and a gigantic quantified formula: a universal quantifier over λ, an inner existential quantifier over λ′, and a dense network of let‑bindings that build dozens of linear expressions (e.g., x₄+20·λ, x₃−3·λ, ‑λ·20) together with a long conjunction of range constraints such as 0 ≤ λ′ ≤ λ, ‑4100 ≤ ‑λ·20, 0 ≤ x₃−3·λ′ ≤ 45, 0 ≤ … ≤ 1200, and several upper‑bound checks (≤ 4820, ≤ 400, ≤ 241, etc.).  The Boolean flags are combined with the arithmetic tests to model the activation or deactivation of individual linear constraints, essentially encoding the problem of whether a given set of polyhedral constraints contains a redundant one.  Because of the deep nesting (max term depth 137) and the sheer number of logical operators (over 400 ‘and’s, ≈ 360 ‘not’s, 104 ‘let’s), the instance is a stress test for solvers’ handling of quantified bit‑vector arithmetic and large conjunctive normal forms.  The overall check‑sat asks whether there exists an assignment to the Boolean selectors and the parameters λ, λ′ that satisfies all the encoded bound conditions, i.e., whether the original polyhedral description is non‑redundant under the given interpolation‑based encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_11.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (fixed‑width bit‑vector) logic, exported from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08) and translated to bit‑vectors by Mathias Preiner.  It contains seven 32‑bit bit‑vector constants (λ, λ′, x3, x4, x5) and four Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6) and is 1 855 characters long, with a maximum term depth of 19.  \n\nThe sole constraint is a quantified formula of the form  \n\n```\n∀λ . (  (∃λ′ .  φ(λ,λ′,x3,x4,x5,flags))  ∨  λ < 0 )  ∧  ¬(¬bool.b22 ∧ ¬bool.b7 ∧ bool.b5 ∧ ¬bool.b6)\n```  \n\nwhere **φ** encodes a conjunction of linear‑like inequalities on the bit‑vectors (expressed with `bvsle`, `bvslt`, `bvadd`, `bvmul`, and `bvneg`) together with a nesting of Boolean literals.  The inequalities compare expressions such as `−(x3+λ′)` and `−(x4+20·λ′)` against constants (‑20, ‑10, ‑4100, ‑4500, ‑4910), and they are guarded by the Boolean flags.  \n\nThus the benchmark tests whether there exists a λ′ (bounded between 0 and λ) that satisfies all the guarded numeric constraints for every λ, while also checking a simple Boolean consistency condition.  Its structure—alternating quantifiers, deep Boolean nesting, and mixed arithmetic on 32‑bit vectors—makes it a characteristic, hard industrial example for quantified BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_76.smt2",
    "description": "The file is a single‑check instance written in the **BV** (32‑bit bit‑vector) logic, taken from the industrial benchmark suite *Preiner‑scholl‑smt08* (the SMT‑08 paper on removing redundant linear constraints from non‑convex polyhedra).  It declares twelve constants – three numeric vectors `x3, x4, x5` and the parameters `lambda` and `lambdaprime`, plus a handful of Boolean switches – and contains **one huge quantified formula** (a universal ∀ over `lambda` and, inside a disjunction, an existential ∃ over `lambdaprime`).  \n\nThe core of the formula is a conjunction of many linear‑integer‑like inequalities expressed as bit‑vector comparisons (`bvsle`, `bvslt`), each of the shape `a·lambda + b·x3 + c·x4 + d·x5 ≤ constant`, often multiplied by small integer coefficients or divided by constants.  The Boolean variables are used to enable or disable individual “redundant‑constraint” clauses, so the solver must decide whether there exists an assignment to the Booleans and to `lambdaprime` (subject to `0 ≤ lambdaprime ≤ lambda`) that satisfies all the nested numeric bounds.  \n\nThe instance is unusually dense: it has **6563 characters**, **77‑level term depth**, and more than **150** occurrences of `not` and `and`.  This structure makes it a stress test for SMT solvers’ handling of deeply nested quantifiers, mixed arithmetic/Boolean reasoning, and bit‑vector encoding of linear polyhedral constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_21.smt2",
    "description": "The file is a 2.6‑SMT‑LIB benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the Scholl et al. 2008 paper on redundant linear‑constraint elimination for non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08).  It is an industrial‑type instance of moderate size (≈2.7 k characters, 12 declared constants and a single quantified assertion with a maximal term depth of 25).  \n\nThe sole assertion is a universally quantified formula over a bit‑vector variable `lambda`, inside of which an existential quantifier introduces a second variable `lambdaprime`.  The body consists of a large disjunction of case‑splits that combine Boolean flags (`bool.b5`, `bool.b22`, …) with linear arithmetic constraints of the form  \n\n```\nbvsle (bvmul c (bvadd xi (bvmul d λ)))  k\n```  \n\nwhere the constants `c,d,k` are small 32‑bit numerals (e.g., ‑1, 20, ‑3, ‑10, 45).  These constraints encode upper and lower bounds on affine expressions that arise from the original polyhedral representation, while the Boolean variables select which of the many possible redundant‑constraint clauses are active.  \n\nThe benchmark is notable for its heavily nested `let`‑bindings, a dense mixture of `and`, `or`, and `not`, and the presence of both universal and existential quantifiers, making it a difficult case for current BV solvers that must handle quantified bit‑vector arithmetic and complex Boolean control flow.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_40.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra; it was later translated to bit‑vectors by Mathias Preiner.  The single assertion contains a universally quantified variable ?lambda and an existentially quantified variable ?lambdaprime, together with twelve 32‑bit constants (lambda, lambdaprime, x3, x4, x5 and a set of Boolean flags bool.b*).  Inside the quantifiers the formula builds a dense network of let‑bindings that express many linear inequalities (e.g., bvsle, bvslt) over the bit‑vectors, mimicking the original rational constraints by using bvadd, bvmul, bvsdiv and bvneg with small integer coefficients (1, 3, 20, 5, …).  The Boolean flags are combined with the arithmetic side‑conditions to encode the presence or removal of particular linear constraints, and the overall check‑sat asks whether there exists an assignment to the flags and the parameters that satisfies all the guarded inequalities.  The instance is relatively large (≈ 3.4 k term nodes, depth 26) and features a rich mixture of quantifiers, nested let‑expressions and mixed Boolean‑arithmetic reasoning, typical of industrial verification encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_25.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (BV logic) taken from the “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra” paper and translated to bit‑vectors by Mathias Preiner (industrial family Preiner‑scholl‑smt08, 2 977 bytes, 1 top‑level assertion). The core of the instance is a universally quantified variable λ (lambda) that must satisfy a complex conjunction of linear‑arithmetical relations involving two other 32‑bit parameters x₃, x₄ and a set of Boolean control flags bool.b17 … bool.b23. Inside the universal quantifier an existential sub‑formula introduces a second variable λ′ (lambdaprime) and checks that λ′ lies in the interval [0, λ] while a number of inequalities (e.g., bvsle (−4100) … , bvsle (−4910), bvsle 0 ≤ λ′, bvslt λ 0) together with the Boolean flags enforce the removal‑of‑redundant‑constraint conditions. The formula essentially asks whether there exists a λ such that, for every possible λ, all the encoded polyhedral‐shape constraints (encoded as bit‑vector arithmetic with constants like 40, 20, 800, 241) are simultaneously satisfied. Notable features are the deep nesting (term depth 40), the mix of universal and existential quantifiers, a large number of negated Boolean atoms (≈55 `not`s), and the encoding of linear arithmetic over 32‑bit bit‑vectors rather than native integer arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_63.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) that originates from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08).  It declares ten constants – two numeric variables `x3`, `x4` and four bit‑vector parameters `lambda`, `lambdaprime` together with six Boolean flags `bool.b17 … bool.b24` – and then asserts a massive quantified formula.  \n\nThe core of the formula is a **universal** clause over an arbitrary `?lambda` that builds a hierarchy of linear inequalities of the form  \n`bvsle( a*?lambda + b , c )` (with constants up to several thousand) and combines them with many Boolean conditions; an **existential** sub‑clause introduces `?lambdaprime` and requires it to lie between 0 and the universally quantified `lambda` while satisfying analogous upper‑ and lower‑bound constraints.  The Boolean flags are used to selectively enable or disable individual inequalities, essentially encoding the problem of whether a given set of linear constraints contains a redundant subset.  \n\nBecause the constraints are expressed with signed division, multiplication by constant coefficients, and numerous nested `let`, `and`, `not`, and `or` operators, the benchmark has a deep term structure (max depth 91) and a high count of logical operators (≈160 `not`, 147 `and`).  It is classified as an **industrial** instance from the Preiner‑Scholl‑SMT08 family, with a total size of about 7 KB and a single top‑level `assert`.  The solver is asked only to decide satisfiability (`check‑sat`).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_27.smt2",
    "description": "This benchmark is a single‑assertion BV problem (logic BV, 32‑bit bit‑vectors) taken from the Scholl et al. “SMT‑based detection of redundant linear constraints” case study (industrial category, Preiner‑Scholl SMT08 family, 2 470 bytes, 12 declared constants). The formula universally quantifies a variable ?λ and existentially quantifies a second variable ?λ′, coupling them with a handful of Boolean flags (bool.b5, bool.b6, …) that switch on different linear‑inequality sub‑constraints. The core arithmetic constraints are simple bounds of the form 0 ≤ ?λ′ ≤ ?λ together with scaled additions such as x₄ + 20·?λ and x₅ + ?λ, all compared to constant thresholds (‑10, ‑20, ‑4100, etc.) using signed‑less‑or‑equal (bvsle) and signed‑less‑than (bvslt). The Boolean structure nests many conjunctions, disjunctions and negations, creating a highly intricate condition that essentially checks whether a certain combination of the flags can satisfy or falsify the polyhedral constraints. Notably, the instance features deep nesting (max term depth 20) and a dense mixture of bit‑vector arithmetic and propositional logic, making it a typical “hard” industrial test for solvers handling quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_3.smt2",
    "description": "This benchmark is a single‑assertion BV (32‑bit bit‑vector) problem taken from the Scholl et al. “SMT08” paper on redundant linear constraints and translated to bit‑vectors by Mathias Preiner (file model_5_3.smt2, size ≈ 1.7 KB, industrial category). The formula asserts a universally quantified condition over a bit‑vector variable λ, which contains an inner existential quantifier over λ′ and encodes several linear inequalities of the form bvsle(‑40·λ′+x4, c) and bvsle(x3‑λ′, c) together with bounds 0 ≤ λ′ ≤ λ. Boolean flags bool.b17…bool.b20 control the activation of four separate clause families; each clause is a negated conjunction mixing these flags with the numeric bounds (e.g., ¬(bool.b17 ∧ ¬(¬bvsle(… ) ∧ …))). The outer disjunction combines the quantified case with a fallback case that requires λ to be negative or a pair of contradictory linear constraints on λ itself, so the solver must decide whether any λ satisfies all these intertwined arithmetic and Boolean conditions. The presence of deep nesting (let‑bindings, quantifiers, and mixed bit‑vector arithmetic) makes the instance a challenging example of quantifier‑instantiation and interpolation‑based reasoning in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_58.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark in SMT‑LIB 2.6 originating from the Scholl et al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra; it was translated to BV by Mathias Preiner and belongs to the industrial “Preiner‑scholl‑smt08” family (4170 characters, 12 declared constants, 1 top‑level assert, quantifier depth 40). The core formula quantifies universally over a parameter λ (a 32‑bit signed integer) and, inside a large nested `let`, builds a conjunction of many linear inequalities of the form `bvsle(bvadd …, constant)` that correspond to the original polyhedral facets, together with a handful of Boolean flags `bool.b*` that encode the presence or removal of specific constraints. A disjunction splits the assertion: one branch requires the existence of a λ′ (0 ≤ λ′ ≤ λ) satisfying a second set of bound constraints and Boolean conditions, while the other branch forces λ to be negative and demands that the whole collection of derived inequalities and Boolean literals hold simultaneously. The encoding is heavily saturated with duplicated `and`/`not` structures and uses only linear bit‑vector operations (`bvadd`, `bvmul`, `bvsdiv`, `bvneg`), making it a typical, highly structured benchmark for quantifier‑heavy BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_8.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem translated from the redundancy‑removal study of linear constraints in non‑convex polyhedra (Scholl et al., SMT‑08), contributed by Mathias Preiner.  It contains a single quantified assertion: a universal quantifier over a BV variable λ and an inner existential quantifier over a second BV variable λ′, together with five free constants (x3, x4 and three Boolean flags bool.b17, bool.b18, bool.b19).  The assertion forces λ′ to lie between 0 and λ and relates the affine terms x3 + (−1/20)·λ (or λ′) and x4 + 20·λ (or λ′) to several signed‑less‑or‑equal bounds (≤30, ≤0, ≤4820) while simultaneously requiring that, unless the corresponding Boolean flag is true, these terms do not drop below the negative thresholds ‑4100, ‑4500, ‑4910.  In effect the formula checks the consistency of a set of linear‑like constraints and thus whether any of them is redundant for the represented polyhedron.  At 1 664 characters, with a max term depth of 17 and a mix of quantifiers, arithmetic and Boolean operators, it typifies an industrial‑size BV benchmark that stresses quantifier handling and bit‑vector linear reasoning in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_4.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (`(set-logic BV)`) taken from the SMT‑08 paper by Scholl et al., translated to bit‑vectors by Mathias Preiner. It contains a single, fairly large quantified assertion (≈ 2 kB, 1953 characters) that mixes one universal quantifier over a variable `?lambda` and an inner existential quantifier over `?lambdaprime`. Inside the quantifiers the formula builds linear expressions such as `x3 + (‑1)*?lambdaprime` and `x4 + 60*?lambdaprime`, then compares them to concrete constants (‑10, ‑4100, ‑4500, ‑4910, 33, 40) using signed‑less‑or‑equal (`bvsle`) and signed‑less‑than (`bvslt`). The Boolean parameters `bool.b22`, `bool.b7`, `bool.b5` and `bool.b6` act as switches that enable or disable particular sub‑constraints, and the whole assertion essentially asks whether there exists a range `0 ≤ ?lambdaprime ≤ ?lambda` that satisfies all the guarded linear inequalities simultaneously. Thus the instance encodes a satisfiability check for a bounded, piece‑wise linear constraint system with optional clauses, typical of the redundant‑constraint detection task described in the original paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_55.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bitvectors) originating from the 2008 SMT‑Workshop paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and was later translated to bit‑vectors by Mathias Preiner (family Preiner‑scholl‑smt08).  It is an industrial‑style instance of moderate size (≈ 4.5 KB, 12 declared constants, 1 quantified formula, max term depth 47) containing a dense mixture of Boolean flags (`bool.b*`) and linear arithmetic on the bit‑vectors `x3, x4, x5` together with two parameters `lambda` and `lambdaprime`.  \n\nThe core of the formula is a universally quantified condition over `lambda` that stitches together many linear inequalities of the form `bvsle` and `bvslt` (e.g., bounds such as `lambda ≥ 0`, `lambda ≤ 0`, `x3 – 3·lambda ∈ [‑10, 40]`, `x4 + 60·lambda ≤ …`) and Boolean combinations that model the presence or absence of individual linear constraints.  An existential sub‑formula over `lambdaprime` relates `lambdaprime` to `lambda` and enforces additional consistency checks (e.g., `0 ≤ lambdaprime ≤ lambda` and negated bounds involving `x4` and `x5`).  \n\nThe overall query asks whether there exists an assignment to the 12 constants and the Boolean flags that makes the quantified conjunction true; the solver therefore has to reason about nested `forall/exists` quantifiers, many conjunctive/disjunctive Boolean combinations, and intricate bit‑vector arithmetic, which explains the large number of `and`/`not` operators and the relatively high term depth.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_64.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al.) and translated to BV by Mathias Preiner; it belongs to the industrial “Preiner‑scholl‑smt08” family and contains 6 000 + characters, 10 declared constants, a single massive assertion, and a maximal term depth of 75.  \nThe formula encodes a quantified “for‑all λ” over a large conjunction of linear bit‑vector inequalities built from the parameters x₃, x₄ and a set of Boolean switches (bool.b17 … bool.b24), and an inner “exists λ′” that restricts λ′ to lie between 0 and the universally quantified λ while also satisfying a similar block of arithmetic constraints.  \nAll arithmetic constraints are of the form `bvsle`/`bvslt` on expressions such as `bvadd x4 (60*λ)` or scaled versions of `x3 + (½*λ)`, together with numerous negated and combined Boolean conditions that mimic the presence or removal of individual linear facets of a non‑convex polyhedron.  \nThe instance therefore checks whether there exists a concrete λ′ (i.e., a concrete point of the polyhedron) that respects all the encoded facet‑wise bounds while the universal λ quantifier enforces that every admissible λ satisfies the intricate Boolean‑guarded system of linear inequalities.  \nIts notable characteristics are the deep alternation of quantifiers, heavy use of `let`‑bindings, and an overwhelming number of nested Boolean operators (≈155 ¬, 139 ∧), which makes it a stress test for solvers’ handling of quantified bit‑vector arithmetic and Craig‑interpolation‑style redundancy detection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_2.smt2",
    "description": "The file is a 32‑bit Bit‑Vector benchmark (logic BV) taken from the 2008 SMT‑LIB paper “Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”, and it was later translated to BV by Mathias Preiner (family Preiner‑scholl‑smt08, industrial category, about 1.9 KB, 1 quantified assertion and 7 declared constants).  \nThe single top‑level assertion is a ∀‑quantified formula over a variable λ (32‑bit) that contains an inner ∃‑quantifier over λ′ together with a handful of Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6).  \nInside the quantified core the encoding builds linear expressions of the form x₃ + (−1)·λ′, x₄ + 20·λ′, x₅ + λ′, multiplies them by constants (including −1), and checks signed‑less‑equal/strict‑less relations against concrete bounds (e.g., 33, −10, −4100, −4500, −4910).  \nThese arithmetic constraints are combined with Boolean conditions that force a particular pattern of the flags (essentially ¬bool.b22 ∧ ¬bool.b7 ∧ bool.b5 ∧ ¬bool.b6) and with range constraints 0 ≤ λ′ ≤ λ, while the outer universal quantifier also allows the case λ < 0.  \nOverall the benchmark tests a solver’s ability to handle nested quantifiers, mixed Boolean‑arithmetic reasoning, and the bit‑vector encoding of non‑convex polyhedral redundancy checks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_35.smt2",
    "description": "**Overview.** This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner. It belongs to the industrial family *Preiner‑scholl‑smt08*, has a moderate size (≈14 k characters, 468 `and`, 390 `not`, maximal term depth 145) and contains a single huge assertion that combines one universal quantifier over a fresh variable `?lambda` and one existential quantifier over `?lambdaprime`.\n\n**Problem structure.** The formula encodes a system of linear inequalities on two integer‑valued parameters `x3` and `x4` together with a family of constraints indexed by the quantified variables. The arithmetic part consists of expressions such as `x4 + 40·lambda`, `x3 – lambda`, and various scaled combinations (e.g., `bvmul (bvsdiv 1 40) …`). These are compared with concrete constants (‑4100, ‑4500, 20, 200, 241, 400, 1200, …) using signed‑less‑or‑equal (`bvsle`) and signed‑less‑than (`bvslt`).\n\n**Key constraints.** Boolean selectors `bool.b17` … `bool.b24` act as flags that enable or disable individual linear bounds; the assertion builds a massive conjunctive normal form where each flag is linked to a specific range (e.g., `bool.b17` ↔ “‑4100 ≤ ‑(x4+40·λ)”). The quantified part also constrains the quantified variables themselves (e.g., `0 ≤ λ′ ≤ λ`), ensuring that the indexed constraints are applied only for admissible parameter values.\n\n**Notable characteristics.** The encoding is deliberately dense: it uses a deep hierarchy of `let` bindings to share intermediate terms, and the Boolean combination contains many nested `and`/`not` patterns that mimic the effect of Craig interpolation in the original paper. The presence of both universal and existential quantifiers makes the instance a challenging test for quantifier‑handling and interpolation‑capable SMT‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_59.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the SMT‑08 paper on using Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedra, and was translated to bit‑vectors by Mathias Preiner (file model_5_59.smt2, 6.5 KB, 1 assertion, 10 declared constants). The single, highly nested assertion encodes a mixed Boolean‑arithmetic formula that quantifies universally over a parameter λ and existentially over a sub‑parameter λ′, together with ten Boolean switch variables (bool.b17 … bool.b24) that activate or deactivate individual linear inequalities. The arithmetic part consists of a large collection of linear bounds on expressions of the form x₃ + λ, x₄ + 20·λ and their scaled variants (e.g., ≤ 0, ≤ 20, ≤ 40, ≤ 45, ≤ 723, ≤ 1200, etc.), all expressed with bit‑vector addition, multiplication, signed division and signed ≤/<? The Boolean structure combines these bounds with many “not” and “and” operators to model the presence, redundancy, or conflict of the constraints, essentially asking whether there is a λ′ (0 ≤ λ′ ≤ λ) that falsifies any enabled inequality. The formula’s depth (max term depth 90) and the dense use of let‑bindings make it a challenging industrial benchmark for solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_38.smt2",
    "description": "The file is an industrial BV benchmark (logic BV, 3 584 bytes, 1 quantified assertion, 12 declared symbols) taken from the Scholl et al. “SMT 08” suite and translated to bit‑vectors by Mathias Preiner. It encodes the detection of redundant linear constraints in a non‑convex polyhedral representation: a universally‑quantified variable λ (32‑bit) is combined with an existentially‑quantified λ′ to describe two nested “interval” constraints on the original linear terms x₃, x₄, x₅. The body consists of a large conjunction of signed‑less‑equal (bvsle) inequalities built from simple affine expressions (e.g., x₅ + λ, x₄ + 40·λ, x₃ ‑ 3·λ) together with a set of Boolean flags (bool.b5,…,bool.b23) that model the presence or removal of individual linear constraints. The formula is essentially a SAT‑check on whether there exists a λ that satisfies all the encoded bounds while respecting the redundancy‑removal conditions expressed by the Boolean flags; the outermost disjunction also tests the case λ < 0. Because the constraints are deep (term depth 36) and heavily nested with many `let`, `and`, and `not` operators, the instance is a stress test for bit‑vector solvers handling quantified arithmetic and interpolation‑style reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_69.smt2",
    "description": "The file is a single‑formula benchmark in the **BV** (fixed‑size bit‑vector) logic, taken from the industrial family *Preiner‑scholl‑smt08* (the “non‑convex polyhedra” case study) and translated to 32‑bit vectors by Mathias Preiner.  It declares four 32‑bit variables `x3, x4, x5, lambda` (plus an existentially quantified `lambdaprime`) and a handful of Boolean switches (`bool.b…`) that enable or disable individual linear constraints.  The core of the assertion is a universally quantified implication over all values of `lambda` that combines many bound checks of the form `bvsle`/`bvslt` on linear combinations such as `x3 – 3·lambda`, `x4 + 20·lambda`, `x5 + lambda`, and on derived expressions that mix these terms with rational coefficients (implemented using `bvsdiv`).  An inner existential quantifier introduces `lambdaprime` and adds further constraints that relate the two parameters, while a large disjunction of complex Boolean conjuncts encodes the presence or absence of redundant constraints that the original polyhedral model may contain.  The benchmark is deliberately dense: 5 924 characters, 12 declared constants, a single top‑level assert, and a maximum term depth of 64, with 137 occurrences of `not` and 131 of `and`, making it a stress test for quantifier handling and Boolean‑bit‑vector reasoning in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_38.smt2",
    "description": "This benchmark is a single‑assertion formula in the quantifier‑free bit‑vector logic (BV) that originates from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08).  It contains 10 declared constants – two 32‑bit integer variables (`x3`, `x4`) and eight Boolean flags (`bool.b20…bool.b24`) that encode the presence of particular linear inequalities.  The sole assertion is a huge conjunctive‑normal‑style expression built with many `and`, `not`, and `let` bindings, and it quantifies universally over a parameter `?lambda` and existentially over a second parameter `?lambdaprime`.  The arithmetic sub‑terms are simple affine expressions of the form `x3 + (-3)*lambda` and `x4 + 40*lambda`, and they are compared with concrete bounds (e.g., ≤ 4820, ≤ 600, ≤ 1200) using signed‑less‑or‑equal (`bvsle`).  Overall the formula checks whether a set of derived linear constraints on the two integer variables, filtered through the Boolean selectors, is simultaneously satisfiable – i.e., whether any redundant or contradictory polyhedral constraints remain after the preprocessing described in the paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_10.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. SMT‑08 paper on removing redundant linear constraints in non‑convex polyhedra, translated to bit‑vectors by Mathias Preiner. It consists of a single, fairly large (≈1.8 KB, term depth 19) quantified assertion that mixes universal and existential quantifiers over the variables **lambda** and **lambdaprime**, together with four integer‑valued constants **x3**, **x4** and three Boolean flags (**bool.b17‑b19**). The core of the formula encodes a system of linear inequalities (e.g. x3 + (‑1/20)·λ ≤ 40, x4 + 60·λ ≤ 4820, and several stronger bounds such as ≤ ‑4100, ‑4500, ‑4910) together with Boolean “activation” conditions that decide whether each bound is relevant. The outer universal quantifier forces that for every λ either a witness λ′ satisfying the bounded range 0 ≤ λ′ ≤ λ and the appropriate flag‑condition exists, or λ is negative, while a final negated conjunction forbids a simultaneous satisfaction of two key inequality pairs. Thus the instance checks the satisfiability of a quantified, piece‑wise linear (non‑convex) polyhedral description encoded entirely in 32‑bit bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_17.smt2",
    "description": "The file is a single‑assertion benchmark in the quantifier‑free bit‑vector logic (BV) of the SMT‑LIB 2.6 format, taken from the “Preiner‑scholl‑smt08” industrial suite (size ≈ 2.3 kB, 9 declared 32‑bit constants and 1 universal plus 1 existential quantifier).  It encodes a verification task arising from the paper *Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra*, where the real‑valued polyhedral constraints have been translated to 32‑bit arithmetic.  The universally quantified variable ?λ (named λ) ranges over all 32‑bit values and the formula forces either λ < 0 or a large Boolean combination of linear inequalities of the form  \n  bvsle ( λ·c + x_i ) k  \ntogether with the presence flags bool.b17 … bool.b23 that represent whether particular original constraints are kept.  An existentially quantified ?lambdaprime (λ′) appears in a sub‑formula that requires 0 ≤ λ′ ≤ λ and checks that the derived expression ‑(x4 + 30·λ′) respects three separate lower bounds (‑4100, ‑4500, ‑4910) according to the flags, embodying the redundancy‑removal condition.  The benchmark is notable for its deep nesting (max term depth 27), heavy use of negations, and a single disjunction that captures the “either redundant or safe” dichotomy, making it a challenging instance for BV solvers with quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_3.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the industrial suite used in Scholl et al.’s 2008 paper on redundant linear constraints; it was translated to BV by Mathias Preiner and contains 1 quantified assertion, 7 declared constants and about 1.9 KB of text. The single assertion has the shape  \n\n\\[\n\\forall\\lambda\\!:\\!BV_{32}\\;.\\; \n\\bigl(\\exists\\lambda' \\;.\\; \\Phi(\\lambda,\\lambda',x_3,x_4,x_5,\\text{bools})\\bigr)\\;\\lor\\;(\\lambda<0),\n\\]  \n\nwhere \\(\\Phi\\) is a large conjunction of linear bit‑vector inequalities (e.g., \\(0\\le\\lambda'\\le\\lambda\\), \\(x_3-\\lambda'\\le 33\\), \\(x_4-40\\cdot\\lambda'\\le -4100\\), \\(x_5+\\lambda'\\ge -10\\)) intertwined with four Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6) that enable or disable particular sub‑constraints. The main property being checked is whether there exists a value of \\(\\lambda\\) that makes the arithmetic constraints together with a specific combination of the Boolean flags simultaneously satisfiable; equivalently, the solver is asked to prove that no such \\(\\lambda\\) exists, which corresponds to detecting a redundant linear constraint in a non‑convex polyhedral representation. Notable characteristics of the instance are the mixed ∀∃ quantifier pattern, deep nesting of let‑bindings, a high count of negations and Boolean‑arithmetic interactions, and the use of only simple linear BV operations, all of which make it a hard benchmark for modern BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_50.smt2",
    "description": "The file is a single‑query benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the SMT‑08 paper by Scholl et al. on detecting redundant linear constraints in non‑convex polyhedra; it was later translated to bit‑vectors by Mathias Preiner and belongs to the industrial “Preiner‑scholl‑smt08” family (≈7 500 characters, 10 declared constants, one quantified assertion, and a maximal term depth of 96).  \n\nThe core of the assertion is a universally quantified formula over a parameter `?lambda` that builds two affine expressions `?v_0` and `?v_2` (linear combinations of the free constants `x3`, `x4` and the quantified variable) and then subjects many derived expressions to a dense web of signed‑less‑or‑equal (`bvsle`) and signed‑less‑than (`bvslt`) comparisons.  \n\nBoolean variables `bool.b17 … bool.b24` act as switches for individual linear inequalities; the formula repeatedly combines these switches with the arithmetic predicates using nested `and`/`not` patterns to express that a subset of the constraints must hold simultaneously while others must be excluded.  \n\nAn existential sub‑formula over `?lambdaprime` additionally enforces a bounded range for the quantified variable (`0 ≤ ?lambdaprime ≤ ?lambda`) and checks that the corresponding affine expressions stay outside a set of “forbidden” intervals, again gated by the Boolean switches.  \n\nThus the benchmark encodes the consistency check of a highly constrained, piece‑wise linear system (a non‑convex polyhedron) where the solver must decide whether there exists a value of `lambda` (and of the auxiliary `lambdaprime`) that satisfies all enabled constraints, making it a challenging test of quantifier handling, bit‑vector arithmetic, and Boolean‑arithmetic interaction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_33.smt2",
    "description": "The file is an industrial BV‑logic benchmark (logic BV, 12 bit‑vector constants of size 32, 12 Boolean constants) originating from the paper *Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra*; it was translated to bit‑vectors by Mathias Preiner and appears in the Preiner‑Scholl‑SMT08 family (≈3 KB, 1 top‑level assertion, max term depth 31).  \nThe single assertion is a universally quantified formula over a fresh 32‑bit variable λ; inside it a cascade of `let` bindings builds several linear expressions such as `x3 + 0·λ`, `x5 + 1·λ`, `x4 + 30·λ` and combines them with signed‑less‑or‑equal (`bvsle`) and multiplication/division constraints.  \nA nested existential quantifier introduces a second parameter λ′ and encodes bounds `0 ≤ λ′ ≤ λ` together with a large disjunction that tests whether certain signed inequalities (e.g., `‑x4‑30·λ′ ≤ ‑4100`, `‑x5‑λ′ ≤ ‑10`) hold under various Boolean flags (bool.b5 … bool.b23).  \nThe Boolean variables are used to toggle the presence of individual linear constraints, and the overall formula checks the consistency of all selected constraints together with the arithmetic bounds, effectively asking whether a given set of linear inequality constraints on x3, x4, x5 is simultaneously satisfiable.  \nBecause of the deep nesting, many combined `and`/`or`/`not` patterns and mixed arithmetic‑Boolean reasoning, the benchmark is a hard case for bit‑vector solvers and is intended to stress interpolation/redundancy‑removal techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_49.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic (32‑bit bit‑vectors) originating from the 2008 SMT‑Workshop paper on removing redundant linear constraints in non‑convex polyhedra; it was translated to bit‑vectors by Mathias Preiner.  The model declares two numeric parameters (`lambda`, `lambdaprime`) and two integer variables (`x3`, `x4`), together with a dozen Boolean flags (`bool.b17 … bool.b24`) that encode whether particular linear constraints are active.  The core of the assertion is a universally quantified condition on an arbitrary `?lambda` that builds a large conjunction of shifted and scaled inequalities (using `bvadd`, `bvmul`, `bvsle`, `bvsdiv`, etc.) and then combines them with the flag variables through many nested `and`/`not` expressions; an existential sub‑formula over `?lambdaprime` adds a secondary bound on a linear combination of `x4` and `lambda`.  Satisfiability asks whether there exists a non‑negative `lambda` (and a suitable `lambdaprime` within it) such that all the encoded numeric bounds hold while respecting the logical structure of the flags.  The benchmark is relatively large (≈ 6.8 k characters, 10 constants, maximal term depth 96) and features a very deep nesting of `let` bindings and Boolean operators, which makes it a stress test for BV solvers’ handling of heavyweight quantified arithmetic encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_14.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Scholl et al. “redundant linear‑constraint” case study and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial instance (size ≈ 1.6 kB, 5 declared constants, 1 quantified assertion). The single assertion is a universally quantified formula over a variable λ; inside it there is an existentially quantified λ′ and three Boolean flags (bool.b17, bool.b18, bool.b19) that control three alternative lower‑bound conditions on a linear expression involving the parameters x₃, x₄, λ and λ′. The core arithmetic constraints are simple linear combinations (bvadd, bvmul, bvsdiv) compared with constant bit‑vector limits such as 0, 20, ‑4100, ‑4500, ‑4910 and 4820, wrapped in signed‑less‑or‑equal (bvsle) and signed‑less‑than (bvslt) checks. The overall property being checked is that for every λ either a suitable λ′ exists satisfying the guarded bound constraints, or λ is negative, or a final inequality on the two linear terms is violated; in other words the model tests whether a certain set of linear constraints is redundant. Notably, the benchmark combines nested quantifiers, mixed Boolean‑guarded arithmetic and non‑trivial constant multipliers, making it a typical challenge for solvers that rely on Craig interpolation or quantifier elimination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_1.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic **BV**) taken from the Scholl et al. 2008 paper on detecting redundant linear constraints in non‑convex polyhedra; it was translated to BV by Mathias Preiner and is classified as an **industrial** instance (size ≈ 1.4 kB, 1 assertion, 5 declared constants).  \n\nThe single assertion is a quantified formula: for every 32‑bit variable `lambda` it requires that either `lambda` is negative, or there exists a `lambdaprime` with `0 ≤ lambdaprime ≤ lambda` such that a linear expression  \n`v0 = -(x4 + 30·lambdaprime)` respects three guarded upper bounds (−4100, −4500, −4910) controlled by the Boolean flags `bool.b17`, `bool.b18` and `bool.b19`.  \n\nIf the existential branch fails, the formula forces an additional property linking `x3` and `x4`: it demands that `x3 ≤ 0` and **not** (`x4 + 30·lambda ≤ 4820`). In other words, the model must exhibit a λ for which the guarded constraints are satisfied, otherwise the pair (`x3`,`x4`) must violate the second inequality.  \n\nThe benchmark therefore encodes a search for a quantifier‑instantiation that proves the non‑redundancy of certain linear constraints, using only linear bit‑vector arithmetic (multiplication by constants) but with both universal and existential quantifiers, a pattern that is challenging for many BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_22.smt2",
    "description": "The file is a 2.6‑compliant SMT‑LIB benchmark in the **BV** logic, taken from the industrial “Preiner‑Scholl‑smt08” suite (size ≈ 2.7 kB, 12 declared constants, one huge quantified assertion, max term depth 25). It encodes the redundancy‑removal problem for a set of linear constraints that arose in a non‑convex polyhedron representation, where the original integer arithmetic has been translated to 32‑bit bit‑vectors. The core formula is a universally quantified variable λ (and an inner existential λ′) together with a collection of Boolean flags (bool.b5, bool.b22, …) that switch individual constraints on or off; the arithmetic part consists of scaled sums of the parameters x3, x4, x5 and the quantified variables, compared with constant bounds such as –10, 0, 20, 45, –4100, –4500, –4910 and 4820 using **bvsle**, **bvslt**, **bvadd**, **bvmul** and **bvneg**. The assertion essentially asks whether, for every λ satisfying the outer bounds, there exists a λ′ within [0, λ] that makes a complex Boolean combination of these linear‑inequality clauses unsatisfiable, thereby checking the existence of redundant constraints. The benchmark is notable for its heavy nesting of let‑bindings, a large number of Boolean connectives (≈ 80 and/not), and the mixture of quantified bit‑vector arithmetic with many optional constraints, which makes it a particularly challenging case for solvers that handle quantifiers and combination of theories.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_34.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the SMT‑08 paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* and translated to bit‑vectors by Mathias Preiner.  It contains 10 declared constants (four 32‑bit variables x3, x4, lambda, lambdaprime and six Boolean flags bool.b17…bool.b24) and a single gigantic assertion that mixes one universal quantifier over lambda and one existential quantifier over lambdaprime.  The core of the formula encodes a system of linear inequalities on the expressions x4 + 20·lambda, x3 – lambda, and their scaled versions, each compared against fixed bounds (e.g., ≤ 4820, ≤ 400, ≥ ‑4100, ≤ ‑20, etc.), with the Boolean flags acting as switches that enable or disable individual constraints.  The constraints are expressed through deeply nested `let` definitions, many redundant `and`/`not` combinations, and a maximum term depth of 138, giving the instance a size of ≈ 13.5 k characters and 436 occurrences of `and`.  Because of the heavy use of quantifiers and the Boolean‑controlled clause structure, the benchmark is used to stress‑test solvers’ ability to simplify and interpolate large, industrial‑style bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_5.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Scholl et al. 2008 SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra; it was translated to BV by Mathias Preiner and is classified as an industrial instance (file BV/2017‑Preiner‑scholl‑smt08/model_6_5.smt2, 2 010 characters, 1 quantified assertion, 7 declared constants).  \n\nThe single top‑level assertion is a universally quantified formula over a variable **λ** (named `?lambda`) that combines an existential sub‑formula over **λ′** (`?lambdaprime`) with a large Boolean combination of linear bit‑vector inequalities involving the parameters `x3`, `x4`, `x5` and the Boolean flags `bool.b22`, `bool.b7`, `bool.b5`, `bool.b6`.  \n\nThe existential part enforces 0 ≤ λ′ ≤ λ and a collection of bounds of the form  \n  bvsle( … , ‑4100), bvsle( … , ‑4500), bvsle( … , ‑4910) and a range test “‑10 ≤ ‑(x5+λ′)”.  \nThese are coupled with the Booleans so that different sets of constraints are activated depending on the truth values of `bool.b22`, `bool.b7`, `bool.b5`, and `bool.b6`.  \n\nThe outer universal branch also requires either λ < 0 or a particular Boolean pattern (¬bool.b22 ∧ ¬bool.b7 ∧ bool.b5 ∧ ¬bool.b6) to be false, effectively checking whether a certain combination of linear constraints can be simultaneously satisfied.  \n\nBecause the formula mixes quantified bit‑vector arithmetic with many nested `and`/`or`/`not` gadgets, it is a typical “hard” benchmark for solvers that must handle both quantifiers and non‑trivial linear arithmetic over 32‑bit signed integers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_51.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the Scholl‑et‑al. “SMT + Craig interpolation for redundant linear constraints” paper and translated to bit‑vectors by Mathias Preiner (file model_6_51.smt2, 3.9 kB, 65 and‑nodes, 58 not‑nodes, max term depth 43).  \nThe single top‑level assertion contains a universally quantified variable ?lambda and, inside a large disjunction, an existentially quantified ?lambdaprime; both are constrained by a host of linear inequalities such as bvsle (?v_0 ≤ 1150), bvsle (?v_6 ≤ 1200), and bounds on the auxiliary expressions built from the base variables x3, x4, x5.  \nBoolean constants bool.b5, bool.b6, bool.b7, bool.b22, bool.b23 etc. act as selectors for individual constraints, allowing the formula to express that a certain subset of the linear bounds must hold simultaneously while others may be disabled.  \nThe overall problem asks whether there exists a non‑negative integer lambda (and possibly a lambdaprime with 0 ≤ lambdaprime ≤ lambda) that satisfies all the enabled linear constraints; this encodes the detection of redundant or contradictory constraints in a non‑convex polyhedral representation.  \nIts size (≈ 4 kB, 12 declared constants) and the heavy nesting of let‑expressions, mixed signed‑comparison and arithmetic operators make it a challenging industrial‑style instance for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_8.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.9 KB, 7 declared constants, a single quantified assertion) taken from the SMT‑08 paper on detecting redundant linear constraints in non‑convex polyhedra, translated to bit‑vectors by Mathias Preiner.  The core of the problem is a universally quantified variable λ (named *lambda*) together with an existential auxiliary variable λ′ (*lambdaprime*) that must satisfy a series of linear inequalities expressed with bit‑vector addition, multiplication, signed division and signed‑less‑or‑equal, all guarded by four Boolean flags (bool.b22, bool.b7, bool.b5, bool.b6).  The asserted formula states that for every λ either the guarded arithmetic constraints are jointly consistent (i.e., there exists a λ′ in the interval [0, λ] meeting all the bounds such as x₃+20·λ′ ≤ 30, x₅−λ′ ≥ ‑10, and various upper‑bounds like ‑4100, ‑4500, ‑4910) or λ is negative, or the combination of Boolean flags is falsified.  Hence the solver is asked to decide whether the combination of those linear polyhedral conditions (possibly representing redundant constraints) can be satisfied for all λ, which amounts to checking the emptiness of a non‑convex polyhedral region encoded in bit‑vector arithmetic.  The benchmark is classified as “industrial” and exemplifies the use of quantified bit‑vector reasoning to model and eliminate redundant linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_62.smt2",
    "description": "The file is a single, huge quantified bit‑vector formula written in the **BV** logic (32‑bit vectors), originating from the industrial benchmark suite *Preiner‑scholl‑smt08* (SMT‑LIB 2.6). It declares ten 32‑bit constants (λ, λ′, x₃, x₄ and several Boolean flags) and then asserts one quantified assertion that contains a single universal quantifier over a fresh 32‑bit variable ?λ together with an inner existential over λ′.  \n\nThe assertion encodes a large conjunction of linear inequalities of the form bvsle, bvslt, bvsdiv, bvadd and bvmul, each multiplied by the quantified parameters; the Boolean flags (bool.b17 … bool.b24) act as optional “guard” literals that enable or disable individual constraints. The overall property being checked is whether there exists a value for λ′ (and for the universal λ) such that all of the guarded inequalities hold simultaneously while respecting the bounds 0 ≤ λ′ ≤ λ, i.e. whether a certain non‑convex polyhedron defined by the linear constraints is non‑empty after redundant constraints have been removed.  \n\nNotable features are the extreme nesting depth (max term depth 96), the heavy use of let‑bindings, and the sheer number of logical connectives (≈ 360 ‘and’, 220 ‘not’), which makes the instance a stress test for BV‑solvers’ handling of quantified formulas and large Boolean‑constraint combinations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_53.smt2",
    "description": "This benchmark is a single‑assertion, quantified BV‑logic formula (32‑bit bit‑vectors) originating from the 2008 SMT‑08 paper on using Craig interpolation to eliminate redundant linear constraints in non‑convex polyhedral representations, and was later translated to bit‑vectors by Mathias Preiner (file model_6_53.smt2, 4 437 characters, 12 declared constants). The core of the problem is a universally quantified block over a variable λ (named lambda) that combines dozens of linear inequalities built from the constants x3, x4, x5 and the integer‑scaled expressions λ·1, λ·20, λ·‑3, etc., together with a nested existential block over λ′ (lambdaprime) that adds a second set of guarded constraints. Boolean flags (bool.b5, bool.b12, …) are used to switch on/off individual sub‑constraints, creating a large disjunction of case analyses that the solver must satisfy; the outermost formula asks whether there is any λ (and compatible λ′) that makes all the required conjunctions hold. All arithmetic is expressed with bit‑vector operations (bvadd, bvmul, bvsle, bvslt, bvsdiv, bvneg), so the instance mimics integer linear arithmetic while remaining in the BV theory, and it features deep nesting (max term depth 49) and a high count of logical connectors (≈85 ands, 73 nots), characteristic of industrial benchmarks designed to stress quantifier handling and interpolation‑based reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_5_33.smt2",
    "description": "The file is a single‑check‑satisfiability benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the 2008 SMT‑08 paper on eliminating redundant linear constraints in non‑convex polyhedra (translated to bit‑vectors by Mathias Preiner).  It contains 10 declared constants (two BV variables `x3`, `x4` and four Boolean flags `bool.b17 … bool.b24` plus the quantified parameters `lambda` and `lambdaprime`) and a single monstrous quantified assertion (one universal over `lambda` and one existential over `lambdaprime`).  The core of the formula is a tight network of linear inequalities such as  \n`bvsle (x3 + 0·λ) 0`,  \n`bvsle (x4 + 30·λ) 4820`,  \nand similar bounds involving constants 20, 30, 40, 45, 964/3, 1200, 723, etc., all combined with the Boolean flags to express whether each individual linear constraint is active.  The Boolean sub‑formulae are heavily nested with `and`, `or`, and `not` (over 270 conjuncts) to encode the redundancy‑removal condition and the Craig‑interpolation criteria that motivated the benchmark.  Because of the deep nesting (max term depth 108) and the intertwined quantifiers, the instance is characteristic of industrial‑scale SMT problems used to stress‑test solvers’ handling of large Boolean‑arithmetic combinations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_24.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 formula in the **BV** (fixed‑size bit‑vector) logic, originating from the Scholl et al. 2008 paper on using interpolation to prune redundant linear constraints in non‑convex polyhedra and later translated to bit‑vectors by Mathias Preiner.  It is a relatively small industrial case (≈2.5 KB, 12 declared constants and 1 quantified assertion) but the assertion has a high structural depth (22) with a nested **forall** over a 32‑bit variable `lambda` and an inner **exists** over `lambdaprime`.  The core of the formula encodes a family of linear inequalities (e.g., `20*lambda + x4 ≤ 4820`, `‑lambda + x5 ≤ –10`, `lambda*5 + x3 ≥ 0`) that are guarded by a collection of Boolean flags (`bool.b5`, `bool.b6`, …) and combined with many `and`/`or`/`not` conditions to represent the redundancy‑removal predicate.  Satisfiability asks whether there exists an assignment to the Boolean control variables and the bit‑vector parameters (`x3`, `x4`, `x5`) such that the quantified condition—essentially “for every λ the guarded constraints hold or a contradictory clause is triggered”—is true.  The instance is notable for its heavy use of nested let‑bindings, mixed arithmetic and Boolean reasoning, and a single, highly conjunctive quantified formula that challenges solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_44.smt2",
    "description": "The file is a 2.6‑SMT‑LIB benchmark in the **BV** (32‑bit bit‑vector) logic, taken from the industrial suite *Preiner‑scholl‑smt08* and originally derived from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (SMT‑08). It is a relatively large instance (≈2.8 KB, 12 declared constants and a single, highly nested assertion of depth 23) that encodes a mixture of Boolean control flags (`bool.b*`) and linear arithmetic over 32‑bit signed bit‑vectors. The core of the problem is a quantified formula: a universal quantifier over a variable `?lambda` and an inner existential quantifier over `?lambdaprime`, together with a network of signed ≤, <, and equality constraints built from additions, multiplications by constants (1, 40, ‑1, etc.), a single signed division, and several linear combinations involving the declared variables `x3`, `x4`, `x5`. These constraints model the feasibility of a set of linear inequalities that describe a non‑convex polyhedron, while the Boolean flags control the presence or removal of particular linear constraints, effectively checking whether a redundant‑constraint configuration is still satisfiable. The benchmark therefore tests the solver’s ability to handle deep quantifier alternation, heavy bit‑vector arithmetic, and a large amount of Boolean‑arithmetic interaction typical of industrial verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_60.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) extracted from the paper *“Using an SMT Solver and Craig Interpolation to Detect and Remove Redundant Linear Constraints in Representations of Non‑Convex Polyhedra”* (Scholl et al., SMT‑08) and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial instance (family Preiner‑scholl‑smt08) and contains 12 declared constants, a single large assertion, and 3 866 symbols (max term depth 36).  \n\nThe core formula consists of a universal quantifier over a variable **λ** that builds a hierarchy of let‑bindings to express a collection of linear inequalities (using bvsle, bvadd, bvmul, bvsdiv, bvneg) together with a set of Boolean flag literals (**bool.b5**, **bool.b7**, …) that model the presence or removal of individual constraints.  \n\nInside the universal part there is an existential sub‑formula over **λ′** which additionally restricts **λ′** to lie between 0 and **λ** and checks the same family of inequalities under a different combination of Boolean flags, thereby encoding a “there exists a tighter bound” test.  \n\nThe overall goal is to decide whether the combination of all these guarded linear constraints is satisfiable – i.e., whether any assignment to the Boolean flags and the integer parameters can satisfy all the implied inequalities, which corresponds to detecting redundant constraints in the original polyhedral representation.  \n\nThe instance is notable for its heavy use of nested lets, mixed arithmetic/Boolean reasoning, and a deep quantifier alternation (∀ λ ∃ λ′) that makes it challenging for BV solvers despite its modest size.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_9.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, coming from the Scholl et al. 2008 SMT‑08 paper on removing redundant linear constraints in non‑convex polyhedra and translated to bit‑vectors by Mathias Preiner (industrial benchmark, 1882 characters, 7 declared constants, max term depth 19).  \nIt encodes a quantified property: for every 32‑bit value λ (named lambda) either λ is negative or there exists a 32‑bit λ′ (lambdaprime) that satisfies a large conjunction of linear inequalities involving the parameters x3, x4, x5 and several constant bounds (‑4100, ‑4500, ‑4910, 30, etc.).  \nThe inequalities are expressed with bit‑vector operations **bvmul**, **bvadd**, **bvsle**, **bvslt**, and a division **bvsdiv**, while a set of Boolean flags (**bool.b22**, **bool.b7**, **bool.b5**, **bool.b6**) control alternative sub‑clauses that model the presence or removal of redundant constraints.  \nThe outermost formula asserts that the combined condition (∃ λ′ …) must hold for all λ unless λ < 0, and additionally that not all four Boolean flags can simultaneously take the pattern (¬b22 ∧ ¬b7 ∧ b5 ∧ ¬b6).  \nThus the solver is asked to decide satisfiability of a heavily quantified, mixed Boolean‑arithmetic specification that captures the correctness condition of a redundancy‑elimination transformation on a non‑convex polyhedral model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-scholl-smt08/model/model_6_28.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the industrial “Preiner‑scholl‑smt08” family, taken from a paper on removing redundant linear constraints in non‑convex polyhedra. It contains a single, fairly deep (max term depth 20) quantified assertion: a universal quantifier over a BitVec variable λ and, inside its body, an existential quantifier over a second BitVec λ′ together with a dozen Boolean flags (bool.b5 … bool.b23). The core of the formula encodes a conjunction of linear‑like inequalities on λ, λ′, and three other 32‑bit variables (x3, x4, x5), expressed with BV addition, multiplication by small constants, negation and signed‑less‑or‑equal (bvsle/bvslt) comparisons against concrete constants (e.g., ‑20, ‑4100, 4820). The Boolean flags selectively enable or disable particular inequality clusters, so the solver must decide whether there exists a Boolean assignment that makes the whole quantified statement true (i.e., that no λ ≥ 0 violates any enabled constraint). With 12 declared constants, 33 ‘and’, 32 ‘not’, and a mixture of quantifiers, the instance is a compact but highly intertwined encoding of a redundancy‑detection condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_432.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark (the “jain” program, true‑unreach‑call, no‑overflow).  It contains three 32‑bit constants c_main_~x~5, c_main_~y~5, c_main_~z~5 and several nondeterministic 32‑bit inputs (|main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2|) that are quantified universally.  The first assertion states that for all such inputs either a large linear combination of the variables plus a constant equals zero, **or** two other linear expressions (one multiplied by 4294967288‑type coefficients) are distinct; the second assertion negates a similar “distinct” condition, effectively encoding the negation of the safety property.  Satisfiability of the whole file therefore corresponds to the existence of a counterexample to the intended safety invariant (i.e., a reachable error state or overflow).  The instance is relatively small (≈3 kB, 2 quantified asserts, depth 6) but unusually heavy on huge coefficients (e.g., 4294967288 ≈ 2³²‑8), which stress the solver’s handling of modular arithmetic and quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_462.smt2",
    "description": "The file is a 3 KB SMT‑LIB 2.6 benchmark in the **BV** logic, generated by **Ultimate Automizer** from an SV‑COMP 2017 C program (category = industrial, family = Heizmann‑UltimateAutomizer, 3834 characters, 2 top‑level asserts, 3 declared 32‑bit bit‑vectors).  \nIt encodes the verification condition for a *true‑unreach‑call* / *no‑overflow* property: three global constants (`c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`) model program variables, while the quantified variables (`v_subst_*`, `|main_#t~nondet*|`) stand for symbolic substitutions and nondeterministic inputs introduced by the automata‑theoretic encoding.  \nThe first assert states that **for all** such substitutions the expression  \n\n```\nbvadd (bvneg (bvadd 4·v5 + y + 4·nondet1))\n      (bvneg (bvadd 4·v6 + 4·nondet0 + x))\n      + 1\n```\n\nis never equal to  \n\n```\nz + 8·v4 + 8·nondet2 .\n```  \n\nThe second (negated) assert combines a similar universally quantified inequality with an additional disjunct that checks whether a specific linear combination of `x`, `y`, `z`, and the nondet variables equals 0 (mod 2³²).  \nThus the whole formula is satisfiable iff the program **does not** violate the intended safety invariant; the solver is asked to prove unsatisfiability, i.e., that the encoded reachability/overflow condition cannot occur.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer from the SV‑COMP 2017 industrial “true‑unreach‑call + no‑overflow” category (file jain_4_true‑unreach‑call_true‑no‑overflow.i_433.smt2). It declares three 32‑bit constants c_main_~x~5, c_main_~y~5 and c_main_~z~5 that model program variables, and contains two quantified assertions. The first universally quantifies three nondeterministic 32‑bit values and asserts that a specific linear combination of the constants and the nondet values (using multiplications by 4 and 8) can never be equal to another linear combination plus 1, i.e. it encodes a safety property that a certain arithmetic relation is unreachable. The second assertion negates a similar universal property, effectively searching for a concrete instantiation (an existential witness) that either violates the same equality or makes the sum of all terms equal to 0 modulo 2³² (the term bvadd … 4294967295 represents an overflow‑to‑‑1 check). The problem is small (≈2.8 KB, 2 asserts, 3 declared constants) but features nested quantifiers and non‑trivial bit‑vector arithmetic, which makes quantifier instantiation the primary difficulty for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_240.smt2",
    "description": "The script is a 32‑bit bit‑vector (BV) formula generated by Ultimate Automizer from the SV‑COMP 2017 “jain” benchmark (file jain_7_true‑unreach‑call_true‑no‑overflow.i).  It declares three 32‑bit constants c_main_~x~5, c_main_~y~5 and c_main_~z~5 that correspond to program variables, and then asserts two universally quantifiedconstraints.  \n\nThe first ∀‑quantifier states that, for all nondeterministic values |main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2|, a linear combination of the constants and the nondet values (built with bvadd and bvmul) must be *distinct* from another linear combination involving c_main_~z~5.  The second ∀‑quantifier (inside a negated conjunction) adds a case split: either the same distinctness condition holds for a more elaborate expression containing extra substitution variables, **or** a specific equality forces a certain weighted sum of the variables to be exactly zero.  \n\nThe outer (not (and …)) turns the whole property into a reachability query: the solver is asked whether there exists a model violating both universal conditions simultaneously.  The formula is pure BV arithmetic with large constant coefficients, three declared symbols, three quantifiers, and a modest depth (max term depth 8), typical of automated software‑verification encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) generated by the Ultimate Automizer tool from an SV‑COMP 2017 industrial benchmark (file jain_4_true‑unreach‑call_true‑no‑overflow.i). It contains three declared constant bit‑vectors (named *x*, *y* and *z*) together with three universally quantified nondeterministic variables, and the total size of the script is about 2.8 KB with two quantified assertions. The first assertion states that a specific linear combination of the nondet variables and the constants can never equal a particular value (expressed with a `not (= …)`), while the second assertion is the negation of a universally quantified disjunction that mixes a summed equality with a shifted equality involving auxiliary substitution variables. Together they encode the negation of a safety property (reachability of an error state) that Ultimate Automizer tries to prove unsatisfiable, i.e., that the error location is unreachable and no integer overflow can occur. The formula is notable for its use of several nested `bvadd`, `bvmul` with constant factors (4, 8) and multiple quantifiers, which makes it a relatively challenging instance for quantifier‑capable BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_2400.smt2",
    "description": "The script is a BV‑logic benchmark (bit‑vector arithmetic) generated by Ultimate Automizer from the SV‑COMP 2017 “sendmail” benchmark (category industrial, file verisec_sendmail__tTflag_arr_one_loop_false‑unreach‑call.i).  It models a single loop of the program with a 32‑bit integer variable c_main_~i~5 (the loop counter) and an 8‑bit array element main_~c~5 that is constrained to the ASCII digit range ‘0’..‘9’ (48 ≤ value ≤ 57).  The body of the script consists of a handful of quantified formulas that state, for every possible digit value and every possible substitution of the array element, a linear inequality of the form  \n\n\\[\n10\\cdot(10\\cdot(\\dots 10\\cdot i + (c-48))\\dots)+(v-48) \\ge 0\n\\]\n\nmust hold; these inequalities are encoded with extensive use of zero‑ and sign‑extension to compare 8‑bit and 32‑bit terms.  An equality c_main_~i~5 = c_main_~i~5_primed + 4294967295 (i.e. c′ = c − 1) represents the effect of one loop iteration, and the final assertion negates a universal condition, asking the solver to find a state that violates the inequality after the iteration—i.e., to show that the “false‑unreach‑call” error is reachable.  The file is relatively small (≈7 KB, 3 asserts, 2 declared constants, max term depth 16) but heavily uses quantifiers and bit‑vector extensions, which is characteristic of automated software‑verification encodings produced by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark generated by **Ultimate Automizer** from the SV‑COMP 2017 industrial suite (family Heizmann‑UltimateAutomizer, size ≈ 3.6 kB, 2 top‑level assertions and three declared constants c_main_~x~5, c_main_~y~5, c_main_~z~5).  It encodes a verification condition for a C program where the three constants model the program’s integer variables x, y and z, and the universally quantified variables v_subst_* and |main_#t~nondet*| model arbitrary substitutions and nondeterministic inputs.  The first quantified clause asserts that either a linear combination of these quantities (with large 32‑bit constants such as 4294967294, 4294967288, 8, 4) equals 0, or two other linear combinations are distinct – a typical encoding of a safety property (e.g., absence of overflow or reachability of a bad state).  The outer assertion negates the conjunction of the same clause and an additional “distinct” condition, thereby asking whether a state violating the safety property can be exhibited.  Consequently, the solver is asked to check **sat** of the negated property; a SAT answer would correspond to a concrete counterexample showing the program can reach an unsafe configuration.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_253.smt2",
    "description": "This instance is a 4 KB BV‑logic benchmark (4299 characters, 9 bit‑vector constants, 3 quantified assertions) generated by the Ultimate Automizer tool from a SV‑COMP 2017 industrial benchmark (category *industrial*, family *Heizmann‑UltimateAutomizer*).  The script models a single program step: three nondeterministic 32‑bit inputs (|c_main_#t~nondet0|, |…1|, |…2|) update the program variables x, y, z via linear combinations with large constant multipliers (e.g., bvadd (bvmul 1048576 |c_main_#t~nondet0|) x).  The core property is expressed with two universally‑quantified clauses: the first demands that a large linear expression over the *pre‑state* variables is distinct from another expression involving z, while the second allows either that distinctness holds or that a different linear combination evaluates to zero.  The final assertion negates the same condition for the *post‑state* (primed) variables, turning the verification task into a check‑whether a reachable state can violate the original invariant.  Hence the solver must decide the unsatisfiability of the negated universally quantified invariant under the given transition relation, a challenging bit‑vector problem involving heavy multiplication and quantifier instantiation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_70.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer for an SV‑COMP 2017 industrial case; it contains 9 declared constants, 3 assertions and about 3 k characters of SMT‑LIB code.  The first assertion encodes a transition relation: the primed program variables x, y and z are updated by adding a scaled nondeterministic 32‑bit value ( 2²⁰, 2²¹ and 2²² respectively) to their current values.  The second assertion universally quantifies over three fresh nondeterministic constants and requires that two linear combinations of the (unprimed) variables are distinct, i.e. a safety invariant holds in the pre‑state.  The third assertion negates an analogous universally‑quantified distinctness condition on the primed variables, asking whether the invariant can be violated after one transition.  Thus the script checks the unsatisfiability of a “reach‑a‑bad‑state” condition, essentially proving that the program cannot reach a state where the invariant fails.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_459.smt2",
    "description": "The file is a BV‑logic benchmark (size ≈ 4 kB, 3 declared 32‑bit variables c_main_~x~5, c_main_~y~5, c_main_~z~5) generated by Ultimate Automizer from the SV‑COMP 2017 “jain_6” C benchmark. It encodes a safety‑property check: the first assertion states that for all possible nondeterministic 32‑bit values (|main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2|) a certain linear combination of the program’s variables and the nondet values must be distinct from another linear combination involving c_main_~z~5. The second, negated, assertion requires that a conjunction of three universally quantified clauses—each expressing either an equality to zero or a distinctness of similar weighted sums—holds; the outer not turns the whole formula into “is there a valuation of x, y, z that makes the universal constraints false?”, i.e., a reachability/unsatisfiability query. All arithmetic uses only constant multiples (mostly 4294967288 = ‑8, 4294967294 = ‑2, etc.) and additions, so the constraints are essentially linear equations over 32‑bit bit‑vectors with heavy quantifier nesting. This pattern is typical for automata‑based verification where Floyd‑Hoare automata are encoded as quantified bit‑vector relations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_408.smt2",
    "description": "This script is a BV‑logic benchmark (size ≈ 2 KB, 2 quantified assertions, 1 declared 32‑bit constant) generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite.  The only uninterpreted symbol is `c_main_~y~5 : (_ BitVec 32)`, and the problem consists of two universally‑quantified formulas over three 32‑bit variables (`v_subst_3`, `v_subst_2`, `|main_#t~nondet0|`).  \n\nThe first assertion states that for every choice of the three variables the expression  \n\n```\nc_main_~y~5 + 2·v_subst_3 + 2·v_subst_2 + 2·|main_#t~nondet0|\n```  \n\nis either non‑zero or, if the two‑term sum  \n\n```\nc_main_~y~5 + 2·|main_#t~nondet0|\n```  \n\nequals zero.  The second assertion negates a similar universal property that the three‑term sum (without the `v_subst_3` term) is always distinct from zero.  \n\nThus the solver is asked to decide whether the constant `c_main_~y~5` can be chosen so that the two quantified constraints are simultaneously satisfied (i.e., whether the negated universal property is violated).  The instance showcases a typical “existential counterexample to a universally quantified arithmetic property” that arises in automata‑based software verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_307.smt2",
    "description": "This instance is a 32‑bit bit‑vector formula (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial benchmark suite (file jain_7_true‑unreach‑call_true‑no‑overflow.i). It declares three program variables c_main_~x~5, c_main_~y~5 and c_main_~z~5 and contains two quantified assertions: the first universally quantifies three nondeterministic inputs and requires two large linear combinations of the variables (built from bvadd and bvmul with big constants) to be distinct; the second is the negation of a similar universally quantified property, stating that either the two combinations differ or a specific weighted sum of the variables equals zero. The overall query therefore asks whether the negated universal property is satisfiable, i.e., whether there exists an execution that violates the intended invariant (an unreachability check). The formula is relatively small (≈3 kB, three declared constants, two asserts) but uses many high‑depth bit‑vector multiplications and two nested quantifiers, which makes it a typical challenging benchmark for QF_BV‑with‑quantifiers solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_469.smt2",
    "description": "This benchmark is a Bit‑Vector (BV) instance generated by Ultimate Automizer for the SV‑COMP 2017 industrial category, consisting of 2 constant declarations and 3 quantified assertions in a script of about 3 KB (size 2939, max term depth 9).  The formula encodes a safety‑property check for a C‑program: two 32‑bit constants (named `main_~x~5_const_-993908852` and `main_~y~5_const_-993907773`) model fixed program data, while the symbolic inputs `|main_#t~nondet0|` and `|main_#t~nondet1|` represent nondeterministic values read at runtime.  The first universal assertion states that for all choices of auxiliary variables the equality between two linear BV‑expressions (a sum of doubled terms plus the constants) either does not hold or the sum of the constants plus an all‑ones mask equals zero, capturing a potential overflow/underflow condition.  The second universal assertion directly forbids a specific equality between a negated linear expression (offset by 1) and another linear expression, thus expressing the intended “unreachable” condition.  Finally, the third assertion negates a universal non‑equality, turning the overall problem into an existence check: it asks whether there exists a choice of the quantified variables that violates the safety condition, so the SAT result determines whether the original program contains a reachable error.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_3_true-unreach-call_true-no-overflow.i_1105.smt2",
    "description": "This instance is a 2‑assertion BV‑logic formula (≈3 KB, 2985 characters) generated by Ultimate Automizer from the SV‑COMP 2017 “gcd_3” benchmark, and it belongs to the industrial category of the Heizmann‑UltimateAutomizer family.  \nThe three 8‑bit bit‑vector constants model the inputs of a Euclidean‑algorithm implementation of gcd: a (|c_gcd_test_#in~a|), the current value of a (c_gcd_test_~a) and the current value of b (c_gcd_test_~b).  \nThe first assertion states the loop‑invariant of the algorithm: whenever the initial a is positive, for every possible b the signed remainder calculations (via **bvsrem**, **bvneg**, **sign_extend**, **extract**) must satisfy the classic Euclidean property that the remainder is non‑negative, smaller than a, and that a divisor relationship holds.  \nThe second assertion is the negation of the same invariant together with the termination condition (either b becomes zero or the remainder of a mod b is at least as large as a), turning the whole query into a proof‑by‑contradiction that the invariant can never be violated.  \nThus the solver is asked to prove unsatisfiability, i.e., to show that the Euclidean‑algorithm implementation never reaches an error state (no overflow, no false‑unreachability) for any 8‑bit inputs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_true-unreach-call_true-no-overflow.i_415.smt2",
    "description": "This benchmark is a BV‑logic instance (32‑ and 64‑bit bit‑vectors) generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark (file sum02_true‑unreach‑call). It declares the loop counter `c_main_~i~6`, the bound `c_main_~n~6`, the current partial sum `c_main_~sn~6` (as a 64‑bit value) and the closed‑form “Gauss” sum `c_main_~gauss~6`. The assertions encode the standard loop invariant for the summation program “sn = i·(i+1)/2”: the first conjunct updates `sn` by adding `i`, while three quantified conjuncts state that for any possible bound n the invariant holds before and after the increment, and that when `i ≤ n` the sum equals the Gauss formula. The final assertion negates the condition that the updated sum (`sn'`) is either zero or exactly the Gauss value, so the solver is asked whether a state violating the invariant can exist. The instance is small (≈3 kB, 3 asserts, 5 constants) and is meant to prove that the program’s sum computation never reaches an incorrect, non‑zero, non‑Gauss result.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_476.smt2",
    "description": "This SMT‑LIB script is a bit‑vector (BV) encoding of a safety‑property check generated by the Ultimate Automizer tool for a SV‑COMP 2017 benchmark (the file *jain_7_true‑unreach‑call_true‑no‑overflow.i*). It works over 32‑bit unsigned variables `c_main_~x~5`, `c_main_~y~5` and `c_main_~z~5`, together with several nondeterministic inputs (the `|main_#t~nondet*|` symbols) that model arbitrary program data. The first assertion states that, for every choice of three nondet values, a linear combination of the program variables and those inputs must be **distinct** from another linear combination involving `c_main_~z~5`, thereby encoding the intended invariant of the original program. The second (negated) forall asserts that there exists an instantiation of a larger set of variables where either the same distinctness fails or a specific equality to zero holds; its negation is used to express the violation of the invariant and thus the reachability of an error state. The problem contains only two quantified formulas (one positive, one negated) with moderate term depth (7) and a total of 3034 characters, typical for automatically generated verification conditions from industrial C programs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_341.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite; it contains 2 quantified assertions over 2 declared constants and has a modest size of about 2 KB (2182 characters, max term depth 9).  The script encodes a classic “unreach‑call/overflow” verification condition: two universally quantified equalities compare a linear combination of nondeterministic 32‑bit inputs (scaled by 2) with the constant expressions c_main_~x~5 and c_main_~y~5, each shifted by +1 or –1.  The first assert states that for all choices of the auxiliary variables the two sides are *never* equal, while the second assert negates a similar universal claim, effectively asking whether there exists a pair of nondeterministic inputs that makes the equality hold.  By asserting the negation of the universal property and then calling check‑sat, the instance asks the solver to find a concrete counterexample that violates the intended safety invariant.  The benchmark is thus a small, quantifier‑heavy test of BV arithmetic handling and unsat‑core generation in the context of software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_228.smt2",
    "description": "The script is a 32‑bit Bit‑Vector (BV) benchmark generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark (file jain_2_true‑unreach‑call_true‑no‑overflow.i). It contains only two declared constants (the program variables x and y) and two quantified assertions; the first universally quantifies over four auxiliary bit‑vectors and forces either an inequality between two linear BV‑expressions or a specific wrap‑around equality, while the second asserts the negation of a universal condition, i.e., it requires the existence of nondeterministic values that make two linear expressions exactly equal. Together they encode the safety property “the program cannot reach a state where a certain linear combination of x, y and nondeterministic inputs coincides,” and the outer (not forall…) turns the check into a search for a counterexample. The problem is modest in size (≈2.4 kB, 2 asserts, term depth 9) but uses quantifiers, BV addition/multiplication, and negation, which makes it a typical challenging case for BV solvers in the competition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_475.smt2",
    "description": "This instance is a 32‑bit bit‑vector formula (logic BV) generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark (category industrial, size ≈ 3 KB, 3 declared 32‑bit variables c_main_~x~5, c_main_~y~5, c_main_~z~5).  The script encodes the verification of a safety property as a pair of quantified constraints: a universal clause that, for all auxiliary variables and nondeterministic inputs, requires either a large linear combination of the program variables to be different from another combination or a specific equality to hold, and a second clause asserting the negation of a simpler universally quantified distinctness condition.  In effect the second assertion asks for a concrete assignment to the nondeterministic inputs that makes two linear bit‑vector expressions equal, i.e., it searches for a counterexample to the original safety claim.  The formula therefore reduces the reachability/overflow check to a SAT query over quantified bit‑vector arithmetic with many constant multipliers (e.g., 4194304, 4290772992) and a maximum term depth of 6.  The overall problem is to decide whether the negated property is satisfiable, which corresponds to proving the original program unsafe.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_387.smt2",
    "description": "This script is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 industrial benchmark suite (file jain_6_true‑unreach‑call_true‑no‑overflow.i). It declares three 32‑bit input constants c_main_~x~5, c_main_~y~5, c_main_~z~5 and then states two universally quantified clauses. The first clause requires that a linear combination of the three inputs and three nondeterministic bit‑vectors be distinct from another linear combination involving c_main_~z~5; the second clause (inside a negated disjunction) asserts either a similar distinctness property with extra symbolic substitutions or a concrete equality c_main_~z~5 + 2·c_main_~y~5 + 4·c_main_~x~5 + 4294967292 = 0. The overall formula checks whether the negation of this disjunction is satisfiable, i.e., whether the safety property encoded by the distinctness/equality constraints can be violated. Notably, the instance uses only bit‑vector linear arithmetic with large constants (e.g., 4294967294 ≡ ‑2 mod 2³²) and features two nested forall quantifiers, a modest term depth (7), and a total of 2 assertions over 3 declared constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "The file is a BV‑logic benchmark (2 322 characters, 2 declarations, 2 assertions) generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite (the “jain_2” C program).  It encodes a safety‑property check: the solver is asked to prove that a particular arithmetic relation on the 32‑bit program variables `c_main_~x~5` and `c_main_~y~5` together with two nondeterministic 32‑bit inputs can never hold.  The first assertion universally quantifies over auxiliary bit‑vector variables and states that either a large linear combination of the program variables and the nondeterministic inputs is **not** equal to a shifted negated combination, or a second equality involving a wrap‑around constant (`0xFFFFFFFF`) holds.  The second assertion negates the disjunction of a simple equality (`c_main_y + c_main_x + 0xFFFFFFFF = 0`) and a universally‑quantified version of the same relational condition, thus requiring the solver to find a contradiction.  In effect the instance checks the unreachability of an overflow/invalid‑state condition using only bit‑vector addition, multiplication by the constant 2, and negation, with a maximum term depth of 10.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_464.smt2",
    "description": "The script is a 32‑bit bit‑vector benchmark (logic BV) generated by the Ultimate Automizer tool from an SV‑COMP 2017 industrial program (the file *jain_2_true‑unreach‑call_true‑no‑overflow*).  It declares two 32‑bit constants, `c_main_~x~5` and `c_main_~y~5`, which model the program’s global variables, and several universally quantified variables that stand for nondeterministic inputs and intermediate substitutions.  The core of the encoding consists of three universally quantified Hoare‑style conditions that relate linear expressions of the form `2·v + const` on the left‑hand side to a negated sum on the right‑hand side, plus a final wrap‑around clause (“ … + 0xffffffff = 0 ”) that captures a potential overflow/under‑flow violation.  The outermost assertion negates the conjunction of these three universal properties and asks the solver to check satisfiability; a **unsat** result corresponds to the program’s safety claim (no reachable error state) being proved.  The instance is modest in size (≈3.4 KB, 2 declares, 2 asserts, max term depth 11) but features a dense use of quantifiers and bit‑vector arithmetic typical for automated software‑model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_407.smt2",
    "description": "The script is a 32‑bit bit‑vector (BV) verification query generated by **Ultimate Automizer** from the SV‑COMP 2017 benchmark *jain_1* (category “industrial”).  It declares a single 32‑bit constant `c_main_~y~5` (the value of a program variable) and reasons about an unconstrained nondeterministic input `|main_#t~nondet0|`.  The first axiom states that **for every** possible nondeterministic value the linear term  \n\n\\[\nc\\_main\\_~y~5 \\;+\\; 2\\cdot |main\\_#t~nondet0|\n\\]\n\nis never equal to zero, i.e. the program never reaches a state where that sum vanishes.  The second, negated universal clause checks whether there exist three nondeterministic values (`v_subst_3`, `v_subst_2`, `|main_#t~nondet0|`) such that either the expanded sum  \n\n\\[\nc\\_main\\_~y~5 \\;+\\; 2\\cdot v\\_subst\\_3 \\;+\\; 2\\cdot v\\_subst\\_2 \\;+\\; 2\\cdot |main\\_#t~nondet0|\n\\]\n\nis non‑zero **or** the original two‑term sum equals zero; the outer `not` turns this into a search for a counter‑example to the intended invariant.  In effect the formula encodes a reachability/overflow property of the original C program: it asks whether the invariant “the sum `c + 2·nondet` is never zero” can be violated when additional nondeterministic increments are added.  The instance is small (≈2 k characters, depth 7) and contains only two quantified assertions over BV arithmetic, making it a typical benchmark for automated software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_409.smt2",
    "description": "The script is a bit‑vector (BV) verification condition generated by the Ultimate Automizer tool from an SV‑COMP 2017 industrial benchmark (file jain_1_true‑unreach‑call_true‑no‑overflow.i_409.smt2).  It contains a single 32‑bit constant c_main_~y~5 and three universally quantified 32‑bit variables that model nondeterministic program inputs; the main check is whether a certain linear combination of these values can ever equal 0.  The first assertion states that for **all** choices of two of the variables the expression `c_main_~y~5 + 2·v_subst_2 + 2·|main_#t~nondet0|` is never zero, i.e. the program invariant holds.  The second, negated assertion encodes the negation of the safety property: it requires that there exist values for three variables such that either the same expression extended with a third term is non‑zero **or** the simpler two‑term expression *is* zero, and the outer `not` forces the solver to look for a counterexample.  Satisfiability of the whole file therefore answers the reachability‑unreachability question for the original C program; the instance is small (≈2 KB, 2 assertions, max term depth 7) but features quantified bit‑vector arithmetic, which is a typical challenging pattern for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "The script is a 32‑bit bit‑vector problem (logic BV) of about 3 KB generated by Ultimate Automizer from the SV‑COMP 2017 industrial benchmark suite (file jain_6_true‑unreach‑call_true‑no‑overflow.i). It declares three program variables x, y, z (each a 32‑bit BitVec) and several nondeterministic 32‑bit constants that model unknown inputs of the original C program. The first assertion is a universally quantified disjunction that links the three variables and the nondet symbols with a series of bvadd and bvmul operations, essentially encoding the program’s transition relation together with a “distinct” safety‑property condition. The second assertion negates a simpler safety condition (a combination of x, y, z and nondet values equal to 0 together with a distinctness test), turning the whole formula into a reachability‑check: the formula is satisfiable iff a counterexample violating the original property exists. Notably, the problem uses many large unsigned constants (e.g., 4294967294) and two quantified formulas, which make it a challenging case for BV solvers despite its modest size (3 KB, 2 assertions, 3 declared constants).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification condition generated by the Ultimate Automizer tool from an SV‑COMP 2017 industrial benchmark (file jain_2_true‑unreach‑call_true‑no‑overflow.i_435.smt2, size ≈ 2.5 KB, 2 declarations, 2 top‑level asserts, max term depth 10).  It works in the BV logic and encodes a reachability/overflow check for a C program that uses two nondeterministic 32‑bit inputs (|main_#t~nondet0|, |main_#t~nondet1|) together with two program variables c_main_~x~5 and c_main_~y~5.  The first assertion universally forbids a specific linear equation involving doubled terms and a constant offset of 1, while the second asserts (by negating a universal) that there exists a valuation where either that equation fails or an overflow‑related equality (adding 0xFFFFFFFF yields zero) holds.  Together the formula asks whether a state violating the intended safety property (no overflow and the forbidden equality) is reachable; satisfiability would indicate a counterexample.  Notably, the problem mixes quantifiers, arithmetic multiplications by the constant 2, and a wrap‑around constant, making it a non‑trivial bit‑vector verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_200.smt2",
    "description": "This file is a BV‑logic SMT‑LIB 2.6 benchmark generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite (benchmark *jain_4*), it contains 3 32‑bit bit‑vector constants, two top‑level assertions and a total size of about 2.8 KB.  The problem encodes a safety property of a C function that uses three nondeterministic 32‑bit inputs (shown as |main_#t~nondet0|, |…1|, |…2|) and three program variables c_main_~x~5, c_main_~y~5, c_main_~z~5.  The first assertion states a universally quantified invariant: for any auxiliary substitutions v_subst_i and any nondet values, the weighted sum  \n\n```\nz + y + 4·nondet0 + 8·nondet2 + x + 4·nondet1 + 0xFFFFFFFF\n```  \n\nmust be zero (mod 2³²) or else a derived inequality between two linear expressions must hold.  The second assertion negates the disjunction of a concrete “zero‑sum” condition and the same universally quantified inequality, i.e. it asks the solver to find a concrete assignment that violates the invariant.  Thus the check‑sat query asks whether the program can reach a state where the invariant fails—essentially a reachability/overflow verification condition for the original C code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_266.smt2",
    "description": "The script is a 2‑KB BV‑logic benchmark generated by Ultimate Automizer for the SV‑COMP 2017 industrial track (benchmark *jain_4*). It declares three 32‑bit bit‑vector constants `c_main_~x~5`, `c_main_~y~5` and `c_main_~z~5`, which correspond to program variables, and uses several nondeterministic 32‑bit inputs. The core of the model consists of two universally quantified clauses: the first asserts that for **all** nondet values a specific linear equation involving the constants and the multipliers 4, 8 and the constant 1 never holds; the second is the negation of another universal statement that either a summed term equals ‑1 (mod 2³²) or a second linear equality between the same terms holds. Together these clauses encode a safety (unreachability) property of the original C program, checking that a certain arithmetic relation—potentially indicating an overflow or an error state—cannot be satisfied for any execution. The instance features modest quantifier depth (max term depth 10) but many bit‑vector multiplications (12) and additions, illustrating how Ultimate Automizer translates program arithmetic into quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) SMT‑LIB 2.6 script (≈3 kB, 2 assertions, 3 declared constants) generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite.  It encodes a tiny piece of C code that defines three global 32‑bit variables `x`, `y`, `z` and relates them through linear expressions built with the constants 4 and 8 and several nondeterministic inputs (`|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|`).  The first assertion universally quantifies over all substitution variables and nondeterministic values and states that a specific equality between two such linear expressions (offset by 1) never holds.  The second assertion negates a similar universally‑quantified formula and adds a disjunct that checks a different equality, thereby asking whether there exists a concrete assignment that violates the intended invariant.  Consequently, the `(check‑sat)` query answers the “unreachable‑call” verification condition: it is satisfiable exactly when a reachable state contradicts the arithmetic invariant.  The instance is notable for its nested quantifiers, extensive use of `bvmul` by constant factors, and the `bvneg`/`bvadd` pattern that models subtraction, making it a representative small‑scale arithmetic challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3235.smt2",
    "description": "The file is a 2‑KB Bit‑Vector (BV) benchmark generated by the Ultimate Automizer tool from an SV‑COMP 2017 C benchmark that verifies a tiny multiplication routine.  \nIt works in the BV logic, declares two 32‑bit constants – an input `|c_mult_#in~m|` and a result `|c_mult_#res|` – and contains a single, heavily quantified assertion.  \nThe assertion fixes the input to zero, forces the result to zero, and then uses a `forall … (or …)` pattern together with an inner `exists` to encode the fact that multiplication by the constant 2 is injective (i.e., if 2·x = 2·y then x = y, otherwise the sum x + y differs from the product).  \nThus the SMT problem asks whether the commutativity/injectivity property of the 32‑bit multiplication by 2 holds for all possible values under the given pre‑ and post‑conditions.  \nAlthough the script is tiny (2 declarations, 1 quantified assertion), the nesting of universal and existential quantifiers with bit‑vector arithmetic makes it a non‑trivial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial benchmark suite (family Heizmann‑UltimateAutomizer, file jain_2_true‑unreach‑call_true‑no‑overflow.i_433.smt2).  It declares two 32‑bit constants, c_main_~x~5 and c_main_~y~5, which model the program’s global integer variables, and uses two universally quantified nondeterministic inputs (|main_#t~nondet0|, |main_#t~nondet1|).  The first assertion states that, for every choice of these inputs, a particular linear equality (involving c_main_~x~5, c_main_~y~5, a multiplication by 2 and a “‑1” offset) never holds; the second assertion negates a similar universally quantified property that would force two differently arranged linear combinations of the same variables to be equal, thereby searching for a concrete counter‑example.  In effect the script encodes a safety‑property check (no‑overflow/ unreachability) by asserting that no assignment to the quantified variables can satisfy the target arithmetic relation.  Although the instance is tiny (2 asserts, 2 declared constants, ≈2 kB, max term depth 10), it features nested quantifiers and mixed addition/multiplication, which make it a non‑trivial challenge for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_214.smt2",
    "description": "This file is a 2 KB BV‑logic benchmark (logic BV, 3 declared 32‑bit bit‑vectors, 2 assertions, term depth 6) generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark.  The script models a single program step: a nondeterministic 32‑bit input `|c_main_#t~nondet0|` is multiplied by 2 and added to the current value `c_main_~y~5`, yielding the primed variable `c_main_~y~5_primed` (the assignment `y' = 2·nondet + y`).  A universally quantified formula then states that for every choice of a second nondeterministic value `v_subst_1` and a fresh input `|main_#t~nondet0|`, either the expression  \n`y + 2·v_subst_1 + 2·|main_#t~nondet0|` is non‑zero, or the simpler expression `y + 2·|main_#t~nondet0|` equals zero.  Together these constraints encode a safety property (absence of a particular overflow or bad state) that the verifier checks with a single `check‑sat`.  The benchmark exemplifies the typical bit‑vector arithmetic and quantified reasoning that Ultimate Automizer produces for software model‑checking tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial suite (benchmark *jain_4_true‑unreach‑call_true‑no‑overflow.i*). It declares three 32‑bit program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` and encodes the program’s transition relation with three universally quantified nondeterministic inputs. The first assertion states that, for **all** choices of the three nondet variables, a certain linear combination of the program variables (involving multiplications by the constants 4 and 8 and a unit increment) can never be equal to another linear combination; i.e. a specific erroneous arithmetic relation is unreachable. The second assertion negates a similar universally quantified formula that also allows additional substitution variables, thereby asking the solver to find a concrete instantiation that violates the “unreachable” property. Satisfiability of the whole script thus corresponds to the existence of a counter‑example execution leading to the forbidden arithmetic condition, and the formula features deep (depth 9) bit‑vector arithmetic with nested `bvadd`, `bvmul` and `bvneg` operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_223.smt2",
    "description": "The script is a 2 KB Bit‑Vector (BV) benchmark generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial suite (file * jain_2_true‑unreach‑call_true‑no‑overflow.i*). It works in the quantifier‑rich BV logic, declaring two 32‑bit constants `c_main_~x~5` and `c_main_~y~5` that correspond to program variables, and contains two top‑level assertions. The first assertion universally quantifies over two nondeterministic 32‑bit values and states that the linear equality  \n\n```\n2·nondet0 + x  =  –(y + 2·nondet1) + 1\n```  \n\ncan never hold; the second assertion is the negation of a conjunction of the same universally‑quantified inequality together with a second quantified clause that expresses a potential witness for the equality after a substitution, essentially encoding the negated reachability condition. The overall `check‑sat` therefore asks whether a counterexample to the “unreachable‑call / no‑overflow” property exists; unsatisfiability would confirm that the program cannot reach the error state. Notably, the problem mixes several nested quantifiers with bit‑vector addition and multiplication, leading to a relatively deep term structure (max depth 11) and making it a typical challenge for quantifier‑handling procedures in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_2674.smt2",
    "description": "This instance is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from an SV‑COMP 2017 benchmark that verifies a C program exercising multiplication. It declares two 32‑bit constants—`c_mult_#in~m` (the first operand) and `c_mult_#res` (the expected result)—and asserts that the first operand is exactly zero. The sole assertion then quantifies universally over the second operand and over intermediate values, and contains an existential sub‑formula; together they encode that multiplying any 32‑bit value by the constant 2 is injective (no two different inputs yield the same doubled value) and that the doubled value cannot be expressed as the sum of certain intermediate terms, i.e. it captures commutativity and the absence of overflow for the multiplication. The formula uses nested `forall`/`exists`, `bvmul`, `bvadd`, `distinct`, and equality predicates, giving a shallow term depth (8) but a non‑trivial quantifier structure. Because it stems from an industrial benchmark (category “industrial”, family “Heizmann‑UltimateAutomizer”) and contains only one large quantified assertion, it serves as a concise yet challenging test for BV solvers with quantifier handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_433.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector verification condition generated by **Ultimate Automizer** from an SV‑COMP 2017 industrial benchmark (the “jain” program).  It uses the BV logic, contains 3 declared 32‑bit constants `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`, and two quantified assertions of depth 7 that combine these constants with several nondeterministic 32‑bit terms (`|main_#t~nondet0|`, …) through linear‑integer‑style expressions built from `bvadd` and `bvmul` with large constant coefficients.  The first assertion requires that a particular weighted sum of all terms be **distinct** from another weighted sum involving `c_main_~z~5`; the second (negated) assertion states that either a different weighted sum equals zero **or** the same distinctness condition fails.  Together they encode the negation of a safety property (unreachability of a bad state or overflow) so that the whole problem is unsatisfiable exactly when the original program satisfies the property.  The script is compact (≈ 3 kB, 2 asserts, 24 `bvmul` occurrences) and omits model‑extraction commands to comply with SMT‑COMP restrictions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.c_415.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 4 bit‑vector constants, 3 asserts, 4 declared 32‑bit variables) generated by Ultimate Automizer from the SV‑COMP 2017 C benchmark *sum02_false‑unreach‑call_true‑no‑overflow.c*.  It encodes the verification condition for a simple loop that accumulates the sum ≈ i + … + n, where `c_main_~i~5` is the loop counter, `c_main_~n~5` the upper bound and `c_main_~sn~5` the running total; `c_main_~sn~5_primed` denotes the total after one loop iteration.  The first assertion states the loop guard (`i ≤ n`) and the update rule `sn' = sn + i`.  The second assertion captures the intended loop invariant: either the total equals the closed‑form formula `n·(n+1)/2` (or is zero), and it is shown to be inductive by a quantified clause that must hold for every possible bound `main_~n~5`.  Finally the script asserts the negation of this invariant for the post‑state and asks the solver to check‑sat, i.e. it looks for a counterexample that violates the sum invariant after one iteration.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_61.smt2",
    "description": "The file is a small (≈2.5 KB, 2 asserts, 3 declared 32‑bit bit‑vectors) BV‑logic benchmark generated by the **Ultimate Automizer** tool from the SV‑COMP 2017 industrial suite.  Three program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` are declared together with three nondeterministic 32‑bit inputs, and a universally quantified clause states that a linear combination of the inputs and the variables (`2·y + 4290772992·n0 + 4294967292·x + 4194304·n1 + 1048576`) must always be distinct from another linear combination (`z + 4194304·n2`).  The second top‑level assertion negates a conjunction of the same universal clause and a second distinctness condition (`z + 4294967294·y + 4·x + 4293918720 ≠ 0`).  Because the universal clause is forced true by the first assert, the negation reduces to requiring the second linear expression to equal zero, i.e., it checks whether the program can reach a state violating that safety inequality.  Thus the instance encodes a classic *reachability‑/assert‑violation* check for a piece of C code translated into bit‑vector arithmetic, with the only non‑trivial feature being the use of quantified distinctness constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 “jain” benchmark, classified as an industrial safety check. It declares three program variables c_main_~x~5, c_main_~y~5 and c_main_~z~5 together with several nondeterministic inputs (the |main_#t~nondet*| symbols) and asserts two quantified formulas. The first forall states that a specific linear combination of the program variables and nondet values—built with large unsigned coefficients close to 2³²—must be distinct from another combination involving c_main_~z~5, thus encoding a relational invariant. The second assertion is the negation of a forall that would require either a particular equality to zero or another distinctness condition to hold, effectively expressing the negated safety property the tool tries to refute. Satisfiability of the whole script therefore corresponds to a violation of the intended invariant, and the benchmark’s modest size (≈3000 characters, 2 asserts, 3 constants, term depth 7) tests the solver’s ability to handle quantified bit‑vector arithmetic with many coefficient multiplications.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "This script is a bit‑vector (`BV`) benchmark generated by the Ultimate Automizer tool on a SV‑COMP 2017 industrial C‑program (the *jain* benchmark) and contains 3 declared 32‑bit constants (`c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`).  It consists of two top‑level assertions: the first universally quantifies three nondeterministic 32‑bit variables and asserts that a linear combination of the program variables and the nondeterministic values can never be equal to another linear combination (a typical “no‑reach‑error” safety condition).  The second assertion negates a conjunction of a universally quantified clause (the same equality‑avoidance condition, but now with additional substitution variables) and a separate universally quantified clause that would force a specific modular sum to be zero, thereby encoding the negation of the safety property.  In effect the solver is asked whether there exists an assignment to the program globals and nondeterministic inputs that makes the forbidden equality hold, i.e. whether the asserted safety property is violated.  The file is relatively small (≈ 3.7 kB, 2 asserts, 3 constants, max term depth 11) and uses only simple bit‑vector arithmetic with constant multipliers 4 and 8.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_340.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) SMT‑LIB script (logic BV) generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark (category industrial, family Heizmann‑UltimateAutomizer, 2 584 characters, 2 quantified asserts). It declares three program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` and encodes a property about nondeterministic 32‑bit inputs (`|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|`). The first assertion universally states that a linear combination of the program variables and the nondeterministic values (with the large constants 4294967294 ≈ ‑2, 4294967288 ≈ ‑8, etc., i.e. modulo 2³²) must be distinct from another linear combination involving `c_main_~z~5`. The second assertion negates a similar universally quantified distinctness, thereby asserting the existence of a concrete assignment that makes the two expressions equal. Consequently, the whole check corresponds to a reachability/overflow query: it asks whether the program can reach a state where the two quantified expressions collide, which would violate the intended safety property. The instance uses only a handful of BV operators (13 × `bvmul`, 4 × `bvadd`) and has a modest term depth of 6.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_198.smt2",
    "description": "This file is a 2 KB BV‑logic benchmark (2675 characters, 2 quantified asserts, 3 declared 32‑bit constants) generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial suite.  The script encodes a classic *unreachability* query: a universally quantified arithmetic condition over the program’s input variables (`c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`) and three nondeterministic 32‑bit values, followed by the negation of another universal property, thus asking whether a concrete counter‑example exists.  Both constraints are pure bit‑vector equalities built from `bvadd`, `bvmul` (with the constants 4 and 8), `bvneg` and a final `+1`, expressing a linear relation that must hold for all substitutions.  Satisfiability of the whole formula therefore corresponds to the existence of a reachable state violating the intended invariant (e.g., an overflow or assertion failure).  The benchmark is notable for using only simple arithmetic operators, a shallow term depth (9), and for being produced automatically as part of an on‑demand Floyd‑Hoare automata construction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_342.smt2",
    "description": "This file is a 2 KB BV‑logic benchmark (logic = BV, 2 32‑bit constants, 2 quantified assertions) produced by Ultimate Automizer from the SV‑COMP 2017 “jain_2” benchmark.  The two declared bit‑vectors `c_main_~x~5` and `c_main_~y~5` represent program inputs that the verifier treats as fixed, while the quantified variables `|main_#t~nondet0|`, `|main_#t~nondet1|`, `v_subst_3` and `v_subst_4` model nondeterministic choices and intermediate values.  The first assertion states that for **all** choices of the two nondeterministic 32‑bit values the equality  \n\n```\n‑(2·|main_#t~nondet0| + c_main_~x~5) + 1 = c_main_~y~5 + 2·|main_#t~nondet1|\n```  \n\ndoes **not** hold; the second assertion is the logical negation of a similar universally‑quantified equality after introducing substitution variables, effectively expressing the same safety condition in a different form.  The overall goal of the script is to check the unsatisfiability of the conjunction of these two formulas, i.e., to prove that the encoded bad state (the equality) can never be reached.  Notably the benchmark uses nested universal quantifiers together with bit‑vector addition, multiplication by the constant 2 and a single negation, reaching a maximum term depth of 9, which makes it a typical quantified‑BV challenge for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_383.smt2",
    "description": "The file is a 2 585‑character BV‑logic benchmark generated by Ultimate Automizer for the SV‑COMP 2017 industrial suite (benchmark *jain_7_true‑unreach‑call_true‑no‑overflow.i*). It declares three 32‑bit variables that model the program’s integer state ( c_main_~x~5, c_main_~y~5, c_main_~z~5 ) and contains two quantified assertions, the second being the negation of a universally quantified condition. Both assertions compare two linear‑arithmetic bit‑vector expressions built from the state variables and three nondeterministic “shadow” variables, asserting that the two expressions are always distinct. The query therefore asks whether the universal “distinctness” property holds for all nondeterministic choices; a SAT result would indicate a counterexample to the safety property (i.e., the expressions can become equal). Notably, the encoding uses many large constant multipliers, a maximum term depth of six, and relies on quantifier reasoning rather than explicit unfolding, which makes it a typical example of an automata‑theoretic verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_250.smt2",
    "description": "The script is a 3‑assertion BV‑logic benchmark (size ≈ 3.8 KB, 9 bit‑vector constants, max term depth 7) generated by Ultimate Automizer from an SV‑COMP 2017 industrial benchmark. It declares three nondeterministic 32‑bit inputs (|c_main_#t~nondet0|,…,2) and three program variables x, y, z together with their “primed’’ post‑state versions. The first assertion defines the transition relation: each post‑state variable is the pre‑state value plus a large‑scale multiple (2²⁰, 2²¹, 2²²) of the corresponding nondet input. The second assertion universally quantifies over all possible nondet values and encodes an arithmetic invariant that must hold in the pre‑state – either a complex linear combination of the variables is distinct from another, or a certain linear expression equals zero. The third assertion negates the same universally‑quantified distinctness property for the post‑state, thus asking the solver to show that the transition can break the invariant (i.e., a reachable unsafe state). Consequently the instance checks a safety (unreachability) condition on a straight‑line bit‑vector program with large constant “scaling’’ factors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/sum02_false-unreach-call_true-no-overflow.i_336.smt2",
    "description": "This is a 32‑bit bit‑vector verification condition generated by **Ultimate Automizer** from an SV‑COMP 2017 benchmark (category *industrial*).  The file uses the BV logic and contains only three constants – `main_~sn~5_const_91336305` (the alleged sum), `main_~i~5_const_-993890349` (an index) and `main_~n~5_const_-993918698` (a bound) – together with five quantified and non‑quantified assertions.  \n\nThe core of the encoding expresses the classic triangular‑number invariant  \n\\[\n\\frac{n\\,(n+1)}{2}= \\text{sn}+i,\n\\]  \nand its “next‑step” version  \n\\[\n\\frac{n\\,(n+1)}{2}= \\text{sn}+2*i+1,\n\\]  \nusing bit‑vector multiplication, addition, unsigned division by 2 and unsigned ≤ comparisons (`bvule`).  The universally quantified parts range over an arbitrary `n` and enforce the invariant only when the index lies within the bound (`i ≤ n`).  \n\nTwo final constraints negate the invariant for the successor index (`i+1`) and force the sum not to be zero, turning the whole formula into a **false‑unreachability** check: the solver is asked to prove that the contradictory combination is unsatisfiable.  \n\nOverall, the instance is a small (≈3 kB, depth 8) BV formula that tests whether the triangular‑number invariant holds for all possible loop iterations of the original C program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "The instance is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 “jain_6” benchmark; it contains three declared program variables (`c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`) together with three nondeterministic 32‑bit inputs (`main_#t~nondet0/1/2`). The formula consists of two universally‑quantified clauses that relate linear combinations of these variables using large constants (e.g., 4294967288 ≈ 2³²‑8) under modular arithmetic, and a top‑level negated disjunction that asserts the existence of a valuation violating either clause. In effect the script checks the unsatisfiability of a safety condition: no assignment should make a particular weighted sum of the program variables equal to zero modulo 2³². The problem is relatively small (≈3 kB, 2 assertions, 3 constants) but features deep term nesting (depth 7) and many `bvmul`/`bvadd` operations, which makes it a typical benchmark for quantifier‑handling and bit‑vector reasoning in industrial verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_58.smt2",
    "description": "This instance is a 32‑bit bit‑vector problem (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2017 benchmark suite; it contains 9 declared constants, 3 top‑level assertions and a total file size of about 3 KB. The model describes a single program step in which three state variables x, y and z are updated to primed versions by adding respectively 2·nondet0, 4·nondet1 and 8·nondet2, where the nondet‑variables are unconstrained 32‑bit inputs. The first assertion encodes these update equations, while the second asserts that for *all* choices of three fresh nondet values the linear expression  \n\n`−2·y + (−8)·nondet0 + (−4)·x + (−8)·nondet1 + 4`  \n\nis distinct from `z + 8·nondet2`.  \n\nThe third assertion negates the same universal distinctness after the update, i.e. it requires the existence of nondet values making the two expressions equal for the primed state. Consequently the solver is asked whether the invariant “the two expressions are always different” can be violated in one transition, which is exactly the reachability‑of‑a‑bad‑state query typical for software model‑checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_225.smt2",
    "description": "This file is a 32‑bit bit‑vector verification condition generated by **Ultimate Automizer** for an industrial SV‑COMP 2017 benchmark (category “industrial”, family Heizmann‑UltimateAutomizer, 3 declared constants and 2 quantified assertions, 3370 characters in total).  \n\nThe three constants `c_main_~x~5`, `c_main_~y~5` and `c_main_~z~5` model the values of program variables at a certain program location, while the universally quantified variables `|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|` and the substitution variables `v_subst_1…3` represent arbitrary nondeterministic inputs and fresh symbolic values that may be assigned later in the execution.  \n\nThe first quantified clause states that for *all* such inputs either a particular linear combination of the constants and inputs (with coefficients 4, 8 and a `0xFFFFFFFF` term) evaluates to zero modulo 2³², or a second arithmetic relation involving negated sums and a constant 1 does **not** hold.  \n\nThe second quantified clause (inside the outer `not (and …)`) asserts the opposite of a similar linear‑equality, i.e., it demands that no input makes the two summed expressions equal.  \n\nThus the whole script asks the solver whether there exists a concrete assignment to `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` that simultaneously satisfies both universal properties – a typical “unreachability / no‑overflow” check.  \n\nThe benchmark is noteworthy for its use of nested quantifiers, many bit‑vector multiplications by small constants, and the presence of the wrap‑around constant `0xFFFFFFFF` (‑1), which together make the condition non‑trivial for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/verisec_sendmail__tTflag_arr_one_loop_false-unreach-call.i_1353.smt2",
    "description": "The file is a 5 KB SMT‑LIB 2.6 benchmark in the **BV** logic, generated by **Ultimate Automizer** from an SV‑COMP 2017 industrial benchmark (the *verisec_sendmail* program). It declares two 32‑bit bit‑vectors, `c_main_~i~5` and its primed copy, and encodes the transition `c' = c‑1` (via `bvadd … 4294967295`). The core of the formula consists of several universally‑quantified blocks that model a loop which reads an 8‑bit character `main_~c~5`, checks that it lies in the ASCII range ‘0’…‘9’ (constants 48 and 57), and updates a decimal accumulator with `acc = 10*acc + (c‑48)`. The final assertion negates the same invariant after the decrement step, asking whether the loop invariant is **not** preserved after one iteration. Thus the solver is asked to find a reachable state that violates the digit‑parsing invariant, i.e., to prove (or refute) the unreachability of an error condition in the original C program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_461.smt2",
    "description": "The script is a 32‑bit bit‑vector (BV) problem generated by the Ultimate Automizer tool from SV‑COMP 2017 benchmarks (family Heizmann‑UltimateAutomizer, industrial category) and contains 3016 characters, 2 quantified assertions and 2 declared constants c_main_~x~5, c_main_~y~5.  \nIts core encodes a safety‑property check for a C program: two universally quantified formulas state that for every pair of nondeterministic 32‑bit inputs |main_#t~nondet0|, |main_#t~nondet1| the linear bit‑vector expression  \n`‑(2·|nondet0| + x) + 1` is never equal to `y + 2·|nondet1|`.  \nThe outermost assertion negates a conjunction of three such universally quantified clauses, effectively asking whether a counterexample (values of x, y, and the nondet variables) exists that makes all clauses simultaneously true.  \nAll arithmetic is limited to multiplication by the constant 2, addition, subtraction and the constant 4294967295 (‑1), keeping the term depth at 11 but resulting in heavily nested quantifiers.  \nThe final `check-sat` therefore tests the (un)satisfiability of the encoded unreachability condition for the original program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_382.smt2",
    "description": "The file is a 2 585‑character BV‑logic benchmark generated by Ultimate Automizer from the SV‑COMP 2017 “jain_7” true‑unreach‑call benchmark (category industrial, family Heizmann‑UltimateAutomizer). It declares three 32‑bit variables `c_main_~x~5`, `c_main_~y~5` and `c_main_~z~5` that model program inputs, and then asserts a universally quantified inequality stating that two linear bit‑vector expressions – one a large weighted sum of nondeterministic symbols and the three declared variables, the other a similar sum involving `c_main_~z~5` – must always be distinct. A second assertion negates a simpler universally quantified version of the same “distinct” property, thereby asking the solver to find an assignment to the nondeterministic symbols that makes the two expressions equal. Consequently the problem checks whether the safety property “the two computed values never coincide for any possible program execution” is violated; a sat result corresponds to a reachable error (a counterexample to the inequality). The instance is notable for its use of several quantified bit‑vector multiplications with large constants (e.g., 2³²‑ish) and a maximum term depth of 6.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/MultCommutative_true-unreach-call_true-no-overflow_true-termination.c_3226.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) verification condition generated by the Ultimate Automizer tool from an SV‑COMP 2017 benchmark (file MultCommutative…termination.c), containing 5 declared constants, one large quantified assertion, and about 2.9 k characters.  The formula encodes the Hoare‑logic proof obligation for a C function that multiplies two unsigned 32‑bit integers, checking the commutativity property n·m = m·n together with auxiliary “no‑overflow” and termination side conditions.  The assertion ties the pre‑state inputs (|c_mult_#in~n|, |c_mult_#in~m|) to the post‑state variables (c_mult_~n, c_mult_~m, c_mult_#res) using bit‑vector multiplication by 2, addition, and several quantified (∀/∃) clauses that handle the special cases when an operand is 0 or 1.  The final conjunct forces the result variable to be zero, so the solver is asked to determine whether the error state (non‑zero result) is reachable under the given preconditions.  Notably, the benchmark exercises nested quantifiers, Horn‑like clauses, and BV arithmetic, reflecting the on‑demand Floyd‑Hoare automaton encoding used by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/gcd_2_true-unreach-call_true-no-overflow.i_921.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (6 8‑bit bit‑vector constants, 3 assertions, 3125 characters) generated by Ultimate Automizer from the SV‑COMP 2017 GCD benchmark suite.  It encodes a single step of the Euclidean algorithm used to compute the greatest common divisor: the un‑primed variables `c_gcd_test_~a` and `c_gcd_test_~b` represent the current arguments, while the primed versions (`…_primed`) represent the next state after assigning `t = b` and `b = a mod b`, `a = t`.  The first assertion states the transition and also enforces the pre‑condition that the second argument `b` is non‑zero; the second assertion expresses the loop‑invariant that, as long as the original input `|c_gcd_test_#in~b|` is positive, the current `b` is non‑negative and never becomes zero after a remainder operation.  The final assertion is the negation of the safety property, i.e., it asserts that an error state (where `b` would become negative or zero while the input is still positive) is reachable; the overall `check-sat` therefore asks whether the algorithm can violate its invariant.  Notably, the script uses many signed extensions (`((_ sign_extend 24) …)`) to perform 32‑bit signed comparisons on 8‑bit values and includes a quantified clause over all possible 8‑bit candidates for `a` to capture the universal part of the invariant.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_434.smt2",
    "description": "This instance is a 32‑bit bit‑vector problem (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2017 industrial benchmark suite (file *jain_2_true‑unreach‑call_true‑no‑overflow.i_434.smt2*). It contains only two quantified assertions over four bound variables and two nondeterministic inputs, together with two global constants `c_main_~x~5` and `c_main_~y~5`. The first assertion states that for all choices of the substitution variables and nondet inputs either a certain linear combination (with constant factor 2) of them does **not** equal another combination shifted by −1, or a separate overflow‑like equality holds; the second assertion negates a similar universal condition, effectively demanding the existence of a counter‑example to the first equality. In verification terms the script checks that a particular arithmetic relation—derived from a program’s control‑flow edge—cannot be satisfied, i.e., the target location is unreachable without overflow. Although the formula uses only linear‑constant multiplications, the nesting of two `forall` quantifiers and the mix of addition, negation and bit‑vector wrap‑around make it a non‑trivial candidate for quantifier‑instantiation engines. The model is small (≈2.5 kB, 2 asserts, depth 9) but representative of the kind of quantified bit‑vector constraints produced by automata‑based software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_259.smt2",
    "description": "This file is a 32‑bit bit‑vector encoding (logic BV) generated by the Ultimate Automizer model‑checker on an SV‑COMP 2017 industrial benchmark (the “jain” program). It declares three 32‑bit program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` and contains two top‑level assertions, the second of which is negated to turn the verification condition into a satisfiability query. The first assertion universally quantifies three fresh nondeterministic bit‑vectors and requires that a linear combination of `x`, `y` and the nondet variables be distinct from another linear combination involving `z`; this models the effect of the program’s arithmetic statements for all possible nondeterministic branches. The second (negated) assertion asserts that a different linear combination of `x`, `y`, `z` cannot be zero **and** that either it is zero or the same universal distinctness condition holds, thereby encoding the “no‑error reachable” property that the tool tries to refute. With 2669 characters, 2 asserts, 3 declared constants and a maximum term depth of 8, the instance is a compact but highly symbolic BV formula typical of automated software‑verification encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_2_true-unreach-call_true-no-overflow.i_230.smt2",
    "description": "The file is a 2 KB Bit‑Vector (BV) benchmark (logic BV, 2 450 characters, 2 declarations and 2 assertions) produced by the Ultimate Automizer frontend on a SV‑COMP 2017 “true‑unreach‑call, no‑overflow” benchmark (family Heizmann‑UltimateAutomizer, industrial category).  \nIt encodes a verification condition for a simple C‑like program that contains two 32‑bit integer variables `x` and `y` (fixed to the constants ‑993 908 852 and ‑993 907 773) and two nondeterministic inputs.  \nThe first assertion states, universally over the two nondeterministic values, that the linear equality  \n\n```\n2·nondet0 + x  =  –(y + 2·nondet1) + 1\n```  \n\ncan never hold.  \nThe second (negated) universal clause expresses the same condition together with an alternative (a disjunction) that would make the equality hold only when an additional overflow‑checking term  \n\n```\ny + 2·nondet0 + x + 2·nondet1 + 0xFFFFFFFF = 0\n```  \n\nis satisfied.  \nTogether they ask the solver whether there exists any choice of the nondeterministic inputs that violates the intended invariant; the overall `check‑sat` therefore corresponds to a reachability‑safety query (the instance is expected to be unsatisfiable, i.e., the error state is unreachable).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_4_true-unreach-call_true-no-overflow.i_436.smt2",
    "description": "The file is a 32‑bit bit‑vector SMT‑LIB 2.6 benchmark (logic BV) generated by Ultimate Automizer for an SV‑COMP 2017 industrial program, containing three declared 32‑bit variables (c_main_~x~5, c_main_~y~5, c_main_~z~5) and a total of 3089 characters with two quantified assertions. The first assertion universally quantifies over several auxiliary and nondeterministic bit‑vectors and states that, for every choice of these values, either a specific equality involving weighted sums (coefficients 4 and 8) does **not** hold, or another equality linking the three main variables must hold; this encodes the program’s transition relation / invariant condition. The second assertion negates a disjunction that would make the initial state (the sum c_main_~x~5 + c_main_~y~5 + c_main_~z~5 + 0xffffffff) equal to zero **or** satisfy the universal condition, thereby expressing the safety property that the “error” (overflow or unreachable call) must never be reachable. The overall check‑sat query asks whether there exists a concrete assignment to the three main variables and the nondeterministic inputs that violates the invariant, i.e., a counterexample to the safety claim. Notably, the script uses only bit‑vector arithmetic (bvadd, bvmul, bvneg) with a modest maximal term depth of 10, and it omits model‑producing commands to meet SMT‑COMP restrictions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_6_true-unreach-call_true-no-overflow.i_460.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification query (logic **BV**) generated by **Ultimate Automizer** from the SV‑COMP 2017 benchmark suite; it contains three program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5`, 2 quantified assertions and a total of about 4 KB of SMT‑LIB text.  \nThe formula encodes a safety property for a small C function: the three declared constants model the values of the program’s registers x, y and z at a particular location, while the symbols `|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|` stand for nondeterministic inputs (e.g., values read from the environment).  \nBoth assertions are universally quantified over auxiliary substitution variables and state that two linear bit‑vector expressions—each built from the program variables, the nondeterministic inputs and the constants ‑8, ‑4, 2, 8, 4, 4294967292, 4294967294—must be **distinct**; the second assertion also contains a disjunction that forces one of the expressions to be either zero or distinct from the other.  \nThe outer `not` wraps a conjunction of these quantified clauses, turning the whole problem into a satisfiability check: the solver must find an assignment to the three program variables and the nondeterministic inputs that violates the distinctness/zero condition, i.e., a counterexample to the asserted safety property.  \nThus the benchmark tests the solver’s ability to handle quantified bit‑vector arithmetic with many multiplications by constants and to decide whether the encoded reachability/overflow condition is reachable (SAT) or proved impossible (UNSAT).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_1_true-unreach-call_true-no-overflow.i_435.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic = BV, 32‑bit bit‑vectors) generated by Ultimate Automizer from an SV‑COMP 2017 “no‑overflow” test case (category = industrial, family = Heizmann‑UltimateAutomizer).  \nIt declares a single 32‑bit constant `c_main_~y~5` and contains two quantified assertions.  \nThe first asserts that for **every** nondeterministic 32‑bit value `|main_#t~nondet0|` the expression `c_main_~y~5 + 2·|main_#t~nondet0|` is never zero (a global non‑zero invariant).  \nThe second is the negation of a conjunction of two universally‑quantified clauses that together would allow the same expression (or a related sum with additional “v_subst” variables) to become zero; thus the script checks whether a reachable state violating the invariant exists (i.e., an overflow/unreachability condition).  \nBecause the outermost formula is a `not`, the solver is asked to prove unsatisfiability, which corresponds to confirming the safety property that the summed term can never be zero for any combination of nondet inputs.  \nThe benchmark is notable for its heavy use of nested `forall` quantifiers and simple linear bit‑vector arithmetic, without any uninterpreted functions or arrays.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_431.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 “jain_7” C benchmark; the file is 2 716 bytes, contains three declared constants and two top‑level assertions. The script encodes a **true‑unreach‑call** verification task: it asserts that, for all possible nondeterministic values (`|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|`), two linear combinations of the program variables `c_main_~x~5`, `c_main_~y~5`, `c_main_~z~5` must be different, and then negates a property that would witness a reachable error state. The negated property is a disjunction of (i) an equality that would make a certain affine expression over the variables equal to zero (the error condition) and (ii) another universally quantified distinctness constraint, so the whole formula is satisfiable only if the error can be avoided for *all* nondeterministic choices. The constraints involve many large constants and multiplications by powers of two, resulting in a moderate term depth (7) and a heavily quantified bit‑vector formula, which is characteristic of the automata‑theoretic encoding used by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20170501-Heizmann-UltimateAutomizer/jain_7_true-unreach-call_true-no-overflow.i_306.smt2",
    "description": "This file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2017 industrial suite; it is 3.5 KB long, contains five declared constants and four top‑level assertions with a maximum term depth of 7. The script encodes the safety check of a C program that contains a `__VERIFIER_assert`, modelling the program variables `x`, `y`, `z` (named *c_main_~x~5_Hier*, etc.) together with three nondeterministic inputs. The first two assertions define an auxiliary condition variable with an `ite` and require both this variable and the original assert‑condition to be non‑zero, i.e. that the asserted property holds. The third assertion universally quantifies over the three nondet inputs and forces two linear bit‑vector expressions—each a weighted sum of the program variables and the inputs with large constants—to be distinct and a second expression to be non‑zero. Finally, the fourth assertion negates a similar universal property, turning the whole formula into a “there exists a counterexample” query; satisfiability therefore means the original program can reach a state violating the assert, while unsatisfiability proves the assertion safe. Notably, the instance relies heavily on quantified bit‑vector arithmetic with many large constants (e.g., 4294967294) and a dense use of `bvmul`/`bvadd`, reflecting the automata‑theoretic encoding used by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem1_32bit.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is a small handcrafted query (≈1 KB, two declared constants `s` and `t`, one top‑level assertion).  \nThe core of the problem is a bidirectional implication between a user‑defined predicate **SC(s,t)**—which relates the signed‑greater‑or‑equal ordering of `s` and `t**—and the existence of a witness `x` such that the totalized unsigned remainder `uremtotal(s,x)` is signed‑greater‑or‑equal to `t`.  \nThe definitions `udivtotal` and `uremtotal` protect division and remainder from division‑by‑zero by returning a neutral bit‑vector (`bvnot 0`) when the divisor is zero; auxiliary `min` and `max` constants are also provided but not used in the assertion.  \nThe benchmark asserts the **negation** of the conjunction of the two implications, i.e., it asks the solver to find a model where either the implication from **SC** to the existence of `x` fails or the converse fails, thereby checking the logical equivalence of the two formulations.  \nIt is intended for solvers such as Boolector, CVC4, and Z3 to test their handling of quantified bit‑vectors, totalized arithmetic, and mixed signed/unsigned comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_2_64bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 1 040 bytes, 3 declared constants) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It declares a 64‑bit word `s`, a 2‑bit word `tx`, and another 64‑bit word `ts`, and defines two 2‑bit constants `min` and `max` using bitwise‑not and logical‑shift. The core Boolean predicate `SC` states that if `tx` equals all‑ones (i.e., `bvnot 0`), then `s` must be unsigned‑greater‑or‑equal to `ts`. The sole assertion negates the bi‑implication between `SC` and the existence of a 2‑bit witness `x` such that the 66‑bit concatenations `(concat x s)` and `(concat tx ts)` satisfy the same unsigned‑greater‑or‑equal relation. Thus the instance checks whether the simple condition `SC` is logically equivalent to the existence of an appropriate high‑order bits `x` for the concatenated comparison; it is meant to expose a subtle invertibility property for quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV, 1 K‑byte, 2 declared constants, 3 auxiliary definitions) generated by Mathias Preiner for the CAV 2018 paper on “Solving Quantified Bit‑Vectors using Invertibility Conditions”.  It defines total‑behavior versions of unsigned division and remainder, the extreme 64‑bit values *min* and *max*, and a Boolean predicate  \n\n\\[\n\\text{SC}(s,t)\\;:=\\;(s\\;\\&\\;(\\sim s))\\;\\lor\\;t = t,\n\\]  \n\nwhich is equivalent to “\\(t\\) is a subset of the bit‑mask \\((\\neg s)\\lor s\\)”, i.e. a simple syntactic condition on the pair \\((s,t)\\).  The sole assertion negates the bidirectional implication  \n\n\\[\n\\text{SC}(s,t)\\;\\leftrightarrow\\;\\exists x\\;.\\;x\\;*\\;s = t,\n\\]  \n\nso the solver must show that the condition SC is **exactly** the invertibility condition for the multiplication equation over 64‑bit vectors.  In other words, the benchmark checks whether the existence of a multiplier \\(x\\) solving \\(bvmul(x,s)=t\\) is equivalent to the predicate SC, and it is expected to be unsatisfiable if the equivalence holds.  The instance is intended for solvers such as Boolector, CVC4 and Z3 that support quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvlshr1_64bit.smt2",
    "description": "The benchmark is a 64‑bit bit‑vector problem (logic **BV**) generated for the CAV 2018 paper on invertibility conditions; it contains two free constants `s` and `t`, three auxiliary definitions (totalised unsigned division/rem, the minimum and maximum 64‑bit values) and a small predicate **SC** that simply states `s ≥ t`.  \nThe single assertion negates the conjunction of two implications, i.e. it asks whether for all 64‑bit values the condition  \n\n```\nSC(s,t)  ⇔  ∃x. (bvlshr s x) ≥ t\n```  \n\nholds.  \nThus the solver must decide the validity of the equivalence between the direct comparison `s ≥ t` and the existence of a logical right‑shift amount `x` that makes the shifted value at least `t`.  \nThe benchmark is labelled *crafted*, has 1253 characters, 1 top‑level assert, and a maximum term depth of 7, making it a compact yet non‑trivial quantified BV test for solvers such as Boolector, CVC4 and Z3.  \n\nThe instance is intended to verify the correctness of the invertibility condition for the `bvlshr` operator with respect to the unsigned‑greater‑or‑equal relation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_64bit.smt2",
    "description": "This SMT‑LIB file is a handcrafted 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it contains 2 declared constants, 3 auxiliary function definitions and a single quantified assertion, spanning 1 256 characters with a maximum term depth of 7.  \nThe instance defines total versions of unsigned division and remainder (returning all‑1s on division‑by‑zero), computes the signed minimum (`min = 0x800…0`) and its complement (`max`), and introduces the predicate `SC(s,t)` which simply states that the right‑hand operand `t` is not equal to this minimum value.  \nThe core property being examined is the logical equivalence between `SC(s,t)` and the existence of a 64‑bit value `x` such that the signed addition `x + s` is strictly less than `t` (`bvslt (bvadd x s) t`).  \nThe benchmark asserts the negation of this equivalence (i.e., it asks whether there is a counter‑example where the two sides disagree) and then calls `check‑sat`.  \nThus the problem checks whether the “invertibility condition” for the signed‑less‑than‑after‑addition relation holds for all 64‑bit vectors, with the extra edge case of `t = min` explicitly excluded.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it contains two free 32‑bit constants `s` and `t` and a handful of auxiliary definitions (total unsigned division/remainer and the 32‑bit minimum/maximum).  A unary predicate `SC(s,t)` is defined simply as “`t` is non‑zero”.  The sole assertion negates the two‑way implication between `SC(s,t)` and the existence of a 32‑bit value `x` such that the unsigned addition `x + s` is strictly less than `t` (`bvult (bvadd x s) t`).  In other words, the solver is asked whether “`t ≠ 0`” is logically equivalent to “there exists an `x` with `x + s <_u t`”.  The benchmark therefore tests the validity of this invertibility condition for unsigned addition, and because the equivalence actually holds for 32‑bit arithmetic the formula is expected to be unsatisfiable.  The instance is small (≈ 1 KB, depth 7) but contains a quantified sub‑formula that challenges solvers’ handling of quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_32bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (32‑bit bit‑vectors) of moderate size (≈1 KB, 2 declared constants, 1 quantified assertion) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions.  It works in the pure bit‑vector theory (logic BV) and defines three auxiliary functions: total unsigned division/remainder that are safe on divisor 0, and the 32‑bit constants **min** and **max**.  The core predicate `SC(s,t)` is a signed‑less‑than test that involves a subtraction and a double bitwise‑or with the negation of `s`.  The single top‑level assertion states the negation of the bi‑implication  \n\n\\[\nSC(s,t) \\;\\Longleftrightarrow\\; \\exists x.\\; (x·s) >_{sgn} t,\n\\]\n\nso the solver must find a pair `s,t` that breaks this equivalence (or prove none exists).  This benchmark therefore exercises quantified reasoning, mixed signed/unsigned operators, and non‑trivial bit‑vector arithmetic, making it a typical test for solvers’ support of invertibility‑condition techniques.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_64bit.smt2",
    "description": "This is a crafted 64‑bit bit‑vector benchmark (logic BV) of about 1.3 kB that comes from the CAV‑2018 paper on *invertibility conditions* for quantified bit‑vectors (generated by Mathias Preiner).  \nIt declares two 64‑bit constants `s` and `t` and defines three helper functions: `udivtotal` and `uremtotal` which make unsigned division and remainder total by guarding against a zero divisor, and `min`/`max` which give the smallest and largest 64‑bit values.  \nThe core predicate `SC(s,t)` asserts that right‑shifting `t` by `s` bits and then left‑shifting the result by the same amount yields the original `t` (i.e., `t` is unchanged by the shift‑round‑trip).  \nThe single assertion negates the equivalence between `SC(s,t)` and the existence of a value `x` such that `x << s = t`; thus the benchmark checks whether the natural invertibility condition for the bit‑vector left‑shift operator holds for all 64‑bit shift amounts.  \nIt contains quantifiers (`exists`), conditional (`ite`) and arithmetic operators, making it a useful test case for solvers like Boolector, CVC4 and Z3 that support quantified BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem1_32bit.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is a small, handcrafted formula (≈1.3 KB, 2 constants, 3 defined functions, 1 quantified assertion). Two 32‑bit constants `s` and `t` are declared, and the file defines totalised versions of unsigned division (`udivtotal`) and unsigned remainder (`uremtotal`) that return a default value when the divisor is zero. A Boolean predicate `SC(s,t)` is defined to hold exactly when at least one of `s` or `t` is non‑zero. The single top‑level assertion negates the bidirectional implication “`SC(s,t)` iff there exists an `x` such that `uremtotal(s,x)` is distinct from `t`”, thereby testing whether the stated condition is a correct invertibility condition for the remainder operation. The problem therefore checks the logical equivalence of a simple non‑zero guard with the existence of a witness for the remainder, using an existential quantifier and totalised arithmetic, and is intended to be answered unsatisfiable by solvers that correctly handle quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (`(set-logic BV)`) of modest size (≈1.3 KB, 2 declared constants, 3 auxiliary definitions and a single top‑level assertion).  It was generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors, and is meant to be solved by Boolector, CVC4 or Z3.  The core of the problem defines total versions of unsigned division (`udivtotal`) and unsigned remainder (`uremtotal`) that return a “default” value when the divisor is zero, and a predicate `SC(s,t) ≡ (s ≠ 1) ∨ (t ≠ 0)`.  The sole assertion negates the equivalence  \n\n```\nSC(s,t)  ⇔  ∃x . uremtotal(x,s) ≠ t,\n```  \n\nthereby asking the solver whether the invertibility condition for the unsigned remainder (with the special zero‑divisor case) holds for all 32‑bit values of `s` and `t`.  The benchmark thus checks a quantified property about the existence of a witness `x` for the remainder operation, a typical pattern in the paper’s analysis of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_64bit.smt2",
    "description": "This SMT‑LIB file is a crafted BV benchmark (logic BV, 64‑bit vectors) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is 1 KB in size and contains two declared constants, three helper definitions and a single quantified assertion.  \nThe helper functions `udivtotal` and `uremtotal` give totalised unsigned division and remainder (returning a default value when the divisor is zero), while `min` and `max` compute the signed‑minimum and signed‑maximum 64‑bit values.  \nThe core predicate `SC(s,t)` is defined as the signed‑less‑than test `t <_s (s & max)`, i.e. it checks whether `t` is smaller than the non‑negative part of `s`.  \nThe sole assertion negates the biconditional that `SC(s,t)` holds exactly when there exists a 64‑bit `x` such that the signed comparison ` (x & s) >_s t` is true; in other words, it asks the solver to find a counter‑example to the claimed invertibility condition for the operation `bvsgt` combined with `bvand`.  \nThus the benchmark tests a quantified reasoning pattern involving bit‑wise conjunction, signed comparisons, and totalised arithmetic, and is meant to be solved (or disproved) by solvers such as Boolector, CVC4, or Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV, 2,291 characters) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is labelled as a crafted instance and targets solvers such as Boolector, CVC4, and Z3. Two 32‑bit constants `s` and `t` are declared, and three auxiliary total‑function definitions (`udivtotal`, `uremtotal`, `min`/`max`) are provided although they are not used later. The core of the benchmark is the predicate **SC**, which is a huge disjunction asserting that for some concrete shift amount i (0 … 32) the left‑shift of `s` by i is unsigned‑greater‑or‑equal to `t`. The single top‑level assertion negates the bi‑directional equivalence between **SC** and the quantified formula “∃ x · bvuge(bvshl s x, t)”, i.e., it asks whether the finite OR over the 33 explicit shift amounts is exactly the same as the unrestricted existential over all 32‑bit shift amounts. Consequently the problem checks the soundness of replacing a quantified shift‑existence with a bounded case‑split, a typical invertibility‑condition test for quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_32bit.smt2",
    "description": "The file is a small, handcrafted BV‑logic benchmark (32‑bit bit‑vectors, 1 235 B) generated for the CAV‑2018 paper on invertibility conditions; it declares two 32‑bit constants `s` and `t` and defines a few auxiliary functions (`udivtotal`, `uremtotal`, `min`, `max`) that are not used later. The core predicate `SC(s,t)` is defined as the Boolean constant `true`, and the single assertion states that the equivalence  \n\n\\[\nSC(s,t)\\;\\leftrightarrow\\;\\exists x\\;.\\;bvneg(x)=t\n\\]\n\nfails (the outer `not` negates the conjunction of the two implications). Because `SC` is always true, the formula reduces to asserting that no 32‑bit value `x` satisfies `bvneg(x)=t`, i.e., that the two’s‑complement negation is not surjective. Since for every `t` the witness `x = bvneg(t)` exists, the benchmark is unsatisfiable, effectively checking the invertibility of `bvneg`. The instance targets the usual BV solvers (Boolector, CVC4, Z3) and exemplifies a quantifier‑instantiation test for a simple invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvudiv0_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 declared constants, 1 quantified assertion) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions.  It defines totalised unsigned division and remainder operators ( udivtotal / uremtotal ) that return a deterministic value when the divisor is 0, and it introduces the constants min = 2⁶³ and max = 2⁶⁴‑1.  The core property, named SC, asserts that both parameters s and t are strictly positive, and the benchmark checks the bidirectional implication:  \n SC(s,t) ⇔ ∃ x . udivtotal(x,s) < t.  \nThe single top‑level assertion negates this equivalence, so the solver must prove that the implication holds in both directions for all 64‑bit values; a successful proof yields unsat.  The benchmark is “crafted” to exercise quantified bit‑vector reasoning in solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_32bit.smt2",
    "description": "This file is a handcrafted BV‑logic benchmark (32‑bit bit‑vectors) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is 1 KB in size and targets solvers such as Boolector, CVC4 and Z3.  Two 32‑bit constants `s` and `t` are declared, and three auxiliary functions are defined: a “total” unsigned division, a “total” unsigned remainder, and the minimum/maximum 32‑bit values (the latter two are not used later).  The core predicate `SC(s,t)` states that `t` is strictly less than the bitwise‑or of `s` and its two’s‑complement negation, i.e. `t < (s | –s)`.  The sole assertion negates the bidirectional implication between `SC(s,t)` and the existence of a multiplier `x` such that the product `x·s` is unsigned‑greater‑than `t` (`bvugt (bvmul x s) t`).  Thus the query asks the solver to find a concrete pair `(s,t)` that disproves the equivalence, i.e. a counterexample to the claimed invertibility condition for multiplication over 32‑bit bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvurem1_32bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 1 assertion, 2 declared 32‑bit variables, 3 helper definitions) generated for the CAV‑2018 paper “Solving Quantified Bit‑Vectors using Invertibility Conditions” by Preiner et al.  It encodes a bidirectional implication between a simple ordering predicate  \n\n\\[\nSC(s,t)\\;:=\\;t<\\text{min}\\;\\lor\\;t\\ge s,\n\\]\n\nand the existence of a 32‑bit witness \\(x\\) such that the *totalized* remainder  \n\n\\[\n\\text{uremtotal}(s,x)=\\begin{cases}\ns &\\text{if }x=0\\\\\n\\text{bvurem}(s,x) &\\text{otherwise}\n\\end{cases}\n\\]\n\nsatisfies the signed‑less‑or‑equal relation \\( \\text{uremtotal}(s,x)\\le_{\\text{signed}} t\\).  The benchmark asserts the negation of the conjunction of the two directions, i.e. it asks whether there is a pair \\((s,t)\\) for which the equivalence fails.  To avoid undefined division, the script also defines a totalized unsigned division (udivtotal) and uses bit‑vector constants “min’’ (all‑ones except the most‑significant bit) and “max’’ (its complement).  The problem therefore tests a solver’s ability to handle quantified bit‑vectors, totalized arithmetic, and mixed signed/unsigned comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv1_64bit.smt2",
    "description": "This 64‑bit bit‑vector benchmark (logic BV) was generated for the CAV 2018 paper on invertibility conditions and is labelled as a crafted instance (size ≈ 1 KB, 2 constants, 1 quantified assertion).  Two 64‑bit constants `s` and `t` are declared and three totalised operations are defined:  \n`udivtotal` returns the usual unsigned division but yields all‑ones when the divisor is zero, and `uremtotal` returns the dividend in the same zero‑divisor case; `min`/`max` compute the extreme signed‑bit values (2⁶³ and 2⁶³‑1).  \nThe core predicate `SC(s,t)` asserts the “double‑division” property `udivtotal s (udivtotal s t) = t`.  \nThe single assertion negates the equivalence between this property and the existence of a divisor `x` such that `udivtotal s x = t`, i.e. it asks whether the invertibility condition for unsigned division holds for all 64‑bit inputs under the totalised semantics.  \nThus the solver must determine a counter‑example (or prove none exists) to the claimed equivalence, involving quantified reasoning and the special zero‑division handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 kB, 2 constants, 3 auxiliary definitions) generated for the CAV‑2018 paper on quantified bit‑vectors; it is labelled “crafted” and was produced by Mathias Preiner.  \nTwo 32‑bit constants `s` and `t` are declared, and three helper functions are defined: `udivtotal` and `uremtotal` give totalised unsigned division and remainder (returning a default value when the divisor is zero), while `min` and `max` denote the smallest and largest unsigned 32‑bit values.  \nA predicate `SC(s,t)` is introduced as `bvuge (bvnot (bvneg s)) t`, i.e. it holds exactly when the unsigned value `s` is at most `t`.  \nThe single asserted clause negates the bi‑implication that `SC(s,t)` is equivalent to the existence of a 32‑bit witness `x` such that the totalised remainder `uremtotal(x,s)` is unsigned‑greater‑or‑equal to `t`.  \nThus the benchmark asks the solver to show whether the “invertibility condition’’ `∃x·(x % s ≥ t) ⇔ s ≤ t` (with safe handling of division‑by‑zero) is valid for all 32‑bit values.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is a small handcrafted instance (≈1.3 KB, 2 declared constants, 1 top‑level assertion).  \nIt defines totalised unsigned‑division and unsigned‑remainder operators ( udivtotal and uremtotal ) that return a default value when the divisor is zero, thereby avoiding the usual undefined‑behaviour of bvudiv and bvurem.  \nThe main property under test is the equivalence between a simple signed condition SC(s,t) — “t < s or 0 ≥ s” — and the existence of a 32‑bit value x such that the signed‑greater‑or‑equal comparison bvsge holds between uremtotal(x,s) and t.  \nThe single asserted formula negates the conjunction of the two implication directions, so the solver is asked to show that the equivalence is *valid* (i.e., the benchmark should be unsatisfiable).  \nNotably, the benchmark exercises quantified reasoning over bit‑vectors, totalised arithmetic, and mixed signed/unsigned comparisons, making it a typical case for testing quantifier‑handling in Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, depth 7) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vector invertibility conditions. It declares two 32‑bit constants `s` and `t` and defines “total” versions of unsigned division and remainder, which return a distinguished value (`bvnot 0`) when the divisor is zero so that the operations are everywhere defined. The core property is a bidirectional implication: under the side‑condition `SC` ( `s ≠ 0` ∨ `t ≠ 0xFFFFFFFF` ) there must exist an `x` with `udivtotal x s ≠ t`, and conversely, if such an `x` exists then `SC` must hold. The single top‑level assertion negates this equivalence, so the solver is asked to find a pair `s,t` that violates the intended invertibility condition. The benchmark is “crafted” for testing solvers’ handling of quantified bit‑vectors and totalized arithmetic, and is aimed at Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) of size ≈1.3 KB, generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is marked as a crafted instance and is meant to be solved by Boolector, CVC4 or Z3. Two 64‑bit constants `s` and `t` are declared, together with three auxiliary total‑ized functions (`udivtotal`, `uremtotal`, `min`, `max`) that are not used later, and a predicate  \n\n```\nSC(s,t) ≡  t ≥_s (t ≫_{logical} s)\n```  \n\nwhere `bvsge` is signed‑greater‑or‑equal and `bvlshr` is logical right‑shift. The single asserted formula negates the conjunction of the two implications  \n\n1. `SC(s,t) → ∃x. (x ≫_{logical} s) ≤_s t`  \n2. `∃x. (x ≫_{logical} s) ≤_s t → SC(s,t)`  \n\nso the solver must check whether the equivalence between `SC(s,t)` and the existence of an `x` satisfying the shifted‑less‑than‑or‑equal condition holds for all 64‑bit values of `s` and `t`. In other words, the benchmark tests the solver’s ability to reason about quantified bit‑vector formulas involving signed comparisons and logical shifts, a typical invertibility‑condition check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvmul_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 declared constants, 1 quantified assertion) generated for the CAV‑2018 paper on invertibility conditions.  It defines a helper predicate **SC(s,t)** that tests a signed‑less‑than relation involving a bitwise‑or of s and t, and then checks the two‑way implication between `SC(s,t)` and the existence of a 64‑bit multiplier x such that `bvmul x s` is signed‑greater‑than t.  The sole top‑level assert negates this equivalence, so the solver is asked to find a counter‑example; the expected result is unsat if the equivalence is valid.  Although the script also defines total versions of unsigned division and remainder as well as min/max constants, those definitions are unused in the core property.  The benchmark features a single quantifier (`exists`) and a nested combination of arithmetic, bitwise, and relational operators, making it a typical crafted instance for testing quantified‑BV reasoning in solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvurem1_32bit.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 constants, 3 auxiliary functions) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions. It declares two 32‑bit variables `s` and `t` and defines totalised versions of unsigned division (`udivtotal`) and remainder (`uremtotal`) that return a default value when the divisor is zero. A predicate `SC(s,t)` is introduced as the unsigned “strict‑less” relation `t <_u s`. The single asserted formula negates the equivalence between `SC(s,t)` and the existence of a 32‑bit `x` such that the totalised remainder `uremtotal(s,x)` is **strictly greater** than `t`. Consequently, the query checks whether the condition “there is an `x` with `s % x > t`” is exactly the same as “`t` is less than `s`” under unsigned semantics, a property used to validate the derived invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors; it is a small, handcrafted instance (≈1.3 KB, 2 constants, 3 user‑defined functions, a single quantified assertion).  \nTwo totalised functions, **udivtotal** and **uremtotal**, extend unsigned division and remainder with safe behaviour on a zero divisor, and the constants **min** and **max** denote the most‑negative and most‑positive signed 64‑bit values.  \nThe core predicate **SC(s,t)** expresses a signed‑less‑than relation between ¬t and the bitwise‑or of the two’s‑complement negatives of s and t.  \nThe sole assertion negates the bi‑implication that **SC(s,t)** holds exactly when there exists an x such that the signed‑less‑than comparison `(uremtotal x s) <_s t` is true, i.e., it checks the correctness of an invertibility condition for the unsigned remainder under signed ordering.  \nThus the benchmark asks solvers to decide whether the stated equivalence is universally valid for all 64‑bit values s and t, a typical pattern used to evaluate Boolector, CVC4 and Z3 on quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvmul_64bit.smt2",
    "description": "This instance is a 64‑bit bit‑vector benchmark (logic BV) with two uninterpreted constants `s` and `t`.  It defines several auxiliary total‑division/reminder functions, the extremal constants `min` and `max`, and a predicate  \n\n\\[\n\\text{SC}(s,t)\\;:=\\;t \\;<_{\\text{u}}\\; (\\text{bvneg}(s)\\;\\lor\\;s),\n\\]  \n\nwhich compares `t` with the bitwise‑or of `s` and its two’s‑complement negation.  The single assertion negates a bi‑implication: it states that SC(s,t) is equivalent to the existence of a 64‑bit multiplier `x` such that the unsigned product `x * s` is greater than `t` (i.e., `bvugt (bvmul x s) t`).  By checking the negation of this equivalence, the benchmark verifies the invertibility condition for the `bvmul` / `bvugt` pair studied in the CAV‑2018 paper by Niemetz *et al.*.  The file is a handcrafted, 1 KB benchmark (1270 bytes, depth 7) generated by Mathias Preiner and intended for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv1_64bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 64‑bit bit‑vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it contains 2 declared constants, 3 auxiliary definitions and a single quantified assertion (size ≈ 1.3 KB). Two 64‑bit variables `s` and `t` are related by the predicate **SC**, which states that if `s` is non‑negative then `s ≥ t`, otherwise the arithmetic right‑shift of `s` must be at least `t`. The benchmark defines totalized unsigned division and remainder (`udivtotal`, `uremtotal`) that return a fallback value when the divisor is zero, and then asserts the negation of the equivalence  \n\\[\nSC(s,t)\\;\\Leftrightarrow\\;\\exists x.\\; s \\,\\text{udivtotal}\\, x \\;\\ge_{signed}\\; t .\n\\]  \nThus the solver is asked to find a concrete 64‑bit pair `s,t` that breaks the claimed equivalence, i.e., a counterexample to the invertibility‑condition property. The problem features mixed signed/unsigned operators, an `ite`‑defined total division, and a single existential quantifier, making it a typical quantified‑BV challenge for solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_64_64bit.smt2",
    "description": "This benchmark is a handcrafted 64‑bit bit‑vector problem (logic BV, 3 declared constants `s`, `tx`, `ts`) generated for the CAV 2018 paper on invertibility conditions.  It defines two auxiliary constants `min` and `max` (bit‑wise complements of each other) and a Boolean predicate **SC** that states “if `tx` equals the all‑ones word then `s` is unsigned‑greater‑or‑equal to `ts`”.  The single assertion negates the equivalence between **SC** and the quantified condition “there exists a 64‑bit word `x` such that the 128‑bit concatenation `x‖s` is unsigned‑greater‑or‑equal to `tx‖ts`”.  In effect the formula asks whether the simple guard **SC** exactly characterises the existence of a prefix `x` making the concatenated comparison true.  The instance is small (≈1 KB, depth 7), contains two existential quantifiers and a `bvuge` over a `concat`, and is intended for solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_64bit.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is a handcrafted instance of 1 assertion, 2 declared constants, 3 helper definitions and a size of about 1.3 KB.  The core of the formula defines a predicate **SC(s,t)** that checks, using signed‑greater‑or‑equal ( bvsge ), whether the signed‑maximal value obtained from the expression `(bvand (bvor (bvneg s) s) max)` dominates `t**.  The main property being tested is the logical equivalence between this predicate and the existence of a 64‑bit multiplier `x` such that the signed product `bvmul x s` is also signed‑greater‑or‑equal to `t`.  The single top‑level assertion negates the equivalence, so the solver is asked to show unsatisfiability (i.e., that the two conditions are indeed equivalent for all 64‑bit `s` and `t`).  Auxiliary definitions for total unsigned division/remainder and the constants `min`/`max` are present but not used in the final check, illustrating typical preprocessing artifacts in the verification of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat1_64_64bit.smt2",
    "description": "This benchmark is a handcrafted 64‑bit bit‑vector problem (logic BV) generated for the CAV‑2018 paper on invertibility conditions; the file is 1 KB long, declares three 64‑bit constants `s`, `tx` and `ts`, and contains a single quantified assertion.  Two helper constants, `min` and `max`, are defined but not used; the central Boolean predicate `SC` states that `s` is unsigned‑greater‑or‑equal to `ts` and, in the case `s = ts`, the word `tx` must be non‑zero.  The sole assertion negates a bidirectional implication between `SC` and the existence of a 64‑bit word `x` such that the 128‑bit concatenation `concat(s,x)` is unsigned‑greater than `concat(ts,tx)`.  In other words, the solver is asked to find a model where the simple ordering condition `SC` is *not* equivalent to the existence of an extension `x` that makes the concatenated numbers compare larger under `bvugt`.  The problem therefore tests quantified reasoning over bit‑vectors, the interaction of `concat` with unsigned comparison, and the correctness of the derived invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvlshr0_64bit.smt2",
    "description": "The file is a small (≈1 KB) BV‑logic benchmark generated by Mathias Preiner for the CAV‑2018 paper on “invertibility conditions” for quantified bit‑vectors. It works over 64‑bit bit‑vectors, declares two free constants `s` and `t`, and defines a few auxiliary functions (total unsigned division/remainder and the extreme values min/max) that are not used later. The core of the benchmark is the predicate  \n\n```\nSC(s,t) ≜ bvslt (bvlshr (bvnot (bvneg t)) s) t\n```  \n\nand an assertion that the logical equivalence  \n\n```\nSC(s,t) ⇔ ∃x . bvslt (bvlshr x s) t\n```  \n\nfails. In other words, the solver is asked to show that the existence of a shift‑right witness `x` is exactly captured by the condition `SC`. The single negated conjunct forces the solver to prove unsatisfiability, exercising its ability to reason about quantified bit‑vectors, signed‑less‑than, and logical right‑shifts. The benchmark is classified as “crafted” and is intended for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr1_64bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 64‑bit bit‑vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it contains two declared constants `s` and `t`, three user‑defined functions (totalized unsigned division and remainder, and the constants `min`/`max`), and a predicate `SC`.  \n`SC(s,t)` is defined as the disjunction of a signed‑less‑than test `s <_s (s >>> ~t)` and an unsigned‑less‑than test `t <_u s`.  \nThe single top‑level assertion negates the conjunction of two implications: (1) `SC(s,t)` implies the existence of a 64‑bit value `x` such that the arithmetic right shift of `s` by `x` is unsigned‑greater‑than `t`, and (2) the converse implication.  \nThus the benchmark checks whether the predicate `SC` is exactly equivalent to the existence of a shift amount making `bvashr s x` exceed `t` (i.e., it tests a quantified invertibility condition for `bvashr`).  \nBecause the negated equivalence is asserted, the instance is expected to be unsatisfiable if the equivalence holds; the presence of both signed and unsigned comparisons, a mixture of arithmetic and logical shifts, and the totalized division/remainder functions makes it a non‑trivial case for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_64bit.smt2",
    "description": "The file is a crafted 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors; it contains two uninterpreted 64‑bit constants `s` and `t`, three auxiliary definitions (`udivtotal`, `uremtotal`, and the constants `min`=0 and `max`=2⁶⁴‑1), and a predicate `SC(s,t)` that simply tests whether `t` is non‑zero (since `bvshl min s` is always 0 and `bvadd t min` is `t`).  \nThe sole assertion negates the bidirectional implication between `SC(s,t)` and the existence of a shift amount `x` such that the signed‑less‑than relation `bvslt (bvshl s x) t` holds.  \nIn other words, the solver is asked to find `s` and `t` that make the condition “`t≠0` iff there exists an `x` with `s<<x` signed‑less‑than `t`” false.  \nThe benchmark therefore checks the correctness of an invertibility condition for left‑shift under signed comparison, using a single quantified existential and a handful of bit‑vector operations.  \nIts modest size (≈1 KB, depth 7) and use of a total‑division helper that is not otherwise referenced are typical of the synthetic instances used to stress‑test Boolector, CVC4 and Z3 on quantified BV problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_32bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic BV, 32‑bit vectors) of modest size (≈1.3 KB, 2 declared constants, 1 top‑level assertion) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions. It introduces totalised versions of unsigned division and remainder – `udivtotal` returns all‑ones when the divisor is zero, and `uremtotal` returns the dividend – together with the 32‑bit minimum and maximum values. A predicate `SC(s,t)` is defined as “the totalised division of ‑1 by s is greater than t” (using unsigned >`). The single asserted formula negates the bi‑implication between `SC(s,t)` and the existence of a witness x such that `udivtotal(x,s) > t`, thereby checking whether the invertibility condition “∃ x · x ÷ s > t  ⇔  (−1) ÷ s > t” holds universally. The benchmark thus exercises quantified reasoning over bit‑vectors, total‑function handling of division‑by‑zero, and the interaction of `bvugt` with `bvudiv`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvadd_64bit.smt2",
    "description": "This benchmark is a handcrafted 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors and invertibility conditions; it contains 2 declared constants, 3 user‑defined functions and a single quantified assertion, totalling about 1.3 kB and a maximal term depth of 7.  \nThe instance defines “total” unsigned division and remainder (guarded by an `ite` that returns a default value when the divisor is 0), as well as the 64‑bit constants `min` (all‑ones except the most‑significant bit) and `max` (its bitwise complement).  \nA Boolean predicate `SC(s,t)` is introduced, which simply asserts that the second argument `t` is non‑zero.  \nThe core property being checked is the logical equivalence between `SC(s,t)` and the existence of a 64‑bit term `x` such that the unsigned addition `x + s` is strictly less than `t` (`bvult (bvadd x s) t`).  \nThe only asserted formula negates this equivalence, so the solver is asked to decide whether there is a counter‑example—i.e., a pair `(s,t)` where `t≠0` does not guarantee a witness `x` (or vice‑versa).  \nThe benchmark therefore tests a solver’s handling of quantified bit‑vectors, guarded arithmetic definitions, and the interaction between a simple side condition and an existential reachability constraint.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr0_32bit.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions, with 2 declared constants, 3 auxiliary definitions and a single quantified assertion (≈1 KB, depth 7). It defines totalised unsigned‑division and remainder, the minimum and maximum unsigned 32‑bit values, and a predicate SC that relates two vectors s and t by a signed‑greater‑or‑equal test against the bit‑wise complement of a right‑shifted maximum. The core assertion is the negation of a bidirectional implication: SC(s,t) ⇔ ∃x·(bvashr x s) ≤_s t, i.e., it asks whether the condition “there exists a value whose arithmetic right‑shift by s is at most t” is exactly captured by SC. By negating the conjunction, the solver is asked to find a counter‑example showing the two statements are not equivalent, thus checking the correctness of the derived invertibility condition for the arithmetic‑right‑shift operation. The instance is labelled “crafted” and intended for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_4bit.smt2",
    "description": "This benchmark is a 4‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions, consisting of only two free constants `s` and `t` and a handful of auxiliary definitions (total unsigned division/remainder, `min`, `max`, and the predicate `SC`).  \nThe core assertion negates the equivalence  \n\n\\[\nSC(s,t)\\;\\Leftrightarrow\\; \\exists x.\\; (x \\mathbin{\\text{bvlshr}} s) \\;>\\!\\!_{\\text{signed}} \\; t ,\n\\]\n\nwhere `SC(s,t)` is defined as the signed‑less‑than test `t < (max shl s) lsr s`.  \nThus the solver is asked to find a 4‑bit assignment to `s` and `t` that disproves the claimed invertibility condition for the signed‑greater‑than after a logical right‑shift.  \nThe instance is deliberately tiny (1257 bytes, depth 7) and crafted to exercise quantifier reasoning, total‑function handling for division‑by‑zero, and the interaction of signed and unsigned bit‑vector operators.  \nIf the condition is indeed valid, the formula is unsatisfiable; otherwise a satisfying model would expose a counter‑example to the theorem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_32bit.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of modest size (≈1.3 KB, 2 declared constants, 3 function definitions and a single quantified assertion).  It originates from the CAV‑2018 paper “Solving Quantified Bit‑Vectors using Invertibility Conditions” [Preiner et al., 2018] and is meant to be checked by solvers such as Boolector, CVC4 or Z3.  The file defines totalised unsigned division and remainder (guarding against a zero divisor) together with the constants *min* and *max*, and a predicate  \n\n\\[\nSC(s,t) \\;:=\\; \\text{bvslt}(\\,\\neg t,\\; \\text{bvor}(\\,\\neg s,\\;\\neg t\\,)\\,),\n\\]\n\nwhich captures an invertibility condition for the signed‑less‑than test.  The sole assertion negates the equivalence  \n\n\\[\nSC(s,t) \\;\\Leftrightarrow\\; \\exists x.\\; \\text{bvslt}(\\,\\text{uremtotal}(x,s),\\;t\\,),\n\\]\n\nso the solver is asked whether there are 32‑bit values \\(s\\) and \\(t\\) that violate this condition; unsat would confirm the intended property.  The benchmark is therefore a crafted verification task checking the correctness of an invertibility condition for the signed‑less‑than relation combined with a totalised remainder operator.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_34_32bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (32‑ and 34‑bit bit‑vectors) that originates from the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. Three constants `s` (32 bits), `ts` (32 bits) and `tx` (34 bits) are declared, and two auxiliary 34‑bit constants `min` (= 2³³) and `max` (= 2³³‑1) are defined but not otherwise used. A Boolean predicate `SC` encodes a signed‑greater‑or‑equal relation between `s` and `ts` together with a side condition that when `s = ts` the vector `tx` must not be all‑ones. The single assertion negates the equivalence between `SC` and the existence of a 34‑bit witness `x` such that the signed comparison `bvsgt (concat s x) (concat ts tx)` holds; in other words it asks the solver to find a model where the proposed invertibility condition is incorrect. The benchmark therefore exercises quantified reasoning, concatenation, and signed‑greater‑than over bit‑vectors, and is targeted at solvers like Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv1_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) of modest size (≈1 KB, 2 declared constants, 3 auxiliary functions) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors.  It defines totalised unsigned‑division (`udivtotal`) and remainder (`uremtotal`) that return a fixed value when the divisor is zero, and a trivial predicate `SC` that is always true.  The single assertion negates a bi‑directional implication that equates `SC(s,t)` with the existence of a divisor `x` such that `udivtotal s x` is *distinct* from `t`; after simplification this amounts to asserting that **no** 64‑bit divisor makes the division result differ from `t`.  Thus the benchmark checks whether a solver can correctly handle quantified bit‑vector constraints involving totalised arithmetic and an equivalence‑style invertibility condition.  It is deliberately crafted to stress quantifier instantiation and ite‑based total functions in solvers like Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvshl1_32bit.smt2",
    "description": "The file is a crafted 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 declared constants and 3 auxiliary definitions) generated for the CAV‑2018 paper on quantified bit‑vectors.  It introduces totalised unsigned‑division and remainder, the extreme signed values min = 0x80000000 and max = 0x7fffffff, and a predicate SC(s,t) that tests whether (bvshl min s) is unsigned‑less‑than (t + min).  The sole assertion negates the equivalence between this syntactic condition SC(s,t) and the existence of a shift amount x such that (bvshl s x) is signed‑less‑than t.  In other words, the benchmark checks whether the “invertibility condition” for the left‑shift operator under the signed‑less‑than relation is both necessary and sufficient.  It is intended for solvers such as Boolector, CVC4, and Z3 to validate the correctness of the quantified reasoning introduced in the cited publication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_32bit.smt2",
    "description": "This file is a 32‑bit bit‑vector query (logic BV) generated by Mathias Preiner for the CAV 2018 paper on “invertibility conditions”.  \nIt contains only two uninterpreted 32‑bit constants `s` and `t` and three auxiliary definitions: a totalized unsigned division `udivtotal`, a totalized unsigned remainder `uremtotal`, and the constants `min`/`max` representing the smallest and largest signed 32‑bit values.  \n\nThe core of the benchmark is the predicate `SC(s,t)`, which states that **either** the signed‑greater‑or‑equal comparison of `udivtotal(~0,s)` with `t` **or** the same comparison with `udivtotal(max,s)` holds. The single asserted formula negates the equivalence  \n\n```\nSC(s,t)  ↔  ∃x.  bvsge(udivtotal(x,s), t)\n```  \n\ni.e., it checks that `SC` is exactly the condition ensuring the existence of an `x` whose (totalized) unsigned division by `s` is signed‑greater‑or‑equal to `t`.  \n\nBecause division‑by‑zero is handled by the `ite` in `udivtotal`, the query tests the correctness of the invertibility condition in the presence of the edge case `s = 0`. The instance is small (≈1.3 KB, depth 7) but crafted to be challenging for solvers that must reason about quantified bit‑vectors and totalized arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvlshr0_64bit.smt2",
    "description": "The benchmark is a 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on “Solving Quantified Bit‑Vectors using Invertibility Conditions”. It declares two 64‑bit constants `s` and `t` and defines a predicate  \n\n```\nSC(s,t) := (bvlshr (bvshl t s) s) = t\n```  \n\nwhich states that shifting `t` left by `s` and then logically right‑shifting back by the same amount yields the original value. The single top‑level assertion negates the equivalence  \n\n```\nSC(s,t)  ↔  ∃x . (bvlshr x s) = t\n```  \n\ni.e., it checks whether the logical right‑shift operator is invertible exactly when the “shift‑cancel” condition SC holds. Although the file also defines total‑division helpers (`udivtotal`, `uremtotal`) and min/max constants, they are unused in this particular query; the core of the benchmark is a quantified‑free equivalence test involving shift operators, making it a crafted example for quantifier‑reasoning and invertibility checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is a small, crafted instance (≈1.3 KB, 2 declared constants, 3 auxiliary definitions, and a single top‑level assertion).  \nIt defines total‑behaviour versions of unsigned division and remainder, the minimum and maximum 32‑bit signed values, and a predicate **SC(s,t)** that is true exactly when the pair \\((s,t)\\) is not the degenerate case “\\(s = 0\\) and \\(t\\) negative”.  \nThe sole assertion negates the bi‑implication between **SC(s,t)** and the existence of a 32‑bit value \\(x\\) satisfying the signed inequality \\(x·s \\le_{s} t\\) (i.e., \\(bvsle (bvmul x s) t\\)).  \nThus the benchmark checks whether the “invertibility condition” for the signed multiplication‑≤ constraint holds for all 32‑bit inputs, by asking the solver to find a counter‑example where the two sides diverge.  \nBecause the formula mixes quantifiers, ite‑terms, and signed comparisons, it is intended to stress quantified‑bit‑vector reasoning in solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvadd_32bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (32‑bit bit‑vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is 1 236 bytes long, contains two declared constants, three auxiliary definitions and a single quantified assertion.  The core of the problem is the equivalence between a user‑defined predicate `SC(s,t)` (here defined as the always‑true Boolean) and the existence of a witness `x` satisfying the equation `x + s = t` under modular 32‑bit addition.  The asserted formula is the negation of the conjunction\n\n```\n(=> (SC s t) (∃x. x+s = t))\n∧ (=> (∃x. x+s = t) (SC s t))\n```\n\nwhich, because `SC` is true, reduces to the negation of the universally valid statement “there exists an x such that x + s = t”.  Hence the benchmark checks that the solver correctly proves unsatisfiability (i.e., that the addition operator is universally invertible over 32‑bit bit‑vectors).  Although the file also defines total division/remainder helpers and min/max constants, they are unused in the asserted property and serve only to exercise the parser.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv0_32bit.smt2",
    "description": "This is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors and invertibility conditions. It declares two 32‑bit constants `s` and `t`, defines totalised unsigned division (`udivtotal`) and remainder that return a distinguished value when the divisor is zero, and introduces the signed minimum and maximum constants (0x80000000 and 0x7fffffff). The predicate `SC(s,t)` encodes an “invertibility condition”: if `t` is non‑positive then the totalised division of the signed minimum by `s` must be strictly less than `t`. The sole assertion negates the bidirectional implication that `SC(s,t)` is equivalent to the existence of some `x` with `udivtotal(x,s) < t`, thus asking the solver to find a counter‑example to this equivalence. The file is a small crafted instance (≈1.3 KB, 2 declarations, 3 definitions, 1 top‑level assertion) intended for Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvshl1_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV, 1 107 bytes, 2 declared constants) generated for the CAV‑2018 paper *Solving Quantified Bit‑Vectors using Invertibility Conditions* by Preiner et al.  It defines three auxiliary total functions – `udivtotal`, `uremtotal` and the constants `min`/`max` – to avoid division‑by‑zero and to obtain the smallest and largest signed 64‑bit values.  The core predicate `SC(s,t)` states that the logical right‑shift of `t` by `s` is strictly smaller than `min` (i.e., the result is a negative signed number).  The single asserted formula negates the equivalence between this predicate and the existence of a shift amount `x` such that the signed‑less‑equal relation `bvshl s x ≤_s t` holds, i.e., it checks whether the proposed invertibility condition for `bvshl`/`bvsle` is valid.  Thus the solver is asked to find a pair of 64‑bit words `s` and `t` that falsify the “iff” between `SC` and the existential shift‑left condition, exposing a potential counter‑example to the invertibility condition.  The benchmark targets Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvurem1_64bit.smt2",
    "description": "This instance is a 64‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 declared constants, 3 auxiliary definitions) that was automatically generated for the CAV‑2018 paper on quantified bit‑vectors and invertibility conditions (author: Mathias Preiner).  It introduces totalised versions of unsigned division and remainder—`udivtotal` and `uremtotal`—that return a well‑defined value even when the divisor is zero, and it defines the constants `min` and `max` as the extreme 64‑bit unsigned values.  The predicate `SC(s,t)` simply asserts that the second argument `t` is non‑zero, i.e., `distinct t 0`.  The sole assertion negates the bidirectional implication that “`t` is non‑zero” is equivalent to “there exists a 64‑bit `x` such that the total unsigned remainder of `s` by `x` is strictly less than `t` (`bvult (uremtotal s x) t`)”.  Thus the benchmark checks whether the invertibility condition for the unsigned remainder under the `<` relation holds universally; a SAT result would provide a counterexample, while UNSAT would confirm the condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_64bit.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors; it is a small, handcrafted instance (≈1.3 KB, 2 declared constants, 3 auxiliary definitions). The file defines totalised versions of unsigned division and remainder ( udivtotal and uremtotal ) that return a default value when the divisor is zero, and also introduces the constant min = 2⁶³ and max = 2⁶⁴−1. A Boolean predicate SC(s,t) is defined as “t is strictly less than the all‑ones word” (i.e., t < 2⁶⁴‑1). The sole assertion negates the equivalence  \n\\[\nSC(s,t) \\;\\iff\\; \\exists x.\\; \\text{udivtotal}(s,x) > t,\n\\]  \nso the solver must decide whether the invertibility condition for unsigned division with the bvugt relation holds for all 64‑bit values. The benchmark therefore exercises quantified reasoning, ite‑based total functions, and bit‑vector comparison operators on a minimal but non‑trivial formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_4bit.smt2",
    "description": "The file is a small, handcrafted BV‑logic benchmark (logic = BV, 4‑bit vectors) generated for the CAV‑2018 paper on quantified bit‑vectors; it contains two 4‑bit constants `s` and `t` and a handful of auxiliary definitions (total unsigned division/remainder and the extreme values min/​max).  \nThe core property is expressed by the predicate **SC**, which holds exactly when `t` is strictly smaller than the maximum 4‑bit value (i.e. `t ≠ 0b1111`).  \nThe single assertion negates the equivalence between **SC** and the existence of a 4‑bit witness `x` such that an arithmetic right‑shift of `x` by `s` (`bvashr x s`) is unsigned‑greater‑than `t` (`bvugt … t`).  \nThus the benchmark checks whether the condition “`t < max`” is precisely the invertibility condition for the operation `bvashr` with respect to the comparison `bvugt`.  \nWith only 2 declared constants, 3 user‑defined functions and a depth‑7 term, the instance is tiny (≈1 KB) but deliberately constructed to probe solvers’ handling of quantified bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvneg_64bit.smt2",
    "description": "The benchmark is a handcrafted 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it contains two 64‑bit constants `s` and `t`, three auxiliary total‑division/‑remainder definitions, and trivial `min`/`max` functions that are never used.  \nThe only substantive predicate, `SC`, is defined as the constant `true`, so the heart of the formula is the pair of bi‑implications  \n\n```\n(SC s t) → ∃x. bvneg x = t\n∃x. bvneg x = t → (SC s t)\n```  \n\nwhich, because `SC` is always true, reduce to “∃x. bvneg x = t” in both directions.  \nSince bit‑vector negation is a total bijection, the existential statement holds for every 64‑bit `t` (choose `x = bvneg t`), making the conjunction true; the outer `not` therefore forces the asserted formula to be false, so the instance is unsatisfiable.  \nThe file is small (≈1 KB, 1 assertion) but includes auxiliary total‑division functions and max/min terms to mimic a realistic verification setting while testing the solver’s handling of quantified bit‑vector invertibility.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvashr0_64bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic = BV, 64‑bit vectors) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors and invertibility conditions; it contains 2 declared constants, 3 helper definitions and a single quantified assertion (≈ 1.3 KB).  Two 64‑bit variables `s` and `t` are introduced, together with totalised unsigned‑division/remainder functions, the extreme values `min` = 2⁶³‑1 and `max` = 2⁶⁴‑1, and a predicate `SC(s,t)` that simply states that `t` is strictly smaller than the all‑ones constant (i.e., `t < 2⁶⁴‑1`).  The core property being checked is the bidirectional implication  \n\n```\nSC(s,t) ↔ ∃x. (bvashr x s) > t\n```  \n\nwhere `bvashr` is arithmetic right‑shift and `bvugt` is unsigned „greater‑than”.  The benchmark asserts the negation of this equivalence and then asks the solver to prove unsatisfiability; thus it verifies whether the stated invertibility condition for the shift operation holds for all 64‑bit values.  The instance is intended for solvers such as Boolector, CVC4 and Z3 and exemplifies a quantified bit‑vector reasoning pattern involving shift, comparison and existential quantification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_64_64bit.smt2",
    "description": "The file is a crafted 64‑bit bit‑vector benchmark (logic BV) of about 1 KB, generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions. It declares three 64‑bit constants `s`, `tx` and `ts`, and defines two auxiliary constants `min` and `max` (the latter is simply the bitwise complement of the former). The core Boolean predicate `SC` states that if `tx` is the all‑ones word (i.e. `tx = bvnot 0`) then `s` must be unsigned‑greater‑than `ts`. The single top‑level assertion negates the equivalence between `SC` and the existence of a 64‑bit word `x` such that the 128‑bit concatenation `concat x s` is unsigned‑greater‑than `concat tx ts`; thus the solver is asked to find a model where one direction of the implication holds but the other does not. In effect the benchmark tests whether the quantified invertibility condition for `bvugt` under concatenation is valid for 64‑bit operands.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvudiv1_64bit.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it is a small, handcrafted instance (≈1.3 KB, 2 declared constants, 3 auxiliary definitions).  \nTwo totalised operations are introduced: `udivtotal` returns the unsigned quotient of `a ÷ b` or, when `b = 0`, the bit‑wise complement of zero (all‑ones); `uremtotal` behaves similarly for the remainder.  \nA predicate `SC(s,t)` is defined as the disjunction “`t` is non‑negative (signed) or `t ≥ s` (signed)”, and the sole assert negates the equivalence between `SC(s,t)` and the existence of a witness `x` such that the signed‑less‑equal relation `bvsle(udivtotal s x, t)` holds.  \nThus the solver is asked to prove (or refute) that the condition on `t` is exactly the condition under which there exists a divisor `x` making the (totalised) unsigned division of `s` by `x` bounded above by `t`.  \nThe query is deliberately unsatisfiable if the equivalence is valid, serving as a regression check for solvers’ handling of quantified bit‑vectors, totalised division, and mixed signed/unsigned reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvudiv0_64bit.smt2",
    "description": "The benchmark is a 64‑bit bit‑vector problem (logic BV) of modest size (≈1.3 KB, 2 declared constants, 3 defined functions and a single quantified assertion).  It originates from the authors’ work on “invertibility conditions” for quantified bit‑vectors [1] and is meant to be run on solvers such as Boolector, CVC4 or Z3.  The file defines totalised versions of unsigned division and remainder (`udivtotal`/`uremtotal`) that return a distinguished value when the divisor is zero, together with the concrete 64‑bit constants `min` and `max`.  The core predicate `SC(s,t)` states the expected algebraic property of division in the non‑zero case: `(s·t) ÷ s = t` using the totalised division.  The sole assertion negates the bi‑implication that `SC(s,t)` holds exactly when there exists an `x` such that `x ÷ s = t`; thus the solver is asked to look for a counter‑example to the equivalence of the concrete property and the existential invertibility condition.  This makes the instance a crafted test of a solver’s ability to handle quantified bit‑vector reasoning together with defined‑functions and edge‑case totalisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvudiv0_64bit.smt2",
    "description": "The file is a crafted 64‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 KB, 2 constants, 3 auxiliary function definitions) generated for the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. It defines totalised versions of unsigned division and remainder (`udivtotal`, `uremtotal`) that return a distinguished value when the divisor is zero, and also introduces the extremal 64‑bit constants `min` and `max`. The core predicate `SC(s,t)` states that the signed‑greater‑or‑equal comparison holds for at least one of the two “extreme” divisions of the all‑ones value by `s`. The single assertion negates the logical equivalence between `SC(s,t)` and the existence of some `x` such that `udivtotal(x,s)` is signed‑greater‑or‑equal to `t`; thus the solver is asked to find a counter‑example to this invertibility condition. The benchmark mixes signed (`bvsge`) and unsigned (`bvudiv`) operations, uses an `ite`‑based totalisation of division‑by‑zero, and contains a quantified existential, making it a typical target for solvers supporting quantified bit‑vectors (Boolector, CVC4, Z3).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvurem0_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV) of about 1.3 KB, generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vector invertibility conditions. It declares two 64‑bit variables `s` and `t` and defines total‑behaviour versions of unsigned division and remainder that return a default value when the divisor is zero. The core property, named **SC**, states that either `t` is signed‑less‑than `s` or `s` is non‑positive; the benchmark then asserts the negation of a bidirectional implication linking this condition to the existence of an `x` whose signed‑greater‑or‑equal remainder (`uremtotal x s`) reaches at least `t`. In other words, it checks whether the logical equivalence  \n\\[\nSC(s,t) \\;\\leftrightarrow\\; \\exists x.\\; \\text{bvsge}( \\text{uremtotal}(x,s), t )\n\\]  \nholds for all 64‑bit values. The single quantified assertion makes the instance a typical test for solvers’ handling of quantified bit‑vectors and totalised arithmetic operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr1_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV, 1 assertion, 2 declared constants, 3 defined functions, 1321 characters) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It introduces total versions of unsigned division and remainder (guarded by a zero‑divisor test), constants min and max for the unsigned range, and a predicate **SC(s,t)** that states “ s is unsigned‑less than t, s is not negative as a signed value, and t ≠ 0 ”. The core property asserts the logical equivalence between **SC(s,t)** and the existence of a 64‑bit shift amount x such that the arithmetic right‑shift of s by x** (bvashr) is unsigned‑less than t**. By negating this equivalence and checking satisfiability, the benchmark verifies whether the invertibility condition for the **bvashr** operator with respect to **bvult** holds under the given side‑conditions. It therefore exercises quantified bit‑vector reasoning, total‑function handling via ite‑expressions, and the interaction of signed/unsigned comparisons in modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_4bit.smt2",
    "description": "The file is a handcrafted 4‑bit bit‑vector benchmark (size ≈ 1.3 KB, 2 declared constants, 3 auxiliary definitions) written in the BV logic of SMT‑LIB 2.6 and originates from the CAV 2018 paper *Solving Quantified Bit‑Vectors using Invertibility Conditions* (generated by Mathias Preiner). It defines totalised unsigned‑division and unsigned‑remainder operators that return a distinguished value when the divisor is zero, and a predicate **SC** that relates two 4‑bit vectors `s` and `t` using signed‑greater‑than/less‑than tests on `s`. The single top‑level assertion negates the equivalence  \n\n```\nSC(s,t)  ⇔  ∃x . (uremtotal s x) >_s t\n```  \n\ni.e., it asks whether the “invertibility condition” SC precisely characterises the existence of a remainder larger than `t`. Hence the solver is expected to show *unsat* (no counterexample) if the condition is correct, otherwise it will return *sat* with a concrete 4‑bit assignment violating the equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv1_32bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (32‑bit bit‑vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is 1.3 KB, contains two declared constants `s` and `t`, three auxiliary definitions, and a single quantified assertion.  Two totalised arithmetic functions are introduced – `udivtotal` and `uremtotal` – which return a distinguished “all‑ones” value when the divisor is zero, thereby avoiding undefined division‑by‑zero behaviour.  A predicate `SC(s,t)` is defined as the unsigned “strictly‑less‑than‑max” condition `t < 0xFFFFFFFF`.  The core property asserts that `SC(s,t)` is equivalent to the existence of a witness `x` such that the totalised unsigned division `udivtotal(s,x)` is **strictly greater** than `t`; the benchmark checks the negation of this equivalence.  Thus the solver is asked to decide whether there is any pair of 32‑bit values `s` and `t` for which the invertibility condition for `bvudiv` w.r.t. `bvugt` fails, a typical verification task for quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_4bit.smt2",
    "description": "This instance is a crafted 4‑bit bit‑vector benchmark (logic BV) with 2 declared constants, 3 auxiliary definitions and a single quantified assertion; its source is the CAV‑2018 paper on “Solving Quantified Bit‑Vectors using Invertibility Conditions” (generated by Mathias Preiner).  The core of the problem is the predicate  \n\n\\[\n\\text{SC}(s,t)\\;:=\\; t \\;\\ge_{s}\\; (t\\;\\text{>>}_{\\text{arith}}\\, s),\n\\]\n\nwhere the shift is the signed arithmetic right‑shift and the comparison is signed (bvsge).  The benchmark checks the equivalence between this predicate and the existence of a 4‑bit value x such that  \n\n\\[\n(bvlshr\\;x\\;s) \\le_{s}\\; t,\n\\]\n\nby asserting the negation of the two implications \\(\\text{SC}(s,t)\\Rightarrow\\exists x\\) and \\(\\exists x\\Rightarrow\\text{SC}(s,t)\\).  Auxiliary functions (udivtotal, uremtotal, min, max) are defined only to avoid division‑by‑zero and to give convenient constants, but they are not used in the main constraint.  The test thus probes the invertibility condition for the combination of signed right‑shift and signed ≤/≥, and a correct solver should return **unsat**, showing the equivalence holds for all 4‑bit assignments.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_32bit.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors, and it is classified as a crafted instance of size ≈1.3 KB.  It declares two 32‑bit variables `s` and `t`, defines three helper functions (`udivtotal`, `uremtotal`, and the constant `min`/`max`), and introduces the predicate  \n\n\\[\nSC(s,t)\\;:=\\;(s<_{s}0 \\Rightarrow (s\\!\\gg\\!1) >_{s} t)\\;\\land\\;(s\\ge_{s}0 \\Rightarrow s >_{s} t),\n\\]\n\nwhere `bvlshr` is a logical right‑shift and `bvsgt`/`bvslt` are signed comparisons.  The single assertion negates the bi‑implication  \n\n\\[\nSC(s,t) \\;\\Leftrightarrow\\; \\exists x.\\; (s\\!\\gg\\!x) >_{s} t,\n\\]\n\nso the solver must decide whether the existence of a shift amount that makes `s` exceed `t` is exactly captured by the piece‑wise condition `SC`.  The benchmark therefore checks the correctness of an invertibility condition for the signed‑greater‑than of a logical shift, and it is intended to be solved by modern BV solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvshl0_64bit.smt2",
    "description": "This instance is a crafted 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it contains two declared constants `s` and `t` and a single quantified assertion, occupying roughly 1.3 KB with a term depth of 7.  Three helper definitions provide totalised unsigned division and remainder (returning a “don’t‑care” value for divisor 0) and the extremal bit‑vectors `min` and `max`.  The core predicate `SC(s,t)` is defined as a signed‑less‑than test: `t` must be smaller than the high half of `max` shifted left by `s`.  The sole assertion negates the equivalence between `SC(s,t)` and the existence of a 64‑bit witness `x` such that the signed‑greater‑than relation `(x << s) >_s t` holds, i.e., it checks whether `SC` correctly characterises the solvability of the shifted‑greater‑than condition.  Hence the benchmark encodes a tiny quantified verification task: is the logical condition `SC` exactly the invertibility condition for the operation “signed‑greater‑than after a left shift” on 64‑bit vectors?",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvshl1_64bit.smt2",
    "description": "This benchmark is a 64‑bit **BV** (bit‑vector) problem (2 631 characters, 2 declared constants, 3 auxiliary definitions) taken from the Preiner‑CAV 2018 suite that tests the “invertibility‑condition” methodology described in [1].  The core predicate **SC(s,t)** is defined as the disjunction of 65 comparisons `bvugt (bvshl s k) t` for shift amounts k = 0,…,64, i.e. it holds exactly when some left‑shift of s by a concrete constant exceeds t.  The single assertion negates the equivalence  \n\n```\nSC(s,t)  ⇔  ∃x. bvugt (bvshl s x) t ,\n```  \n\nthereby asking the solver to find s and t for which the existence of a *variable* shift does **not** coincide with the exhaustive constant‑shift test.  The instance therefore checks the soundness of the quantified condition for the unsigned‑greater‑than‑after‑shift relation, using quantified bit‑vectors together with a handful of totalised division/rem operations that are otherwise unused.  It is a crafted, quantifier‑heavy benchmark aimed at Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_4bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 4‑bit vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It declares two 4‑bit constants `s` and `t` and defines a small library of total division/remainder, as well as the constants `min` (= 8) and `max` (= 7) obtained by bit‑wise tricks. The predicate  \n\n\\[\nSC(s,t)\\;:=\\; \\texttt{bvsge}(\\texttt{bvlshr}(\\texttt{max},s),\\,t)\n\\]\n\ncaptures a signed‑greater‑or‑equal condition on a logical right‑shift of the constant `max`. The sole assertion negates the equivalence  \n\n\\[\nSC(s,t) \\;\\leftrightarrow\\; \\exists x.\\; \\texttt{bvsge}(\\texttt{bvashr}(x,s),\\,t),\n\\]\n\ni.e., it asks the solver to find a 4‑bit counter‑example where the existence of an arithmetic‑right‑shifted value satisfying the signed order does **not** coincide with the simpler `SC` condition. The benchmark is small (≈ 1 KB, 2 declared variables, 1 top‑level assertion) and is intended to test solvers’ handling of quantified bit‑vector invertibility reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvconcat0_34_32bit.smt2",
    "description": "This file is a handcrafted BV‑logic benchmark (logic BV, 1052 bytes, 3 declared bit‑vector constants) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions. It works over 32‑bit vectors `s` and `ts` and 34‑bit vectors `tx` and an existentially quantified `x`. Two auxiliary constants, `min` = 2³⁴−2 and `max` = ¬`min` (i.e., all‑ones), are defined and a Boolean predicate `SC` states that if `tx` equals the all‑ones word then the 32‑bit value `s` must be unsigned‑greater‑or‑equal to `ts`. The sole assertion negates the logical equivalence between `SC` and the existence of a 34‑bit prefix `x` such that the 66‑bit concatenation `concat(x,s)` is unsigned‑greater‑or‑equal to `concat(tx,ts)`. In other words, the benchmark asks the solver to refute (or confirm) that the condition on the high‑order bits (`tx` being all‑ones) exactly characterises when a suitable low‑order extension makes the concatenated numbers compare as required. The instance exercises quantified bit‑vectors, concatenation across different widths, and unsigned‑comparison, making it a typical test for solvers’ handling of such invertibility‑condition reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvudiv1_64bit.smt2",
    "description": "This benchmark is a crafted BV‑logic instance (64‑bit bit‑vectors) of about 1.3 kB that was generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. It declares two 64‑bit variables `s` and `t` and defines totalised versions of unsigned division (`udivtotal`) and remainder (`uremtotal`) that return a deterministic value when the divisor is zero. A Boolean predicate `SC(s,t)` expresses a mixed signed condition – either `s <_s t` or `t ≥_s 0`. The single assertion negates the bidirectional implication that `SC(s,t)` holds exactly when there exists a 64‑bit `x` such that the signed‑less‑than comparison `(udivtotal s x) <_s t` is true; in other words, it checks whether the invertibility condition for unsigned division with respect to signed less‑than is sound. The formula contains quantified `exists` and uses the totalised operators to avoid undefined division, making it a typical benchmark for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_32bit.smt2",
    "description": "This SMT‑LIB file is a crafted 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It declares two 32‑bit variables `s` and `t` and defines auxiliary total‑division and total‑remainder functions that return a defined value when the divisor is zero, as well as constant “min” and “max” bit‑vectors. The core predicate `SC(s,t)` is defined as the disjunction “`t` is non‑negative or `t` is at least `s`” (using signed‑greater‑or‑equal), and the sole assertion negates the equivalence between `SC(s,t)` and the existence of a 32‑bit witness `x` such that the signed arithmetic right‑shift `bvashr(s,x)` is less‑or‑equal to `t`. In other words, the benchmark asks the solver to prove that `SC(s,t)` holds **iff** there is an `x` making the shifted value bounded by `t`. The instance contains a single quantified implication pair (two `=>` inside an `and`), uses a small depth (max 7), and is intended to be checked for unsatisfiability by solvers such as Boolector, CVC4, or Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvurem1_64bit.smt2",
    "description": "This benchmark is a crafted 64‑bit bit‑vector problem (logic BV, 1 852 bytes, 1281 characters) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vector invertibility conditions.  \nIt introduces totalised versions of unsigned division and remainder ( udivtotal and uremtotal ) that return a distinguished “all‑ones” value when the divisor is zero, together with the 64‑bit constants min and max.  \nA Boolean predicate SC(s,t) is defined as bvuge(bvand(bvsub(bvadd t t) s) s) t), which is the invertibility condition conjectured for the equation uremtotal(s,x)=t.  \nThe single assertion negates the bi‑implication that SC(s,t) holds exactly when there exists a bit‑vector x satisfying uremtotal(s,x)=t; thus the solver is asked to find a counter‑example to the equivalence.  \nIf the invertibility condition is correct, the formula is unsatisfiable, making the instance a targeted test of solvers’ handling of quantified bit‑vectors and totalised arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvshl0_32bit.smt2",
    "description": "The file is a crafted 32‑bit bit‑vector benchmark (logic **BV**) generated by Mathias Preiner for the CAV‑2018 paper on quantified bit‑vectors; it contains two declared constants, three auxiliary definitions, and a single quantified assertion (1260 bytes, max term depth 7).  \nIt defines a total‑division and total‑remainder operator, the extremal values **min** and **max**, and a predicate **SC(s,t)** that holds exactly when shifting t right by s and then left by s reproduces t (i.e., `t = (t >>> s) <<< s`).  \nThe main property being checked is the bi‑implication between this syntactic shift‑compatibility condition and the existence of a witness x such that `x <<< s = t`.  \nThe benchmark asserts the **negation** of that equivalence, so the solver is asked to find a counterexample where **SC** and the solvability of the left‑shift equation diverge.  \nThus the instance tests the invertibility condition for the bit‑vector left‑shift operator, a key ingredient in the paper’s quantifier‑elimination technique.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_32bit.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it contains two free bit‑vector constants `s` and `t` and a handful of totalised arithmetic helpers (`udivtotal`, `uremtotal`).  The auxiliary functions `min` and `max` compute the smallest and largest unsigned 32‑bit values, while the predicate `SC(s,t)` captures a piecewise signed‑comparison condition on `s` (positive `s` must be larger than `t`, otherwise a shifted‑down version of `s‑1` must exceed `t`).  The single assertion negates the bidirectional implication that `SC(s,t)` holds exactly when there exists a 32‑bit `x` such that the signed‑greater‑than test `bvsgt (uremtotal s x) t` is true.  Hence the solver is asked to check whether the existence of a remainder (with division by zero safe‑guarded) greater than `t` is logically equivalent to the `SC` condition.  The instance is a crafted, quantified benchmark (size ≈ 1.4 KB, depth 7) intended for solvers like Boolector, CVC4 and Z3 to exercise their handling of quantified bit‑vector invertibility reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr0_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV, 1276 bytes) generated for the CAV‑2018 paper on invertibility conditions for quantified bit‑vectors. It declares two 64‑bit variables `s` and `t` and defines auxiliary functions for total unsigned division/remainder (guarding against division‑by‑zero) and the signed extremal constants `min = 0x8000…0` and `max = 0x7FFF…F`. The predicate  \n\n```\nSC(s,t) :=  t <_s ((max << s) >>_l s)\n```  \n\nexpresses a signed‑less‑than bound on `t` that depends on `s`. The sole assertion negates the bi‑implication that `SC(s,t)` is equivalent to the existence of an `x` such that the shifted value `(x >>_l s)` is signed‑greater‑than `t`:  \n\n```\n¬[ (SC ⇒ ∃x. (x >> s) >_s t) ∧ (∃x. (x >> s) >_s t ⇒ SC) ] .\n```  \n\nThus the benchmark asks a solver to find a counter‑example to the claimed invertibility condition for the relation “signed‑greater‑than after logical right‑shift”, exercising quantified reasoning, 64‑bit arithmetic, and signed comparison.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvudiv0_64bit.smt2",
    "description": "The file is a small (≈1 KB, 2 constants, 1 assertion) BV‑logic benchmark generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions of quantified bit‑vectors.  It works over 64‑bit bit‑vectors s and t and introduces totalised versions of unsigned division and remainder ( udivtotal and uremtotal ) that return a default value when the divisor is zero.  A helper predicate SC(s,t) asserts the “safe‑case’’ condition s ≠ 0 ∨ t ≠ −1 (all‑ones), and the sole assertion negates the equivalence  \n SC(s,t) ↔ ∃ x · udivtotal(x,s) ≠ t.  \nThus the benchmark checks whether the existence of a witness x for a division result differing from t is exactly characterised by the safe‑case predicate, i.e. it verifies the invertibility condition for unsigned division with a totalised divisor.  It is labelled as a crafted benchmark intended for Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem1_64bit.smt2",
    "description": "The file is a handcrafted 64‑bit bit‑vector benchmark (logic BV, 1 assertion, 2 declared constants, 3 auxiliary definitions, 1 336 bytes) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors.  \nIt introduces totalised versions of unsigned division and remainder—`udivtotal` and `uremtotal`—that return a default value when the divisor is zero, together with the 64‑bit minimum and maximum constants.  \nA Boolean predicate `SC(s,t)` is defined using signed comparisons (`bvsge`, `bvslt`) and a shifted‑sub expression, capturing a specific relationship between the two input words `s` and `t`.  \nThe sole constraint asserts the negation of a bidirectional implication: `SC(s,t)` should be equivalent to the existence of a witness `x` such that the totalised unsigned remainder of `s` by `x` is **signed‑greater‑than** `t`.  \nThus the benchmark checks whether this invertibility condition for `bvurem` under a signed‑greater‑than test holds for all 64‑bit values, a property that is expected to be either provable or refuted by solvers like Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_64bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic BV, 64‑bit vectors, 1 assertion, 2 declared constants, 1272 bytes) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vector invertibility conditions. It introduces total versions of unsigned division and remainder (guarding against division‑by‑zero), defines the 64‑bit constants min = 2⁶³‑1 and max = ¬min, and a predicate SC(s,t) that holds when either s is below min or t is not smaller than s. The core formula asserts the negation of a bidirectional implication: SC(s,t) ↔ ∃x · (bvashr s x) ≤_u t, i.e., it checks whether the simple arithmetic condition SC exactly characterises the existence of a right‑shift amount making the unsigned‑less‑equal comparison true. Thus the benchmark tests the solver’s ability to reason about quantified bit‑vector arithmetic, totalised operations, and the equivalence of a derived invertibility condition. It is intended for Boolector, CVC4 and Z3 and is labeled “crafted” in the metadata.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_64_64bit.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic BV) generated for the CAV‑2018 paper on invertibility conditions; it contains three 64‑bit constants `s`, `ts` and `tx` and a single quantified assertion (size ≈ 1 KB, 3 declares, 1 assert).  Two helper constants `min` and `max` are defined as the signed‑minimum and signed‑maximum 64‑bit values, and a Boolean predicate **SC** asserts the signed‑greater‑or‑equal relation `s ≥_s ts` together with the side condition that, when `s = ts`, the word `tx` must be non‑zero.  The core of the benchmark is the equivalence\n\n\\[\nSC \\;\\Longleftrightarrow\\; \\exists x{:}64.\\; (concat\\;s\\;x) >_s (concat\\;ts\\;tx),\n\\]\n\nwhere `concat` builds a 128‑bit word from the 64‑bit parts and `bvsgt` is signed greater‑than.  The asserted formula negates this equivalence, so the solver is asked to find a model where the condition fails, i.e., to check whether the invertibility condition for `bvsgt` with concatenation holds.  The instance is “crafted”, targets solvers such as Boolector, CVC4 and Z3, and exercises quantifier reasoning, signed comparisons, and bit‑vector concatenation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic **BV**) of modest size (≈1 KB, 2 constants, 1 quantified assertion) generated by Mathias Preiner for the CAV 2018 paper on *invertibility conditions* and licensed under CC‑BY 4.0.  It declares two 32‑bit variables `s` and `t` and defines three helper functions: `udivtotal` and `uremtotal` that make unsigned division and remainder total by returning a default value when the divisor is zero, and `min`/`max` that compute the smallest and largest signed 32‑bit values.  The core predicate `SC(s,t)` asserts the signed‑greater‑or‑equal relation `t ≥ (t >>> s)` (arithmetic right‑shift).  The single assertion negates the bi‑implication between `SC(s,t)` and the existence of a witness `x` satisfying `((x >>> s) ≤ₛ t)`, i.e. it checks whether the “invertibility condition” for the right‑shift with respect to signed ≤ holds for all 32‑bit inputs.  The benchmark therefore exercises a solver’s handling of quantified bit‑vectors, totalised arithmetic, and signed comparison across shift operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvlshr1_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark in the **BV** logic (size ≈ 1.3 KB, 2 declared constants and 3 auxiliary definitions) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions.  It defines total‑behaviour variants of unsigned division and remainder (returning a default value when the divisor is zero), as well as the minimum and maximum signed 64‑bit values, and introduces the Boolean predicate **SC(s,t)** that relates two signed numbers by: if s is negative then (s >> 1) > t, otherwise s > t.  The single assertion states the negation of the bidirectional implication between **SC(s,t)** and the existential statement “there exists an unsigned shift amount x such that (s >> x) > t” (the comparison being signed greater‑than).  Consequently the solver is asked to find a pair (s,t) that makes the two conditions non‑equivalent, i.e., a counterexample to the proposed equivalence.  The benchmark therefore tests quantified reasoning over bit‑vector shifts and signed comparisons, a characteristic pattern used to validate the invertibility‑condition techniques described in the cited publication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_32bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (32‑bit bit‑vectors, 1 279 bytes, 2 declared constants, 3 auxiliary definitions) generated for the CAV‑2018 paper on invertibility conditions.  \nIt introduces a predicate `SC(s,t)` that holds when either the unsigned value `t` is below the signed‑minimum constant `min = 0x80000000` or the signed value `t` is greater‑or‑equal to `s`.  \nThe single assertion negates the conjunction of two implications:  \n\n1. `SC(s,t) ⇒ ∃x. (bvlshr s x) ≤_signed t`  \n2. `∃x. (bvlshr s x) ≤_signed t ⇒ SC(s,t)`  \n\nThus the benchmark asks the solver to find a counter‑example to the equivalence between `SC` and the existence of a logical right‑shift amount `x` that makes the shifted `s` signed‑less‑or‑equal to `t`.  \nOnly the constants `min` and `max` (the signed‑min and max) are actually used; the total division/remainder helpers are present but unused.  \nThe problem is meant to be solved by standard BV solvers such as Boolector, CVC4, or Z3 and serves to check the correctness of the derived invertibility condition for the `bvlshr`/`bvsle` combination.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvlshr1_64bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (64‑bit bit‑vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is 1 KB long, declares only two constants `s` and `t`, and contains three auxiliary definitions (total unsigned division/remainder and the extreme values `min`/`max`).  \nThe core predicate `SC(s,t)` is simply `t <u s`, and the single asserted formula negates the bi‑implication  \n\n\\[\nSC(s,t)\\;\\;\\Longleftrightarrow\\;\\;\\exists x\\!:\\;(s \\;>>\\_u\\; x) >u t ,\n\\]\n\nwhere `>>_u` is the unsigned logical right‑shift.  \nThus the solver must show whether, for all 64‑bit values of `s` and `t`, the existence of a shift amount producing a larger result is exactly equivalent to the ordering `t <u s`.  \nAll other defined functions (`udivtotal`, `uremtotal`, `min`, `max`) are unused in the assertion and merely illustrate the “total‑operation” style employed in the paper.  \nThe benchmark targets Boolector, CVC4 and Z3 and is classified under the “crafted” category of the Preiner‑CAV18 family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvashr0_64bit.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is a small crafted instance (≈1.3 KB, 2 declared constants, 3 user‑defined functions, a single quantified assertion). The two free bit‑vectors `s` and `t` are used in the definition  \n\n\\[\nSC(s,t) \\;:=\\; \\texttt{bvsge}(\\texttt{bvlshr}(\\texttt{max},s),\\,t),\n\\]\n\nwhere `max` is the 64‑bit value with all bits 1; `SC` therefore checks whether the signed‑greater‑or‑equal relation holds between `t` and the logical right‑shift of the maximal signed value by the amount `s`. The sole assertion negates the conjunction of the two implications  \n\n\\[\nSC(s,t) \\Rightarrow \\exists x.\\, \\texttt{bvsge}(\\texttt{bvashr}(x,s),t) \\quad\\text{and}\\quad\n\\exists x.\\, \\texttt{bvsge}(\\texttt{bvashr}(x,s),t) \\Rightarrow SC(s,t),\n\\]\n\nso the solver is asked to find a pair `s, t` that breaks the equivalence between the `SC` condition and the existence of an `x` making the arithmetic right‑shift satisfy the same signed comparison. The test thus encodes a verification of the invertibility condition for the arithmetic‑right‑shift operator under a signed‑greater‑or‑equal predicate, and includes auxiliary total‑division functions (unused) and explicit handling of division‑by‑zero to keep the instance self‑contained for solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvurem1_64bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 64‑bit vectors) of about 1.3 KB that originates from the CAV 2018 paper on quantified bit‑vectors and invertibility conditions (generated by Mathias Preiner).  It declares two 64‑bit constants `s` and `t` and defines three auxiliary functions: `udivtotal` and `uremtotal`, which safely return a total unsigned division/remainder by mapping a zero divisor to a default value, and the constants `min` and `max` that denote the smallest and largest unsigned 64‑bit numbers.  The heart of the instance is the predicate `SC(s,t)`, which expresses a particular ordering condition using a combination of unsigned‑greater‑or‑equal (`bvuge`) and a bit‑wise test on `s` and `t`.  The sole assertion negates the bi‑implication that `SC(s,t)` holds exactly when there exists a 64‑bit `x` such that the guarded remainder `uremtotal(s,x)` is at least `t` (i.e., `bvuge (uremtotal s x) t`).  Thus the solver is asked to find a counterexample to this invertibility condition; a satisfiable result would exhibit values of `s` and `t` where the condition fails, while unsat would confirm the equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvmul_32bit.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 kB, 2 declared constants, 3 auxiliary definitions) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors and invertibility conditions.  It defines totalizing versions of unsigned division and remainder, the extreme signed values **min** and **max**, and a predicate SC(s,t) that checks whether the signed‑greater‑or‑equal relation holds between the “masked” value (bvand (bvor (bvneg s) s) max) and t.  The single top‑level assertion negates the equivalence between SC(s,t) and the existence of a 32‑bit multiplier x such that the signed product bvmul x s is ≥ t, i.e., it asks whether the condition SC is both necessary and sufficient for solving the inequality.  Consequently the solver must search for a concrete pair (s,t) that falsifies this bidirectional implication, exercising quantified reasoning, signed comparisons, and bit‑vector arithmetic.  The benchmark is handcrafted to stress solvers’ handling of quantified bit‑vectors, invertibility‑condition reasoning, and edge‑case handling of signed overflow.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvlshr1_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) with 2 declared constants `s` and `t`, generated for the CAV‑2018 paper on quantified bit‑vectors (family *Preiner‑cav18*).  It defines three helper functions: `udivtotal` and `uremtotal` that give a totalised unsigned division/remainder by returning a distinguished value when the divisor is zero, and `min`/`max` which denote the signed‑negative‑half‑range and its complement (i.e., −2⁶³ and 2⁶³‑1).  The core predicate `SC(s,t)` is the disjunction “ `t` is strictly smaller than `min` or `t ≥ s` ” expressed with signed comparisons (`bvult`, `bvsge`).  The single top‑level assertion negates the bi‑implication that `SC(s,t)` holds exactly when there exists a 64‑bit shift amount `x` such that the arithmetic right shift `s >>ₐ x` is signed‑less‑or‑equal to `t`.  Thus the benchmark checks the correctness of an invertibility condition for the signed‑less‑or‑equal‑after‑shift relation, and its small size (≈ 1 kB, depth 7) makes it suitable for solvers like Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvashr0_64bit.smt2",
    "description": "This benchmark is a crafted 64‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is 1.3 KB in size and contains two declared constants `s` and `t`.  Three auxiliary functions are defined: `udivtotal` and `uremtotal` give totalised unsigned division/remainder (returning a default value when the divisor is zero), and `min`/`max` compute the smallest and largest signed 64‑bit values.  The key predicate `SC(s,t)` is defined as the signed‑less‑than test `bvslt (bvashr min s) t`, i.e. the result of arithmetically shifting the minimal signed value right by `s` and comparing it to `t`.  The single assertion negates the equivalence between this predicate and the existence of a witness `x` such that `bvslt (bvashr x s) t` holds, thereby checking whether the invertibility condition “∃ x · (bvashr x s) < t ⇔ SC(s,t)” is valid.  The instance is meant to be fed to solvers like Boolector, CVC4 or Z3 to test their handling of quantified bit‑vectors and totalised arithmetic operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_eq_bvmul_32bit.smt2",
    "description": "This SMT‑LIB file works in the **BV** (fixed‑size bit‑vector) logic and was generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it is a small handcrafted benchmark (≈1 KB, 2 declared 32‑bit variables, 3 auxiliary definitions).  The core of the problem is the predicate  \n\n\\[\nSC(s,t)\\;:=\\;( ( \\neg s \\lor s ) \\,\\&\\, t ) = t,\n\\]\n\nwhich the benchmark claims should be equivalent to the existence of a multiplier \\(x\\) satisfying \\(x·s = t\\) over 32‑bit bit‑vectors.  The sole assertion negates the conjunction of the two implications  \n\n\\[\nSC(s,t)\\Rightarrow \\exists x.\\;x·s = t \\quad\\text{and}\\quad \n(\\exists x.\\;x·s = t)\\Rightarrow SC(s,t),\n\\]\n\nso a solver must exhibit a pair \\((s,t)\\) that breaks this equivalence.  The file also defines total‑division and total‑remainder helpers (unused here) and min/max constants, illustrating typical bit‑vector idioms.  Its purpose is to test quantified‑BV reasoning in solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvashr1_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it contains two 64‑bit constants `s` and `t` and a handful of auxiliary definitions (total unsigned division/remainder, `min`/`max`, and the predicate `SC`).  \n`SC(s,t)` is defined as the disjunction “`t` is non‑negative (signed) or `t` is at least `s`”, i.e. `(bvsge t 0) ∨ (bvsge t s)`.  \nThe single assertion negates the bidirectional implication that `SC(s,t)` holds exactly when there exists a 64‑bit shift amount `x` such that the signed arithmetic right‑shift `bvashr(s,x)` is less‑than‑or‑equal to `t`.  \nThus the solver is asked to check whether the quantified condition  \n\n```\nSC(s,t) ↔ ∃x . bvashr(s,x) ≤_s t\n```  \n\nis valid for all `s` and `t`; the outer `not` makes the instance unsatisfiable if the equivalence is indeed a theorem.  \nThe benchmark is relatively small (≈1 KB, depth 7), contains two quantifiers, and was crafted to test solvers’ handling of quantified bit‑vector invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvand_32bit.smt2",
    "description": "This benchmark is a handcrafted 32‑bit bit‑vector problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions; it contains two free 32‑bit variables **s** and **t** and a single top‑level assertion.  It defines auxiliary total‑definition functions for unsigned division and remainder (guarding against division‑by‑zero), the extreme values **min** = 0…0 111…1 and **max** = 1…1 000…0, and a predicate `SC(s,t)` that holds exactly when `t` is signed‑less‑than the bitwise‑and of `s` with **max** (i.e., when t < s & 0x7FFFFFFF).  The core property being examined is the equivalence  \n\n```\nSC(s,t) ↔ ∃x. (x & s) >_s t\n```  \n\nwhere `bvsgt` is signed greater‑than; the benchmark asserts the negation of this equivalence, so it is satisfiable iff there exists a counter‑example to the claimed invertibility condition.  The formula is shallow (maximum term depth 7) but features quantifiers, conditional definitions (`ite`), and mixed signed/unsigned operations, making it a typical stress test for solvers like Boolector, CVC4, and Z3.  Its modest size (≈1 KB, 1 assertion) and use of both arithmetic and bit‑wise primitives highlight subtle interactions that can provoke missed quantifier‑instantiation or division‑by‑zero handling bugs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_2_64bit.smt2",
    "description": "This benchmark is a crafted BV‑logic (bit‑vector) instance of size ≈ 1 KB (1044 characters) generated for the CAV‑2018 paper on invertibility conditions, and is meant to be run on solvers such as Boolector, CVC4 or Z3.  It declares three constants: a 64‑bit word `s`, a 2‑bit word `tx`, and another 64‑bit word `ts`; two auxiliary 2‑bit constants `min` (value 2) and `max` (value 1) are defined but not used later.  The core property, named `SC`, states that if `tx` equals the bit‑wise complement of zero (i.e. `tx = 3`), then `s` must be unsigned‑greater‑than `ts`.  An assertion then negates the bi‑implication between `SC` and the existence of a 2‑bit prefix `x` such that the 66‑bit numbers obtained by concatenating `x` with `s` and `tx` with `ts` satisfy `bvugt`; in other words, it checks that “`SC` holds iff there exists an `x` making `concat x s > concat tx ts`” is *always* true.  The formula therefore tests the correctness of the invertibility condition for the unsigned‑greater‑than operation under bit‑vector concatenation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvule_bvashr1_32bit.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) generated by Mathias Preiner for the CAV 2018 paper on quantified bit‑vectors, with a file size of about 1.3 kB and a single quantified assertion.  It declares two 32‑bit constants `s` and `t` and defines helper functions `udivtotal` and `uremtotal` that give a totalised unsigned division/remainder (returning a distinguished value when the divisor is zero), as well as the constants `min` (the smallest unsigned 32‑bit value, i.e. 0) and `max` (the largest, i.e. 2³²−1).  The key predicate `SC(s,t)` is defined as “either `s` is below the minimum (always false) or `t` is greater‑or‑equal to `s`”, which simplifies to `bvuge t s`.  The sole assertion negates the equivalence between this side‑condition and the existence of a shift amount `x` such that the arithmetic right‑shift of `s` by `x` is unsigned‑less‑or‑equal to `t`:  \n\n```\n¬ ( (SC ⇒ ∃x. bvashr(s,x) ≤ₙ t) ∧ (∃x. bvashr(s,x) ≤ₙ t ⇒ SC) )\n```  \n\nThus the solver is asked to find a counter‑example to the purported invertibility condition for the unsigned‑right‑shift operator under the given side‑condition.  The benchmark is handcrafted, intended for solvers like Boolector, CVC4 and Z3, and exemplifies the kind of quantified reasoning that arises in verification of invertibility conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_ne_bvurem0_64bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic BV, 64‑bit vectors) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions; it contains two declared 64‑bit constants `s` and `t` and three auxiliary totalised functions: `udivtotal`, `uremtotal` (a safe remainder that returns the dividend when the divisor is zero) and the constant bounds `min`/`max`.  \n\nThe core predicate `SC(s,t)` is defined as `s ≠ 1 ∨ t ≠ 0`, i.e. it forbids the specific pair `(s = 1, t = 0)`.  \n\nThe single assertion negates the equivalence between `SC(s,t)` and the existence of a 64‑bit witness `x` such that `uremtotal(x,s) ≠ t`; formally it checks whether  \n\\[\nSC(s,t) \\;\\leftrightarrow\\; \\exists x.\\; \\text{uremtotal}(x,s) \\neq t\n\\]\nholds for all `s` and `t`.  \n\nThus the instance encodes a quantified verification condition that tests the correctness of the invertibility condition for the (totalised) unsigned remainder operation under the edge case of a zero divisor.  \n\nIts modest size (≈1 KB, 1 assertion, 2 constants, 3 defined functions) and the use of `ite`‑based totalisation make it a typical example for solvers such as Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsge_bvshl0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1.3 kB, 2 declared constants and 3 user‑defined functions) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions.  It defines total‑division and total‑remainder helpers, the signed minimum and maximum 32‑bit values, and a predicate **SC(s,t)** that holds when the signed‑greater‑or‑equal comparison `bvsge (bvand (bvshl max s) max) t` is true.  The sole assertion negates the bidirectional implication that **SC(s,t)** is equivalent to the existence of a 32‑bit word x satisfying `bvsge (bvshl x s) t`.  Thus the solver is asked to show whether, for all 32‑bit s and t, the condition expressed by **SC** exactly characterises the solvability of the shifted‑greater‑or‑equal inequality.  The benchmark is crafted to test quantified‑bit‑vector reasoning (the two `exists` quantifiers) and the handling of signed comparisons involving shift‑left and the extreme signed constants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvuge_bvshl1_64bit.smt2",
    "description": "This benchmark is a handcrafted BV‑logic (64‑bit) instance (≈3.3 KB, 2 constants, 1 top‑level assertion) generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It declares two 64‑bit bit‑vectors `s` and `t` and defines a predicate **SC(s,t)** that is true iff *some* concrete shift amount i ∈ {0,…,64} makes the unsigned‑greater‑or‑equal test `(bvshl s i) ≥ t` hold (the predicate is expressed as a long disjunction of 65 `bvuge` checks). The sole assertion negates the bi‑implication between **SC(s,t)** and the quantified formula `∃x . (bvshl s x) ≥ t`, thus asking the solver to find a model where the explicit enumeration of shift constants disagrees with the existential quantifier. The problem therefore encodes a correctness check of the “shift‑exists” invertibility condition for unsigned‑greater‑or‑equal, a typical test used to stress quantified‑bit‑vector reasoning in Boolector, CVC4 and Z3. Auxiliary total‑division and total‑remainder functions, as well as `min`/`max` constants, are defined but unused, highlighting the benchmark’s focus on the shift‑predicate equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvconcat1_62_4bit.smt2",
    "description": "This instance is a handcrafted **BV** (bit‑vector) benchmark (size ≈ 1 KB, 3 declared constants) generated for the CAV 2018 paper on quantified bit‑vector invertibility conditions.  \nIt works with a 4‑bit signed variable `s`, a 4‑bit signed variable `ts`, and a 62‑bit signed variable `tx`; auxiliary 62‑bit constants `min` and `max` are defined using bitwise not and logical shift.  \nThe Boolean predicate `SC` requires `s` to be signed‑greater‑or‑equal to `ts` and, when they are equal, forces `tx` to be non‑zero.  \nThe sole assertion negates the bi‑implication between `SC` and the existence of a 62‑bit witness `x` such that the signed concatenation `concat(s,x)` is greater than `concat(ts,tx)`.  \nThus the solver is asked to prove that `SC` is *exactly* the condition under which such a concatenated signed‑greater‑than witness exists; a satisfiable result would exhibit a counter‑example to this equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem0_4bit.smt2",
    "description": "This SMT‑LIB file is a handcrafted BV benchmark (logic BV, 4‑bit bit‑vectors) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions for quantified bit‑vectors (≈1.3 KB, 2 declared constants, 3 auxiliary definitions). It defines totalized versions of unsigned division (`udivtotal`) and remainder (`uremtotal`) that return a default value when the divisor is zero, as well as the 4‑bit minimum and maximum constants. The core predicate `SC(s,t)` is expressed as a signed‑less‑than comparison between the bitwise‑negated `t` and the bitwise‑or of the negated `s` and `t`. The single top‑level assertion negates the biconditional that `SC(s,t)` holds exactly when there exists a 4‑bit `x` such that the signed‑less‑than comparison `bvslt (uremtotal x s) t` is true; in other words, it checks whether the “invertibility condition” for the unsigned remainder with respect to a signed‑less‑than bound is valid. The benchmark is intended for solvers such as Boolector, CVC4, and Z3 to test their handling of quantified bit‑vector reasoning and totalized arithmetic edge cases.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsgt_bvurem0_32bit.smt2",
    "description": "This instance is a crafted BV‑logic benchmark (32‑bit bit‑vectors) from the CAV‑2018 paper *Solving Quantified Bit‑Vectors using Invertibility Conditions* by Preiner et al. It declares two 32‑bit constants `s` and `t`, defines totalised unsigned division and remainder operators that return a defined value when the divisor is zero, and introduces the constants `min = 0x80000000` and `max = 0x7fffffff`. The core predicate `SC(s,t)` encodes a small set of side‑conditions on the signs of `s` and the range of `t`. The single top‑level assertion negates the equivalence  \n\\[\nSC(s,t) \\;\\;\\iff\\;\\; \\exists x.\\; \\mathrm{uremtotal}(x,s) \\;>\\!_{s}\\; t,\n\\]  \nwhere `>` is signed greater‑than; thus the solver must show that the equivalence holds for all 32‑bit values. The benchmark therefore checks an invertibility condition for the signed‑greater‑than relation combined with unsigned remainder, and is intended for modern QBV‑capable solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvudiv0_64bit.smt2",
    "description": "This benchmark is a crafted 64‑bit bit‑vector problem (logic BV) of modest size (≈1.3 KB, 2 declared constants, 1 quantified assertion) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions. It introduces totalised versions of unsigned division and remainder ( udivtotal and uremtotal ) that return a default value when the divisor is zero, and defines the extreme values min and max of the 64‑bit domain. The predicate SC(s,t) holds exactly when the maximal possible result of udivtotal(—1, s) exceeds t, i.e., when the division of the all‑ones constant by s is greater than t. The single asserted formula negates the bidirectional implication that SC(s,t) is equivalent to the existence of some x such that udivtotal(x,s) is greater than t, thus checking the correctness of this invertibility condition. The instance exercises quantified reasoning, totalised arithmetic, and the unsigned‑greater‑than comparison, and is intended as a regression test for Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvmul_32bit.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark ( set‑logic BV ) consisting of 2 free 32‑bit bit‑vector variables `s` and `t` (≈1.3 KB, 1 assertion, 3 auxiliary definitions).  It defines total‑defined unsigned division/ remainder (`udivtotal`, `uremtotal`), the minimum and maximum unsigned 32‑bit values, and a predicate `SC(s,t)` that expresses a signed‑less‑than relationship involving bitwise‑and, negation and or.  The single top‑level assertion negates the equivalence between `SC(s,t)` and the existence of a 32‑bit multiplier `x` such that `x·s` is signed‑less‑than `t`; i.e., it asks whether the condition “∃x. bvmul x s <ₛ t” is exactly characterised by `SC(s,t)`.  The benchmark therefore checks the correctness of an invertibility condition for signed multiplication over 32‑bit bit‑vectors, a property that underlies the quantified‑BV techniques described in the CAV‑2018 paper.  It targets modern solvers (Boolector, CVC4, Z3) and contains nested ite‑expressions and quantifiers, making it a non‑trivial test of quantifier handling and bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvsle_bvmul_64bit.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic BV, 64‑bit vectors) of about 1.3 KB generated by Mathias Preiner for the CAV‑2018 paper on invertibility conditions. It declares two 64‑bit constants `s` and `t`, defines total division/reminder helpers that avoid division‑by‑zero, and introduces the signed minimum and maximum constants. The core predicate `SC(s,t)` is true except when `s = 0` and `t` is a signed negative number, and the single asserted formula checks the equivalence between `SC(s,t)` and the existence of a 64‑bit `x` such that the signed multiplication `x·s` is less‑or‑equal to `t` (`bvsle`). By asserting the negation of both implication directions, the benchmark asks the solver to find a counter‑example where the simple condition `SC` does **not** capture exactly the solvability of `∃x. bvsle(bvmul x s, t)`. It therefore tests quantified reasoning over bit‑vectors, handling of signed arithmetic, and the correctness of the invertibility condition for signed multiplication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvadd_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of about 1 KB, generated by Mathias Preiner for the CAV 2018 paper on quantifier‑based invertibility conditions. It declares two 32‑bit constants `s` and `t` and defines a few auxiliary total‑division functions and the signed extrema `min = 0x80000000` and `max = 0x7fffffff`; these helpers are not used in the core query. The main property, named `SC`, simply states that `t` is different from the signed minimum value. The solitary assertion negates the equivalence “`SC(s,t)` holds iff there exists a 32‑bit `x` such that `bvadd(x,s)` is signed‑less‑than `t`”, i.e. it checks whether the forward and backward implications of this condition are both valid for all `s` and `t`. Consequently the solver is asked to prove unsatisfiability of the negated bi‑implication, exercising quantified reasoning over bit‑vectors. The benchmark is handcrafted, contains a single quantified `exists`, and is intended for solvers like Boolector, CVC4, and Z3.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvslt_bvurem1_64bit.smt2",
    "description": "The file is a 64‑bit bit‑vector benchmark (logic BV) generated for the CAV‑2018 paper on invertibility conditions; it is a small handcrafted instance (≈1.3 KB, 2 declared constants, 3 defined functions, 1 top‑level assertion).  It introduces totalised unsigned division and remainder operators `udivtotal` and `uremtotal` that return a safe value when the divisor is zero, as well as `min` and `max` bit‑vector constants.  The predicate `SC(s,t)` is defined as the disjunction “`s` is signed‑less‑than `t` or `t` is positive”, and the sole assertion negates the bi‑implication that `SC(s,t)` holds exactly when there exists a 64‑bit `x` such that the signed‑less‑than comparison `uremtotal(s,x) < t` is true.  Thus the benchmark checks the correctness of a particular invertibility condition for the signed‑less‑than‑`bvurem` combination.  It is intended for solvers like Boolector, CVC4, and Z3 to decide whether the encoded equivalence is valid.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvult_bvashr0_32bit.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈1 KB, 2 declared constants, 3 auxiliary definitions) that was generated for the CAV 2018 paper on invertibility conditions for quantified bit‑vectors.  It introduces totalised unsigned division and remainder (guarded by a zero‑test), the constants min and max (the smallest and largest 32‑bit unsigned values), and a unary predicate **SC(s,t)** that simply requires the second argument t to be non‑zero.  \n\nThe single top‑level assertion negates the logical equivalence between **SC(s,t)** and the existence of a 32‑bit witness x such that an arithmetic right shift of x by s is strictly less than t (unsigned `<`).  In other words, the benchmark asks whether the condition “t ≠ 0” is exactly the invertibility condition for the relation bvashr x s < t.  \n\nThe formula combines quantifiers (`exists`), Boolean connectives (implication, conjunction, negation), and bit‑vector operators (`bvashr`, `bvult`, `bvnot`, `bvlshr`) and therefore exercises solvers’ handling of quantified bit‑vector reasoning and totalised arithmetic.  \n\nIt is a crafted instance intended for Boolector, CVC4, Z3 and similar solvers, illustrating a subtle equivalence that should be valid but is deliberately negated to check for unsatisfiability.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2018-Preiner-cav18/check_bvugt_bvconcat0_62_4bit.smt2",
    "description": "This benchmark is a crafted BV‑logic instance (logic = BV, 1050 bytes, 3 declared bit‑vector constants) generated by Mathias Preiner for the CAV 2018 paper on invertibility conditions for quantified bit‑vectors. It introduces a 4‑bit variable `s`, a 62‑bit variable `tx`, and another 4‑bit variable `ts`, and defines a Boolean condition **SC** that demands `s` be unsigned‑greater‑than `ts` whenever `tx` equals the 62‑bit all‑ones value. The sole assertion negates the bi‑implication between **SC** and the existence of a 62‑bit witness `x` such that the 66‑bit concatenation `concat x s` is unsigned‑greater‑than `concat tx ts`. In other words, the formula checks whether the simple invertibility condition **SC** is equivalent to the existence of a satisfying concatenated value, and it expects the negated conjunction to be unsatisfiable. The problem features quantified existential variables, the `concat` operation, and unsigned‑greater‑than (`bvugt`) on mixed‑width bit‑vectors, making it a typical case for solvers that support quantified bit‑vector reasoning (Boolector, CVC4, Z3).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-4.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) taken from the Wintersteiger “hardware fixpoint” suite, with 3 498 AST nodes, 10 universal and 8 existential quantifiers and a maximum term depth of 26.  The formula quantifies over ten 2 501‑bit vectors (a₀…a₄ and b₀…b₄) that model successive states of a small hardware component, and over four “primed” copies (a₀₍₃₉₎…a₃₍₃₉₎, b₀₍₃₉₎…b₃₍₃₉₎) representing a candidate fix‑point.  The core constraints express a deterministic update: each next a is either the current a (if it is ≥ 100) or a + b, and each next b is the current a; the initial condition fixes a₀ = 1 and b₀ = 0 for both the universal and existential sides.  The final property requires that after four transition steps the universally quantified state (a₄,b₄) must coincide with **some** intermediate existential state (aᵢ₍₃₉₎,bᵢ₍₃₉₎), i.e., that a fix‑point is reached within four iterations.  The instance therefore checks a safety/fix‑point condition for a hardware model using deep nesting of ite, bvult and bvadd over unusually wide (2 501‑bit) vectors, making it a challenging industrial benchmark for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-4.smt2",
    "description": "This benchmark is a quantified bit‑vector formula (logic BV) taken from the Wintersteiger “fixpoint” family of industrial hardware‑verification problems; the file is about 5 KB and contains a single, large assertion with 20 universal and 16 existential quantifiers.  It models a small arithmetic block that computes, on 8‑bit inputs in1 and in2, both the remainder (`bvurem`) and the residual `in1 – (in1 / in2)·in2` for five successive pipeline stages (indices 0…4).  The universally‑quantified part asserts that each stage’s outputs satisfy the exact division‑remainder identities, while the existentially‑quantified part introduces a copy of the same five‑stage computation for a later “iteration” (named …_39_) and forces the final stage (4) to be equal to one of those five copies, thereby encoding a fix‑point/loop‑unrolling property.  The formula therefore checks whether the hardware module reaches a steady state after a bounded number of steps; its difficulty stems from the deep nesting of quantifiers (max term depth 44) and the interplay of several bit‑vector arithmetic operators (bvurem, bvudiv, bvmul, bvsub).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-6.smt2",
    "description": "This benchmark is a quantified bit‑vector formula in the **BV** logic (SMT‑LIB 2.6) originating from the Wintersteiger “efficiently solving quantified bit‑vector formulas” paper; it models a tiny hardware pipeline taken from the VCEGAR suite and is classified as an **industrial** fix‑point check (size ≈ 14 k characters, 98 bit‑vector variables).  \nThe asserted formula quantifies universally over the pipeline’s state at seven consecutive clock cycles (variables `dataOut_64_i`, `stageOne_64_i`, `stageTwo_64_i`, `tmp_stageOne_64_i`, `tmp_stageTwo_64_i` for i = 0…6) together with the control signals `reset_64_i`, inputs `dataIn_64_i` and constants `c1_64_i`, `c2_64_i`.  \nFor each step the transition relation is encoded: the next output is either zero (when reset is true) or the sum of the two stage registers (`bvadd stageTwo stageOne`); the next stage registers are updated by adding the input to a constant (`bvadd dataIn c1`) and by masking the previous stage with another constant (`bvand stageOne c2`), while the temporary registers simply copy the previous stage values.  \nExistentially quantified “primed” copies of the same variables (with the suffix `_39_`) represent a candidate steady‑state, and the final constraint asserts that after six steps the concrete state must be identical to one of the five earlier primed states (an `or` over equality conjuncts).  \nThus the problem asks whether there exists a reachable loop (a fix‑point) in this six‑step pipeline, a typical verification task for hardware models involving deep quantifier nesting (59 ∀, 50 ∃) and a large term depth (116).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-9.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) taken from the Wintersteiger “fixpoint” suite; it contains a single huge assertion (size ≈ 7 KB, max term depth 46) and uses 2501‑bit vectors. The formula consists of a ∀…∀…∀…∃…∃… quantifier block that first universally quantifies ten pairs of state variables (a₀…a₉, b₀…b₉) and then existentially quantifies a second copy of the same ten pairs (named …_39_). Both the universal and existential copies evolve through ten synchronous steps, where each step updates   aᵢ to either the previous aᵢ₋₁ or aᵢ₋₁ + bᵢ₋₁ depending on whether aᵢ₋₁ < 100, and sets bᵢ to the previous aᵢ₋₁; this is expressed with ite, bvadd and bvult. The final constraint forces the universal and existential trajectories to meet at step 9 by requiring the universal (a₉,b₉) to be identical to one of the nine earlier existential states, expressed as a disjunction of eight equalities. Thus the instance checks whether, for every possible initial universal state, there exists a second execution that reaches the same state after at most nine iterations – a classic hardware fix‑point / safety‑reachability check. The problem is industrial‑scale, featuring 56 equalities, 31 conjunctions, 20 universal and 18 existential quantifiers, and a single large implication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-10.smt2",
    "description": "This benchmark is a quantified bit‑vector (BV) instance (logic BV) taken from the Wintersteiger et al. “efficiently solving quantified bit‑vector formulas” evaluation, using hardware models from the VCEGAR suite; it contains 12 428 characters, 84 8‑bit variables, 44 ∀‑quantifiers, 40 ∃‑quantifiers and a maximum term depth of 92.  \n\nThe single assertion describes an execution trace of a small datapath that is iterated 11 times (indices 0…10); for each step the circuit must satisfy the arithmetic definition of unsigned division: `out1 = in1 mod in2` (bvurem) and `out2 = in1 – (in1 div in2)·in2` (bvsub of a bvmul of the quotient).  \n\nTwo copies of the trace are introduced: one universally quantified (the “original” variables) and one existentially quantified (the “primed” variables with the suffix _39_).  The core constraint is an implication stating that if the original trace obeys the division definition for all steps, then the primed trace must obey the same definition for the corresponding steps.  \n\nFinally, an `or` clause forces the 10‑th step of the original trace to be equal to one of the first ten primed steps, thereby encoding the existence of a fixpoint (a loop) in the hardware’s execution.  \n\nThe formula is thus a large, deeply nested quantified BV problem that tests a solver’s ability to reason about arithmetic correctness and reachability of a cyclic state in an industrial‑scale hardware model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-6.smt2",
    "description": "This benchmark is a **BV‑logic** fixpoint‑checking problem taken from the Wintersteiger et al. hardware verification suite (VCEGAR).  \nThe file encodes a **single quantified assertion** that universally quantifies over a large set of Boolean and bit‑vector state variables (send en, load, registers, counters, etc.) for seven time frames (indices 0 through 6).  Inside the quantifier the assertion describes the **transition relation** of a synchronous hardware component: each next‑state variable is defined by a cascade of `ite` expressions that model loading data, counting bits, multiplexing, error handling, handshaking (`rdy`, `confirm`, `shot`), and output generation.  After unwinding the transition relation six times, the formula asserts that the **state at time 6 must be identical to the state at time 0** (or to any of the intermediate snapshots), i.e. it checks a **reachability‑invariance/fixpoint property**.  The instance is large (≈ 146 k tokens, 1727 `ite`s) and contains many Boolean and bit‑vector operations (`extract`, `zero_extend`, `bvadd`, `bvugt`) that capture the detailed hardware control‑flow.  The sole top‑level constraint is the implication that the system, starting from the all‑zero/false initial configuration, cannot reach a differing state after the prescribed number of steps.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-7.smt2",
    "description": "The file is a quantified bit‑vector benchmark (logic **BV**) taken from the Wintersteiger “hardware fix‑point” suite (VCEGAR hardware models) and counts 8 858 characters, 60 distinct 8‑bit variables and a single huge assertion.  \n\nThe assertion universally quantifies over eight pipeline stages (indices 0…7) of a tiny datapath; for each stage the variables `in1`, `in2`, `out1` and `out2` are related by the arithmetic identities  \n\n```\nout1 = in1  %  in2\nout2 = in1 – (in1 / in2) * in2\n```  \n\n(i.e. remainder and the remainder‑free part of a division).  \n\nInside the universal block there is an existential block that introduces a second, “candidate” copy of the same eight stages (named …_39_), and finally an implication forces the seventh stage’s outputs and inputs to be **identical to one of the seven candidate copies** (or‑branch over the seven possibilities).  \n\nThus the formula checks whether, for *all* possible sequences of inputs that respect the division/remainder semantics, the last stage can be matched to a previously‑generated copy – a typical equivalence/fix‑point property used to verify that a hardware block reaches a stable state.  \n\nThe benchmark is notable for its deep quantifier alternation (32 ∀, 28 ∃), a maximum term depth of 68 and the presence of the non‑linear bit‑vector operators `bvudiv`, `bvurem` and `bvmul`, which make it a challenging industrial case for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-8.smt2",
    "description": "This benchmark is a single quantified assertion in the BV logic (bit‑vectors of width 32) taken from the “wintersteiger” family of industrial fix‑point checks [Wintersteiger et al., FMSD 2013]; the file is about 19 KB long and contains 77 universal and 68 existential quantifiers. It models an 8‑stage pipeline hardware component, where each stage i (0 … 8) has a data output, two pipeline registers (stageOne, stageTwo), temporary copies of the registers, a reset flag, a data‑in word and two constant parameters (c1, c2). The body of the quantifiers encodes the step‑wise transition relation: on a non‑reset cycle the output is the sum of the two registers, stageOne is updated by adding the input and c1, stageTwo is the bitwise‑and of the previous stageOne and c2, and the temporary registers simply remember the previous values. The final constraint requires that after the eighth step the whole state (output, registers and temporaries) must be identical to the state of *some* earlier step (0 … 7), i.e. a fix‑point/loop condition. Because the formula uses deep nesting of ite, bvadd, bvand and equality over many copies of the same variables, it features high quantifier alternation and term depth, making it a challenging benchmark for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-8.smt2",
    "description": "The file is an SMT‑LIB 2.6 benchmark in the **BV** logic that comes from the Wintersteiger “efficiently solving quantified bit‑vector formulas’’ evaluation (category *industrial*).  It encodes a hardware interface model of a serial transmitter/receiver pipeline with nine time‑frames (indexed 0…8) – each frame contains the same set of Boolean control signals ( send_en, tre, tx_end, send, load, itfc_state, …) and a few bit‑vectors (8‑bit data registers, 10‑bit counters, 4‑bit channel selectors).  The core of the formula is a single universally quantified block that defines the transition relation between consecutive frames by a massive network of nested ite‑assignments; a second existential block introduces “primed’’ copies of the variables for the ninth frame, which are then constrained to be equal to the variables of the first frame.  The only top‑level assertion is an implication: **if** the initial frame (frame 0) is in the all‑zero/false reset state, **then** after nine deterministic transitions the system must return to exactly the same state – i.e., the model must exhibit a fix‑point (a length‑9 loop).  The instance therefore tests the solver’s ability to handle deep quantified bit‑vector formulas with thousands of ite‑ and equality constraints (≈ 2 300 ite’s, 2 200 = , 370 Booleans, 83 BitVecs) and a term depth of 472.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-3.smt2",
    "description": "**Ethernet‑fixpoint verification (wintersteiger fmsd13)** – This benchmark is a single, universally quantified assertion written in the BV logic that models a complete Ethernet transceiver (the “L0/L1” link‑layer, two frame‑transmitters FT0/FT1, back‑off timers BT0/BT1, frame‑receivers FR0/FR1, a shared channel CHN, and associated control signals).  \n\nThe formula encodes the hardware’s step‑wise state‑transition equations: each clock‑tick updates request flags, acknowledgment registers, packet data, back‑off counters, collision‑detect registers, carrier‑sense flags, and timing counters (delay, prop‑delay, collision count, etc.) via a huge nest of `ite`‑expressions and zero‑extensions over 2‑, 3‑, 4‑ and 6‑bit vectors.  \n\nAll these updates are tied together with a massive conjunction of equalities that represent the intended protocol invariants (e.g., a transmitter may send only when the channel is idle, back‑off increases after a collision, frames are correctly captured and acknowledged, and the shared channel respects carrier‑sense and collision detection).  \n\nThe instance therefore asks whether the described hardware model admits a fix‑point (i.e., a reachable state that satisfies all the invariants) for every possible valuation of its Boolean and bit‑vector signals.  \n\nIt is notable for its size (≈ 435 k characters, depth > 1000), the huge number of quantified variables (over 500 ∀ and 400 ∃), and the dominant use of `ite`, `zero_extend`, and relational operators (`bvugt`, `bvuge`), which together make it a challenging industrial verification problem for quantified‑bit‑vector solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-10.smt2",
    "description": "This benchmark is a quantified bit‑vector encoding of a hardware fix‑point (reachability) check for a simple 6‑bit state‑machine CPU, taken from the VCEGAR suite and described in Wintersteiger et al.’s “Efficiently solving quantified bit‑vector formulas” (FMSD 13). The file uses the **BV** logic, contains a single top‑level assertion, and is massive (≈ 779 k characters, 10867 equality atoms, 10 203 ite‑terms, 350 universal and 318 existential quantifiers, with a term‑depth of 688). It models a sequence of ten pipeline stages (State_64_0 … State_64_10) together with their control signals (RegRW, MemRW, ALUOp, etc.) and monitor flags for specific opcodes (j, sw, lw, nop, beqz, bnez, fsel), defining the next‑state relation by extracting opcode fields from a 32‑bit IR word and using nested ite‑expressions. The universal part quantifies over all possible values of the variables at each stage, while the existential part introduces a concrete trace (the “_39_” copies) that must satisfy the transition constraints, effectively encoding a reachability/induction query: does there exist a sequence of states that violates the safety property under the given transition relation? Because of the depth of nesting and the sheer number of quantified variables, the instance is a classic industrial‑scale challenge for solvers that handle quantified bit‑vectors and fixpoint reasoning.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-2-fixpoint-6.smt2",
    "description": "The file is a single quantified‐SMT benchmark in the **BV** logic (448 k characters, 3 645 equalities, 2 627 ite‑terms and a maximum term depth of 1 344) taken from the Wintersteiger “hardware fixpoint” suite (VCEGAR benchmarks, see www.cprover.org/hardware). It models a tiny two‑core cache‑coherence system: two private caches (**pcacheA** and **pcacheB**) interact with a shared bus arbiter that arbitrates snoop, invalidate and grant signals over six discrete time‑steps (0…5), each step being represented by a block of Boolean and 3‑bit/2‑bit BitVec variables (e.g., req_enable, is_snoop, sh_snp, state, master_out, etc.). The outermost **forall** quantifies over all possible values of the protocol state at a given step, while the innermost **exists** introduces a concrete initial configuration (values for request enables, hit/miss flags, read/write actions, etc.) that must satisfy a large conjunctive description of the transition rules (updates of proc.count, snoop_type, next_state, hit/miss logic, bus acknowledgements, and global invariants such as “all_shared = is_sharedA ∧ is_sharedB” and “mem_served = ¬(info_availA ∨ info_availB)”). The single top‑level assertion therefore checks that the instantiated initial state can evolve while respecting all the encoded cache‑coherence constraints, i.e., that the system has a reachable fixpoint satisfying the protocol’s safety properties. Because the formula is heavily quantified, deeply nested and contains thousands of Boolean and bit‑vector operations, it is a typical “industrial” challenge for quantifier‑aware SMT solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-9.smt2",
    "description": "The file is a BV‑logic benchmark from the Wintersteiger “hardware fix‑point” suite (size ≈ 21 k characters, 1 top‑level assertion, 86 universal and 77 existential quantifiers).  \nIt models a 10‑stage unrolled execution of a small 32‑bit pipeline circuit: each stage contains a `stageOne` register that adds an input word to a constant c1, a `stageTwo` register that takes the bitwise‑and of the previous `stageOne` with a constant c2, and an output `dataOut` that (when not reset) adds the two registers.  \nThe universal part enumerates the concrete state variables for steps 0…9; the existential part introduces a second copy of the same unrolled system (the “candidate” fix‑point) and asserts the same transition equations for it.  \nThe crux of the formula is the implication that, assuming the initial state is all zeroes, the concrete execution satisfies the transition relations and that the 10th concrete state must be identical to one of the earlier candidate states (expressed by a large disjunction of equalities).  \nThus the solver is asked whether a reachable loop (i.e., a steady‑state or fix‑point) exists for this bit‑vector pipeline under the given reset and input dynamics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/sdlx-fixpoint-6.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB2 file (logic BV) that originates from the VCEGAR hardware suite used in the 2013 “Efficiently solving quantified bit‑vector formulas’’ paper (family wintersteiger, category industrial). It encodes a fixpoint‑style verification problem for a small, MIPS‑like pipelined processor: the formula universally quantifies over six successive pipeline stages (State₀ … State₆ and the associated control signals such as RegRW, MemRW, ALUOp, etc.), and defines the next‑state relation with a massive cascade of `ite` expressions that decode the 32‑bit instruction word (`extract` on bits 31‑26) into monitor flags (reset, jump, load/store, branch, etc.). The core property asserted is that, starting from the reset configuration (State₀ = 0, all control bits false) and following the defined transition relation, the monitors correctly reflect the decoded opcode at each step—i.e., the pipeline never reaches a state where the decoded control signals are inconsistent with the instruction. To prove (or refute) this, the formula also introduces an existential block of “copy’’ variables (the …_39 suffixes) that represent a potential counterexample trace, turning the whole statement into a quantified fixpoint check. The instance is unusually large (≈ 453 k characters, term depth 432) and heavily nested, featuring thousands of `ite`, `extract`, and Boolean operators, which makes it a stress test for quantifier handling and bit‑vector reasoning in SMT solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-10.smt2",
    "description": "This benchmark is a quantified bit‑vector formula in the **BV** logic (SMT‑LIB 2.6) taken from the Wintersteiger “efficiently solving quantified bit‑vector formulas” paper and the VCEGAR hardware suite (file AR‑fixpoint‑10.smt2, size ≈ 8 KB, 1 assertion, max term depth 50).  \nIt models a simple arithmetic loop with eleven unrolled iterations (variables a_64_0 … a_64_10 and b_64_0 … b_64_10), each iteration updating the pair (a,b) as `if a < 100 then a+b else a` for a and copying the previous a into the next b; the bit‑vectors are unusually wide (**2501 bits**).  \nThe outermost formula universally quantifies the whole forward trace and existentially quantifies a second, identically‑initialized trace (the “_39_” variables), then asserts an implication: if both traces obey the recurrence, the final state of the first trace must coincide with **some** earlier state of the second trace (a disjunction over the ten previous steps).  \nThus the instance checks a *fix‑point / loop‑detection* property: after ten steps the system must have revisited a previous configuration.  \nThe problem is notable for its deep nesting of 22 ∀‑quantifiers and 20 ∃‑quantifiers, heavy use of ite, bvadd and bvult, and a single large conjunctive‑implication that stresses quantifier‑instantiation and bit‑vector reasoning in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-pipeline-fixpoint-5.smt2",
    "description": "The file is a single “fix‑point” benchmark in the quantifier‑rich BV logic (120 82‑bit vectors, 80 equalities, 50 universal and 41 existential quantifiers) taken from the Wintersteiger et al. hardware‑verification suite (VCEGAR, 2013).  It models a five‑stage pipelined datapath: each cycle has a 32‑bit dataIn, two pipeline registers (stageOne, stageTwo), temporary copies of the registers, a reset flag, and a 32‑bit dataOut that is either the sum bvadd of the two stages or zero when reset is true.  The universal block encodes the deterministic transition relation for five successive clock cycles, while the existential block introduces a fresh copy of the same five‑cycle execution (suffix “_39_”) to be compared with the original.  The only property asserted is a fix‑point condition: after the fifth cycle the current state (dataOut, stageOne, stageTwo, tmp_stageOne, tmp_stageTwo) must be identical to *one* of the five earlier states of the fresh copy, expressed by a disjunction of five equalities.  Thus the solver is asked whether the pipeline can reach a cyclic (steady‑state) behavior within five steps, a typical industrial verification task for small hardware pipelines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-7.smt2",
    "description": "The file is a quantified bit‑vector benchmark (logic BV) taken from the Wintersteiger “fixpoint” suite (size ≈ 5.7 kB, 1 top‑level assertion, 16 universal and 14 existential quantifiers).  It models an 8‑step transition system where each step updates a pair \\((a_i,b_i)\\) of 2501‑bit vectors by  \n\\(a_{i+1}= \\text{ite}(a_i<100,\\;a_i+b_i,\\;a_i)\\) and \\(b_{i+1}=a_i\\), starting from the concrete initial state \\(a_0=1,\\;b_0=0\\).  Inside the same implication a parallel 39‑step trace \\((a_{j}^{39},b_{j}^{39})\\) is existentially instantiated with the identical transition rule.  The core property asserts that, whenever both traces follow the rules, the 8‑step endpoint \\((a_7,b_7)\\) must coincide with *some* earlier state of the 39‑step trace (i.e., a reachability/fix‑point condition).  The benchmark is notable for its extremely wide bit‑vectors (2501 bits), deep nesting of quantifiers, and a large number of ite, bvadd and bvult terms, which together make it a hard industrial case for quantified‑BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-9.smt2",
    "description": "The file is a single quantified assertion in the **BV** logic (8‑bit vectors) taken from the Wintersteiger “small‑equiv‑fixpoint‑9” benchmark (industrial hardware fix‑point check, 11 230 characters, 40 ∀ and 36 ∃ quantifiers).  \nIt models an unrolled hardware datapath over ten time‑frames (indices 0…9); each frame contains four 8‑bit signals `in1`, `in2`, `out1` and `out2`.  \nFor every universally quantified frame the assertion enforces the exact unsigned‑division semantics:  \n`out1 = in1 bvurem in2` and `out2 = in1 bvsub (bvudiv in1 in2 ⋅ in2)`.  \nIn addition, an existential copy of the same ten frames (named with the suffix `_39_`) is introduced, and the final conjunct requires that the ninth frame’s outputs coincide with the outputs of **some** earlier frame (0‑8) of the existential copy, i.e. the circuit reaches a fix‑point within nine steps.  \nThe benchmark is notable for its deep nesting of quantifiers (max term depth 84) and its use of many identical arithmetic constraints, which makes it a challenging test for quantified‑bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-7.smt2",
    "description": "**Instance overview.** This benchmark is a quantified bit‑vector formula (SMT‑LIB 2.6, logic BV) taken from the Wintersteiger et al. “Efficiently solving quantified bit‑vector formulas” experimental suite; it models an industrial‑strength hardware component (a UART‑style interface with signals such as `send_en`, `tx_end`, `out_reg`, `data_in`, `canale`, `mux_en`, etc.).  \n\n**Problem structure.** The single top‑level assertion is a ∀…∀ … ∃…∃ block that first universally quantifies a whole 8‑step execution trace (variables indexed 0…7) and then existentially quantifies a “copy” of that trace with a suffix `_39`. The body consists of a massive cascade of `ite`‑definitions that encode the transition relation of the circuit from step i to i+1, together with the usual state‑update equations for the registers, counters, and handshake signals.  \n\n**Key property being checked.** The outermost clause asserts that the 8‑step trace either ends in a state identical to the initial one (all variables with suffix `_39` equal to those at step 0) or matches the same pattern after any of the intermediate steps (0→1, 1→2, …, 6→7). In other words, it asks whether the system reaches a fixpoint (or a periodic state) within eight clock cycles.  \n\n**Notable characteristics.** The formula contains 2041 nested `ite`s, 1945 equalities, and a quantifier alternation depth of 2 (∀…∃), leading to a maximum term depth of 418. With 326 Boolean variables, 73 BitVecs (sizes 4, 8, 10), and over 170 KB of textual size, it is a classic example of an industrial fix‑point verification problem that stresses quantifier handling and term‑size reduction in modern SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-6.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (bit‑vectors of size 8) taken from the Wintersteiger “fixpoint” suite of industrial hardware verification problems (size ≈ 7.8 kB, 52 bit‑vector variables, 28 universal and 24 existential quantifiers, max term depth 60).  \nIt models a small datapath that, at each of seven successive cycles (indices 0 … 6), computes a remainder `out1 = in1 mod in2` and a corresponding “residue” `out2 = in1 – (in1 / in2) * in2` using the BV operations `bvurem`, `bvudiv`, `bvmul` and `bvsub`.  \nThe universally quantified part asserts that these relations hold for the concrete variables of each cycle, while a second block of existentially quantified variables (named `*_39_`) represents a possible loop‑candidate state that also satisfies the same arithmetic relations.  \nThe final conjunct states that the state reached at cycle 6 must be *identical* to one of the five earlier candidate states, i.e. the system must enter a previously‑seen configuration within six steps (a reachability‑to‑fixpoint condition).  \nThus the benchmark asks whether, for **all** input sequences, the hardware model inevitably cycles back to an earlier state within a bounded horizon—a typical quantified fixpoint‑equivalence check that stresses solvers with deep nesting and many duplicated bit‑vector terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/usb-phy-fixpoint-4.smt2",
    "description": "**Summary** – The file is a quantified bit‑vector formula written in the *BV* logic (size ≈ 242 k symbols, 530 universal and 424 existential quantifiers, term depth 972). It originates from the Wintersteiger 2013 “fixpoint” benchmark suite, which models a USB‑2.0 PHY (the low‑level transceiver that performs NRZI encoding, bit‑stuffing, line‑state decoding, and clock‑recovery).  \n\n**Structure** – The model is unrolled for five consecutive clock cycles (indices 0 … 4); each cycle introduces a large group of Boolean and 3‑/8‑bit signals (reset, hold, state machines, data registers, etc.) and defines their next‑state behavior with a cascade of `ite`, `and`, `or`, and arithmetic (`bvadd`) expressions.  \n\n**Key property** – The single top‑level assertion is an implication of the form  \n\n```\n(=> (and …initial‑reset‑conditions and inductive‑step equations…) \n    (and …safety‑conditions…))\n```  \n\nwhich asserts that, assuming the reset and the hardware transition relations hold, the error flag `i_rx_phy.RxError_o` (and related consistency predicates) can never become true.  \n\n**Notable characteristics** – The encoding mixes quantifiers with deep nesting to capture the fix‑point (inductive) reasoning over the state machine, resulting in a very large but highly regular formula that stresses solvers’ handling of quantified bit‑vectors, uninterpreted Boolean combinations, and arithmetic on small bit‑vectors. This makes the instance a representative industrial case for evaluating quantified‑BV solving (especially quantifier instantiation and model‑based projection) in the context of hardware verification.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/cache-coherence-3-fixpoint-3.smt2",
    "description": "This benchmark is a BV‑logic fix‑point verification problem (≈ 330 k characters, 1 assertion, depth > 1 000) taken from the Wintersteiger‑et‑al. hardware‑cache‑coherence suite used in the FMSD 13 paper. It encodes a three‑cache (A, B, C) coherence protocol together with a bus arbiter, modelling each cache’s state machine, snoop types, validity bits, request/ack signals, and the shared‑snoop vector that circulates on the bus. All of the protocol’s combinatorial transition rules are expressed as a massive quantified formula: a single ∀‑block (≈ 600 quantified variables) that defines the next‑state functions for the caches and the arbiter, followed by an ∃‑block that introduces a fresh “prime” state and finally an implication stating the desired invariant (e.g., that no two caches may simultaneously consider a line exclusive, or that a memory response is issued only when the line is not held by any cache). The instance therefore checks whether the inductive invariant, written as a universally quantified safety condition, is preserved by the transition relation—a typical industrial cache‑coherence fixpoint test that stresses quantified‑bit‑vector reasoning in SMT solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/small-equiv-fixpoint-5.smt2",
    "description": "This benchmark is a quantified bit‑vector formula in the **BV** logic (8‑bit vectors) taken from the Wintersteiger “fixpoint” suite of industrial hardware verification problems (VCEGAR, 2013); the file is about 6 KB long, contains a single assertion, and features 44 bit‑vector variables, 24 universal and 20 existential quantifiers, with a maximum term depth of 52.  \n\nThe formula models a small pipelined datapath that is unfolded for six consecutive time frames (indices 0 … 5).  For each frame *i* the universal part asserts the functional relationship  \n `out1_i = in1_i % in2_i`  and  `out2_i = in1_i – (in1_i / in2_i) * in2_i`  \n(i.e., remainder and the complementary subtraction), and the existential part introduces a fresh copy of the same six‑frame variables (named *_39_*) that must also satisfy the same arithmetic definitions.  \n\nThe only property being checked is the implication that, if all the universal and existential definitions hold, then the fifth frame’s outputs (`out1_5`, `out2_5`) must coincide with **one** of the five earlier existential frames (0‑4), expressed as a disjunction of equalities.  Hence the problem asks whether a *fixpoint* (a loop where the state repeats) exists for this arithmetic circuit.  \n\nNotable characteristics are the heavy alternation of quantifiers (∀…∀…∃…∃…), the repetitive structure of the arithmetic constraints, and the single large →/∨ clause that encodes the equivalence condition, making it a typical challenge for solvers that handle quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-8.smt2",
    "description": "The file is a single quantified assertion written in the **BV** (fixed‑width bit‑vector) logic, coming from the “wintersteiger” industrial benchmark suite (hardware fix‑point checks) – its SMT‑LIB identifier is *BV/wintersteiger/fmsd13/fixpoint/AR‑fixpoint‑8.smt2*, it contains 6 466 characters, 1 top‑level assert and a maximum term depth of 42.  \nThe formula introduces 9 pairs of universally‑quantified bit‑vectors `a_64_i`, `b_64_i` (i = 0 … 8) of width 2501, together with a parallel set of 9 existentially‑quantified copies `a_64_i_39_`, `b_64_i_39_`.  \nEach pair is defined recursively: for i = 0 the initial values are fixed to 1 and 0, and for i > 0 the next state is either kept unchanged or updated by `a_i+1 = a_i + b_i` and `b_i+1 = a_i` whenever the current `a_i` is unsigned‑less‑than 100 (the condition is expressed with `bvult`).  \nThe core property being checked is a **fix‑point condition**: after the eight updates, the final universal state `(a_64_8, b_64_8)` must be identical to **some** of the existentially‑quantified intermediate states `(a_64_j_39_, b_64_j_39_)` for j = 0 … 7, expressed by a disjunction of equalities.  \nThus the instance asks whether there exists a sequence of eight bounded‑increment steps that can return to an earlier state, i.e., whether the hardware model admits a non‑trivial loop; the heavy use of large bit‑vectors, nested quantifiers (18 ∀, 16 ∃), and many `ite`, `bvadd`, `bvult` terms makes it a challenging quantified‑BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/AR-fixpoint-3.smt2",
    "description": "The file is a single, quantified bit‑vector benchmark (logic BV) of size ≈2.8 KB taken from the Wintersteiger “fixpoint” suite, which originates from the VCEGAR hardware model‑checking benchmark collection.  It quantifies eight universal 2501‑bit variables (four pairs a_i_, b_i_) and six existential 2501‑bit variables that encode a second copy of the same transition system.  The antecedent fixes the initial state to a₀ = 1, b₀ = 0 and iteratively defines a₁, b₁, a₂, b₂, a₃, b₃ with an ite that adds the previous b to a while a is less than the constant 100; the existential copy repeats exactly the same recurrence.  The formula then asserts (via an implication) that the final universal state (a₃,b₃) must coincide with one of the three intermediate existential states, i.e., it checks a fix‑point/loop condition for the hardware model.  The benchmark is notable for its extremely wide bit‑vectors (2501 bits), deep nesting of quantifiers (8 ∀, 6 ∃) and use of arithmetic‑like operations (bvult, bvadd, ite), making it a challenging industrial case for quantifier‑handling procedures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/itc-b13-fixpoint-9.smt2",
    "description": "The benchmark is a quantified bit‑vector formula from the wintersteiger family (file BV/wintersteiger/fmsd13/fixpoint/itc‑b13‑fixpoint‑9.smt2) that uses the **BV** logic and is classified as an industrial, hardware‑fixpoint check.  It models a serial‑communication controller (the many variables such as send_en, tx_end, out_reg, mpx, rdy, confirm, shot, etc.) replicated over ten pipeline stages (indices 0…9) and captures their step‑wise transition relations with thousands of conditional (ite) updates.  The single top‑level assertion universally quantifies over the entire initial state (all Boolean signals false except next_bit true) and then existentially quantifies over a later state (the “39‑th” unrolling) to require that a particular combination of signals holds after the system evolves.  In effect the instance asks whether the described hardware can reach a reachable configuration satisfying those constraints, i.e. whether the fixpoint (or a safe state) exists within the bounded unfolding.  The problem contains 267 universal, 240 existential quantifiers, over 2 500 equality atoms and more than 2 600 ite‑expressions, yielding a formula of roughly 223 k symbols and a term‑depth of 526.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/fixpoint/ethernet-fixpoint-4.smt2",
    "description": "This benchmark is a quantified bit‑vector fixpoint check for an Ethernet‑style MAC controller, expressed in the **BV** logic and taken from the VCEGAR hardware suite described by Wintersteiger et al. (“Efficiently solving quantified bit‑vector formulas”, FMSD 2013).  The single top‑level assertion universally quantifies over a large tuple of Boolean and 2‑, 3‑, 4‑, 6‑ and 30‑bit variables that model the instantaneous state of two link layers (L0/L1), two transmit‑forward modules (FT0/FT1), two back‑off timers (BT0/BT1), two frame receivers (FR0/FR1), and the shared channel (CHN), together with auxiliary control signals (plr, pls, cs, cd, etc.).  Inside the body the formula relates this current state to an existentially‑quantified “next‑state” copy (the …_39_ variables), using a massive network of **ite**, **zero_extend**, **bvadd**, **bvugt**, and other bit‑vector operations to encode the Ethernet back‑off algorithm, carrier‑sense, collision‑detect, request/ack handshake and frame‑ready logic.  The property being verified is essentially a safety invariant: whenever the current state satisfies the protocol’s transition rules, there must exist a successor state that respects all protocol constraints (e.g., no illegal simultaneous transmissions, correct update of back‑off counters, and proper acknowledgment of frames).  At ≈ 600 KB, 5 k equality atoms and a term‑depth of 1 324, the instance is one of the larger industrial examples in the wintersteiger family, stressing solvers’ ability to handle deep conditional bit‑vector reasoning and large quantified alternations.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_osrusbfx2_exe_testapp.c.smt2",
    "description": "The benchmark is a single‑assertion quantified bit‑vector problem written in the **BV** logic (SMT‑LIB 2.6), taken from the “wintersteiger” industrial family (size ≈ 1 KB, 4 bit‑vector variables, max term depth 10).  \nIt asks whether there exists a 32‑bit constant `c__G_ReadLen_36_C` such that, for **all** possible values of the loop‑counter variables `termination__pre__0__c__G_ReadLen`, `c__G_ReadLen_35_0` and `c__G_ReadLen`, a ranking‑function inequality holds.  \nThe universally quantified premise encodes one loop iteration: the pre‑state equals `c__G_ReadLen_35_0`, the counter is not a multiple of 4 (`bvurem … 4 ≠ 0`), and the next counter value is the predecessor plus 1 (`c__G_ReadLen = c__G_ReadLen_35_0 + 1`).  \nThe checked property is `bvslt (c * new) (c * old)`, i.e., the signed product of the unknown coefficient and the new counter must be strictly smaller than the product with the old counter, which would constitute a linear ranking function proving termination.  \nKey features are the use of `sign_extend` to perform 64‑bit signed multiplication, the modular test (`bvurem`) for the “not divisible by 4” guard, and a single existential quantifier that synthesises the ranking‑function coefficient.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm610.c.smt2",
    "description": "This benchmark is a **BV‑logic** problem (bit‑vectors of size 32) taken from the Wintersteiger “ranking‑function synthesis” suite, with a total file size of about 1.2 KB and a single top‑level assertion. It asks whether there exists a 32‑bit constant `c__gsm610__main__1__n_36_C` that serves as a linear ranking function for a simple loop that increments a counter `n` while it is at most 8. The formula is quantified as  \n\n```\n∃c. ∀termination_pre ∀n0 ∀n .\n   (termination_pre = n0 ∧ n0 ≤ 8 ∧ n = n0+1) → \n   (c·n)  <_s  (c·termination_pre)\n```  \n\nwhere the multiplication is performed after sign‑extending `c` and zero‑extending the counters to 33 bits, and `<_s` is a signed‑less‑than (`bvslt`). Thus the solver must check the existence of a coefficient that makes the signed product strictly decrease for every allowed loop iteration, which is the core condition for proving termination of the modeled software fragment. The instance is typical of industrial verification benchmarks: it features nested quantifiers, mixed signed/unsigned comparisons, and a small but non‑trivial arithmetic constraint.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kernel_uagp35_gart.c.smt2",
    "description": "This benchmark is a quantified bit‑vector formula (logic **BV**) taken from the Wintersteiger “ranking‑function synthesis” suite (size ≈ 1.6 KB, 1 top‑level assertion, max term depth 12). It asks whether there exists a 32‑bit constant `c__gart__main__1__Index_36_C` that serves as a linear ranking‑function coefficient for a loop‑like transition described by the variables `c__gart__Main…Index`, `NumberOfPages`, and a nondeterministic value. The quantified part universally ranges over all possible pre‑state values and asserts that, whenever the loop guard holds (the current index is **not** greater‑or‑equal to the number of pages) and the index is incremented by one, the signed product `c·newIndex` is **strictly smaller** than `c·oldIndex`. The strict decrease is expressed with `bvslt` after lifting the 32‑bit terms to 33 bits via `sign_extend` and `zero_extend`, and the guard uses `bvuge` and `not`. Thus the formula encodes the classic termination‑proof condition “find a monotone decreasing ranking function” for a concrete bit‑vector program fragment. It is an industrial‑style benchmark targeting solvers’ handling of nested quantifiers, mixed signed/unsigned arithmetic, and multiplication in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_hwsim.cpp.smt2",
    "description": "This benchmark is a quantified bit‑vector formula (logic BV) taken from the Wintersteiger “ranking‑function synthesis” suite (file AVStream_hwsim.cpp.smt2, size ≈ 4.4 KB, industrial‑category).  \nIt models a fragment of the C program *AVStream_hwsim.cpp*, where three state variables – the number of queued scatter‑gather mappings, the number of queued bytes, and the remaining buffer size – are updated in a loop that copies a nondeterministic number of bytes.  \nThe single assertion introduces three existential variables that represent a candidate linear ranking function, and then universally quantifies over the current state, the pre‑state, and the nondeterministic return values of two helper functions.  \nThe core constraint requires the ranking expression  \n`(w1·mappings + w2·bytes) + w3·remaining` (with implicit 64‑bit extensions) to strictly decrease after the loop body, encoded by a signed‑less‑than (`bvslt`) between the post‑state and pre‑state weighted sums.  \nAll other conjuncts capture the program’s operational premises (e.g., buffers non‑zero, mappings > 0, bytes ≤ remaining, proper decrement of counters), making the problem a termination‑proof check for a quantified bit‑vector transition system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_sysfx_swap.cpp.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) taken from the Wintersteiger “ranking” collection, originally extracted from the termination‑proving evaluation of the C program **audio_sysfx_swap.cpp**.  It is a single quantified assertion of size about 1.6 KB that asks whether there exists a 32‑bit constant `cpp__main__c__main__1__u32ValidFrameCount_36_C` serving as a ranking‑function coefficient.  \n\nThe body quantifies four 32‑bit state variables that model one loop iteration: the pre‑state frame count (`termination_pre…`), a temporary copy (`c__main___36_tmp__tmp_36_1`), the old count (`cpp__main__c__main__1__u32ValidFrameCount_35_0`), and the new count (`cpp__main__c__main__1__u32ValidFrameCount`).  The antecedent forces the usual loop update (`new = old‑1` and `tmp = old ≠ 0`).  \n\nThe consequent asserts a strict decrease of the linear ranking expression `C * new` versus `C * old`, implemented by sign‑extending the 32‑bit operands to 65 bits, zero‑extending the other side, multiplying, and comparing with signed‑less‑than (`bvslt`).  \n\nThus the problem checks the existence of a positive coefficient that makes the affine function `C·frameCount` a valid decreasing measure, i.e., it is a classic ranking‑function synthesis query for a termination‑critical software loop.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_voice.cpp.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the “wintersteiger” family of termination‑ranking‑function synthesis problems; it is about 2.4 KB in size and contains a single, highly‑quantified assertion.  The statement asks whether there exist two 32‑bit constants (named `dwSoFar_36_C` and `dwLength_36_C`) such that, for all possible values of the pre‑state variables (`dwSoFar`, `dwLength`), a nondeterministic intermediate value, and the corresponding post‑state values, a certain termination condition holds.  The core constraint ties the pre‑state and post‑state variables with equalities, enforces that the loop guard `dwSoFar < dwLength` is true (`not (bvuge …)`), updates `dwLength` by subtracting `dwSoFar`, and finally requires a strict decrease of a linear ranking expression built from signed‑extended multiplications of the candidate constants and the variables (`bvslt (bvadd …) (bvadd …)`).  In other words, the formula encodes the existence of a linear ranking function (with coefficients `dwSoFar_36_C` and `dwLength_36_C`) that proves termination of a loop manipulating the `dwSoFar` and `dwLength` counters in the C program *audio_ddksynth_voice.cpp*.  The instance is notable for its deep nesting of eight universal quantifiers, mixed sign‑ and zero‑extensions, and the use of both unsigned (`bvuge`) and signed (`bvslt`) comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_pcidrv_sys_hw_nic_init.c.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (fixed‑width bit‑vector) logic, taken from the Wintersteiger “ranking” suite (software ranking‑function synthesis for a NIC‑driver initialization routine).  It contains one quantified formula of size ≈ 1.3 KB (1259 characters) with three nested universal quantifiers and one outer existential, all ranging over 32‑bit vectors.  The antecedent forces a pre‑state variable to equal another, constrains that variable to be strictly less than 6, and defines a current state as “previous + 2”.  The consequent asserts that, for the existentially chosen coefficient c₁, the signed product c₁·(prev + 2) is **strictly smaller** than c₁·prev for **all** such pre‑states, i.e. it looks for a negative multiplier that witnesses a ranking function proving termination of the loop.  The formula uses sign‑extension to 64 bits and only a handful of BV operators (add, mul, signed‑less‑than), making it a compact but non‑trivial example of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_usbnwifi_mp_util.c.smt2",
    "description": "The benchmark is a 3 KB BV‑logic instance (size 3221, 1 assertion) from the Wintersteiger “ranking‑function synthesis” suite, taken from the USB‑N‑WiFi driver (`network_usbnwifi_mp_util.c`).  It uses the quantifier‑rich fragment of the bit‑vector theory: three existentially quantified 32‑bit constants (`OldFlags_36_C`, `NewFlags_36_C`, `FlagsObj_36_C`) are guessed as coefficients of a linear ranking function, and a block of eleven universally quantified 32‑bit variables represents an arbitrary loop state and its predecessor.  \n\nThe body of the formula asserts that the guessed coefficients are compatible with the concrete transition relation of the loop: the new flag values must differ from the old ones, the “flags object’’ must be linked to the old value, and the updated flag vector is defined by a combination of bitwise‑and, or, and not (`bvand`, `bvor`, `bvnot`).  \n\nThe crucial property being checked is a strict decrease (`bvslt`) of the weighted sum  \n\n```\nsign_extend2(FlagsObj·OldFlags) + sign_extend2(NewFlags·NewFlags)\n```\n\nagainst the corresponding sum for the predecessor state, where the weights are the three existential constants (extended to 66 bits, multiplied with the state variables, and finally added).  This encodes the existence of a linear (signed) ranking function proving termination of the loop.  \n\nNotably, the formula mixes arithmetic (`bvadd`, `bvmul`), sign and zero extensions, and bit‑vector comparisons, illustrating the challenging quantified‑BV reasoning typical of industrial termination‑analysis benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_pnpi8042_moudep.c.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic **BV**) taken from the Wintersteiger et al. “ranking function synthesis” suite; it is an industrial‑size instance (≈1.5 KB, 7 bit‑vector variables, 6 nested quantifiers). The formula asks whether there exists a 32‑bit constant *C* (named `c__moudep__main__1__i_36_C`) such that for all possible pre‑state values of the loop variable `i`, a nondeterministic input, a bound `Attempts`, and the next state `i' = i+1`, a simple linear ranking function `C·i` strictly decreases across the transition. The antecedent of the implication encodes the loop’s guard (`i < Attempts`), the fact that the nondeterministic value is zero, and the update of `i`; the consequent checks `C*i' < C*i` using signed‑less (`bvslt`) after extending both operands to 65 bits for multiplication. Satisfiability of the formula therefore proves the existence of a ranking function proving termination of the `moudep.c` loop. The instance is representative of the “quantifier‑heavy” benchmarks used to evaluate solvers’ handling of quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_isochapi.c.smt2",
    "description": "The file is a single‑assertion benchmark written in the **BV** (fixed‑size bit‑vector) logic, taken from the “wintersteiger” industrial suite of ranking‑function synthesis problems (size ≈ 1.9 KB, 9 bit‑vector variables and a quantifier depth of 8).  \nIt asks whether there exists a 32‑bit constant `c__isochapi__main__1__i_36_C` that can serve as a linear ranking coefficient for a loop in the C function *isochapi_main*.  \n\nThe quantified part models the loop transition: the loop index `c__isochapi__main__1__i` is incremented by one, several nondeterministic values are forced to zero, and the index is required to stay below the descriptor bound `c__isochapi__main__1__nNumberOfDescriptors`.  \n\nThe core constraint is the implication  \n\n```\nbvslt (c * (i+1)) (c * i)\n```\n\nwhere `c` is sign‑extended to 65 bits, `i` and `i+1` are zero‑extended, and `bvslt` is signed less‑than.  Thus the formula checks that the signed product strictly decreases on every loop iteration, which guarantees termination.  \n\nIf the solver returns **sat**, a suitable coefficient exists; otherwise the loop has no linear ranking function of the given form.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_misc.c.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (bit‑vector) logic, taken from the Wintersteiger “ranking‑function synthesis” suite (industrial category, 3 KB, 3022 characters).  \nIt asks whether there exist three 32‑bit constants `c__st_misc__main__1__rateSet_uRateSetLength_36_C`, `c__st_misc__main__1__j_36_C` and `c__st_misc__main__1__i_36_C` that serve as coefficients of a linear ranking function for a loop extracted from the C source *network_ndis_rtlnwifi_extsta_st_misc.c*.  \nThe formula quantifies universally over the pre‑state variables `i`, `j`, and `rateSet_uRateSetLength` (the loop indices and bound) together with a nondeterministic value `termination__nondet1`, and then requires that, whenever the loop guard holds (i.e., `i` is **not** unsigned‑greater‑or‑equal to the bound) and the iteration variables satisfy the update relations, the constructed ranking expression strictly decreases (`bvslt`) after one loop step.  \nThe decreasing expression is a signed 64‑bit linear combination built with `bvadd`, `bvmul`, `sign_extend` and `zero_extend`, contrasting the “old” and “new” weighted sums of `i` and `j`.  \nThus the benchmark encodes the classic termination‑proof problem of synthesising a linear ranking function for a nested counter‑based loop over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ddksynth_csynth2.cpp.smt2",
    "description": "The benchmark is a 16‑bit bit‑vector problem (logic BV) taken from the Wintersteiger et al. “ranking function synthesis” suite (industrial category, size ≈ 1.6 KB, 1 top‑level assertion). It asks whether there exists a 16‑bit constant `cpp__main__c__main__1__1__nNew_36_C` that serves as a linear ranking function for a loop whose counter `nNew` is a signed 16‑bit value. The universally quantified part encodes the loop’s transition: the predecessor counter `cpp__main__c__main__1__1__nNew_35_0` must be positive (`bvsgt` after sign‑extension), a nondeterministic 32‑bit variable is non‑zero, and the successor counter is the predecessor minus 1. The key constraint is the strict decrease `C * n' < C * n` (signed multiplication after sign‑extension), which must hold for every admissible transition. Satisfiability therefore corresponds to the existence of a positive coefficient C proving termination of the modeled program fragment.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/kmdf_usbsamp_sys_queue.c.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (bit‑vectors) of size ≈1.5 KB, taken from the Wintersteiger “ranking‑function synthesis” collection (industrial‑category software verification).  \nIt asks whether there exists a 32‑bit constant `c__queue__main__1__ix_36_C` such that, for every possible pre‑state `termination__pre__0__c__queue__main__1__ix`, nondeterministic value `termination__nondet1`, and loop index values `c__queue__main__1__ix_35_0` and `c__queue__main__1__ix`, a certain linear ranking function strictly decreases after one loop iteration.  \nThe loop body is modeled by the constraints: the index is signed‑greater‑than −1 (`bvsgt … (_ bv4294967295 32)`), a nondet return value is non‑zero, and the next index is the current one minus 1 (`bvsub … (_ bv1 32)`).  \nThe key condition to be satisfied is  \n`bvslt (c * new_ix) (c * old_ix)`,  \nwhere both products are formed after sign‑extending the 32‑bit terms to 64 bits; this encodes the requirement that the candidate linear ranking function `c·ix` is strictly decreasing.  \nThus the benchmark checks the existence of a constant multiplier that proves termination of the modeled queue‑processing loop using a quantified bit‑vector formulation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_cseries.c.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the “wintersteiger” family of industrial ranking‑function synthesis problems; the file is about 1.3 KB and contains a single quantified assertion.  The assertion asks whether there exists a 32‑bit constant `c__cseries__main__1__count_36_C` (the candidate ranking‑function coefficient) such that for every loop state ‑‑ represented by the variables `termination__pre__0__c__cseries__main__1__count`, `c__cseries__main__1__count_35_0` and `c__cseries__main__1__count` – the loop body respects the termination condition.  The loop body is encoded by the premises  \n```\ntermination__pre__0__c__cseries__main__1__count = c__cseries__main__1__count_35_0,\nc__cseries__main__1__count_35_0 ≥ 0,\nc__cseries__main__1__count = c__cseries__main__1__count_35_0 - 1\n```  \nwhich capture a decrement of a counter that stays non‑negative.  Under these premises the constraint to be satisfied is  \n`c * c__cseries__main__1__count  <  c * termination__pre__0__c__cseries__main__1__count`  \nwhere the multiplication is performed after sign‑extending the 32‑bit terms to 64 bits, i.e., the ranking function `c·count` must strictly decrease each iteration.  Thus the formula checks the existence of a linear ranking function proving termination of a simple decrementing‑counter loop.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_wavepcistream2.cpp.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) taken from the “wintersteiger” family of industrial ranking‑function synthesis cases; the file is about 1.4 KB and contains a single, moderately deep (depth 11) assertion.  \n\nThe formula asserts the existence of a 32‑bit constant `cpp__main__c__main__1__1__i_36_C` (the candidate ranking‑function coefficient) such that for **all** reachable program states—represented by the 32‑bit variables `termination__pre__0__cpp__...i`, `cpp__...i_35_0`, the 8‑bit loop index `cpp__...nCurrentIndex`, and a fresh copy of `cpp__...i`—a certain transition condition holds.  \n\nThe transition condition ties the pre‑state `termination__pre__0__...i` to the current state `cpp__...i_35_0`, requires that the loop index is not the zero‑extended value of the 8‑bit index, and defines the next value of `i` as `(i_35_0 + 1) & 31`.  \n\nThe key property being checked is a strict decrease of the candidate ranking measure: the signed 64‑bit product `C * i` after the transition must be **less than** the product `C * termination__pre__0__...i` (expressed with `bvslt`).  \n\nThus the instance encodes a classic termination‑proof obligation: does there exist a linear (multiplicative) ranking function over 32‑bit variables that strictly decreases on every loop iteration under the given bit‑vector transition semantics?",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_extsta_st_aplst.c.smt2",
    "description": "This benchmark is a single‑assertion, quantified bit‑vector query (logic BV) taken from the Wintersteiger “ranking” family of industrial termination‑proving problems (size ≈ 1.3 KB, 5 BV variables, max term depth 11).  \nIt asks whether there exists a 32‑bit constant c (named c__st_aplst__main__1__i_36_C) that can serve as a linear ranking function for a loop iteration of the function st_aplst__main__1.  \nThe universally‑quantified variables describe a single loop step: the current loop counter i is the predecessor i₃₅₀ plus 1, the predecessor value termination_pre equals i₃₅₀, and i₃₅₀ is constrained not to overflow the bound bvadd (4294967295, APCount).  \nThe key constraint is  \n\n```\nbvslt (c * i) (c * termination_pre)\n```  \n\nwhere the products are compared after sign‑extending to 65 bits, enforcing that the candidate ranking function strictly decreases on every iteration.  \nThus the instance checks the existence of a monotonic decreasing linear ranking function for a bounded 32‑bit counter, a typical sub‑task in automated termination‑proof synthesis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/input_mouser_detect.c.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the “wintersteiger” industrial suite (size ≈ 1.3 KB, 1 assertion, max term depth 10) that originates from the ranking‑function synthesis evaluation of the Wintersteiger et al. 2013 paper. It asks whether there exists a 32‑bit coefficient c (i.e., c__detect__main__1__i_36_C) that serves as a ranking function for a simple loop extracted from the detect.c software model. The universally quantified part fixes the loop’s pre‑state (termination__pre__0__c__detect__main__1__i = i₃₅₀) to zero, requires the loop guard variable s₀ to be non‑zero, and relates the next iteration variable i to the current one by i = i₃₅₀ + 1. The central constraint is a signed‑less‑than comparison (bvslt) between two signed 64‑bit products: the coefficient c multiplied by the new loop counter must be strictly smaller than c multiplied by the pre‑state counter, thereby encoding a decrease condition for the ranking function. The formula combines existential quantification over the coefficient with a four‑fold universal quantification over the loop variables, a typical pattern for checking the existence of linear ranking functions in bit‑vector termination proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_ac97_common.cpp.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** (fixed‑size bit‑vector) logic, taken from the “wintersteiger” industrial suite (size ≈ 1.8 KB, 7 bit‑vector variables, 6 nested quantifiers).  \nIt asserts the existence of a 32‑bit constant `cpp__main__c__main__1__ulCount_36_C` that serves as a *ranking coefficient* for a simple loop extracted from the C file `audio_ac97_common.cpp`.  \nThe universally quantified part describes one loop iteration: the loop counter (`cpp__main__c__main__1__ulCount`) is read, a nondeterministic 8‑bit value is obtained, a guard `not(bvugt tmp 100)` ensures the loop runs only while the counter is ≤ 100, and the counter is incremented by one (`bvadd … 1`).  \nThe key property to be proved is the strict decrease of the linear ranking expression `C * newCount` versus `C * oldCount`, expressed by the signed‑less‑than test `bvslt (bvmul C newCount) (bvmul C oldCount)`.  \nThus the benchmark checks whether a suitable multiplier **C** exists that makes this multiplication a valid ranking function, i.e., that guarantees termination of the modeled counter loop.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_cdfs_allocsup.c.smt2",
    "description": "The benchmark is a quantified bit‑vector formula (logic BV) taken from the “wintersteiger” family of industrial ranking‑function synthesis problems (size ≈ 3800 bytes, 1 top‑level assertion, 13 ∀‑quantifiers and 3 ∃‑quantifiers).  It models a loop of the C function *allocsup* that walks a file‑system control block list, using 32‑bit offsets and 64‑bit file‑offset/byte‑count fields (the existential variables `c__allocsup__..._36_C` represent the post‑state of the loop).  The universally quantified pre‑state variables and two nondeterministic 64‑bit values describe an arbitrary iteration of the loop, together with safety pre‑conditions such as “the current offset is below the entry count” and “the file offset lies after the current entry”.  The core constraint asserts that a linear combination of the offset, byte‑count and file‑offset (built with sign‑ and zero‑extensions, additions and multiplications) strictly decreases (`bvslt`) from the pre‑state to the post‑state, i.e., it is a candidate ranking function proving termination.  The instance therefore checks whether such a ranking function exists for the allocator’s loop, a typical case in termination‑proving tool evaluations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/AVStream_image.cpp.smt2",
    "description": "The benchmark is a 2.2 KB quantified bit‑vector formula (logic BV) taken from the “wintersteiger” suite of industrial ranking‑function synthesis problems, originating from the termination‑proving evaluation of the AVStream image.cpp program. It consists of a single quantified assertion that first existentially guesses two 32‑bit variables (the current space X and a mask) and then universally quantifies over the previous state variables, a nondeterministic 32‑bit value, and two copies of the current‑state variables. The core constraint asserts that the guessed previous state must equal the universally quantified previous‑state variables, that both the guessed mask and space are non‑zero, that the new mask is obtained by a logical right‑shift of the old mask, and that the new space equals the nondeterministic value. Finally a signed‑less‑than (`bvslt`) comparison is required between two linear expressions built from sign‑extended products of space and mask, enforcing a strictly decreasing ranking function across the transition. The formula therefore checks whether a suitable linear ranking function exists that proves termination of the underlying bit‑vector transition relation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/mmedia_gsm610_gsm6103.c.smt2",
    "description": "The file is a quantified bit‑vector benchmark (logic BV) taken from the Wintersteiger “ranking” family, size ≈ 1.3 KB and classified as an industrial termination‑proof instance.  It contains a single assertion of the form  \n\n\\[\n\\exists C\\!:\\!BV_{32}.\\;\\forall\\,x_{pre},y,z\\!:\\!BV_{32}.\\; \n\\bigl(\\text{pre‑state conditions} \\;\\Rightarrow\\; \n\\text{signed }(C\\!\\times\\!z) < \\text{signed }(C\\!\\times\\!x_{pre})\\bigr),\n\\]\n\nwhere the pre‑state conditions enforce that \\(x_{pre}=y\\), that \\(y\\) is larger than the constant 0xC0000000, and that the next state \\(z\\) is obtained by left‑shifting \\(y\\) by one bit.  The core property being checked is that, for some 32‑bit coefficient \\(C\\), the signed product \\(C\\cdot\\)next is strictly smaller than \\(C\\cdot\\)current, i.e., a linear ranking function decreasing on each loop iteration.  The formula uses sign‑extension to 64 bits before the multiplications and mixes signed comparisons (`bvslt`, `bvsgt`) with bit‑vector arithmetic (`bvmul`, `bvshl`).  It thus encodes the synthesis of a linear ranking function for a loop extracted from the GSM‑610 audio codec model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/general_pcidrv_sys_hw_eeprom.c.smt2",
    "description": "The benchmark is a 2‑K‑bit‑vector (BV) instance of size ≈ 2.4 KB taken from the Wintersteiger “ranking function synthesis” suite (industrial category, source = software termination‑proving benchmarks).  It encodes a ∃∃∀⁹ quantified formula that asks whether there exist two 16‑bit coefficients c​_x₃₆ and c​_size₃₆ that serve as a linear ranking function for a loop over the variables c​_eeprom_main_1_x and c​_eeprom_main_1_size.  The universal part describes the loop body: the size variable is doubled (bvmul … 2), the index x is updated by a sequence of bitwise operations (bvor with 0x8, bvand with the complement of 0x4), a size bound (¬(size·2 > 256)) and a non‑zero low‑byte condition (¬((x & 0x8)=0)) are imposed, and the ranking function must strictly decrease (bvslt) when both the old and new states are plugged into the linear expression built from the existential coefficients.  The formula therefore checks termination of the modeled EEPROM‑handling loop by synthesising a suitable ranking function, using many sign‑ and zero‑extensions to lift 16‑bit terms to 32‑bit arithmetic.  Its high quantifier alternation depth (2 existentials followed by 9 universals) and extensive use of bit‑vector arithmetic make it a characteristic challenge for modern BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_filter_namelookup.c.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) taken from the Wintersteiger “ranking” suite, originally extracted from a termination‑proof evaluation of the C program *filesys_filter_namelookup.c* (≈1.5 KB, 1 assertion). It asks whether there exists a 32‑bit constant `c__namelookup__main__1__i_36_C` that serves as a linear ranking function for a loop transition described by the universally quantified variables representing the pre‑state (`termination__pre__0__c__namelookup__main__1__i`), the current loop counter (`c__namelookup__main__1__i`), and several nondeterministic values. The core constraint asserts that, whenever the loop guard (`c__namelookup__main__1__i_35_0 > 0`) holds and the loop decrements the counter by one, the product `c * i` strictly decreases:  \n`bvslt (c * i_new) (c * i_old)`, where the multiplications are performed after sign‑ and zero‑extending the 32‑bit terms to 66 bits.  \nAll other conjuncts force the nondeterministic return value to be zero and tie the quantified variables together, ensuring the formula encodes the classic ranking‑function condition for proving termination. The instance therefore tests a solver’s ability to handle existential‑universal quantifier alternation, bit‑vector arithmetic, and ordering under extensions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_e100bex_5x_kd_mp_dbg.c.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 2059 characters, 1 assertion) taken from the Wintersteiger “ranking function synthesis” suite, which originates from termination‑proving experiments on real‑world C code.  \nIt encodes a quantified termination condition for the function `c_mp_dbg_main_1_cb`: two existential 32‑bit variables (`c__mp_dbg__main__1__cb_36_C` and `c__mp_dbg__main__1__cbLine_36_C`) are guessed as coefficients of a linear ranking function, while four universally quantified 32‑bit variables represent the current state (`termination__pre__0__…`).  \nThe antecedent asserts that the current state satisfies the loop guard (`c__mp_dbg__..._cb_35_0 ≠ 0`) and that the loop’s update computes a new “cbLine” as the minimum of the old value and 16, and a new “cb” as the old value minus that line.  \nThe consequent is a strict decrease condition (`bvslt`) of the synthesized ranking expression  \n\\[\n(\\text{sign\\_extend}\\,c\\_C)\\cdot c\\_{\\text{cb}} + (\\text{sign\\_extend}\\,c\\_L)\\cdot c\\_{\\text{cbLine}}\n\\]  \nbetween the post‑state and the pre‑state, with all arithmetic performed after widening the 32‑bit terms to 66‑bit signed vectors.  \nThus the benchmark checks whether there exist integer coefficients that make the given bit‑vector loop admit a linear ranking function, a typical industrial termination‑proof problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/hid_hclient_ecdisp.c.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV) of modest size (≈1.4 KB, 1 quantified assertion) coming from the Wintersteiger “ranking‑function synthesis” suite, which originates in termination‑proving work on the C source *hid_hclient_ecdisp.c*.  The formula asks whether there exists a 32‑bit constant C such that for every choice of the loop variables `termination_pre`, `UlongIndex_35_0`, `nUlongs` and `UlongIndex` the following holds: if `termination_pre` equals `UlongIndex_35_0`, `UlongIndex_35_0` is strictly below `nUlongs`, and `UlongIndex` is the successor of `UlongIndex_35_0`, then the signed product C·`UlongIndex` is strictly less than C·`termination_pre`.  In other words the instance encodes the existence of a linear ranking function (multiplication by C) that strictly decreases on each loop iteration of the original software model.  The constraint uses sign‑ and zero‑extension to 65‑bit before multiplication, avoiding wrap‑around, and combines one outer existential quantifier with four inner universal quantifiers, which makes it a typical quantified bit‑vector benchmark for solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_fmsynth_miniport.cpp.smt2",
    "description": "The benchmark is a quantified bit‑vector problem (logic BV) taken from the “wintersteiger” family of industrial ranking‑function synthesis instances; it is about 1.3 KB in size and contains a single quantified assertion.  The formula asks whether there exists a 32‑bit constant `cpp__main__c__main__1__dwPitch_36_C` that can serve as a ranking‑function coefficient for a loop in the program *audio_fmsynth_miniport.cpp*.  For every reachable state (`termination__pre__0__cpp__...dwPitch` and the current value `cpp__main__c__...dwPitch_35_0`) that satisfies the loop guard (`dwPitch_35_0 ≥ 1024` and the next value is obtained by a logical right‑shift by 1), the assertion requires the signed product `C·dwPitch` (after sign‑extending the constant and zero‑extending the predecessor) to be strictly smaller than the product `C·dwPitch_pre`.  The key constraints are a universal‑forall pattern over the loop variables combined with a single existential‑exists quantifier for the coefficient, and the comparison is performed with a signed‑less‑than (`bvslt`) after 65‑bit multiplication.  This encoding therefore checks the existence of a linear ranking function that proves termination of the bit‑vector loop.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/filesys_fastfat_cachesup.c.smt2",
    "description": "The file is a small (≈1.3 KB) quantified bit‑vector benchmark in the **BV** logic, taken from the Wintersteiger “ranking” suite (industrial category, source: ranking‑function synthesis for C programs).  It contains a single quantified assertion that first **exists** a 32‑bit constant `c__cachesup__main__1__i_36_C` and then **foralls** three 32‑bit variables that model the loop‑state before an iteration (`termination__pre…`) and two auxiliary copies of the loop counter.  \n\nThe core constraint states that whenever the counter `c__cachesup__main__1__i_35_0` is less than 4 and the next counter value is exactly `c__cachesup__main__1__i_35_0+1`, the signed product `c * c_i` must be strictly smaller than the signed product `c * termination_pre` (both products are formed after sign‑extending the constant to 65 bits).  In effect the formula asks for a constant multiplier c that makes the value `c·counter` a **ranking function** that decreases on each loop step for the bounded domain.  \n\nKey features are the mixed use of **sign_extend** and **zero_extend** to align bit‑widths, a simple linear arithmetic pattern (`bvadd`, `bvmul`) and a combination of **bvult** and **bvslt** to capture unsigned loop bounds and signed descent.  The benchmark therefore tests solvers’ ability to handle nested quantifiers, bit‑vector arithmetic, and ranking‑function synthesis in a compact industrial example.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/network_ndis_rtlnwifi_hw_hw_ccmp.c.smt2",
    "description": "The file is a single‑assertion BV‑logic benchmark (≈1.4 KB, 5 bit‑vector variables, four nested universal quantifiers under one existential) taken from the Wintersteiger “ranking” suite, which models termination‑proof obligations for the ccmp component of the network_ndis_rtlnwifi_hw driver.  \nThe existential variable `c__hw_ccmp__main__1__i_36_C` is a 16‑bit coefficient that is meant to serve as a linear ranking function for a loop variable `c__hw_ccmp__main__1__i`.  \nThe universal part quantifies over the pre‑state counter (`termination__pre__0__c__hw_ccmp__main__1__i`), the loop bound `c__hw_ccmp__main__1__aad_len`, and two successive values of the counter (`c__hw_ccmp__main__1__i_35_0` and the updated `c__hw_ccmp__main__1__i`).  \nThe core constraint forces the product `c * i` (with sign‑extension of the coefficient and zero‑extension of the counter) to be strictly smaller after the update (`bvslt`), while also requiring that the counter increment is exactly 16, stays below a masked 32‑bit bound (`bvand … 0xFFFFFFF0`), and respects the usual unsigned‑greater‑or‑equal guard.  \nNotably the formula mixes signed and unsigned arithmetic via `sign_extend`/`zero_extend`, uses a concrete 32‑bit mask constant, and exhibits a quantifier alternation pattern (∃∀∀∀∀) that is typical for ranking‑function synthesis problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/audio_gfxswap.xp_filter.cpp.smt2",
    "description": "The file is a 1 367‑character BV‑logic benchmark (logic BV, category “industrial”, source Wintersteiger et al., 2013) that contains a single quantified assertion.  It encodes a termination‑proof obligation for a C loop: an existential 32‑bit coefficient `cpp__main__c__main__1__1__nLoop_36_C` must exist such that, for every possible loop state (`termination__pre__0_…`, `cpp__main__c__main__1__1__nLoop_35_0`, and the current value `cpp__main__c__main__1__1__nLoop`), two conditions hold – the loop variable is non‑zero and is decremented by 4 each iteration – and a strict decrease of a linear ranking function is guaranteed.  The ranking function is the signed product `coeff * loop‑var`, expressed by sign‑extending the 32‑bit terms to 64 bits before a signed multiplication (`bvmul`).  The key constraint is the inequality `bvslt (coeff * new_val) (coeff * old_val)`, which must hold for all reachable states.  Notably the benchmark uses nested `forall`s inside an `exists`, sign‑extension, and only a handful of bit‑vector operators, making it a compact but non‑trivial quantified BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/wintersteiger/fmsd13/ranking/1394diag_ioctl.c.smt2",
    "description": "This benchmark is a quantified bit‑vector problem (logic BV) taken from the Wintersteiger “ranking‑function synthesis” collection; it contains 2 existentially‑quantified 32‑bit parameters and 11 universal quantifiers over the program state, for a total of 2 994 AST nodes. The formula asks whether there exist two 32‑bit constants (named c__ioctl__main__1__ulBuffSize_36_C and c__ioctl__main__1__i_36_C) that serve as coefficients of a linear ranking function for a loop in the ioctl driver 1394diag_ioctl.c. The antecedent encodes the loop’s guard and its arithmetic updates: bounds on the loop counter i, buffer‑size calculations involving ulBuffSize, checks that certain low bits are zero, and relationships between input‑buffer length and descriptor lengths, all expressed with BV‑addition, multiplication, extension, and comparison operators. The consequent requires that the constructed linear combination of ulBuffSize and i decreases strictly (signed bvslt) from one iteration to the next, i.e., the ranking function is decreasing for every reachable state. Because the property is expressed with nested quantifiers, sign/zero extensions, and non‑trivial bit‑vector arithmetic, the instance is a typical industrial‑scale verification query that challenges solvers’ handling of quantified BV formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_11.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer for the SV‑COMP 2019 “jain_2” benchmark, classified as an industrial safety‑property instance.  It declares two program variables, `c_main_~x~0` and `c_main_~y~0`, and models several nondeterministic 32‑bit inputs (`v_main_#t~nondet*`) by existential quantifiers.  The first top‑level assert states two linear equations in which the variables are combined with the constants −2 (`0xFFFFFFFE`) and 2, together with offsets 1 and −1, thereby describing the reachable states of the program after the nondeterministic choices.  The second assert negates a conjunction of two similar existential equations, expressing that no choice of the nondet values can make both equations hold simultaneously—this is the unreachability (or termination) condition that the verifier checks.  The script contains 2 asserts, 2 declared constants, a maximum term depth of 7 and a total size of about 3 KB, and it is solved by a standard BV‑solver via a simple `check‑sat`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_5.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (size ≈ 2.6 k characters, 6 declared bit‑vectors, 4 top‑level asserts) generated by Ultimate Automizer from the SV‑COMP 2019 C‑program *soft_float_4*.  The script encodes the Boolean condition of a C‑level `assert` that checks whether the value of `c_addflt_~ea~0_Hier` is greater‑or‑equal to `c_addflt_~eb~0_Hier`, and forces this condition to be true (`c___VERIFIER_assert_~cond ≠ 0`).  Two auxiliary variables `c_addflt_~ma~0_Hier` and `c_addflt_~mb~0_Hier` are defined existentially as the result of masking a 32‑bit word with `0x00 FFFFFF` and then setting the hidden‑bit `0x01 000000` (the typical encoding of IEEE‑754 single‑precision mantissas).  The core property being checked is the negated existential formula that would witness a overflow‑free addition error: it asserts that there is **no** triple `(addflt_~delta~0, addflt_~b, addflt_~a)` satisfying a specific arithmetic relation built from the masked values, a logical right shift, a negation and a bit‑vector addition.  Satisfiability of the whole file therefore corresponds to the absence of a counterexample to the original assertion, i.e., to the verification of the floating‑point addition routine under the given “no‑overflow” and “termination” assumptions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 “jain_7” C program; it is classified as an industrial‑category instance and contains 3 declared constants, 2 top‑level assertions and 15 bit‑vector symbols in a formula of depth 7 (≈3 kB).  \nThe first assertion encodes three independent existential sub‑problems, each stating that a linear combination of two nondeterministic 32‑bit variables (scaled by large constants such as 4292870144) plus the program’s input variable x, y or z equals another nondeterministic variable multiplied by a smaller power‑of‑two constant (2097152, 1048576, 4194304).  \nThe second assertion negates a similar conjunction, but each existential sub‑problem now involves only two nondeterministic variables (the third one is omitted), again relating the same input variables to scaled products.  \nThus the overall query asks whether the “reduced” system of equations can be falsified under the stronger constraints of the first assertion – effectively checking a reachability/termination condition of the original program.  \nA notable characteristic is the heavy use of large constant multipliers and existential quantifiers, which is typical for the arithmetic encodings produced by Ultimate Automizer when transforming C‑level arithmetic into bit‑vector constraints for SMT‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/pals_lcr-var-start-time.6_true-unreach-call.ufo.UNBOUNDED.pals.c_1.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) formula generated by Ultimate Automizer from an SV‑COMP 2019 benchmark (category *industrial*, file pals_lcr‑var‑start‑time… .ufo.UNBOUNDED).  It declares six abstract “function address” constants whose base is fixed to 0xFFFFFFFF and whose offsets enumerate 0…5, together with eight 8‑bit state variables ~st1~0 … ~st6~0 and their “old” copies.  The core of the problem consists of a series of transition‑relation constraints: each assertion sign‑extends the 8‑bit states to 32 bits, adds a specific subset of the current and previous state values, and forces the signed sum to be ≤ 1 (or its negation) in order to model a bounded‑time counter or resource usage.  A single quantified axiom states that for any choice of the five states ~st2~0, ~st3~0, ~st4~0, ~st5~0, ~st6~0 the same bound must hold unless all those extended values are zero, thus encoding a safety invariant.  The final `assert (not …)` negates one of these bounds, turning the check into a reachability question: the solver is asked whether a state violating the invariant exists.  The formula is relatively small (≈6 KB, 13 asserts, 24 declared constants) but heavily uses `sign_extend`, `bvadd`, `bvsle`, and a single `forall`, which are typical of the automata‑theoretic encoding employed by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_16.smt2",
    "description": "This SMT‑Lib file is a BV‑logic benchmark (logic BV, 2582 bytes, 2 quantified assertions, 3 declared 32‑bit constants) generated by the Ultimate Automizer tool from an SV‑COMP 2019 C‑program benchmark (category industrial).  The three declared constants `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0` correspond to program variables, while the quantified symbols `|main_#t~nondet0|`, `|main_#t~nondet1|`, `|main_#t~nondet2|` model nondeterministic inputs.  The first assertion states that for **all** nondeterministic values the linear bit‑vector equation  \n\n```\n4294967288·nondet0 + 4294967294·y + 4294967292·x + 4294967288·nondet1 + 4\n≠ z + 8·nondet2\n```  \n\ncannot hold (i.e., the unsafe state is unreachable).  The second assertion negates a similar universally‑quantified clause that additionally introduces substitution variables `v_subst_1…v_subst_3`; its negation forces the existence of a witness that violates the first property, turning the whole formula into a consistency check.  Thus the script encodes a safety‑property verification task: it asks the solver whether the alleged unreachable condition can ever be satisfied, and the result (unsat) proves the program’s correctness with respect to that property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "This SMT‑LIB file is a **BV‑logic** benchmark (32‑bit bit‑vectors) generated by **Ultimate Automizer** from the **SV‑COMP 2019** “jain” benchmark suite; it contains 3 declared constants, 2 top‑level asserts and a total size of about 3 KB. The program models three 32‑bit inputs `c_main_~x~0`, `c_main_~y~0`, `c_main_~z~0` and, for each of them, introduces two nondeterministic auxiliary variables that must satisfy a linear equation of the form  \n`a·v₁ + const = b·v₂`, where the constants `a` and `b` are small (2, 4, 8) or their two‑complement equivalents (e.g. 4294967294 = ‑2).  \n\nThe first assert states that *there exists* such a pair of variables for each of the three inputs, i.e. the three equations are simultaneously solvable. The second assert negates a stronger conjunction that requires **two copies** of each equation (hence `a·v₁ + a·v₁’ + const = b·v₂`) to be simultaneously solvable; the overall formula is thus checking that the weaker system is satisfiable while the stronger one is not.  \n\nConsequently the benchmark encodes a reachability/termination condition: it asks whether the program can reach a state where the three simple linear relations hold, and whether a state with duplicated constraints (representing a loop‑unrolling) is impossible, using only bit‑vector arithmetic and existential quantification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_4.smt2",
    "description": "The file is a bit‑vector (BV) SMT‑LIB 2.6 benchmark generated by Ultimate Automizer from an SV‑COMP 2019 industrial benchmark (size ≈ 2.9 KB, 2 assertions, 3 declared 32‑bit constants).  It encodes three quantified “nondeterministic” equations that relate the program variables `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0` to auxiliary 32‑bit witnesses via linear bit‑vector arithmetic, using the two’s‑complement constants ‑2, ‑4 and ‑8 (e.g. `bvadd (bvmul -2 v7) (bvmul -2 v6) x = bvmul 2 v5`).  The second assertion negates a simpler conjunction that would force each of those equations to reduce to a single‑witness form (`2·v5 = x`, `4·v5 = y`, `8·v5 = z`).  Consequently the solver is asked whether there exists a valuation satisfying the full three‑witness equations while **not** simultaneously satisfying all three reduced equations – a typical reachability/termination condition extracted from a C program.  The benchmark features only quantifiers and basic BV operators (addition, multiplication, equality) with a modest term depth of 6, highlighting Quantifier‑BV reasoning in the verification pipeline.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_7.smt2",
    "description": "The file is a quantifier‑rich verification condition in the **BV** logic (32‑bit bit‑vectors) generated by **Ultimate Automizer** from an SV‑COMP 2019 benchmark (soft‑float addition).  It declares two free 32‑bit constants `addflt_~ma~0` and `addflt_~mb~0` and then encodes three existential sub‑conditions that model extracting a 24‑bit mantissa (`0x00FF_FFFF`), adding a bias, and performing a logical right‑shift (`bvlshr`) that corresponds to the semantics of a software floating‑point addition routine.  A fourth assertion forces the exponent‑bit `0x0200_0000` of `addflt_~ma~0` to be zero and simultaneously asserts that **no** 32‑bit value `a` can make `addflt_~ma~0` equal the canonical mantissa‑masked form, i.e., it checks that a certain representation cannot be achieved.  The overall query asks whether these constraints are satisfiable; a SAT result would witness a concrete overflow/termination violation in the original C program, while UNSAT would prove the property holds.  The instance is modest in size (≈2 kB, 4 assertions, 2 constants, max term depth 8) but notable for mixing quantifiers with bit‑wise arithmetic, a pattern typical of automated software model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_14.smt2",
    "description": "This SMT‑LIB file is a bit‑vector ({BV}) benchmark generated by **Ultimate Automizer** from the SV‑COMP 2019 industrial suite (file *jain_2…termination.i_14.smt2*).  It contains two 32‑bit constants `c_main_~x~0` and `c_main_~y~0` together with two universally quantified clauses that relate them to two nondeterministic 32‑bit inputs (`|main_#t~nondet0|`, `|main_#t~nondet1|`).  The first clause asserts that for all auxiliary variables the sum  \n\n```\n2·v3 + 2·v1 + c_main_~y~0 + 2·|nondet1| + 0xFFFFFFFF\n```  \n\nis never equal to the negation of  \n\n```\n2·v4 + 2·v2 + 2·|nondet0| + c_main_~x~0 .\n```  \n\nThe second clause is the negation of a simpler universal property stating that the expression  \n\n```\nc_main_~y~0 + 2·|nondet1| + 0xFFFFFFFF\n```  \n\ncannot equal the negation of  \n\n```\n2·|nondet0| + c_main_~x~0 .\n```  \n\nThus the instance checks whether there exist concrete values for the nondeterministic inputs that falsify these equalities – i.e., it encodes a reachability/termination condition expressed as the unsatisfiability of the two quantified arithmetic constraints.  The file is small (≈2 KB, 2 declarations, 2 asserts) but features nested quantifiers, bit‑vector multiplications by 2, and a full‑width constant, giving a maximum term depth of 8.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_21.smt2",
    "description": "The file is a 3.4 KB BV‑logic benchmark (logic BV, 32‑bit bit‑vectors) generated by Ultimate Automizer for a SV‑COMP 2019 industrial benchmark (the “jain” program). It encodes a single verification condition that checks whether a certain linear relation on the program’s pre‑state variables x, y, z (given as constant bit‑vectors) can be satisfied after a call that introduces three nondeterministic 32‑bit values. The condition is expressed as the negation of a disjunction of a universally‑quantified equality and an existentially‑quantified equality, each involving large integer coefficients built via bvmul (e.g. 4290772992·v) and additions, thus forming a quantified Diophantine‑like constraint over bit‑vectors. If the solver reports **unsat**, the original C program’s safety property (e.g., absence of a reachable error state) holds; otherwise a counterexample exists. The benchmark is notable for mixing both ∀ and ∃ quantifiers in a single assertion and for the deep term nesting (depth 11) caused by the repeated multiplications and additions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/gcd_3_true-unreach-call_true-no-overflow.i_0.smt2",
    "description": "This file is a BV‑logic benchmark generated by Ultimate Automizer for the SV‑COMP 2019 industrial suite (the “gcd_3_true‑unreach‑call_true‑no‑overflow” benchmark).  It declares three 8‑bit bit‑vector variables that model the input a, the current values of a and b in the Euclidean algorithm, and contains two top‑level assertions – one encoding the expected loop invariant together with the condition that the input is non‑zero, and a second asserting the negation of that invariant combined with the same precondition.  Both assertions use nested let‑bindings, sign‑extensions to 32 bits, extracts of the low 8 bits, signed remainder (bvsrem) and signed less‑than (bvslt) to capture the arithmetic of the GCD computation.  The first assertion states that, for some value of the loop‑counter variable (the existentially quantified v_gcd_test_~b_41), the remainders computed from a and b satisfy the invariant; the second asserts that such a state cannot be reached, thereby checking the unreachability (safety) property.  The solver is asked to decide sat, so a satisfying model would indicate a counterexample to the unreachability claim, while unsat confirms that the GCD implementation cannot violate the asserted invariant.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "This SMT‑LIB file is a bit‑vector (BV) benchmark generated by Ultimate Automizer for the SV‑COMP 2019 “jain_7” true‑unreach‑call case (file BV/20190429‑…/jain_7_… .smt2, 32‑bit vectors, 2 842 characters, 2 quantified assertions). It declares three 32‑bit program variables c_main_~x~0, c_main_~y~0, c_main_~z~0 and three nondeterministic inputs |main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2| that appear inside universal quantifiers. The first assertion states a universal invariant: for every choice of auxiliary substitution variables the two large linear BV‑terms (built from multiplications by 2²² and 2³²‑​… constants) are never equal. The second assertion negates a universal “not‑equal” clause, i.e. it asserts the existence of a nondet assignment that makes another pair of linear BV‑expressions equal, modelling a potential error state. Together the formula checks whether the universal invariant can coexist with a reachable error configuration; satisfiability means the tool found a counterexample to the safety property. Notable features are the heavy use of large constant multipliers, nested bvadd/bvmul expressions, and a shallow quantifier depth (max term depth 10).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic = BV, 2 declared 32‑bit variables, 2 quantified assertions) produced by Ultimate Automizer for the SV‑COMP 2019 “jain_2” benchmark (family = UltimateAutomizerSvcomp2019, category = industrial).  \nIt encodes a software‑verification query: the two 32‑bit constants `c_main_~x~0` and `c_main_~y~0` model the program’s global integers x and y, while the quantified variables (`v_subst_*` and `|main_#t~nondet*|`) stand for arbitrary intermediate and nondeterministic values that can arise during execution.  \nThe first assertion states, for all such values, that a specific linear combination of them (essentially `‑(2·v₂ + 2·nondet0 + x) + 1`) can never equal another linear combination (`2·v₁ + y + 2·nondet1`). This captures a candidate invariant of the program’s transition relation.  \nThe second assertion negates a disjunction consisting of the concrete equality `1 = y + x` together with a second universally quantified inequality that is similar in shape to the first but includes an extra constant `‑1`. By asserting the negation, the solver is asked to show that both the equality and the quantified property are impossible, i.e., to prove that an error state (represented by `x + y = 1`) is unreachable.  \nNotably, the instance relies only on linear bit‑vector arithmetic with multiplications by the constant 2, contains nested quantifiers, and reaches a maximum term depth of 9, making it a typical “quantified‑BV” challenge for SMT‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_3.smt2",
    "description": "The file is a 2‑KB BV‑logic benchmark generated by Ultimate Automizer from the SV‑COMP 2019 C‑code benchmark *soft_float_4*; it uses only bit‑vector operations and contains six declared 32‑bit constants.  \nThe first assertion defines the “masked” mantissa of two floating‑point operands (c_addflt_~a and c_addflt_~b) by extracting the lower 24 bits, inserting the hidden‑bit (0x01000000), and also computes biased exponent fields by shifting right 24 bits and adding a constant (0xFFFFF??).  \nThe second assertion is the negation of an existential formula that would witness a δ such that, after right‑shifting the masked second operand by δ, negating it, adding the masked first operand, and comparing to the masked first operand, the equality holds.  \nIn other words, the solver is asked to prove that **no** choice of δ, a, and b can make the adjusted mantissa addition cancel out, which corresponds to checking a safety property (e.g., absence of overflow or incorrect cancellation) of the soft‑float addition routine.  \nThe benchmark therefore encodes a quantified safety check over bit‑vector arithmetic, typical of the industrial verification tasks used in SV‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "The file is a 32‑bit bit‑vector (`BV`) SMT‑LIB 2.6 benchmark generated by Ultimate Automizer from the SV‑COMP 2019 “jain_2” benchmark (industrial category, 2 982 bytes, 2 assertions and 2 declared constants). It declares two 32‑bit inputs `c_main_~x~0` and `c_main_~y~0` that model the values of the original program’s variables `x` and `y`. The first assertion asserts the existence of four nondeterministic 32‑bit values that satisfy two simple linear equations: one ties `c_main_~y~0` to a combination of two nondet terms multiplied by the constant 4294967294 (‑2) and offset by 4294967295 (‑1), the other ties `c_main_~x~0` to a similar expression with a single nondet term. The second assertion negates a conjunction of two richer existential constraints, each requiring three nondet terms (for `x`) or four (for `y`) to satisfy a larger linear equation; the `not` encodes the safety property that these combined conditions must be unreachable. Thus the query checks whether the conjunction of the more complex existential equations is impossible, i.e., whether the program state described by the first, simpler equations can ever lead to the forbidden state expressed by the second. The problem is pure bit‑vector arithmetic with shallow terms (depth ≤ 7) and only existential quantifiers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "This SMT‑LIB script is a bit‑vector (BV) benchmark generated by Ultimate Automizer from an SV‑COMP 2019 C‑program verification task (category “industrial”). It declares three 32‑bit variables `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0`, which correspond to the program’s global integers, and a handful of quantified “nondet” variables that model the nondeterministic choices of the program’s execution. The first assertion encodes a universally quantified relational invariant: for all possible substitutions of the quantified variables the weighted sum of the program state (using large constants such as 2²², 2³²‑2, etc.) must not equal another weighted sum, i.e., a safety condition on the transition relation. The second assertion negates a similar universally quantified equality, turning the problem into “does there exist a substitution that violates the invariant?”; the solver is asked to check the satisfiability of the conjunction of these two constraints. Thus the instance checks whether the inferred invariant holds for all reachable states—unsat means the invariant is valid (the program is safe), while sat would exhibit a counterexample violating it. The benchmark is small (≈3 kB, 2 quantified asserts) but uses deep term nesting (depth 10) and many bit‑vector multiplications, reflecting the arithmetic‑heavy nature of the original program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_6.smt2",
    "description": "This SMT‑LIB file is a 32‑bit‑vector instance (logic BV) generated by **Ultimate Automizer** from an SV‑COMP 2019 benchmark (file jain_7…‑termination.i_6.smt2); it belongs to the “industrial” category and contains about 3 kB of text, 3 declared constants (c_main_~x~0, c_main_~y~0, c_main_~z~0) and two top‑level assertions.  \nThe first assertion encodes three simultaneous linear arithmetic constraints, each expressed with an **existential quantifier** over four fresh nondeterministic 32‑bit variables and a large constant‑coefficient equation of the form  \n\n\\[\nk\\cdot v_5 = k'\\cdot v_8 + k'\\cdot v_7 + k'\\cdot v_6 + c,\n\\]\n\nwhere the constants \\(k\\) and \\(k'\\) (e.g., 1048576, 4293918720) are powers of two shifted by a large offset, linking the program’s input variables \\(c\\_main\\_~x~0, c\\_main\\_~y~0, c\\_main\\_~z~0\\) to the nondeterministic choices.  \n\nThe second assertion negates a conjunction of three simpler equalities, each stating that the same output variable must be exactly a single multiplication of a nondeterministic term (e.g., \\(c\\_main\\_~x~0 = 1048576\\cdot v\\_5\\)).  \n\nThus the whole formula asks whether there exists a model that satisfies the complex multi‑term equations **and simultaneously violates** the simple single‑term equalities; satisfiability corresponds to a counterexample to the original safety property (reachability/termination) of the source C program.  \n\nThe instance is notable for its heavy use of nested existential quantifiers and large bit‑vector constants, which stress the solver’s ability to reason about quantified linear arithmetic in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "The file is a 2.6‑compliant SMT‑LIB script for the quantifier‑rich bit‑vector logic (BV), generated by Ultimate Automizer from an SV‑COMP 2019 benchmark (size ≈ 2.9 KB, 9 declared constants, 3 top‑level assertions).  It models a single loop‑iteration of a C program that maintains three 32‑bit variables x, y, z, each of which is constrained to be an even, a multiple‑of‑4, and a multiple‑of‑8 value respectively (expressed with existentially quantified “witness” variables).  The transition relation asserts that, on this step, x is increased by 2·nondet0, y by 4·nondet1 and z by 8·nondet2, where the three nondeterministic inputs are fresh 32‑bit constants.  The final assertion negates the existence of witnesses for the updated (primed) variables, i.e. it asks whether the update can break the required divisibility invariants; the script therefore checks the **unreachability** of a state violating those invariants.  Notable characteristics are the use of quantified bit‑vector equalities, a low term depth (≤ 6), and a straightforward linear arithmetic pattern that makes the instance a typical “array‑free” verification problem for industrial software.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "The script is a 32‑bit bit‑vector verification query (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 “jain_7” benchmark (family UltimateAutomizerSvcomp2019, industrial category, 3,122 bytes, 2 top‑level assertions). It declares three program‑state variables c_main_~x~0, c_main_~y~0 and c_main_~z~0 and a handful of nondeterministic inputs (|main_#t~nondet0| …). The first assertion universally quantifies over auxiliary variables and states that a certain linear combination of the program variables and nondet inputs can never be equal – it encodes an invariant derived from the program’s arithmetic. The second assertion negates a disjunction that would allow either a concrete unsafe condition (the equality bvadd(‑2·y, 4·x, z) = 1048576) or another universally quantified violation of a similar invariant; thus the whole formula checks that the unsafe state is unreachable. Notable characteristics are the use of large constant multipliers (e.g., 4194304, 4290772992), nested double negations, and quantified bit‑vector arithmetic, which makes the instance challenging for typical BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "This script is a bit‑vector problem (logic BV) generated by Ultimate Automizer from an SV‑COMP 2019 benchmark; it is 3 KB long, declares three 32‑bit variables (`c_main_~x~0`, `c_main_~y~0`, `c_main_~z~0`) and contains only two top‑level asserts. The first assert introduces three existential “nondet” variables that force the three declared variables to be respectively twice, four times and eight times some arbitrary 32‑bit value (i.e., `x = 2·v0`, `y = 4·v1`, `z = 8·v2`). The second assert negates a conjunction of three similar existential constraints that relate the same variables to linear combinations involving the constants 4294967294 (≡ ‑2), 4294967292 (≡ ‑4) and 4294967288 (≡ ‑8) together with additional nondet terms; this encodes the condition that a certain arithmetic relation expected to hold after a program step (or loop iteration) does **not** hold. Thus the whole formula asks whether the conjunction of those three complex arithmetic requirements is unsatisfiable; `check-sat` will return `sat` exactly when a counterexample to the intended invariant (or termination condition) exists. Notably, the instance relies heavily on chained `bvmul` and `bvadd` with maximal term depth 7, reflecting a small arithmetic loop from the original C program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_19.smt2",
    "description": "The script is a single‑query BV benchmark (logic **BV**, 3 declared 32‑bit constants) generated by **Ultimate Automizer** from the SV‑COMP 2019 “jain_7” benchmark (file *…_true‑unreach‑call_true‑no‑overflow_false‑termination.i_19.smt2*, size ≈ 3.6 KB).  \nIt encodes a safety‑property check on a piece of C code: the three constants model the values of program variables x, y and z just before a function call, while the symbols |main_#t~nondet0|, |main_#t~nondet1|, |main_#t~nondet2| stand for nondeterministic inputs introduced by the tool.  \nThe sole assertion is the negation of a disjunction that contains  \n\n* a **forall**‑quantified linear equation over the bit‑vectors (a weighted sum of the program variables, the nondet inputs and large constants must equal 2²⁰), and  \n* a corresponding **exists**‑quantified equation that mirrors the same relation.\n\nThus the solver is asked whether there exists a concrete assignment to the constants (i.e., a program state) that **violates** the universally quantified invariant or makes the existential witness true; in other words, it checks that the invariant holds for all nondeterministic choices.  \n\nThe formula is unusually dense with large constants (e.g., 0xFFF00000, 0x100000) and many multiplied terms, leading to a maximum term depth of 11 and a high count of `bvmul`/`bvadd` operations, which is typical for bit‑vector encodings of linear arithmetic in software‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_8.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (logic = BV) generated by Ultimate Automizer from an SV‑COMP 2019 C‑program (the “soft_float_4” benchmark). It contains 2 declared 32‑bit bit‑vector constants and three top‑level assertions, the whole file being about 2 KB (2187 characters) with a maximum term depth of 9.  \n\nThe first two assertions introduce two auxiliary bit‑vectors (`addflt_~ma~0` and `addflt_~mb~0`) as the mantissa part of a floating‑point value: each is defined by masking a 32‑bit word with the constant 0x00FF_FFFF and forcing the hidden bit 0x0100_0000 (the usual IEEE‑754 mantissa reconstruction).  \n\nThe third assertion is the negation of an existential statement that would make the sum of the negated, right‑shifted masked operand b equal the masked operand a (after adding the reconstructed mantissa of a). In other words, the script checks that no choice of the three unknown 32‑bit words (`addflt_~delta~0`, `addflt_~b`, `addflt_~a`) can satisfy the equation  \n\n```\n‑( ( (mb ∨ (b ∧ 0x00FF_FFFF)) >> delta ) ) + ma  =  (ma ∨ (a ∧ 0x00FF_FFFF))\n```  \n\nThus the benchmark encodes a reachability‑unreachability property of a floating‑point addition routine, expressed purely with bit‑vector operations.  \n\nThe instance is typical of industrial verification tasks: it uses only bit‑vector primitives (bvand, bvor, bvlshr, bvadd, bvneg) and existential quantifiers, and its unsatisfiability (the `check-sat` is expected to return unsat) certifies that the asserted erroneous overflow/termination condition cannot occur.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_9.smt2",
    "description": "This instance is a BV‑logic benchmark (size ≈ 3.7 KB, 3 declared 32‑bit variables and 21 bit‑vector terms) generated by Ultimate Automizer from an SV‑COMP 2019 industrial benchmark.  It introduces three groups of existentially quantified 32‑bit “nondet” variables, each group paired with one of the program variables c_main_~x~0, c_main_~y~0, c_main_~z~0.  For each group the script asserts a linear bit‑vector equation of the form  \n\n\\[\n\\text{const}_1·v_5 = \\text{const}_2·v_8 + \\text{const}_2·v_7 + \\text{const}_2·v_6 + c,\n\\]\n\nwhere the constants are large unsigned values (e.g. 2 048 152, 4 293 870 144) and c is the corresponding program variable.  A second top‑level assertion negates a conjunction of three similar equations (with the summands reordered and one fewer nondet variable in each block), so the solver must decide whether the original three equations can simultaneously be true and false.  The check‑sat therefore encodes the verification condition that the three linear bit‑vector constraints are jointly consistent; unsatisfiability would witness that the program property (e.g. absence of a reachable error state) holds.  The formula features six quantifier blocks, depth 7, and is typical of automata‑theoretic encodings used by Ultimate Automizer for termination/overflow analyses.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_31.smt2",
    "description": "The script is a 2‑K‑byte BV (bit‑vector) benchmark generated by Ultimate Automizer from an SV‑COMP 2019 C program that calls the IEEE‑754 `sqrtf` function. It uses the SMT‑LIB 2.6 format, declares two 32‑bit constants that represent the internal “r” and “s” parts of the sqrt implementation, and contains only two assertions. The first assertion is a universally quantified property stating that for every 32‑bit input `ix` the expression  \n\n```\n2·(−( (r >> 1) >> 1) + s) + 4·ix\n```  \n\ncannot be zero; this encodes a safety condition of the floating‑point square‑root algorithm. The second, negated, assertion forces `s = 0xFE000000` and `r = 0x00010000`, i.e., a concrete test case that would violate the universal property. The solver is asked to check satisfiability of the conjunction, effectively asking whether the given concrete values can falsify the universal invariant of the sqrt routine.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_8.smt2",
    "description": "This script is a 32‑bit bit‑vector SMT‑LIB 2.6 problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 “jain_7” benchmark (file BV/…/jain_7_… .smt2, size ≈ 3.4 KB, 2 assertions, 3 declared constants).  \nIt models a safety check on a C program where the three input variables c_main_~x~0, c_main_~y~0 and c_main_~z~0 are treated as 32‑bit parameters, and three groups of existentially quantified nondeterministic 32‑bit variables are used to encode linear arithmetic relations between the inputs and the hidden program state.  \nThe first assertion states that for each input there exists a pair of nondet‑variables satisfying a simple equality of the form bvmul(k₁, v₁) = bvadd(bvmul(k₂, v₂), c), i.e., the base case of the program’s transition relation is realizable.  \nThe second (negated) assertion demands that there is **no** assignment to three nondet‑variables per input that fulfills a more complex equality where the left‑hand side is multiplied by the same constant and the right‑hand side adds three such terms plus the input; the outer (not …) turns this into an unsatisfiability query.  \nThus the overall query asks whether the extended transition relation is unreachable (the formula is unsatisfiable), which corresponds to proving the program’s “unreach‑call” safety property.  \nThe instance is notable for its heavy use of existential quantifiers, large constant coefficients (≈ 2³⁰), and a modest term depth of 7, reflecting the automata‑theoretic encoding used by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from an SV‑COMP 2019 C‑program (category industrial, size ≈ 3 kB, 3 declared constants x, y, z).  \nThe first top‑level assertion requires that there exist three independent triples of nondeterministic 32‑bit variables whose linear relations  \n\\(4294967294·v_0^7 + 4294967294·v_0^6 + x = 2·v_0^5\\),  \n\\(4294967292·v_1^7 + 4294967292·v_1^6 + y = 4·v_1^5\\) and  \n\\(4294967288·v_2^7 + 4294967288·v_2^6 + z = 8·v_2^5\\)  \nare simultaneously satisfiable.  \nThe second assertion negates a weaker conjunction where each equation is expressed with only two existential variables (dropping one multiplier term), i.e. it asks whether the conjunction of the three simplified equations can be false.  \nThus the whole problem checks the unsatisfiability of the negated conjunction under the original existential constraints – a typical unreachability/termination condition encoded as “no model exists where the simplified constraints hold while the full constraints hold”.  \nThe formula uses only bit‑vector arithmetic with large constants that are the two’s‑complement representations of –2, –4 and –8, highlighting that overflow‑free linear arithmetic is being reasoned about.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_2.smt2",
    "description": "This instance is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 soft‑float benchmark suite; it is classified as an industrial benchmark, contains 2 declarations and 2 top‑level assertions and has a modest size of 2 256 characters (max term depth 10).  \nTwo uninterpreted 32‑bit constants `c_addflt_~ma~0` and `c_addflt_~mb~0` are introduced to model the result of a floating‑point addition after normalisation, using the usual IEEE‑754 mantissa mask `0x007FFFFF` and the hidden‑bit mask `0x00800000`.  \nThe first assertion existentially quantifies auxiliary bit‑vectors (`addflt_~a`, `addflt_~b`, `addflt_~delta~0`) and equates the constants to the masked‑and‑shifted forms of those inputs, thus encoding the definition of the addition operation in terms of bitwise `bvor`, `bvand` and logical right‑shift.  \nThe second assertion negates a safety property: it states that it is **not** the case that the hidden‑bit of `c_addflt_~ma~0` is cleared **and** that the algebraic relation  \n`bvadd (bvneg (bvlshr (…) addflt_~delta~0)) c_addflt_~ma~0 = bvor (…) addflt_~a` holds, i.e., it checks that the addition never yields an unexpected overflow or incorrect mantissa combination.  \nThus the solver is asked to prove unsatisfiability of the negated property, which corresponds to verifying that the soft‑float addition implementation respects its specification for all 32‑bit inputs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "The file is a 32‑bit bit‑vector SMT‑LIB 2.6 query (logic BV) generated by Ultimate Automizer for an SV‑COMP 2019 benchmark (the *jain_6* C program).  It contains three 32‑bit input variables x, y and z and a pair of conjunctive constraints, each built from three existentially quantified “nondet” vectors that must satisfy linear equations of the form  \n\n\\[\na·v_1 + a·v_2 + c = b·v_3,\n\\]\n\nwhere the constants a are the 32‑bit values 4294967294 (≈ −2), 4294967292 (≈ −4) and 4294967288 (≈ −8), and the right‑hand multipliers are 2, 4 or 8.  The first top‑level assertion asserts that such solutions exist for the three equations (one per x, y, z), while the second assertion negates a stronger conjunction in which each equation contains an additional nondet term on the left‑hand side.  Consequently the solver is asked to prove that the stronger conjunction is unsatisfiable – i.e., that no assignment to the nondet variables can simultaneously satisfy all three enriched equations, which corresponds to a reachability/termination condition for the original program.  The benchmark is relatively small (≈ 3.7 k characters, 2 top‑level asserts, 21 bit‑vector occurrences) but features nested quantifiers, mixed multiplication and addition, and modular arithmetic near the 32‑bit wrap‑around, making it a typical challenging instance for BV solvers in industrial verification contests.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_7.smt2",
    "description": "The file is a 3 KB BV‑logic benchmark (SMT‑LIB 2.6) generated by the Ultimate Automizer tool for the SV‑COMP 2019 industrial suite, and it belongs to the “jain” benchmark family (true‑unreach‑call, no‑overflow, false‑termination). Three 32‑bit input variables `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0` are declared, and the first assertion introduces three separate blocks of existentially quantified 32‑bit “nondet” variables that must satisfy large linear equations of the form  \n\n```\n2097152·v5 = 4292870144·v8 + 4292870144·v7 + 4292870144·v6 + c_main_~y~0\n```  \n\n(and analogous equations for x and z with different constants). The second assertion negates the conjunction of three simplified versions of those equations (each using only two nondet variables), thereby asking whether the three full equations can simultaneously hold while the simplified ones cannot. In other words, the SMT problem checks the unsatisfiability of a counter‑example to the verification condition: if the whole formula is unsat the program’s safety/termination property is proved. The benchmark contains 2 top‑level asserts, 3 declared constants, 18 bit‑vector terms, and a maximum term depth of 7.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_1.smt2",
    "description": "This instance is a bit‑vector (BV) verification condition generated by **Ultimate Automizer** from a SV‑COMP 2019 benchmark (file *…jain_2_true‑unreach‑call_true‑no‑overflow_false‑termination.i*).  It works over 32‑bit unsigned integers, declares six constants (two nondeterministic inputs and the pre‑ and post‑state variables x and y), and contains three top‑level assertions.  The first assertion defines the program’s transition relation:  \n  x′ = x + 2·nondet0, y′ = y + 2·nondet1.  \nThe second asserts a safety property that *for all* choices of the nondet inputs a certain linear equality (involving x, y and a constant 0xFFFFFFFF) never holds, while the third is the negation of a universally quantified version of the same equality on the primed (post) state, i.e. it states that *there exists* nondet values making the equality true after the transition.  The final `check‑sat` therefore asks whether the program can reach a state violating the safety invariant, which in this benchmark corresponds to a counterexample to the expected termination claim.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_13.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic = BV, 2 declared 32‑bit bit‑vectors `c_main_~x~0` and `c_main_~y~0`) generated by Ultimate Automizer from an SV‑COMP 2019 C program (category = industrial, family = UltimateAutomizerSvcomp2019).  It contains two quantified assertions: the first states that for all nondeterministic 32‑bit values `|main_#t~nondet0|` and `|main_#t~nondet1|` a certain linear equality over the variables and these nondets never holds, and the second is the negation of a similar universal statement, i.e. it requires the existence of some values (including auxiliary variables `v_subst_1`, `v_subst_2`) that make a related equality true (after adding 1).  The conjunction of the two assertions therefore encodes a classic “unreachability vs. reachability” check: the solver must determine whether the universal “no‑error” condition can coexist with a witness that violates it.  The problem uses only bit‑vector addition, multiplication by the constant 2, and negation, with a maximum term depth of 9 and a modest symbol count (6 bit‑vectors, 6 `bvmul`, 5 `bvadd`).  Because it combines quantifiers with arithmetic, it is a representative challenging instance for BV solvers in the competition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_28.smt2",
    "description": "The file is a very small BV‑logic benchmark (1837 characters, 1 quantified assertion) generated by Ultimate Automizer from an SV‑COMP 2019 C‑program that contains a call to the single‑precision IEEE‑754 square‑root routine.  \nOnly two 32‑bit constants, `c___ieee754_sqrtf_~r~0` and `c___ieee754_sqrtf_~s~0`, are declared, and a single universally quantified formula is asserted over a fresh 32‑bit variable `__ieee754_sqrtf_~ix~0`.  \nThe formula states that for **all** possible inputs the bit‑vector expression  \n\n```\nbvadd (bvmul 2 (bvneg (bvadd (bvlshr c_r 1) c_s))) (bvmul 4 __ieee754_sqrtf_~ix~0)\n```  \n\nmust never be equal to zero; equivalently, the solver is asked to prove that the linear combination of the constants and the input cannot produce the zero vector.  \nThus the benchmark checks a safety property of the sqrt implementation (the “unreachable‑call” condition) by encoding it as a quantified bit‑vector inconsistency.  \nIt uses only elementary BV operators (add, mul, shift‑right, neg) and has a shallow term depth (9), making it a typical example of a quantified BV instance produced for the industrial category of the competition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/soft_float_4_true-unreach-call_true-no-overflow_true-termination.c.cil.c_0.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification query (logic **BV**) generated by **Ultimate Automizer** from an SV‑COMP 2019 benchmark that tests a soft‑float addition routine. It declares seven 32‑bit constants that represent the inputs, mantissas and exponents of two floating‑point numbers and uses a handful of bit‑wise operations ( bvand, bvor, bvlshr) to extract the 23‑bit mantissa and the 8‑bit exponent fields, together with bvadd to model the integer arithmetic on those fields. The first two asserts fix the inputs so that both operands are −1 (adding 1 to each yields zero) and require the second operand to be non‑zero, while also defining the “primed” mantissa and exponent values. The final assert negates an existential property that would witness a delta value making the shifted mantissa of the second operand equal to the stored primed mantissa and simultaneously causing the primed mantissa of the first operand to overflow to zero; the overall **check‑sat** asks whether this negated condition is reachable, i.e., whether the original error state is *unreachable*. The script is relatively small (≈2.6 kB, three top‑level asserts) but contains a quantified sub‑formula, making it a typical industrial bit‑vector reachability problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_5.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from an SV‑COMP 2019 C‑program benchmark (family UltimateAutomizerSvcomp2019, industrial category, 3 declared constants, 2 top‑level asserts, ≈3.2 KB, max term depth 7).  \nThe first assertion states that three separate linear equations over the program variables x, y, z have a solution: for each variable there exist two nondeterministic 32‑bit values that satisfy a multiplication‑by‑large‑constant equality (e.g. 2097152·v₅ = 4292870144·v₆ + y).  \nThe second assertion asserts the **negation** of a similar set of equations where each equality is extended with an additional copy of the nondeterministic term (e.g. 2097152·v₅ = 4292870144·v₆ + 4292870144·v₇ + y), and combines the three negated conjuncts with a top‑level (and).  \nThus the whole query asks whether it is **unsatisfiable** that the original equations are solvable while the “augmented” versions are **not** solvable—essentially a reachability/termination check encoded as quantified bit‑vector arithmetic.  \nThe problem is notable for its use of multiple ∃‑quantifiers, large constant multipliers, and only bit‑vector operations (bvmul, bvadd, =), making it a typical example of the kind of quantified BV constraints produced by automated software model‑checking tools.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "The file is a 2‑KB SMT‑LIB 2.6 benchmark in the **BV** logic, produced by **Ultimate Automizer** for the SV‑COMP 2019 industrial suite (benchmark *jain_6*). It declares three 32‑bit bit‑vector variables `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0`, which correspond to the program’s integer variables x, y and z. The core of the problem consists of two quantified formulas: a universal clause stating that, for all nondeterministic 32‑bit values (the `|main_#t~nondet*|` terms) and auxiliary substitutions, a large linear combination of those values cannot equal another linear combination involving x, y, z; and a second clause that negates a similar universal statement, effectively asking whether there **exists** nondeterministic choices that make the two side‑by‑side expressions equal. These constraints encode a safety/termination condition of the original C program: the solver must show that the equality can never be satisfied (unsat) or find a witness that violates it (sat). Notably, the formulas use extreme constants such as 4294967288 (= −8 mod 2³²) and multiples of 8, illustrating bit‑vector overflow arithmetic while keeping the term depth shallow (max 7) despite many `bvmul` occurrences.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_36.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (size ≈ 2 kB, 2 declarations and 2 assertions) generated by Ultimate Automizer from an SV‑COMP 2019 C program that contains a call to `ieee754_sqrtf`.  It models the floating‑point square‑root routine with two 32‑bit bit‑vector constants `r` and `s` that represent internal approximation variables of the algorithm.  The first assertion universally quantifies over an input word `ix` and forces the arithmetic relation  \n\n\\[\n4·ix + 2·\\neg\\bigl((r>>1)>>1)>>1 + s\\bigr) \\neq 0,\n\\]\n\nexpressing a necessary invariant of the sqrt computation.  The second assertion negates the conjunction  \n\n\\[\nr = 16384 \\;\\land\\; s + 0xFDE00000 = 0,\n\\]\n\nthereby asking the solver to check that the particular pair \\((r,s)\\) never satisfies this combination.  Satisfiability of the whole file therefore corresponds to proving the unreachability of the error state encoded by that pair of constants in the analyzed program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_5.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2019 industrial “false‑unreach‑call” category (size ≈ 3 kB, 6 assertions, 3 declared constants). It models a simple loop that accumulates the sum of the first *n* natural numbers, using the classic closed‑form formula *n·(n+1)/2* (expressed as `bvudiv (bvmul main_~n~0 (bvadd main_~n~0 (_ bv1 32))) (_ bv2 32)`). The three constants represent the loop counter *i*, the current partial sum *sn*, and the bound *n*, and the quantified constraints relate *sn* to *i* and *n* for different offsets of the counter (e.g., `i+1`, `i+2`, `i+3`, `i+4`). Two final assertions negate a universal property about the relationship for the case `i+3` and also assert that the expression `3*i + sn` is different from the concrete constant 4294967293, thereby encoding a putative counterexample to the correctness condition. The solver is asked to check satisfiability of these contradictory constraints, which corresponds to the verification question “does the program reach the error state?” in the original C benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 “jain_6” C program (size ≈ 3400 characters, 3 declared constants and 2 top‑level assertions).  It models three program inputs `c_main_~x~0`, `c_main_~y~0`, `c_main_~z~0` and, for each of them, existentially quantifies auxiliary 32‑bit “nondet” variables that must satisfy linear equations of the form `k·v = m·w + const` where the coefficients are small constants (2, 4, 8) or their 2’s‑complement equivalents (e.g. 4294967294 = −2).  The first assertion states that there exists a solution for each of the three equations separately, while the second assertion, wrapped in a `not`, requires that **no** solution exists when each equation is allowed to use three nondet variables summed together.  Consequently the whole formula checks the unsatisfiability of the negated conjunction, which corresponds to the safety (unreachability) property of the original program.  The problem is purely arithmetic, uses only bit‑vector constants, `bvmul`, `bvadd`, equality and quantifiers, and has a maximal term depth of 7.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/float_req_bl_0730b_true-unreach-call.c_38.smt2",
    "description": "The script is a 2 KB BV‑logic benchmark (logic BV, 1980 characters, 2 asserts, 3 declared 32‑bit bit‑vectors) generated by Ultimate Automizer from the SV‑COMP 2019 C‑benchmark *float_req_bl_0730b_true‑unreach‑call.c*. It declares three 32‑bit constants that model internal variables of the IEEE‑754 `sqrtf` function (`r`, `ix`, `s`). The first assertion is a universally quantified property saying that for **any** value of the quantified variable `__ieee754_sqrtf_~ix~0` the expression  \n\n```\nbvadd (bvmul 4 __ieee754_sqrtf_~ix~0)\n      (bvmul 2 (bvneg (bvadd (bvlshr (bvlshr (bvlshr c_r 1) 1) 1) c_s)))\n```  \n\nis never equal to zero. The second assertion fixes the concrete constant `c___ieee754_sqrtf_~ix~0` to zero, thereby instantiating the quantified variable with the value used in the benchmark. The check‑sat query therefore asks whether the implementation of `sqrtf` can ever make the above combination zero when its input is zero – a typical “unreachable‑call” property that combines arithmetic reasoning with a single quantified bit‑vector clause. Notably, the formula contains nested logical right‑shifts and a mix of multiplication, addition and negation, which makes it a non‑trivial case for quantifier‑capable BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/sum02_false-unreach-call_true-no-overflow.c_1.smt2",
    "description": "This instance is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 benchmark *sum02_false‑unreach‑call_true‑no‑overflow.c*. It declares three unsigned 32‑bit variables `i`, `sn` and `n`, where `sn` is intended to denote the triangular number `n·(n+1)/2`. The core constraints assert that either `sn` is zero or equals that triangular‑number expression, and then relate `i`, `sn` and `n` through a handful of linear equations (e.g., `3·i + sn = n·(n+1)/2 − 3` and similar for coefficients 2 and 4) guarded by range conditions on `i` and `n`. Two negated universally quantified formulas together with a final assertion `sn + i ≠ 0` encode the negation of the safety property, so the solver is asked to find a counterexample to the invariant. The script is relatively large (≈ 3 kB, 6 assertions, 4 nested quantifiers) and features wrap‑around arithmetic, division by a constant, and large constants such as 4294967293 (‑3 mod 2³²), making it a typical challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_15.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 32‑bit bit‑vectors) generated by **Ultimate Automizer** from the SV‑COMP 2019 industrial suite (the benchmark *jain_2*).  It contains only two declared constants – the program variables `c_main_~x~0` and `c_main_~y~0` – and two quantified assertions that involve a handful of universally quantified “nondet” inputs.  \n\nThe first assertion states, for all nondeterministic 32‑bit values `|main_#t~nondet0|` and `|main_#t~nondet1|`, that a certain linear combination of `c_main_~y~0`, `c_main_~x~0` and those inputs can **never** be equal; the second assertion is the negation of a similar universally‑quantified equality that also includes auxiliary substitution variables.  Together they encode the negation of a reachability/termination condition: the solver is asked to find a concrete assignment that violates the universally quantified safety property, i.e., to exhibit a counterexample to the program’s claimed correctness.  \n\nBecause the outermost formula is a negated `forall`, the problem reduces to checking the existence of a witness (an `exists`‑style query) for the equality, which is why the script ends with a single `(check-sat)`.  The benchmark is relatively shallow (max term depth 8) but features several bit‑vector multiplications and additions, illustrating the bit‑precise arithmetic reasoning required by Ultimate Automizer’s automata‑theoretic analysis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_17.smt2",
    "description": "The script is a 2‑KB BV‑logic benchmark generated by **Ultimate Automizer** from the SV‑COMP 2019 industrial suite (benchmark *jain_2*).  It declares two 32‑bit program variables `c_main_~x~0` and `c_main_~y~0` and a number of unnamed auxiliary bit‑vectors that model nondeterministic choices (`|main_#t~nondet0|`, `|main_#t~nondet1|`).  The problem consists of two quantified assertions: the first universally quantifies four variables and asserts that a certain linear combination of them (all coefficients are the constant 2) can never equal another combination plus 1; the second negates a similar universal statement involving an additional constant `0xFFFFFFFF` (the bit‑vector “‑1”).  By negating the second universal, the solver is asked to find a concrete assignment that violates the intended invariant, i.e. to check whether the encoded safety/termination condition of the original C program is reachable.  The instance is notable for its heavy use of bit‑vector multiplication by a constant, the bit‑wise negation operator, and two nested `forall` quantifiers, which make it a non‑trivial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "This instance is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 “jain_6” benchmark; it is classified as an industrial verification task and contains 9 declared constants, 3 top‑level asserts and about 3 kB of text. The first assert defines the post‑state (“primed”) variables x′, y′, z′ as a linear update of the pre‑state variables x, y, z using three nondeterministic 32‑bit inputs multiplied by the constants 2, 4 and 8 respectively. The second assert states a universally quantified property over all possible nondeterministic inputs: a particular affine combination of the pre‑state variables and the inputs must never be equal to a constant‑shifted expression (the constant 4294967292 equals ‑4 mod 2³²). The third assert negates an analogous universally quantified equality but with the primed variables, thereby asking whether there exists a choice of inputs that makes the post‑state violate the same affine relation. The overall check‑sat query therefore asks if the transition relation can reach a state that disproves the intended invariant, i.e., whether the safety/termination condition encoded by the quantified equalities is falsifiable. Notable features are the use of large “near‑overflow” constants (‑4,‑8,‑2 modulo 2³²) and two quantified formulas, which give the benchmark a moderate term depth (7) and expose how the tool models linear arithmetic on bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_7_true-unreach-call_true-no-overflow_false-termination.i_10.smt2",
    "description": "The script is a 32‑bit bit‑vector verification query generated by Ultimate Automizer from the SV‑COMP 2019 “jain_7” benchmark (family *UltimateAutomizerSvcomp2019*, industrial category, 3 KB, 2 assertions, 3 declared constants).  It works in the **BV** logic and declares the three program variables `c_main_~x~0`, `c_main_~y~0` and `c_main_~z~0`.  \n\nThe first assertion requires that, for each of the three variables, there exist three auxiliary 32‑bit “nondet” values satisfying a linear equation of the form  \n\n```\nbvadd (bvmul K v7) (bvmul K v6)  <var> = bvmul M v5\n```  \n\nwhere the constants `K` and `M` are large (e.g., 4292870144, 2097152) and all arithmetic is modulo 2³².  \n\nThe second assertion negates a similar conjunction but with an additional nondet variable on the left‑hand side, i.e., it asserts that **no** choice of four nondet values can satisfy the extended equations.  Together the two assertions encode a reachability/termination condition: the script asks whether the program state described by the first set of equations can lead to a state that violates the second set.  \n\nThus the problem is a SAT/UNSAT check for the existence of a counterexample to a safety property, expressed as quantified bit‑vector linear constraints with heavy use of multiplication and addition, typical of automated software model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_6_true-unreach-call_true-no-overflow_false-termination.i_18.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark generated by Ultimate Automizer for an SV‑COMP 2019 “true‑unreach‑call” test case (file BV/…/jain_6_… .smt2, 2 kB, industrial category). It declares three 32‑bit program variables x, y, z and three nondeterministic inputs, then asserts a universally quantified statement that a weighted sum of these values (using the constants 4294967288 (= ‑8), 4294967294 (= ‑2) and 4294967292 (= ‑4) modulo 2³²) can never equal z plus 8 times another nondet variable. A second assertion negates a similar universal equality that also introduces fresh substitution variables, so the overall query asks whether there exists an assignment violating the first property. Hence the check‑sat call is equivalent to a reachability/overflow proof: the formula is unsatisfiable if the encoded arithmetic invariant always holds. The instance features only linear bit‑vector arithmetic (16 bvmul, 4 bvadd) with a modest term depth of 7, making it a typical small‑scale verification condition for integer‑overflow‑free C code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_2.smt2",
    "description": "The script is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from the SV‑COMP 2019 benchmark *jain_2* (file …/jain_2_true‑unreach‑call… .smt2).  Two program inputs, `c_main_~x~0` and `c_main_~y~0`, are declared, and the remaining symbols are existentially quantified “nondet” variables that model the values of temporary program variables.  The first top‑level assertion requires the existence of two pairs of nondet values that satisfy two linear equations modulo 2³²: one equation involves the constant 4294967294 (≡ ‑2) multiplied by the nondet values together with `c_main_~y~0`, and the other involves `c_main_~x~0` and a factor 2.  The second assertion states the negation of a conjunction of two similar existential constraints, i.e. it asserts that no pair of nondet values can simultaneously make `c_main_~x~0+4294967295` even and make `c_main_~y~0` equal to 1 after the same scaling.  The overall check‑sat query therefore asks whether the combination of these constraints is consistent; a result of unsat would prove that the error condition encoded by the negated conjunction is unreachable in the original program.  The file is small (≈ 2 kB, 2 declares, 2 asserts) and uses only basic BV operators (add, mul, equality) with a maximum term depth of 7.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20190429-UltimateAutomizerSvcomp2019/jain_2_true-unreach-call_true-no-overflow_false-termination.i_12.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer from the SV‑COMP 2019 industrial suite (file jain_2_*; size ≈ 2 KB, 2 assertions, 2 declared constants). The logic is pure BV, and the only free symbols are the two program variables c_main_~x~0 and c_main_~y~0 together with several universally quantified “nondet” variables that model nondeterministic choices in the source program.  \n\nThe first assertion universally quantifies over four 32‑bit terms and asserts that the equality  \n\\[\n2·v_{sub2}+2·nondet0+x = 2·v_{sub1}+y+2·nondet1+1\n\\]  \ncan never hold (the equality is negated).  \n\nThe second assertion is the negation of a universal statement, i.e. it requires the existence of nondet0 and nondet1 such that  \n\\[\ny+2·nondet1+0xFFFFFFFF = -\\,(2·nondet0+x)\n\\]  \nholds; this is expressed as ¬∀…¬(= …).  \n\nTogether the formula encodes a reachability (or unreachability) condition: it asks whether the program can reach a state where the two linear bit‑vector expressions become equal, which is precisely the property checked by the original “true‑unreach‑call” benchmark.  \n\nThe instance is notable for using quantifiers over BV terms—unusual for BV‑only benchmarks—and for compactly representing the program’s transition relation and safety property without auxiliary commands such as model extraction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/073.smt2",
    "description": "The file is a BV‑logic benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task; it contains 32 Boolean constants, 42 32‑bit BitVecs, a single universal quantifier and a total of 15 646 AST nodes (depth 85).  The core of the model is the quantified clause $x3432$, which relates two abstract program states (source S₁, S₂ and transformed state E₁) by a large conjunction of equalities and arithmetic constraints built from “write‑mask’’ Booleans (MW_*) and ite‑expressions over the bit‑vectors.  Around this clause the benchmark adds a suite of Boolean consistency axioms: read/write flags (R_* , W_* ), disjointness predicates (DISJ_*) and non‑interference conditions that force, for example, a write to a location to be exclusive of any read of the same location.  The final two top‑level assertions explicitly require the disjointness predicates DISJ_W_S2_R_S1 and DISJ_W_S2_R_S2 to be simultaneously false, and also demand that W_S2_V2 and DISJ_W_S2_R_S2 cannot both hold, thereby turning the whole problem into a satisfiability check for the synthesized precondition.  The benchmark is typical of industrial verification instances: it mixes a deep quantified data‑flow formula with many lightweight Boolean “control‑flow’’ constraints, resulting in a highly nested, ite‑heavy formula that stresses solvers’ handling of quantifiers, bit‑vector arithmetic and Boolean reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/133.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit vectors) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task; it belongs to the “industrial” Preiner‑psyco family (≈ 19 KB, 25 Boolean constants, one quantified formula).  \nThe quantified part universally ranges over the original program variables V2, V4, V5, V6 together with a set of Boolean control flags MW_S1_V* that select which of the two candidate statements (the original or the optimized one) is active for each program location.  \nWithin the body of the quantifier a large conjunction of equalities, ordering constraints (signed‑greater‑or‑equal / signed‑less‑or‑equal) and **ite** expressions relates the values of the original variables (E1, E2, S1_Vi) before and after the transformation, while auxiliary Boolean flags R_* and W_* encode read‑set and write‑set information.  \nThe outermost conjunction enforces disjointness between writes and reads (DISJ_W_S1_R_*) and requires that certain reads are omitted (e.g., ¬R_E1_V5, ¬R_E2_V3) and that the write‑set flags satisfy consistency conditions such as “if a variable is not written then the corresponding write‑flag is true”.  \nOverall, the benchmark checks that, under the specified read/write and disjointness assumptions, the transformed program preserves the necessary value relations, i.e., the weakest precondition of the optimization holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/026.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task; it is an industrial‑style instance of about 10 KB, with one quantified formula, 32 Boolean constants and a handful of auxiliary bit‑vector variables.  The encoding models two program fragments (labelled S1 and S2) and an original fragment E1, using Boolean flags such as R_S1_V4, W_S2_V5, DISJ_W_S1_R_E1, etc., to represent whether a variable is read, written, or whether write‑sets are disjoint.  The main universally‑quantified conjunct $x3307$ captures the weakest‑precondition conditions that relate the values of the variables before and after the transformation, enforcing equality of values for unchanged locations, ordering constraints (bvsle/bvsge) on the 32‑bit data, and consistency of the “must‑write” flags (MW_*) with the corresponding write‑Boolean variables.  A second block of constraints defines the disjointness predicates (DISJ_*) and forbids conflicting read/write combinations, and the three top‑level assertions negate specific combinations (e.g., a write to V2 in S2 together with the disjointness of S2‑reads from S1‑reads) to turn the verification question into an unsatisfiability check.  Consequently, the solver is asked to prove that, under all possible inputs, the transformation preserves the intended semantics and respects the read/write conflict‑avoidance properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/121.smt2",
    "description": "This instance is a BV‑logic benchmark (32‑bit vectors) generated by the PSyCO tool (industrial‑category “Preiner‑psyco”) and contains 26 Boolean constants that encode reads (R_*) and writes (W_*) of six program variables (V1…V6) in three program fragments (S1, E1, E2). The heart of the encoding is a single universally quantified formula that models the effect of a sequence of assignments: each write flag MW_S1_Vi selects, via ite, either the newly written value or the old value, and a collection of bit‑vector equalities, additions and signed‑order constraints (bvsle/bvsge) enforces consistency and data‑dependence among the generated values. Additional Boolean clauses build the predicates DISJ_W_S1_R_S1, DISJ_W_S1_R_E1 and DISJ_W_S1_R_E2, which assert that the sets of writes performed in S1 are pairwise disjoint from the sets of reads performed in S1, E1 and E2 respectively. The final query asserts (not DISJ_W_S1_R_S1) and asks the solver to check satisfiability, i.e., whether a counter‑example exists in which the write‑read disjointness required by the weakest‑precondition synthesis for a compiler optimization is violated. The file is large (≈ 17 k characters, term depth 312) and heavily uses nested let bindings, a single forall, and many or/and/ite constructs to compactly represent the verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/099.smt2",
    "description": "The file is a **BV‑logic** benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesiser for a compiler‑optimisation verification task (see Lopes & Monteiro VMCAI’14).  It models two versions of a small program (named S1 and S2) that manipulate four 32‑bit data variables V1…V5 together with an “environment” variable E1; the Boolean constants `W_*` and `R_*` mark whether a given statement writes or reads a particular variable, and the `DISJ_*` flags express the required disjointness of write‑sets and read‑sets.  The core of the encoding is a single universally quantified formula (`$x5110`) that ties together the concrete bit‑vector updates (using nested `ite`, `bvadd`, `bvsle`, etc.) with the Boolean control‑flow conditions, essentially stating the weakest‑precondition equivalence between the two program versions.  A collection of nine top‑level assertions then require that certain combinations of write/read flags and disjointness predicates are **unsatisfiable**, i.e., they check that no illegal overlap of reads/writes can violate the equivalence.  With 32 declared Boolean constants, more than 200 `let` bindings, and a maximum term depth of 191, the instance is a medium‑size industrial benchmark (≈ 22 KB, 9 assertions) used to stress‑test BV solvers on complex quantified and combinatorial reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/052.smt2",
    "description": "The file is a BV‑logic benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesis tool for compiler optimizations (see Lopes & Monteiro VMCAI’14); it belongs to the “industrial” Preiner‑psyco family, contains 32 Boolean constants, 16 ‑ bit vector constants, a single universal quantifier, and a total of 6 top‑level assertions in a 21 KB text.  \n\nThe main body is a huge quantified formula ($x6721) that encodes the equivalence of two program states (original vs. optimized) using conditional (ite) selections of write‑flags (MW_*) and the corresponding 32‑bit values of variables V1…V5 and the temporary E1.  \n\nAround this core the benchmark adds a collection of “disjointness” predicates (DISJ_…) that enforce that a write in one thread does not interfere with a read in another, together with simple write‑read consistency literals such as W_S1_V4 ↔ R_S1_V4, and invariants like ¬R_E1_Vi → (…value equality…).  \n\nThe final three top‑level assertions negate three conjunctions of these DISJ‑ and consistency literals, effectively asking the solver to find a counter‑example that violates the correctness condition of the transformation.  \n\nBecause the problem is expressed almost entirely with Boolean scaffolding and a single quantified equivalence over 32‑bit bitvectors, it is a typical “weakest‑precondition” industrial case: many let‑bindings, deep nesting, and a high proportion of ite/and/or operators, but a relatively modest number of distinct top‑level constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/075.smt2",
    "description": "The file is a **BV** (32‑bit bit‑vector) benchmark generated by the **PSyCO** weakest‑precondition synthesis tool for the “compiler‑optimisation” case study (VMCAI ’14) and then translated to pure bit‑vector logic by Mathias Preiner.  It declares a collection of Boolean flags `R_*` and `W_*` that model reads and writes of four program variables (V1…V5) in three program points – the original expression **E1**, and two statements **S1** and **S2** – together with auxiliary Boolean selectors `MW_*` that choose which version of a variable is the “most recent write”.  The core of the problem is a single universally quantified formula that enforces the usual single‑assignment and memory‑consistency properties (e.g., a read must see the latest write, writes must be mutually exclusive) using a dense network of `ite`, `bvadd`, `bvsle`/`bvsge` constraints and a large set of derived disjointness predicates (`DISJ_…`).  The last five top‑level assertions are the negations of several conjunctive combinations of those disjointness predicates, essentially asking the solver to find a contradiction—i.e., to prove that no assignment to the read/write flags can satisfy all consistency and disjointness requirements simultaneously.  With about 32 Boolean constants, 17 880 characters, 173 `let`s and a single quantifier, the instance is a typical industrial “memory‑model” verification problem that stresses the solver’s handling of quantified ite‑heavy bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/045.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, 19 top‑level asserts, 32 Boolean constants, ~19 k characters) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task.  It models three program states—an entry state E1 and two transformed states S1 and S2—each holding five 32‑bit variables V1…V5, and introduces Boolean flags R_*/W_* that indicate whether a particular variable is read or written at each state.  The core of the encoding is a single universally‑quantified formula ($x3462) that relates the values of the variables across the states using nested ite‑expressions, bvadd 1, and signed comparisons, together with Boolean “write‑selection’’ variables (MW_*) that capture which version of a variable is the effective one after the optimization.  A large collection of auxiliary constraints enforces disjointness of reads and writes (the DISJ_* predicates) and rules out forbidden combinations of read/write choices via many negated conjunctions.  The final check‑sat query asks whether there exists a consistent assignment to the read/write flags that satisfies the weakest‑precondition relation, i.e. whether the proposed optimization is provably correct for this industrial‑size instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/086.smt2",
    "description": "The file is a BV‑logic benchmark (2.6) generated by the PSyCO weakest‑precondition synthesiser and then translated to bit‑vectors; it contains 32 Boolean constants (the read/write flags R_/W_ and the disjointness literals DISJ_…) together with a single universally quantified clause $x3432 that symbolically describes the effect of a small concurrent program with two threads S1, S2 and an environment E1.  The quantified part enumerates all possible selections of the write‑choose flags MW_S1_*/MW_S2_* and builds the resulting values of the program variables V1…V5 using nested ite terms, while simultaneously asserting ordering and value‑equality constraints that model a weak‑memory or compiler‑optimisation semantics (e.g., “if a read occurs then the read value must equal the most recent selected write”).  Around this core, a collection of Boolean constraints (DISJ_W_S*_R_*) encode mutual‑exclusion/disjointness conditions between reads and writes, and the final 16 top‑level assertions are negated conjunctions of these literals that ask the solver to find a concrete assignment violating any of the intended safety properties.  In effect, the query asks whether there exists a reachable state where the read/write disjointness and ordering guarantees are broken; a result of **unsat** would prove that the encoded optimisation (or weak‑memory model) preserves the program’s correctness.  The benchmark is relatively large (≈ 19 k tokens, max term depth 165) and belongs to the industrial “Preiner‑psyco” family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/079.smt2",
    "description": "**Instance summary**  \n- The file is a BV‑logic benchmark (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro VMCAI’14) and translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” Preiner‑psyco family (BV/2017‑Preiner‑psyco/079.smt2).  \n- It declares 32 Boolean flags that model reads (**R\\_***), writes (**W\\_***), and auxiliary disjointness predicates (**DISJ\\_***).  A single universal quantifier (`forall`) wraps a huge let‑nested expression that encodes the SSA‑style semantics of a small program fragment: each variable version (e.g., `V1_0`, `E1_!2446`) is related through a cascade of `ite`‑terms, arithmetic (`bvadd`, `bvneg`) and ordering (`bvsle`, `bvsge`) constraints.  \n- On top of the semantic core the instance adds a block of Boolean constraints expressing that the read/write sets of the two “states” (S1 and S2) must be pairwise disjoint (`DISJ_W_S1_R_S2`, `DISJ_W_S2_R_E1`, etc.) and that certain write‑read combinations are prohibited; these are then negated in nine top‑level assertions (e.g., `(assert (not (and DISJ_W_S2_R_S1 DISJ_W_S2_R_S2)))`).  \n- The overall check asks the solver whether the conjunction of the program‑semantics formula (`$x3432`) together with the disjointness/consistency clauses is **unsatisfiable**; the benchmark therefore tests the solver’s ability to handle deep let‑nesting, many ite‑chains, and a mixture of quantified and propositional reasoning.  \n- The problem is relatively large for a BV benchmark (≈ 18 k characters, max term depth 165) but contains only a single quantifier and nine top‑level asserts, making it a good stress‑test for bit‑vector solvers that also have to manage extensive Boolean bookkeeping.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/115.smt2",
    "description": "The file is a 12 KB BV‑logic benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesiser for a compiler‑optimisation verification task and then translated to 32‑bit bit‑vectors by Mathias Preiner.  \nIt declares a large collection of Boolean flags (`W_…` for writes, `R_…` for reads, and `DISJ_…` for disjointness) together with 32‑bit variables `V1…V6` and auxiliary versions that model the values before and after a program block S1 and two surrounding environments E1 and E2.  \nThe core of the instance is a single universally quantified formula that encodes the semantics of S1 as a series of conditional `ite` updates guarded by the write‑flags and a host of relational constraints (ordering, increment, and inequality) between the pre‑ and post‑state bit‑vectors.  \nAdditional Boolean constraints enforce that the write set of S1 is disjoint from the read sets of S1, E1 and E2, and they are coupled with a few “negative” assertions (e.g. `(not (and (not W_S1_V2) DISJ_W_S1_R_S1))`) that force the solver to look for a contradictory combination of flags.  \nThus the benchmark checks the feasibility of the weakest‑precondition conditions for the optimisation; if the solver returns *unsat* it witnesses that no assignment to the write/read flags can satisfy all the relational and disjointness requirements.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/078.smt2",
    "description": "This benchmark is a **BV‑logic** instance (bit‑vectors of size 32 together with Booleans) generated by the **PSyCO** weakest‑precondition synthesis tool (the source cites Lopes & Monteiro, VMCAI ’14, and is translated to BV by Mathias Preiner).  It is an **industrial‑style verification task** of moderate size (≈ 18 k characters, 32 Boolean constants, a single deep ∀‑quantifier, and 8 top‑level assertions).  \n\nThe model encodes a small imperative program with three “states’’ – the original execution (E1) and two transformed versions (S1, S2).  For each program variable V1…V5 the file declares Boolean flags for **reads** (R_…) and **writes** (W_…) and also Boolean “mod‑write’’ flags (MW_…) that select which version of a variable’s value is used in the post‑state.  The massive quantified conjunct $x3432 describes the **weakest‑precondition constraints** that relate the old values (V*_0) to the new values (the many indexed BitVec terms) and enforces consistency of the read/write selections, ordering of increments, and the usual “disjointness’’ conditions between reads and writes (the DISJ_… predicates).  \n\nA handful of additional assertions explicitly assert the **negation of several of these disjointness conditions** (e.g., both a read‑set and a write‑set overlapping), and the final `(check‑sat)` asks whether the whole conjunction is satisfiable.  The intended outcome is **unsatisfiable**, showing that the proposed transformation violates the required read/write separation and weakest‑precondition properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/060.smt2",
    "description": "The file is a BV‑logic benchmark (size ≈ 4 kB, 11 Boolean constants, 2 top‑level asserts) generated by the PSyCO weakest‑precondition synthesis tool and translated to bit‑vectors by Mathias Preiner.  Its core is a single quantified formula that ranges over three 32‑bit variables V2₀, V5₀, V6₀ (the values of program variables before a transformation) together with a set of “write‑mask’’ Booleans MW_S1_Vi and versioned copies S1_Vi_!… which model the effect of possible assignments to V1…V6.  Inside the quantifier the instance forces each versioned copy to equal either the original value or a new value depending on the corresponding mask, and adds arithmetic constraints such as V2·V2 ≤ 0, V2‑1 ≤ 0, and checks that a division (0 ÷ V2₀) produces 0 only when allowed, using bvmul, bvsge, bvsle and bvsdiv.  Outside the quantifier a collection of Boolean flags W_S1_Vi (write) and R_S1_Vi (read) is linked by a disjointness condition (the DISJ_W_S1_R_S1 flag) and by additional clauses that require W_S1_V5 to be true while prohibiting all of W_S1_V1, W_S1_V2, W_S1_V3 from being false simultaneously.  The whole benchmark therefore asks whether there exists a concrete assignment to the three 32‑bit variables and the Boolean control flags that satisfies the weakest‑precondition verification condition for the encoded compiler optimization.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/074.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, 17 kB, 32 declared Boolean constants and many 32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesiser for a small compiler optimisation (see Lopes & Monteiro, VMCAI’14).  The core of the model is a single ∀‑quantified formula that links a set of “write‑mask’’ Booleans (MW_*) with the values of program variables (V1…V5) after each of two statements (S1, S2) and an entry point (E1), using a dense hierarchy of ite‑expressions, adds and signed comparisons to capture the data‑flow and ordering constraints of the optimisation.  Around this quantifier the benchmark declares a large collection of Boolean predicates for reads (R_*) and writes (W_*) of each variable in each statement and builds disjointness constraints (e.g. DISJ_W_S2_R_S1, DISJ_W_S1_R_E1) that enforce that a variable is not simultaneously read and written in conflicting ways.  The final top‑level assertions negate three specific disjointness combinations, effectively asking the solver to find a state where those conflicts occur; the surrounding conjuncts also require consistency of the read/write masks and the quantified weakest‑precondition conditions.  Consequently the problem checks the feasibility of an illegal interleaving of reads and writes under the optimiser’s semantics, a typical “industrial’’ SAT/SMT challenge with a single quantifier, deep let‑nesting and heavy use of ite, making it a hard benchmark for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/056.smt2",
    "description": "The file is a BV‑logic benchmark (SMT‑LIB 2.6, BV) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification case; it contains 32 Boolean constants, dozens of 32‑bit variables, a single ∀‑quantifier and a ground propositional core of 10 top‑level asserts (≈ 22 KB, max term depth 205).  \n\nThe quantified part ($x6721) models the semantics of two program states (S1 and S2) and an expression E1: for each memory location V1…V5 a Boolean flag MW_S*_V* selects whether the value comes from the original variable or from a write in one of the two states, and a collection of equalities and bvadd/bvneg constraints enforce the required ordering (e.g., “the new value is the old value plus 1” and the usual ≤/≥ relations).  \n\nThe remaining Boolean section introduces read‑flags (R_*) and write‑flags (W_*) together with disjointness predicates (DISJ_*) that guarantee that a location cannot be both read and written by conflicting threads; these predicates are combined with many OR/AND/NOT patterns to express the safety condition of the optimization.  \n\nThe final assertions negate several conjunctions of the DISJ_* and read/write flags, asking the solver to find a counter‑example that violates the intended “no‑interference” property; thus the whole instance is used to prove (by unsatisfiability) that the optimization preserves the program’s weakest precondition.  \n\nOverall the benchmark is an industrial‑style memory‑consistency/alias‑analysis problem with a single quantified arithmetic core surrounded by a large propositional encoding of read/write‑disjointness constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/034.smt2",
    "description": "The file is a bit‑vector (BV) benchmark (logic BV) of moderate industrial size (≈ 17 k characters, 8 top‑level asserts, 32 Boolean constants, one universal quantifier and a maximal term depth of 170).  It comes from the PSyCO weakest‑precondition synthesis tool (VMCAI ’14) and was translated to bit‑vectors by Mathias Preiner, so it models a compiler‑optimization correctness condition.  The core of the instance is a single quantified implication ($x3462) that describes the effect of three program versions (E1, S1, S2) on a set of 32‑bit variables V1…V5, using “MW_” Booleans to select which version’s write is the effective one and a web of equalities/inequalities that encode the required data‑flow and ordering constraints (e.g., ‑1 ≤ V2 ≤ E1, monotonicity of increments, and consistency of reads R_ and writes W_).  A second group of Boolean variables (DISJ_…) captures pairwise disjointness conditions between reads and writes of the three versions, and the final eight top‑level asserts state that certain combinations of these disjointness conditions must be impossible.  The solver is therefore asked to decide whether the encoded pre‑ and post‑conditions for the optimization are mutually compatible; a SAT result means a counter‑example to the correctness proof exists, while UNSAT would confirm the transformation respects the weakest‑precondition specifications.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/172.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** (fixed‑size bit‑vector) logic, generated by the PSyCO weakest‑precondition synthesis tool (pre‑translated to bit‑vectors by Mathias Preiner).  It models a small imperative program with five 32‑bit scalar variables V1…V5 and two “states’’ S1, S2; Boolean constants W_* denote whether a variable is written, R_* whether it is read, and MW_* are auxiliary write‑enable flags used inside a large quantified formula.  The quantified part (`forall …`) expresses the functional correctness of the program by equating the original variables with their possible updated values through a cascade of `ite`‑terms, and also enforces relational constraints such as ordering (`bvsge`) and non‑trivial inequalities between the variables.  A second block of constraints introduces **disjointness** conditions (`DISJ_…`) that forbid overlapping read/write accesses between the two states, and finally the outer conjunction requires that certain writes (e.g., W_S1_V3, W_S2_V4) hold together with all the disjointness predicates.  The benchmark is relatively large for an industrial instance (≈10 k characters, 25 Boolean constants, one universal quantifier, depth 53) and contains a dense mix of `ite`, equality, and Boolean combinators, making it a challenging case for solvers that must handle quantifier instantiation together with bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/119.smt2",
    "description": "This benchmark is a 13 KB, industrial‑style SMT‑LIB 2.6 file in the **BV** logic (bit‑vectors of size 32) generated by the PSyCO weakest‑precondition synthesis tool for compiler optimizations. It declares 27 Boolean constants that model “write” ( W_… ) and “read” ( R_… ) permissions for three program fragments (S1, E1, E2) together with a large set of uninterpreted bit‑vector variables representing the values of program variables before and after the transformation. The core of the instance is a single universally quantified formula that relates the original and optimized states using a mixture of equalities, linear bvadd/ bvneg arithmetic, and signed‑inequality (bvsle/bvsge) constraints, while simultaneously enforcing that a variable is either unchanged or updated according to the corresponding write‑mode flag (the MW_… Booleans). Additional propositional clauses encode three “disjointness” properties (DISJ_W_S1_R_E1, DISJ_W_S1_R_S1, DISJ_W_S1_R_E2) that require the sets of variables written by S1 to be disjoint from those read by E1, S1 itself, or E2, respectively, and they are combined with the write/read flags. The final two assertions state that (1) the whole quantified condition must hold and (2) the write flag W_S1_V2 cannot be false while the disjointness with R_E1 holds, forcing the solver to find a model that satisfies all consistency and disjointness requirements.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/185.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, 25 Boolean constants and many 32‑bit bit‑vector variables) generated by the PSyCO weakest‑precondition synthesis tool for compiler‑optimisation verification (see Lopes & Monteiro VMCAI’14).  It models a small program fragment with three versions of each scalar variable (the original source S1, an optimized version S2 and an intermediate expression E1) and introduces Boolean flags W_* and R_* that select whether a given variable is written or read in each version.  A single quantified assertion relates the concrete bit‑vector values of the variables across the three versions using a cascade of ite‑expressions guarded by the write flags, together with arithmetic constraints (bvadd, bvsle, bvsge) that capture the semantics of the program statements (e.g., increments and value ordering).  A collection of additional Boolean clauses enforces consistency of the read/write flags (e.g., not all writes are false, certain reads imply the corresponding writes) and ties the symbolic equalities together, essentially checking whether there exists a selection of reads/writes that satisfies the weakest‑precondition conditions.  The overall check‑sat query asks whether the encoded weakest‑precondition constraints are simultaneously satisfiable, i.e. whether the proposed optimisation is semantically correct under some feasible control‑flow choice.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/092.smt2",
    "description": "**The file is a bit‑vector (BV) benchmark generated by the PSyCO weakest‑precondition synthesiser (Preiner’s translation of the “compiler‑optimisation” case study in VMCAI ’14).**  \nIt works with a small “program” that has three blocks – E1, S1 and S2 – each reading (`R_*`) or writing (`W_*`) a handful of scalar variables (V1 … V5).  \nThe core of the model is a single quantified formula (`$x5110`) that describes the functional correctness of the optimisation: for every possible 32‑bit value of the variables it enforces that the values after the transformation (chosen by the Boolean “write‑choice’’ flags `MW_*`) are equal to the original values and respects a set of numeric ordering constraints (bvadd, bvsle, bvsge).  \nAround this, a large collection of Boolean “disjointness’’ constraints (`DISJ_*`) ensures that a variable is not simultaneously read and written by incompatible statements and that the write‑selection flags are mutually exclusive (e.g. `DISJ_W_S1_W_S2`, `DISJ_W_S2_R_E1`, …).  \nFinally the benchmark asserts the conjunction of all correctness and disjointness clauses and also asserts the negation of the combined disjointness of S2 reads (`DISJ_W_S2_R_S1 ∧ DISJ_W_S2_R_S2`); the solver is asked whether this whole formula is satisfiable, i.e. whether a counter‑example to the optimisation exists.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/081.smt2",
    "description": "The file is a BV‑logic benchmark (≈ 18 k characters, 32 Boolean constants, one quantified formula) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task.  It models a small program with three control points (E1, S1, S2) and five integer variables V1–V5; each “R_…’’ and “W_…’’ Boolean denotes whether a read or write of a given variable occurs at a given point, while “MW_…’’ flags select which version of a variable (the original or one of several renamed copies) is used in the weakest‑precondition expression.  The quantified part (a single ∀) asserts a large collection of equalities that tie the selected versions together, together with ordering constraints expressed with signed‑bit‑vector comparisons (bvsle, bvsge) and “next‑value’’ relations (bvadd 1).  A second layer of constraints introduces the DISJ_… Boolean terms that enforce mutual exclusion between writes and reads (e.g., a variable cannot be both read and written simultaneously) and tie those exclusions to the write‑read Boolean variables.  The final eight “assert (not …)’’ statements negate particular conjunctions of these DISJ_… and read/write literals, so the whole problem asks whether the verification condition for the optimization is satisfiable – i.e., whether there exists a consistent assignment of reads, writes, mode flags and integer values that violates the intended safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/122.smt2",
    "description": "The file is a BV‑logic verification condition generated by the PSyCO weakest‑precondition synthesiser for a compiler optimisation.  It introduces Boolean flags R_*/W_* that record whether each program variable V1…V6 is read or written in the source block S1 or in the two expression fragments E1 and E2, together with “MW_*” flags that model the optional write of a variable in the transformed program.  The core of the instance is a single ∀‑quantified formula over 32‑bit values (V2_0, V5_0, V4_0, V6_0) that uses many ite terms to express that the values after the transformation are equal to the values after the original program under all possible write‑choices, and that ordering constraints (≤, ≥) on the bit‑vectors are respected.  Additional Boolean constraints (DISJ_W_S1_R_*) enforce that a variable cannot be both written and read simultaneously, and the outer asserts deliberately set one of these disjointness clauses to false (and force W_S1_V1) to ask the solver whether the remaining constraints are inconsistent.  Thus the problem asks the BV solver to find a model for the read/write selection that satisfies the weakest‑precondition equivalence, and its satisfiability answer indicates whether the proposed optimisation is provably correct.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/027.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** logic (bit‑vector size 32) that comes from the PSyCO weakest‑precondition synthesis tool; it is classified as an industrial instance (family *Preiner‑psyco*, 15 432 characters, 32 Boolean constants and one quantified formula).  \nAll Boolean symbols are of the form `R_…_V*` (read permissions), `W_…_V*` (write permissions) and `DISJ_…` (disjointness flags) for three program states – the original program (**E1**) and two transformed versions (**S1**, **S2**) – over five scalar variables V1…V5.  \nThe sole assertion starts with a universal quantifier over the five 32‑bit variables and a large collection of `let`‑bindings that encode, with nested `ite`s, the effect of each possible write‑set (`MW_S1_…`, `MW_S2_…`) on the values of the variables in the three states, together with arithmetic constraints (increments, `bvadd`, `bvneg`) that model the program’s control‑flow counters.  \nOn top of these functional definitions the formula asserts a raft of equivalences and inequalities expressing: (i) that reads see the latest matching write, (ii) that the write‑sets of the two versions are pairwise disjoint from the reads they affect (`DISJ_W_S1_R_S2`, etc.), and (iii) that the transformed programs preserve the original program’s weakest precondition (no contradictory read/write ordering and the same final values).  \nBecause the whole conjunction is required to hold for **all** possible inputs, the benchmark checks the semantic equivalence of the two compiler optimisations under a rich memory‑model encoding, and it is deliberately crafted to be difficult for solvers (deep term nesting, many `ite`s, and a single massive quantified block).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/123.smt2",
    "description": "**Description**\n\nThis instance is a BV‑logic verification condition generated by the PSyCO weakest‑precondition tool (pre‑translation of a compiler‑optimization proof) and belongs to the “Preiner‑psyco” industrial benchmark. It declares 26 Boolean flags that model reads (`R_…`) and writes (`W_…`) of six program variables (V1–V6) in three program points (the original code E1/E2 and the transformed code S1), together with a few “disjointness” Boolean predicates (`DISJ_…`). The heart of the file is a single universally quantified block over 32‑bit bit‑vectors (the concrete values of the variables) that relates the values before and after the optional writes (using many `ite`/`let` equations) and enforces ordering constraints with `bvsle`/`bvsge` to capture the semantics of the optimization. Outside the quantifier a set of Boolean constraints forces specific reads and writes to be true (`W_S1_V1`, `R_S1_V1`) and deliberately falsifies the disjointness condition `DISJ_W_S1_R_S1`, turning the whole formula into a SAT/UNSAT question about whether the program transformation can violate the required memory‑consistency properties. The problem is thus a quantified bit‑vector consistency check with heavy use of `ite`, `let`, and equality/inequality combinators, typical of weakest‑precondition synthesis tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/094.smt2",
    "description": "This file is a bit‑vector encoding (logic BV) of a weakest‑precondition proof generated by the PSyCO tool for a small compiler‑optimisation benchmark (the “industrial” Preiner‑psyco family).  \nThe model contains 32 Boolean flags that record whether the five program variables (V1…V5) are read (`R_…`) or written (`W_…`) in three program fragments – the original expression E1 and two transformed statements S1, S2 – together with a number of auxiliary “disjointness” flags (`DISJ_…`).  \nThe core of the instance is a single ∀‑quantified assertion that relates the concrete 32‑bit values of the variables before and after each transformation by a cascade of `ite` terms; it also imposes ordering constraints (e.g., `bvsle`, `bvadd`) that encode the semantics of the original program (increment, bounds) and the requirement that the transformed programs preserve those semantics.  \nOn top of this, a large conjunctive block encodes consistency conditions such as “if a variable is written in S2 then the corresponding write flag must be true”, mutual exclusion of certain writes/reads (`DISJ_W_S1_R_E1`, `DISJ_W_S1_W_S2`, …), and equivalences between different renamed copies of the same value.  \nFinally, three top‑level assertions force the conjunction of the disjointness conditions and various read/write combinations to be false, which together make the whole formula unsatisfiable – the instance is used to check that the optimisation’s weakest precondition cannot hold under the given interference assumptions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/137.smt2",
    "description": "The file is a BV‑only SMT‑LIB v2.6 benchmark (logic BV) generated by the PSyCO weakest‑precondition synthesiser for compiler optimisations (PSyCO 0.1, VMCAI’14) and then translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” Preiner‑psyco family and contains 27 Boolean constants, a single 32‑bit universal quantifier, about 58 k characters, 2 top‑level asserts and a term depth of 1 167.  \nThe main body of the problem is a huge quantified conjunct that models two source programs (E1, E2) and one transformed version (S1) by introducing Boolean flags for every possible read (R_*) and write (W_*) of the variables V1…V6, together with auxiliary “mode‑write” flags (MW_S1_V*).  Within the quantifier the formula uses a cascade of `ite` expressions to select, for each variable, either the original value, a value written by S1, or a constant, and then imposes a dense set of ordering constraints (`bvsle`, `bvsge`) and equality checks that capture the data‑flow and control‑flow relations required for a correct weakest‑precondition.  \nTwo global consistency constraints are asserted: (i) the disjointness of any write of S1 from any read of S1 (`DISJ_W_S1_R_S1`) and (ii) analogous disjointness between S1 writes and the reads of the two original programs (`DISJ_W_S1_R_E1`, `DISJ_W_S1_R_E2`).  The final query asserts the negation of `DISJ_W_S1_R_S1`, so the solver is asked to find a counter‑example in which a write of S1 collides with a read of S1; the intended result is unsatisfiability, i.e. that the optimisation preserves the required read/write separation.  \nNotable characteristics are the massive use of `let`‑bindings (over 1 100), many nested Boolean combinations (≈ 460 `or`s, 455 `=`s) and a single 32‑bit universal quantifier that makes the instance a demanding test of quantifier handling and bit‑vector reasoning for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/160.smt2",
    "description": "The file is a 6 KB BV‑logic benchmark (logic BV, 6440 characters, 4 assertions, 9 Boolean constants, max term depth 66) generated by the PSyCO weakest‑precondition synthesis tool and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial‑style instance.  It models a small imperative fragment (named S1) with four 32‑bit program variables V1…V4, Boolean write flags W_S1_Vi, read flags R_S1_Vi and auxiliary “may‑write’’ flags MW_S1_Vi that decide whether a variable is updated to a fresh symbolic value (the S1_Vi_!… terms).  The core of the benchmark is a single ∀‑quantified formula $x2093$ that enforces, for every concrete valuation of the original variables, a collection of relational constraints: equality of old and new values when a write is disabled, monotonicity conditions expressed with signed‐less‑/greater‑equal (bvsle, bvsge), and several consistency clauses that tie together the different “snapshot’’ versions of each variable under the various MW flags.  On top of this, the instance introduces a Boolean DISJ_W_S1_R_S1 that requires the write and read sets to be disjoint, and adds three additional assertions that together ask the solver to find a model where a specific write (W_S1_V2) is false while the disjointness holds, where not both W_S1_V1 and W_S1_V2 are false, and where the disjointness is not forced by a read of V1.  Thus the problem checks whether the synthesized weakest‑precondition and the disjoint‑write/read condition can be simultaneously satisfied, a typical correctness‑checking task for compiler optimisations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/055.smt2",
    "description": "The file is a BV‑only SMT‑LIB 2.6 benchmark (logic BV, 32‑bit vectors) generated by the PSyCO weakest‑precondition synthesiser for a compiler optimisation and then translated to bit‑vectors by Mathias Preiner.  It declares a large family of Boolean constants that model “read” (R_*) and “write” (W_*) events for several program variables (E1, S1, S2) together with auxiliary “disjointness” flags (DISJ_*), and a single quantified formula that relates the values of the 32‑bit variables before and after the optimisation using a mesh of ite‑expressions, bvadd, bvneg and signed‑order predicates.  The quantified part encodes the weakest‑precondition conditions that must hold for every possible concrete state (the V*_0 vectors) and for every combination of memory‑write decisions (MW_*), essentially capturing the semantic equivalence of the original and the transformed program fragment.  The remaining nine top‑level asserts negate various conjunctions of the DISJ_* and read/write literals, turning the task into a satisfiability check: does there exist a consistent assignment to the Boolean flags and bit‑vector values that satisfies all the weakest‑precondition constraints while violating the specified disjointness properties?  The benchmark therefore asks whether the proposed optimisation can be invalidated (unsat → the optimisation is safe, sat → a counterexample exists) and is representative of industrial‑scale verification problems (≈ 22 k characters, 32 Boolean constants, one quantifier, deep nesting of ite‑terms).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/167.smt2",
    "description": "The file is a BV‑logic benchmark generated by the PSyCO weakest‑precondition synthesis tool (version 0.1) for a compiler‑optimization verification task; it belongs to the “industrial” Preiner‑psyco family, contains 32 Boolean constants, a single 32‑bit universally‑quantified block (over V1…V5) and about 10 k characters (10067 bytes, max term depth 138).  The model encodes a small program fragment with three abstract locations (the blocks B1, S1 and S2) and five scalar variables (V1–V5); for each location a set of Boolean flags (`R_*` for reads, `W_*` for writes, `MW_*` for “may‑write”/move) indicates whether a read or write of a given variable occurs and whether it is subject to a transformation.  A large quantified conjunct captures the weakest‑precondition relationships between the original values and the values after the possible writes, using `ite`, `bvadd`, and signed comparisons to model increments and ordering constraints among the variables.  Around the quantified core a collection of Boolean “disjointness” constraints (`DISJ_*`) asserts that writes and reads of different blocks do not interfere, and the final assertion negates one of these (`(not DISJ_W_S1_R_B1)`) to ask the solver for a counter‑example where a write in S1 overlaps a read in B1.  Thus the instance checks whether the compiler transformation preserves the required non‑interference property, and it is deliberately difficult because of the deep nesting of `let`s (172 of them) and the interplay of quantified arithmetic with many Boolean control flags.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/048.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool and translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” category, has 32 Boolean constants (the read/write and disjointness flags) and a single universal quantifier that relates the values of the program variables V1…V5 in three program states (S1, S2, and E1) together with a large set of Boolean control flags (MW_…, DISJ_…).  \n\nThe core of the instance is a massive conjunction of equalities, ordering constraints (bvadd, bvneg, bvsle/bvsge) and disjointness conditions that encode the semantics of a compiler optimisation (the preservation of values after writes and the mutual exclusion of overlapping memory accesses).  \n\nTwo top‑level assertions are then posted: one asserts that all the Boolean flags and the quantified relational constraints hold simultaneously, and the second asserts the negation of the conjunction DISJ_W_S2_R_S1 ∧ DISJ_W_S2_R_S2, i.e. it forces at least one of the two disjointness constraints to fail.  \n\nThus the solver is asked to decide whether the whole memory‑model encoding can be satisfied while violating the S2‑read/write disjointness, a pattern that often leads to unsatisfiability in these PSyCO benchmarks.  \n\nThe instance is relatively large (≈27 KB, 2 top‑level asserts, depth ≈ 500) and features a very high number of let‑bindings, ite‑expressions and arithmetic on 32‑bit vectors, making it a demanding test for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/015.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool (pre‑processor “Preiner‑psyco”) and labelled as an industrial case; it contains 25 Boolean constants, 13494 characters and a maximum term depth of 75.  \nThe core of the assertion is a universally quantified formula that introduces fresh 32‑bit variables V1…V5 together with a large set of Boolean “mode‑write” flags MW_S1_* and MW_S2_* and versioned copies of the program variables (e.g. S1_V3_!5050, S2_V4_!5062).  Inside the quantifier the formula builds a web of equalities (mostly via `ite`) that relate the current values of the variables to the appropriate versioned copies depending on which write‑mode flag is true, and it adds arithmetic ordering constraints such as `bvsge` and `bvsle` on those values.  \nOutside the quantifier the benchmark adds a collection of “disjointness” constraints (e.g. DISJ_W_S1_R_S2, DISJ_W_S1_W_S2, DISJ_W_S2_R_S1) that enforce that reads and writes to the same variable are mutually exclusive, together with a few simple Boolean consistency clauses (e.g. `not (W_S1_V5 ∧ R_S2_V5)` etc.).  \nThus the whole instance checks whether there exists a consistent assignment to the Boolean mode selectors and the 32‑bit variables that satisfies the weakest‑precondition conditions of a compiler optimisation while respecting read‑write exclusivity.  \nThe problem is notable for its extreme nesting of `let`/`ite` expressions (85 ite, 74 let), a single massive `forall`, and a dense mixture of Boolean and bit‑vector reasoning, making it a characteristic “industrial” SAT/SMT challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/084.smt2",
    "description": "This benchmark is a bit‑vector (BV) problem generated by the PSyCO weakest‑precondition synthesis tool (pre‑2017 industrial suite) and encoded in the BV logic of SMT‑LIB 2.6.  It declares a family of Boolean flags R_*/W_* that model reads, writes and “must‑write” (MW_*) of several program variables (V1…V5) at three abstract locations (S1, S2, E1), and a single universally quantified formula that relates all concrete 32‑bit versions of those variables via a large network of ite‑expressions, equality constraints, and ordering constraints expressed with bvadd, bvneg, bvsle and bvsge.  On top of the quantified core, a set of Boolean “disjointness” constraints (DISJ_*) enforce that a location cannot be both read and written simultaneously unless the corresponding write flag is asserted, and additional clauses tie the MW_ flags to the plain write flags (e.g., (or (not MW_S2_V5) W_S2_V5)).  The final assertions negate several conjunctions of these DISJ_ and read/write literals, effectively asking whether a consistent assignment of reads, writes and ordering exists; the instance is therefore a correctness‑checking query for a compiler optimization.  It is unusually large (≈19 k characters, 32 Boolean constants, one quantified block, depth 165) and heavily uses let/ite, reflecting the automatic translation of a verification condition rather than a handcrafted benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/046.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, 19 kB, 32 declared Boolean/BitVec constants, 20 top‑level asserts) produced by the PSyCO weakest‑precondition synthesiser for compiler‑optimisation verification (VMCAI ’14); the original model was translated to bit‑vectors by Mathias Preiner.  \nIts core is a single quantified formula (∀ over 32 BitVec variables and a set of Boolean “write‑mask’’ flags MW_…) that expresses the semantic effect of a program fragment: the ite‑terms assemble the values of the program’s variables after a possible write in either source S1 or sink S2, while the embedded arithmetic constraints (`bvsle`, `bvsge`, `bvadd`) capture the required ordering and increment relations between the original and updated values.  \nAround this formula a large collection of auxiliary Boolean variables (e.g. DISJ_W_S2_R_E1, DISJ_W_S1_R_S2, …) encode mutual‑exclusion and “read‑after‑write’’ constraints between the reads (R_…) and writes (W_…) of the different program locations; these are linked by many equivalences and disjunctions that enforce consistency of the aliasing and memory‑access model.  \nThe final part of the script consists of a series of negative conjunctive assertions (e.g. `(assert (not (and DISJ_W_S2_R_S1 DISJ_W_S2_R_S2)))`) that forbid particular combinations of the disjointness predicates, thereby turning the whole set of constraints into a satisfiability‑checking problem for the existence of a valid assignment of reads, writes and values.  \nThus the benchmark asks whether there is a feasible way to assign the Boolean read/write flags and concrete 32‑bit values so that the weakest‑precondition conditions and all disjointness/ordering requirements hold simultaneously.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/008.smt2",
    "description": "**Instance overview.** The file is a 27 KB SMT‑LIB 2.6 benchmark in the **BV** logic, generated by the PSyCO weakest‑precondition synthesis tool (pre‑translation of a compiler‑optimization verification problem) and then translated to bit‑vectors by Mathias Preiner. It declares 37 Boolean constants that model “read” (`R_…`) and “write” (`W_…`) permissions for three abstract program locations S1, S2 and E1 at six version indices (V1–V6), together with a handful of auxiliary disjointness flags (`DISJ_…`).  \n\n**Main structure.** The first top‑level assertion is a single massive conjunction built from many nested `let`‑bindings; at its core it contains a **forall** quantifier over twelve 32‑bit variables representing the values of the program variables at each version, and a cascade of `ite`‑expressions that tie the current version of a variable to one of the concrete versioned copies depending on the Boolean write‑flags (`MW_S1_Vi`, `MW_S2_Vi`).These conditionals are then related by a large set of equality, ordering (`bvsle`, `bvsge`) and disequality constraints that encode the semantics of the program transformation (e.g., that a read must see the most recent write, that versions are monotonically increasing, and that unrelated writes are disjoint).  \n\n**Key constraints.** The benchmark checks three families of properties:  \n1. **Read‑write consistency** – every `R_S*_Vi` must be justified by a corresponding `W_S*_Vj` (encoded by the disjunctions `or $x… $x… $x…` and the `DISJ_…` flags).  \n2. **Version equality/disjointness** – numerous equalities such as `S1_V6_!1463 = S1_V6_!1438` enforce that different execution paths agree on the same value, while the `DISJ_…` Booleans assert that certain write sets are mutually exclusive.  \n3. **Numerical ordering** – the quantified part contains arithmetic constraints like `bvsle V2_0 E1_!1445` and `bvsge ?x1998 ?x2070` that capture the required ordering of variable values across versions.  \n\n**Notable characteristics.** Besides the single universal quantifier, the formula is dominated by a dense network of Boolean `let` bindings (548 occurrences) and a high degree of sharing, which makes the proof‑search highly combinatorial; nevertheless the overall logical shape is a pure SAT/UNSAT check (the second assertion simply demands `¬R_S1_V3 ∨ W_S1_V3`). The benchmark is classified as **industrial** and belongs to the *Preiner‑psyco* family, illustrating the kind of massive, bit‑vector‑heavy verification conditions that arise from automated weakest‑precondition synthesis for compiler optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/050.smt2",
    "description": "The file is a BV‑logic verification condition (logic BV, 32‑bit vectors) generated by the PSyCO weakest‑precondition synthesis tool for a compiler optimization; it is classified as an industrial example, contains 32 Boolean constants, a single universal quantifier and more than 20 k characters (≈ 4 KB, term depth 205).  The main structure consists of a large quantified formula ($x6721) that models the semantics of a small program in static‑single‑assignment form, using many ite‑expressions to describe conditional updates of the 32‑bit variables V1…V5 and the program counter E1.  Around this formula a collection of Boolean flags (R_* for reads, W_* for writes) and derived “DISJ_…” predicates enforce that reads and writes are mutually exclusive, that write–read pairs are disjoint, and that the ordering constraints (bvsle, bvsge) required by the weakest‑precondition hold.  The final three top‑level asserts negate three conjunctions of these DISJ predicates, effectively asking the solver to prove that the combination of read‑write conflicts and ordering constraints is unsatisfiable.  Consequently, the instance checks whether the candidate optimization preserves the program’s correctness under all possible choices of which writes actually occur.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/125.smt2",
    "description": "The file is a bit‑vector (BV) verification condition generated by the PSyCO weakest‑precondition synthesiser (see Lopes & Monteiro VMCAI’14) and translated to SMT‑LIB 2.6 by Mathias Preiner; it belongs to the industrial “Preiner‑psyco’’ benchmark suite (size ≈ 25 k characters, 26 Boolean constants, 1 quantified formula, max term depth 464).  \n\nIt models a small program that manipulates six 32‑bit variables V1…V6 at three program points (E1, E2, S1) and introduces Boolean flags R_* (reads) and W_* (writes) for each variable at each point.  \n\nThe core of the instance is a single ∀‑quantified block that describes the semantics of the transformed program: the original values (V2_0,…,V6_0) may be overwritten depending on the “maybe‑write’’ flags MW_S1_*, and the resulting values are related by ite‑expressions, bvadd, bvneg and signed‑order constraints (bvsle/bvsge).  \n\nSurrounding this are many Boolean clauses that encode three disjointness properties — DISJ_W_S1_R_S1, DISJ_W_S1_R_E1 and DISJ_W_S1_R_E2 — stating that the write set of the optimized code (S1) must not intersect the read sets of the original code (S1, E1, E2).  \n\nThe final assertion forces ¬DISJ_W_S1_R_S1, so the solver is asked to produce a concrete assignment (including concrete 32‑bit values) that violates the disjointness, i.e., a potential correctness bug in the compiler optimization.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/035.smt2",
    "description": "**The file is a Bit‑Vector (BV) benchmark (`set‑logic BV`) of medium size (≈ 17 k characters, 32 Boolean constants, one quantifier, 9 top‑level asserts) that was automatically generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation case study (VMCAI ’14) and then translated to BV by Mathias Preiner.**  \n\nIt models two “threads” (or program fragments) S1 and S2 together with an “environment” E1, each accessing five scalar variables V1…V5; the Boolean symbols `R_*` and `W_*` denote read‑ and write‑permissions, while the `MW_*` flags indicate whether a particular write is *may‑write* in the corresponding fragment.  \n\nThe big quantified conjunct encodes the weakest‑precondition semantics: for every concrete 32‑bit value of the variables and for every combination of may‑write flags it forces equality between the “old” and “new” values of each V‑slot (using nested `ite`s), and it adds arithmetic ordering constraints (`bvsle`, `bvsge`, `bvadd 1`) that capture the intended data‑flow and loop‑counter relationships of the original program.  \n\nA second layer of Boolean constraints introduces the *disjointness* predicates (`DISJ_W_S*_R_*`) that require reads and writes of the same location to be mutually exclusive, and the final series of `assert (not …)` statements tries to falsify several combinations of these disjointness conditions together with the main semantic clause.  \n\nThus the overall problem asks whether the weakest‑precondition and disjointness requirements can be satisfied simultaneously; the instance is used as an industrial‑style SAT/SMT challenge for solvers handling deeply nested ite‑terms, mixed arithmetic, and a large number of auxiliary Boolean variables.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/058.smt2",
    "description": "The file is a quantifier‑free BV (bit‑vector) benchmark (logic BV) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation verification task; it belongs to the “Preiner‑psyco” industrial family and contains about 22 k characters, 32 Boolean constants, 12 top‑level assertions and a maximum term depth of 205.  The model describes a small program fragment with three abstract locations (E1, S1, S2) and five integer‑typed variables V1…V5, where Boolean atoms such as R_S1_V3 and W_S2_V5 encode reads and writes to those variables and “MW_…​” flags select which version of a variable (old or newly written) is observed.  A large universally‑quantified formula ($x6721) captures the semantics of the statements: it equates the values selected by the write‑flags to the corresponding bit‑vector terms, enforces ordering constraints (e.g., “bvsle”, “bvsge”), and ties reads to the most recent write via a set of ite‑expressions.  The surrounding Boolean constraints introduce the disjointness predicates (DISJ_…) that require reads and writes to be mutually exclusive or appropriately ordered, and the final asserts negate several of these disjunctions, asking the solver to find a state that violates the intended consistency.  In effect, the instance checks whether the synthesized weakest precondition for the optimisation is strong enough to rule out any illegal interleaving of reads and writes; a UNSAT result would certify the transformation as safe.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/148.smt2",
    "description": "The file is a **BV** (32‑bit bit‑vector) benchmark generated by the **PSyCO** weakest‑precondition synthesis tool (pre‑processing of a compiler‑optimisation proof) and belongs to the *industrial* Preiner‑psyco family (≈7 k characters, 14 Boolean/bit‑vector constants, one top‑level ∀‑quantifier and a depth of 77).  \nIts core models two program states, **S1** (the original) and **E1** (the optimized version), using Boolean flags such as `W_S1_Vi`, `R_S1_Vi`, `R_E1_Vi` to denote whether a variable *i* is written or read, and a large conjunction of conditional equalities (`ite …`) that relate the values of the 32‑bit variables `V1`, `V2`, `V3`, `V4` before and after the transformation.  \nThe benchmark checks three properties: (1) the *disjointness* of write‑sets and read‑sets (`DISJ_W_S1_R_S1`, `DISJ_W_S1_R_E1`), (2) that the transformed values satisfy the weakest‑precondition constraints encoded by the quantified formula `$x1318`, and (3) a set of consistency clauses linking the Boolean flags to the actual value equations.  \nAdditional assertions force the disjointness predicates to be contradictory, thereby turning the whole problem into a satisfiability check that determines whether the proposed optimisation can obey all the weakest‑precondition and read/write constraints.  \nOverall, the instance is a typical industrial verification benchmark with a heavily nested let‑/ite structure, a single quantified block, and numerous Boolean “guard” variables that make it challenging for SAT/SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/110.smt2",
    "description": "This benchmark is a single‑query SMT‑LIB 2.6 file in the **BV** logic (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation verification task (see Lopes & Monteiro VMCAI 2014).  It declares 27 Boolean flags that model whether particular variables (V1…V6) are **written** (W_…) or **read** (R_…) in three program fragments – the original program (S1), and two transformed versions (E1 and E2) – and a single universally‑quantified formula that relates the symbolic values of the variables before and after each fragment using a large collection of `ite`, `bvadd`, `bvsle`/`bvsge` constraints.  The core of the formula enforces the weakest‑precondition relations (e.g., that a read must see the most recent write, that incremented values line up across versions) and adds *disjointness* conditions (`DISJ_W_S1_R_*`) expressing that a write in S1 cannot simultaneously be a read in the same or transformed fragment unless the corresponding Boolean flag is true.  The outer part of the file builds Boolean expressions (`$x66`, `$x68`, `DISJ_W_S1_R_E*`, etc.) that capture the overall consistency of the read/write flags and the mutual exclusion constraints, and finally asserts the conjunction of all these constraints.  The solver is asked to check satisfiability, i.e., whether there exists an assignment to the Boolean flags and the 32‑bit variables that satisfies the weakest‑precondition verification condition for the given optimisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/064.smt2",
    "description": "The file is a **BV‑logic** benchmark (32‑bit bit‑vectors together with Booleans) originating from the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro VMCAI 2014) and later translated by Mathias Preiner; it belongs to the industrial “Preiner‑psyco” family and contains 8 075 characters, 32 declared constants and 2 top‑level assertions.  \n\nThe first assertion introduces a single *forall* that quantifies over the program’s input variables (V1…V5) and auxiliary Booleans (MW_*) and encodes the operational semantics of a small three‑statement fragment (S1, S2, E1) as a conjunction of equality and signed‑order constraints on the 32‑bit values (using =, bvadd, bvsge, bvsle, ite).  Around this core are many Boolean “weak‑precondition” atoms (W_…) and “relation” atoms (R_…) together with *disjointness* clauses (DISJ_…) that demand that a weak‑precondition and a corresponding relation cannot hold simultaneously.  \n\nThe second top‑level assertion simply checks that the conjunction “¬W_S1_V2 ∧ DISJ_W_S1_R_E1” is *not* satisfiable, i.e. it forces either the weak‑precondition W_S1_V2 to be true or the disjointness predicate to fail.  \n\nThus the benchmark tests a solver’s ability to handle a deep quantified BV formula combined with a large Boolean “conflict‑graph” of mutually exclusive predicates, typical of verification conditions generated from compiler optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/113.smt2",
    "description": "The file is a 11 KB BV‑logic benchmark (logic BV, 27 Boolean constants, 24 32‑bit vectors, one universal quantifier) that was automatically generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimization verification task (VMCAI ’14).  The core of the problem is a single ∀‑formula that encodes the relational semantics of a small program fragment: Boolean flags W_* and R_* indicate whether a variable is written or read, while the indexed bit‑vectors model the concrete values of the program’s variables before and after each of several program points (E1, E2, S1).  Inside the quantifier the constraints enforce that, for every possible initial valuation, the written values propagate correctly (using many ite‑expressions) and that the arithmetic ordering relations (bvsle/bvsge) required by the original program’s control‑flow are respected.  Two auxiliary Boolean variables (DISJ_W_S1_R_E1, DISJ_W_S1_R_E2, DISJ_W_S1_R_S1) capture the required disjointness between write and read sets, and the outer assertions ask the solver to find a model where certain writes are absent yet the disjointness conditions still hold.  The benchmark is notable for its dense use of ite, bvadd/bvneg and relational operators, a deep term nesting (depth ≈ 60), and the mixture of quantified and ground constraints that stem from a weakest‑precondition synthesis encoding of an industrial‐strength program transformation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/070.smt2",
    "description": "The file is a bit‑vector (BV) benchmark in SMT‑LIB 2.6 generated by the PSyCO weakest‑precondition synthesis tool (pre‑processed by Mathias Preiner) and classified as an industrial case (family Preiner‑psyco, 10 KB, 32 bit‑vectors, 32 Boolean constants).  The core of the problem is a single universally quantified formula that models two successive program states S1 and S2 together with an expression E1; the quantified variables are the four 32‑bit values `V2_0 … V5_0` and a collection of Boolean “write‑mask’’ flags (`MW_S1_*`, `MW_S2_*`) that choose between the old value, a new SSA value, or the original input.  Around this core a large collection of Boolean predicates (`R_*`, `W_*`, `DISJ_*`) encode read/write permissions, disjointness of writes, and consistency of the SSA equations, while additional top‑level assertions force specific combinations of these flags (e.g., a write to S2 V2 must be disjoint from reads of E1, and certain writes must not occur simultaneously).  The benchmark therefore checks whether there exists a selection of the write‑mask booleans and concrete 32‑bit values that satisfy all ordering, equality, and exclusivity constraints; the final `check-sat` asks if the encoded weakest‑precondition can be realized.  Notable features are the heavy use of nested `ite`s, a deep term depth (85), and a dense mix of arithmetic (`bvadd`, `bvneg`, signed comparisons) with propositional reasoning, which makes the instance challenging for solvers that must combine bit‑vector reasoning with extensive Boolean reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/083.smt2",
    "description": "This benchmark is a **BV‑logic** instance (32‑bit bit‑vectors) generated by the **PSyCO** weakest‑precondition synthesis tool for a compiler‑optimisation verification task (see Lopes & Monteiro, VMCAI ’14).  It contains 32 Boolean constants that model reads (`R_…`) and writes (`W_…`) of five program variables (V1–V5) in three abstract states (E1, S1, S2), together with Boolean “mode” flags (`MW_…`) that indicate whether a particular write is selected in a transformation.  \n\nThe heart of the formula is a single **forall‑quantified** clause (`$x3432`) that expresses the relational semantics of the transformation: the values of the variables after the transformation must either equal the original values or be the result of a permitted write, and the increment of the “E1” variable must be respected (via `bvadd`).  Around this core, a large collection of **disjointness constraints** (`DISJ_…`) forces mutually exclusive combinations of reads and writes (e.g., a variable cannot be both read and written simultaneously), and the final assertions negate several conjunctions of those constraints to ask whether a contradictory schedule exists.  \n\nThe instance is **industrial‑style** (size ≈ 19 k characters, 13 top‑level asserts, 32 declared constants, max term depth 165) and is meant to check the **satisfiability of the weak‑precondition plus the exclusive‑access properties**, i.e., whether the intended optimisation can be applied without violating the program’s correctness conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/041.smt2",
    "description": "The file is a BV‑logic benchmark (SMT‑LIB 2.6, logic BV) generated by the PSyCO weakest‑precondition synthesis tool for a compiler‑optimisation verification task; it contains 32 Boolean/Bit‑Vector constants, a single quantified formula, and 15 top‑level assertions (≈18 KB, max term depth 170).  \nThe quantified part (\\$x3462) describes a relational semantics of two program versions S1 and S2, using Boolean “memory‑write” switches (MW_…).  Each version’s variables (V1…V5, E1, etc.) are tied together by a cascade of `ite`‑expressions that model the effect of optional stores and the corresponding value‑propagation across the two versions.  \nA second layer of Boolean flags (R_*, W_*) records which variables are read or written, and the auxiliary predicates DISJ_… express the required disjointness between reads and writes of the two versions (e.g., DISJ_W_S2_R_S1 ≡ ¬(∃ write in S2 ∧ read in S1)).  \nThe remaining top‑level assertions are a collection of “mutual‑exclusion” constraints that forbid illegal combinations of the read/write flags and the DISJ predicates, together with a final `check‑sat` that asks whether the whole verification condition is consistent.  \nThus the benchmark encodes the correctness condition of a transformation (that the two versions produce the same observable results) and checks that no contradictory read/write/ordering scenario can arise.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/126.smt2",
    "description": "**Overview**  \nThe file is a single‑query BV problem (logic BV) generated by the PSyCO weakest‑precondition synthesiser (PSyCO 0.1, VMCAI ’14) and translated to bit‑vectors by Mathias Preiner. It belongs to the “industrial” benchmark family *Preiner‑psyco* and is relatively large (≈ 18 k characters, 26 Boolean constants, a quantified formula with depth 87 and many nested *ite*, *or* and *and*).  \n\n**What is being modelled**  \nThe instance encodes a verification condition for a compiler optimisation that introduces a new “shadow” state S₁ while preserving the behaviour of two original program fragments E₁ and E₂. Boolean flags such as `R_E1_Vi`, `R_E2_Vi`, `W_S1_Vi` and `DISJ_W_S1_R_*` denote, respectively, reads of variable i in the original code, writes of variable i in the shadow code, and the required disjointness between the write‑set of S₁ and the read‑sets of the other fragments.  \n\n**Core constraints**  \nA single `forall` quantifier ranges over the concrete values of the program variables (32‑bit BitVecs V2, V4, V5, V6) and over the “memory‑write” control bits `MW_S1_Vi`. Inside the quantifier a large conjunction enforces:  \n\n* equality of the values before and after the transformation for variables that are not modified,  \n* signed ordering relations (`bvsge`, `bvsle`) that capture the monotonicity of pointer arithmetic,  \n* consistency of the “new” values (`S1_Vi_!…`) with the original ones (`E1_!…`, `E2_!…`) depending on the `MW_S1_Vi` flags,  \n* and finally a clause that asserts the three disjointness properties (`DISJ_W_S1_R_S1`, `DISJ_W_S1_R_E1`, `DISJ_W_S1_R_E2`) hold.  \n\n**Goal of the check**  \nAfter the massive assertion the script adds the contradictory unit constraints `(not DISJ_W_S1_R_S1)` and `W_S1_V1`, then asks the solver to `check-sat`. Thus the query asks whether there exists a program state and a selection of the Boolean flags where the write‑set of S₁ is **not** disjoint from its own read‑set while still satisfying the whole weakest‑precondition formula. In other words, it searches for a counter‑example to the disjoint‑write/read safety condition of the optimisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/101.smt2",
    "description": "The file is a bit‑vector (BV) SMT‑LIB 2.6 benchmark (logic BV, 22 903 characters, 32 Boolean constants and a single universal quantifier) generated by the PSyCO weakest‑precondition synthesis tool for compiler‑optimisation verification.  It models a small program fragment (named E1) and two transformed versions (states S1 and S2) by introducing Boolean flags for each possible read (R_…) and write (W_…) of five abstract variables (V1…V5) together with “disjointness” Boolean atoms (DISJ_…) that enforce that a location is written at most once and that reads are either satisfied by a write or by the original value.  The quantified core defines, with a cascade of nested ite‑expressions, the value of every variable after a write may be taken either from the original version, from a write in S1, or from a write in S2, and it adds ordering constraints expressed with 32‑bit arithmetic (e.g. bvadd 1, bvsle, bvsge) to capture the required monotonicity of version counters.  The surrounding non‑quantified assertions combine the DISJ_ atoms with the write‑read flags to express coherence (e.g. (¬R_S2_V4) ∨ … ) and to forbid illegal combinations such as simultaneous writes to the same location, while a final `assert (not $x3927)` forces the solver to check the unsatisfiability of a particular conjunction of these conditions.  In short, the instance encodes the verification condition that the transformed programs S1 and S2 preserve the semantics of E1 under a weak memory model, and it is used as an industrial‑scale benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/190.smt2",
    "description": "**Instance summary** – The file is a BV‑logic benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesis tool for compiler optimizations (see Lopes & Monteiro, VMCAI ’14). It contains 25 Boolean constants (write‑ and read‑flags such as W_S1_V3, R_E1_V5) and 32‑bit bit‑vector variables that model the concrete values of program variables at several program points (V1…V5, S1_Vi, S2_Vi, E1_!…).\n\n**Main modelling pattern** – A single universally‑quantified block enumerates fresh 32‑bit vectors for every original and transformed variable, and then uses a cascade of `ite` expressions whose conditions are the Boolean flags to relate each “new” version to either the previous version, a constant increment, or the original value. The Boolean part of the formula (the many `or`/`and`/`not` clauses) constrains which combination of reads and writes may be selected for each variable and enforces consistency between the two program versions (S1 and S2) and the original program (E1).\n\n**Key constraints** – The assertions require that at least one write flag for each program location is true (e.g. `not (and (not W_S2_V2) (not W_S2_V4) …)`), that a write cannot be simultaneously absent and read‑only (`not (and $x1088 $x1094 $x8825 …)`), and that the chosen write/reads respect the intended data‑flow ordering (e.g. the `bvsle`/`bvsge` comparisons on the `ite`‑generated values). Together they encode the correctness condition that the transformed program preserves the weakest precondition of the original.\n\n**Notable characteristics** – The benchmark is relatively large for a pure‑BV problem (≈ 25 KB, 57 top‑level asserts, 433 occurrences of `not`, nesting depth 147) and mixes a huge Boolean “control” formula with a modest amount of arithmetic on 32‑bit vectors. Its structure is typical of industrial verification tasks that stem from program‑transformation tools: a massive Boolean decision diagram gating many small ite‑based data‑flow equations. The final `(check‑sat)` asks whether there exists a consistent selection of write/read flags and concrete values that satisfies all the weakest‑precondition constraints, i.e. whether the candidate optimization is semantically valid.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/182.smt2",
    "description": "**Description**  \nThis instance is a BV‑logic benchmark (SMT‑LIB 2.6, category *industrial*, family *Preiner‑psyco*) generated by the PSyCO weakest‑precondition synthesis tool (PSyCO 0.1) and translated to bit‑vectors of size 32.  It declares a small set of Boolean flags \\(W\\_S1\\_V*\\) (write permissions), \\(R\\_S1\\_V*\\) (read permissions) and a disjointness flag \\(DISJ\\_W\\_S1\\_R\\_S1\\); the top‑level assertion forces \\(W\\_S1\\_V6\\) to be true and requires that the read/write selection is mutually exclusive (the formula \\(DISJ\\_W\\_S1\\_R\\_S1\\) is the negation of a disjunction of read/write combinations).  \n\nThe core of the problem is a single quantified formula \\(\\forall\\) over 12 concrete 32‑bit variables (\\(V1\\_0,\\dots ,V7\\_0\\)) and a collection of auxiliary “snapshot” variables (e.g., \\(S1\\_V1\\_!77\\)).  Within the quantifier the model uses many nested \\(\\text{ite}\\) terms indexed by Boolean control flags \\(MW\\_S1\\_V*\\) to represent optional updates of program variables, and it builds arithmetic relations such as \\(V3 = V1\\cdot V4 + V4\\) and various bounds (e.g., \\(V2 > V1\\)).  \n\nKey constraints are: (1) consistency equations that tie each “new” version of a variable to either the old version or an incremented/modified version depending on the \\(MW\\) flags; (2) relational conditions expressing ordering and arithmetic properties (e.g., \\(V2_0 \\not\\le V1_0\\) and a signed‑greater‑or‑equal comparison involving increments); (3) a large conjunction of equivalences/implications linking the read/write Boolean flags with the corresponding \\(MW\\) updates, ensuring that whenever a variable is read its value matches the appropriate snapshot.  \n\nOverall the formula checks whether there exists a selection of write flags (with \\(W\\_S1\\_V6\\) true) and a consistent assignment to all bit‑vector variables that satisfies the program‑style update semantics and the disjointness condition; the single‑assertion result is therefore a SAT/UNSAT query about the feasibility of this weakest‑precondition invariant.  \n\nNotably, the benchmark contains a deep term structure (max depth 30), a single universal quantifier with many nested `let` bindings, and a high proportion of Boolean combinators (`or`, `and`, `ite`), making it a typical challenging case for solvers handling quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/154.smt2",
    "description": "The file is a bit‑vector (BV) benchmark generated by the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro, VMCAI ’14) and translated to pure BV by Mathias Preiner; it belongs to the “industrial” Preiner‑psyco family and contains 6 423 characters, 2 top‑level asserts, 9 declared constants and a quantifier depth of 1.  \nThe core of the problem is a single universally quantified condition (named $x18341$) that relates six 32‑bit variables V1,…,V6 and an auxiliary 32‑bit V4 with a set of “write‑model” Booleans MW_S1_V* and “memory‑state” values S1_V*_!… through many ite‑expressions.  Inside the quantifier the formula enforces a lattice of equalities (e.g., “if MW_S1_V6 then the new value of V6 must equal S1_V6_!1403”) together with signed range constraints (bvsge / bvsle) that capture the semantics of a compiler optimisation (loop‑bound checks, array‑index safety, etc.).  \nOutside the quantifier the benchmark introduces Boolean flags W_S1_V* (writes) and R_S1_V* (reads) and defines a predicate DISJ_W_S1_R_S1 as the negation of a disjunction of admissible write/read combinations; the final assertion forces ¬DISJ_W_S1_R_S1, i.e., it asks whether the write/read flags can violate the intended disjointness while still satisfying all the quantified safety constraints.  \nThus the SAT query checks the existence of a concrete assignment to the 32‑bit variables and the Boolean flags that both respects the weakest‑precondition of the optimisation and falsifies the disjoint‑write/read property, effectively testing the correctness of the synthesized precondition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/040.smt2",
    "description": "The file is a BV‑logic benchmark generated by the PSyCO weakest‑precondition synthesiser (the “psyco” family) and translated to bit‑vectors by Mathias Preiner; it belongs to the industrial category and contains about 18 kB, 32 Boolean constants and a single universal quantifier.  \nIt models a small shared‑memory program with three abstract locations (E1, S1, S2) each having five versioned values (V1‑V5); the Boolean symbols R_* and W_* represent reads and writes, while the auxiliary MW_* flags select, via nested ite expressions, which concrete 32‑bit value (or its successor) is observed after a write.  \nThe core formula (\\$x3462) encodes the weakest‑precondition relationships between the original values (V*), the updated values (E1_!, S1_!, S2_!), and the ordering constraints expressed with signed‑less‑or‑equal/greater‑or‑equal and bvadd/bvneg operations.  \nA collection of “DISJ_” predicates enforces mutual exclusion between reads and writes of different threads (e.g., DISJ_W_S2_R_S1 means a write in S2 must be disjoint from a read in S1), and the final assertions are negated conjunctions of these disjointness conditions, thus asking whether any illegal interleaving can satisfy all the memory‑consistency constraints.  \nIn short, the instance checks the satisfiability of a memory‑model consistency problem for a compiler optimisation, where unsat would certify that the optimisation preserves the program’s weakest precondition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/174.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** logic (32‑bit bit‑vectors) generated by the PSyCO weakest‑precondition synthesis tool (pre‑processor “Preiner‑psyco”). It contains 25 Boolean constants that encode the presence or absence of writes (*W\\_S*_V*) and reads (*R\\_S*_V*) to five program variables in two program states (S1 and S2), together with Boolean “disjointness” flags (e.g., DISJ\\_W\\_S1\\_R\\_S2). The heart of the model is a single quantified assertion (`forall …`) that relates the concrete 32‑bit values before and after the transformation using a cascade of `ite` expressions; this encodes the weakest‑precondition conditions and the required ordering relations (such as `bvsge` and `bvsle`) for the optimization to be correct. Around the quantified core the benchmark adds several conjunctive constraints that enforce consistency between the Boolean read/write flags and the disjointness predicates, and finally asserts the negation of a combination of three of those predicates, together with a trivial “both W\\_S2\\_V1 and W\\_S2\\_V2 are false” clause, to ask whether the whole specification is satisfiable. The instance is relatively large (≈10 k characters, max term depth 55) and contains one quantifier, many nested `let`‑bindings, and a heavy use of `ite`, reflecting an industrial‑scale verification problem stemming from compiler optimisation validation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/076.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV) generated by the PSyCO weakest‑precondition synthesis tool and translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” Preiner‑psyco family (BV/2017‑Preiner‑psyco/076.smt2) and contains 32 Boolean constants, a single quantified ∀‑formula over four 32‑bit vectors and a dozen Boolean flags, and six top‑level assertions (the main one plus four negated conjuncts).  \n\nThe quantified part encodes a memory‑model style relational specification for five variables (V1…V5) together with Boolean “write‑mask’’ flags (MW\\_S1\\_V*, MW\\_S2\\_V*) and a large collection of equalities that relate the original values to “written’’ versions selected by the masks, using many ite‑expressions and let‑bindings.  \n\nThe remaining assertions describe a set of disjointness and consistency conditions between reads (R\\_*) and writes (W\\_*) of two simulated states S1 and S2 (e.g., DISJ\\_W\\_S2\\_R\\_S1, DISJ\\_W\\_S1\\_R\\_E1, etc.), as well as ordering constraints expressed with signed‑comparison and bvadd/bvneg operations.  \n\nThe final four asserts are negated conjunctions that force contradictions among these disjointness predicates (e.g., ¬(DISJ\\_W\\_S2\\_R\\_S1 ∧ DISJ\\_W\\_S2\\_R\\_S2), ¬(¬W\\_S2\\_V2 ∧ DISJ\\_W\\_S2\\_R\\_S2), …), so the solver is asked to check whether the whole specification is satisfiable under those contradictory requirements.  \n\nOverall the benchmark tests a solver’s ability to handle deeply nested let/ite structures, a large quantified “execution‑graph’’ formula, and numerous Boolean‑logic disjointness constraints typical of compiler‑optimization verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/117.smt2",
    "description": "**This benchmark encodes a verification condition generated by the PSyCO tool for weakest‑precondition synthesis of a compiler optimisation.**  \nIt works in the quantifier‑free bit‑vector logic (BV, 32‑bit integers) and declares Boolean flags for “write” (`W_S1_*`) and “read” (`R_*`) of six program variables together with auxiliary control flags (`MW_S1_*`).  \nA single quantified formula (`$x62538`) describes the effect of a conditional update step: each variable may be left unchanged or replaced by a new value (`S1_…`) depending on the `MW_S1_*` flags, and it enforces ordering constraints (`bvsle`, `bvsge`) and consistency equalities between the old and new values.  \nAdditional Boolean constraints (`DISJ_W_S1_R_E1`, `DISJ_W_S1_R_E2`, `DISJ_W_S1_R_S1`) express that the sets of variables that are written and read must be disjoint, and the final eight top‑level assertions assert the negation of several admissible combinations of these flags, thereby looking for a counter‑example to the intended disjointness/property.  \nThe solver is thus asked whether there exists a selection of write/read flags that violates the weakest‑precondition specification; the instance is a typical “industrial” verification problem of size ≈ 12 kB with 27 Boolean constants and a single ∀‑quantifier.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/077.smt2",
    "description": "**Overview.** This instance is a BV‑logic benchmark (SMT‑LIB 2.6) generated by the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro, VMCAI’14) and then hand‑translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” family *Preiner‑psyco* and contains roughly 18 k characters, 32 Boolean constants, a single 32‑bit‑quantified formula and seven top‑level assertions.  \n\n**Core encoding.** The heart of the problem is a single `forall` over 32‑bit variables (V1 … V5) and a collection of Boolean “memory‑write” flags (`MW_S1_Vi`, `MW_S2_Vi`) that model the effect of possible stores to two abstract stores S1 and S2; the body consists of a dense network of `ite`‑expressions that equate the resulting values of the stores with the original variables, together with a suite of ordering constraints expressed with signed‑inequality (`bvsle`, `bvsge`) and `bvadd`.  \n\n**Read/write discipline.** Around the quantified block the file declares a set of Boolean read‑flags (`R_*`) and write‑flags (`W_*`) for each variable and each store, and defines several “disjointness” predicates (`DISJ_W_S*_R_*`, `DISJ_W_S1_W_S2`) that capture the intended mutual exclusion between reads and writes (e.g., a variable cannot be both read and written simultaneously, and certain writes must be exclusive).  \n\n**Top‑level checks.** The final seven asserts are all negated conjunctions of combinations of these disjointness predicates and write/read flags; together they force the solver to look for a model that simultaneously violates the intended exclusivity conditions, which is precisely the sanity check used by the original PSyCO verification task.  \n\n**Notable characteristics.** The formula is unusually deep (max term depth 165) and extremely rich in `let`‑bindings (173 occurrences) and `ite`s (103), reflecting a systematic translation of a program‑verification condition rather than a handcrafted benchmark, and it typically challenges solvers on both bit‑vector arithmetic and large Boolean combination handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/033.smt2",
    "description": "The file is a bit‑vector (BV) benchmark generated by the PSyCO weakest‑precondition synthesis tool (pre‑processor of a compiler‑optimization verification task) and translated to the BV logic by Mathias Preiner.  It declares a handful of Boolean flags that model reads ( R_* ) and writes ( W_* ) of several program variables (V1…V5) in two program states (S1 and S2) together with auxiliary “must‑write” flags ( MW_* ) and a universal quantifier that relates the original values (V?_0) to their updated values after a sequence of assignments expressed with nested ite and bvadd operations.  The core of the formula encodes the functional correctness conditions of the optimisation (equality of corresponding variables when the appropriate read/write flags hold) together with a large set of disjointness and exclusivity constraints (the DISJ_* booleans) that require the write‑sets of the two versions to be non‑overlapping and the reads to be consistent.  A handful of additional top‑level assertions negate combinations of these disjointness conditions, so the final check‑sat asks whether the optimisation can violate the required independence properties.  The instance is relatively large (≈ 17 k characters, 32 declared constants, a quantified formula of depth ≈ 170) and belongs to the “industrial” Preiner‑psyco family of verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/095.smt2",
    "description": "The file is a **BV‑logic** benchmark (bit‑vectors of size 32) generated by the **PSyCO** weakest‑precondition tool for compiler‑optimization verification; it belongs to the *industrial* “Preiner‑psyco” family and contains 32 Boolean constants, a single quantified formula over 16 bit‑vector variables and more than 21 k symbols (about 1 900 nested `let`s, 176 disjunctions and 172 equalities).\n\nThe model describes two program statements **S1** and **S2** and an expression **E1**, each of which may read (`R_…`) or write (`W_…`) the four scalar variables V1–V5.  The Boolean symbols `MW_S1_Vi`/`MW_S2_Vi` select between the “old” value of a variable and a fresh symbolic value, while the series of `ite`‑terms inside the quantified assertion encode the value propagated to each read after a possible write.\n\nA large set of auxiliary predicates `DISJ_…` expresses *disjointness* (no simultaneous read/write of the same location) and *ordering* relations (e.g., `bvsle`/`bvadd` 1) between the reads and writes of the two statements and the expression.  The top‑level conjuncts also require that the values observed by reads are equal when the corresponding write is performed, and that certain write‑read pairs cannot both be true.\n\nFinally, three extra assertions negate conjunctions of the disjointness predicates (`DISJ_W_S2_R_S1`, `DISJ_W_S1_R_S2`, etc.), so the SAT check asks whether there exists an assignment to the Boolean control variables and the bit‑vector values that violates the intended alias‑freedom/property.  In other words, the instance tests whether the synthesized weakest precondition for the optimization is *unsound* (a counterexample exists).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/150.smt2",
    "description": "The file is a BV‑logic benchmark (bit‑vectors of size 32) generated by the PSyCO weakest‑precondition synthesis tool (see Lopes & Monteiro VMCAI’14) and translated to bit‑vectors by Mathias Preiner; it belongs to the “industrial” Preiner‑psyco family and contains about 12 k characters, 14 Boolean constants and a single universally‑quantified formula.  \nThe quantified part encodes a program fragment **S1** and an environment **E1**: for each program variable V1…V4 it introduces fresh 32‑bit copies (e.g. V3_0, V2_0) together with “write‑mask’’ Booleans (MW_S1_Vi) that select either the original value or a transformed value (S1_Vi_!… ).  The formula then builds a large conjunction of equalities, order constraints (bvsle/bvsge) and consistency conditions (ite‑based definitions) that must hold for every choice of the input vectors.  \nOn top of the quantified core the benchmark adds Boolean control flags (W_S1_Vi, R_E1_Vi, R_S1_Vi) and two disjointness constraints **DISJ_W_S1_R_E1** and **DISJ_W_S1_R_S1**, which express that a variable cannot be simultaneously written by S1 and read by E1 (or by S1 itself).  These are combined with further simple clauses (e.g. R_S1_V1 is asserted true) and a final big disjunction/conjunction that ties all flags together.  \nThe instance is therefore a classic verification‑condition check: does there exist an assignment to the write‑mask and flag Booleans such that the weakest‑precondition of the optimized code (S1) is compatible with the original semantics (E1) while respecting read/write disjointness?  The solver is asked simply to determine satisfiability of this condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-psyco/006.smt2",
    "description": "The file is a single‑query BV‑logic benchmark (12 371 characters, 37 Boolean constants, one quantified formula) produced by the PSyCO weakest‑precondition synthesiser for a compiler‑optimisation example and then translated to bit‑vectors.  \nIt models two program states S1 and S2 together with an expression E1; the Boolean variables `W_…` indicate whether a variable is taken from the “original” version, `R_…` whether it is read in the “reference” version, and the `DISJ_…` flags enforce that each pair of write/read choices is mutually exclusive.  \nThe massive quantified assertion encodes the functional correctness conditions of the optimisation: equalities between the original and transformed values, bit‑vector arithmetic on the variables (adds, negations, multiplication), and relational constraints such as `bvsge`/`bvsle` that capture the required ordering of values.  \nA second, much smaller assertion forces a particular combination of write‑flags (`W_S1_V4 ∧ W_S2_V5`) together with the disjointness clauses and then negates the whole conjunct, asking the solver to find a model that violates those conditions.  \nThus the benchmark checks whether there exists a selection of the `W_/R_` Boolean controls that satisfies all semantic equalities while also meeting (or contradicting) the specified write/read pattern, i.e., it is a correctness‑verification problem for the synthesized weakest precondition of the optimisation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/medium.smt2",
    "description": "This instance is a single‑assertion benchmark in the **BV** logic, generated by the PEak hardware‑rewrite‑rule synthesis tool for an industrial‑scale hardware verification task (see the source comment).  The formula quantifies over seven input signals (six 16‑bit data inputs, a Boolean clock‑enable, a Boolean condition flag, two 1‑bit inputs and a 30‑bit identifier) and then builds a massive concatenated bit‑vector that encodes a candidate instruction word together with its control‑field encodings (conditions, ALU opcode, mux selections, signedness bits, etc.).  Inside the quantified body the model extracts many sub‑fields (using `extract`) and applies a cascade of arithmetic and logical operations—adds, negations, signed/unsigned comparisons, shifts, multiplications and a large decision tree implemented with nested `ite`s—to compute the expected outputs of that instruction.  The outermost assertion equates the result of this computation with a hand‑crafted reference value and finally requires the whole universally quantified formula to hold, effectively checking that no assignment to the inputs can violate the encoded hardware rule (the benchmark is unsatisfiable).  Notable features are the extreme term depth (over 6 000), the heavy use of bit‑vector concatenation and extraction, and a very large number of `ite`, `zero_extend`, and comparison operators, making it a stress test for bit‑vector solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/easy.smt2",
    "description": "This SMT‑LIB file is a **BV‑logic** benchmark (logic = BV) drawn from the **PEak hardware rewrite‑rule synthesis** suite; it is labelled industrial, has about **65 KB of text**, declares **19 bit‑vector constants** (ranging from 1‑bit flags to 16‑bit data fields), and contains a single massive quantified assertion whose term‑depth exceeds **1 300**.  \n\nThe assertion builds, via a cascade of **let‑bindings**, a gigantic bit‑vector that concatenates the instruction‑encoding bits (condition fields, ALU opcode, multiplication flag, constant data, mux inputs/outputs, signedness bits, etc.) together with the six 16‑bit input operands, clock‑enable and a Boolean “data‑valid” flag.  From this packed word it extracts numerous sub‑fields (e.g., 16‑bit slices for arithmetic results, 4‑bit op‑codes, single‑bit control signals) and then applies an extensive suite of **bit‑vector arithmetic, logical, and comparison operators** (addition, subtraction, twos‑complement negation, signed/unsigned comparisons, shifts, multiplication, bitwise AND/OR/XOR/NOT, zero‑ and sign‑extensions).  \n\nThe core property being checked is that, for **all** possible input combinations, the computed result of the modeled ALU/mux network equals a particular 16‑bit pattern derived from the “data0” input, while simultaneously satisfying a set of **opcode‑specific constraints** on the 6‑bit identifier `ib_0` (e.g., requiring it to be one of the bit‑patterns 000100, 000001, 000010, 100000, 010000).  \n\nBecause the quantified body combines mutually exclusive opcode cases with contradictory equalities, the overall formula is **unsatisfiable**, which is reflected in the file’s placement in the “unsat_subset” directory.  The benchmark is notable for its **extremely deep nesting of let‑expressions** (over 1 300 let‑bindings) and a heavy use of extraction and concatenation, making it a challenging stress test for BV solvers’ term‑rewriting and quantifier‑instantiation heuristics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/easy.smt2",
    "description": "**What the file encodes** – The SMT‑LIB script is a bit‑vector model of a small datapath that a PEak rewrite‑rule synthesis tool generated for a hardware verification task. It lives in the **BV** logic, contains a single quantified assertion (a `forall` over 14 input bit‑vectors and a clock‑enable flag) and a large Boolean combination of extracts, concatenations, extensions, arithmetic, shifts and comparisons that model a mux tree, an ALU, signed/unsigned arithmetic, a multiplier, and a few control‑flag registers. The core property being checked is an **equality** between the circuit’s output bit `ob_0` (and a few other “wrapped‑if” flags) and a constant pattern built from the declared configuration bits (`|('inst', …)`), together with several range constraints such as `bvule … #b10010`.  \n\n**Why it matters** – The formula asks whether there exists any assignment to the 24 configuration constants that makes the datapath behave correctly for **all** possible 42‑bit input vectors (`ib_0`) and control signals; in other words, it is a synthesis/verification condition for a rewrite rule. The instance belongs to the **industrial / PEak** benchmark suite, is very large (≈ 0.5 M characters, 10202 `let` bindings, nesting depth > 10 000), and contains hundreds of `extract`, `ite`, and `concat` operations, which together make it a hard test for bit‑vector solvers.  \n\n**Result** – For this particular file the condition is **unsatisfiable** (no configuration can satisfy the universal property), which the benchmark name `extern-loop_unsat_subset/easy.smt2` also hints at. The file therefore serves as a stress‑test for solvers’ handling of deep quantifier‑instantiation and massive bit‑vector arithmetic.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy1.smt2",
    "description": "The file is a large (≈224 KB) quantifier‑free bit‑vector benchmark in the BV logic, generated by the PEak hardware‑rewrite‑rule synthesis project for the “easy1” instance of its SAT‑subset suite.  It declares 26 bit‑vector constants (mostly 1‑, 14‑, 16‑ and 32‑bit values) together with a single universally quantified assertion that builds a massive concatenated word representing the complete state of a datapath (including condition codes, multiplexers, LUTs, signed/unsigned flags and a small ALU).  Inside the assertion a cascade of nested ite, extract, concat, zero/sign‑extend, addition, multiplication, shifts and comparisons implements a symbolic execution of the datapath for any choice of the input vectors, and finally checks that a particular output slice equals a target constant and that several control bits (e.g., PE_wrapped_if_5, clk_en) satisfy required Boolean relations.  The benchmark therefore encodes a functional‑correctness verification problem for a handcrafted hardware unit, testing whether the circuit’s arithmetic‑logic and routing logic always produce the prescribed result.  Its notable characteristics are an extremely deep term structure (max depth 4676), thousands of ite/ extract/ let nodes, and a single massive forall‑quantified clause that forces the solver to reason about all possible input combinations.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_unsat_subset/hard.smt2",
    "description": "**What the file encodes** – This is a single‑assertion BV‑logic benchmark generated by the PEak hardware‑rewrite‑rule synthesis framework (the “hard” industrial category). The script uses the 2‑state bit‑vector logic (BV) and declares 25 constants (mostly 16‑, 32‑ and 64‑bit vectors and a few Booleans) that model the control bits, operands, and intermediate results of a small datapath (ALU, multipliers, condition codes, muxes, signed/unsigned flags, and constant data).  \n\n**Problem structure** – Inside the sole `assert` a massive quantified formula (`forall` over a handful of Boolean and 16‑bit inputs) builds a 144‑bit word by repeatedly `concat`‑ing the declared signals, then extracts overlapping fields (e.g., bits 0‑15, 16‑31, …) to emulate the wiring of arithmetic units, shifters, and comparators. Each extracted slice is fed to a cascade of bit‑vector operations (`bvadd`, `bvsub`, `bvneg`, `bvmul`, `bvnot`, `bvand`, `bvor`, `bvxor`, `bvlshr`, `bvashr`) together with relational checks (`bvule`, `bvsle`, `bvslt`, `bvult`) and conditional selections (`ite`).  \n\n**Key constraints** – The formula ends with a large conjunction that requires the final 16‑bit result to equal a concrete constant (`260`), that the 720‑bit input vector `ib_0` has a specific pattern, that a single‑bit output `ob_0` be true, and that several flag conditions (e.g., `clk_en`, `PE_wrapped_if`) hold. Effectively the benchmark asks whether there exists an assignment to the datapath inputs that satisfies all of these hardware‑level functional constraints.  \n\n**Notable characteristics** – The benchmark is extremely large (≈8.7 M characters, >158 k term depth) and heavily uses `let`, `extract`, `concat`, and `ite`, which makes it a stress test for solvers’ handling of deeply nested bit‑vector expressions and quantifiers. It is known to be unsatisfiable (the “unsat_subset” directory), so a solver must prove that no combination of inputs can meet the asserted condition. The file therefore serves as a difficult industrial case for BV‑solvers such as CVC4 or Z3.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium2.smt2",
    "description": "**What the file encodes**  \nThis benchmark is a bit‑vector (BV) instance generated by the PEak project for hardware rewrite‑rule synthesis.  It uses the SMT‑LIB 2.6 language, the BV logic, and contains a single quantified assertion (a `forall` over 16 + 8 + 2 + 1 + 1 + 1 + 5 + 4 + 4 + 5 + 5 Boolean‑valued inputs) whose body builds a 181‑bit word by repeatedly `concat`‑ing condition bits, ALU control fields, multiplexor selections, signed‑ness flags and constant data.  Inside the quantifier the model describes a datapath with a conditional ALU, a three‑way mux network, signed/unsigned arithmetic, and a scalar multiplier; the extracted sub‑words are then compared with concrete constants (e.g. checks that certain 5‑bit fields equal patterns such as 0010, 0011, … 1001) and ordered with `bvule`/`bvsle`.  The outermost conjunct also forces the 1‑bit signal `ob_5` to be true and fixes a large 420‑bit input vector `ib_5` to a specific binary pattern, thereby turning the quantified formula into a SAT‑check of whether the encoded hardware transformation can ever produce the prescribed output.  The instance is industrial‑scale (≈5.4 M characters, >1 M AST nodes, depth > 100 k) and stresses solvers with huge amounts of nested `ite`, `extract`, and arithmetic operators.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/easy4.smt2",
    "description": "**PEAK‑generated hardware verification condition (BV logic, 1.37 M‑character file).**  \nThe file declares a set of 26 constants (mostly 16‑bit data words, Bool flags and a few 84‑bit and 1‑bit ports) and then asserts a single quantified formula that is universally quantified over a large vector of symbolic inputs – several 16‑bit vectors, Boolean control signals, and configuration bits that model a small processor datapath (bit‑ALU, multiplexer tree, constant and LUT fields, signedness flags, etc.).  \nInside the quantifier the model is built with thousands of `let`‑bindings that repeatedly concatenate these fields, extract sub‑vectors, and apply arithmetic (`bvadd`, `bvmul`), logical (`bvand`, `bvor`, `bvxor`), shift (`bvshl`, `bvlshr`, `bvashr`) and comparison (`bvule`, `bvsle`, `bvslt`) operations, ending in a collection of equalities and ordering constraints that tie the output port `ob_6` and the internal “instruction” bits to the computed result of the datapath.  \nThe final conjunct enforces specific constant patterns on the 84‑bit input `ib_6` and the 1‑bit output `ob_6` together with several Boolean side‑conditions (`.def_48`, `.def_45`, `.def_43`, `.def_41`) which encode the applicability of a rewrite rule; the whole assertion is true iff the candidate hardware implementation is functionally equivalent to the reference for **all** possible input combinations.  \nBecause the formula was automatically generated, it exhibits an extreme term depth (27 537), more than 27 k `let`s, 6 k extracts, and 6 k `ite`s, a typical hallmark of industrial‑scale hardware rewrite‑rule synthesis problems.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/08.smt2",
    "description": "This SMT‑LIB file (logic **BV**, 2 613 bytes, 7 assertions) comes from the LLVM constant‑range verification suite (LLVM 13, “Verifying Optimizations using SMT Solvers”).  It models 16‑bit unsigned integers (`Integer`) and 32‑bit intervals (`Interval`) as a concatenation of a lower and an upper bound, and defines predicates for *full*, *empty* and *wrapped* intervals together with membership, size, and the unsigned‑max of two intervals (`umax`).  The core problem introduces three uninterpreted intervals `N1`, `N2` (both assumed **non‑wrapped**) and a result interval `R`, and asserts that `R` is **strictly smaller** than the interval obtained by `umax(N1,N2)`.  A single universally quantified condition then requires that for every pair of elements `n1∈N1` and `n2∈N2` the larger of the two (`umaxInt n1 n2`) must belong to `R`.  The solver is asked to check whether such a configuration can exist, i.e., whether the specification that `R` must contain all pairwise maxima can be violated by an interval smaller than the computed `umax`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/07.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition generated from LLVM’s `ConstantRange.cpp` (see N. P. Lopes, *Verifying Optimizations using SMT Solvers*, LLVM 2013) and follows the industrial category of the LLVM‑13 SMT‑LIB suite (file BV/llvm13‑smtlib/07.smt2, 2 645 characters, 7 assertions).  It models integer intervals as 64‑bit vectors where the high 32 bits are the lower bound **L** and the low 32 bits are the upper bound **H**, and defines predicates for empty, full, and wrapped (cyclic) intervals together with operations such as containment, size, and the unsigned‑max of two intervals (`umax`).  The core problem declares three interval variables `N1`, `N2` (both required to be non‑wrapped) and a result interval `R`, and asserts three conditions: (1) `R` must be strictly smaller than the supremum interval `umax(N1,N2)`, (2) every pair of elements `n1∈N1` and `n2∈N2` must have their unsigned maximum `max(n1,n2)` belong to `R`, and (3) any degenerate interval (where L = H) is forced to be either full or empty.  In essence, the solver is asked whether there exist non‑wrapped input ranges whose pointwise unsigned‑maximums can be captured by a strictly tighter interval than the naive union, a property that underlies correctness of LLVM’s constant‑range optimizations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/03.smt2",
    "description": "The file is a BV‑logic benchmark (SMT‑LIB 2.6) originating from LLVM’s ConstantRange verification suite (llvm13‑smtlib/03.smt2, 2 689 characters, 3 assertions, 15 user‑defined functions).  It models intervals over 8‑bit integers (`Integer`) and their 12‑bit signed extensions (`Integer2`) as 16‑bit and 24‑bit “Interval” bit‑vectors, providing auxiliary selectors (`L`, `H`, `L2`, `H2`) and predicates for emptiness, fullness, wrapping and sign‑wrapping.  The core property asserts that, for any concrete interval `N`, the size of a target interval `R` is strictly smaller than the size of the sign‑extended version of `N` (`signExtend N`), and that every element of `N` (interpreted unsigned) maps into `R` after a 4‑bit sign‑extension.  Supporting axioms guarantee that degenerate intervals are either full or empty and relate the “wrapped” cases to the usual containment semantics.  Thus the instance checks that the LLVM sign‑extension transformation preserves a strict bound on the reachable value set.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/05.smt2",
    "description": "The file is a 2.6‑version SMT‑LIB benchmark in the **BV** logic (≈2.5 kB, 2 assertions, 3 top‑level constants) extracted from LLVM’s `ConstantRange.cpp` verification suite (LLVM 13, industrial category).  It models integer ranges as bit‑vector intervals: a 32‑bit integer (`Integer`) is stored in a 64‑bit interval (`Interval`) with low/high parts extracted, while a 36‑bit “extended” integer is stored in a 72‑bit interval (`Interval2`).  Helper functions classify intervals as empty, full, or wrapped (i.e., low > high), define element‑containment for both kinds of intervals, compute the cardinality of an interval, and *zero‑extend* a 32‑bit interval to the 36‑bit domain (mapping empty sets to a special constant and full/wrapped sets to the universal range).  The two constraints assert that (1) the size of the extended range `R` is strictly smaller than the size of the zero‑extended version of `N`, and (2) every element of `N` (as a 32‑bit value) maps, after zero‑extension, into `R`.  Consequently the benchmark checks whether a candidate 36‑bit interval `R` can safely over‑approximate a given 32‑bit LLVM constant range while still being strictly larger in cardinality.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/llvm13-smtlib/01.smt2",
    "description": "The file is a BV‑logic verification condition (SMT‑LIB 2.6, logic BV) of moderate size (≈2.6 K characters, 3 top‑level asserts, 15 defined functions) generated from LLVM 13’s `ConstantRange.cpp` as described in Lopes 2013.  It models integer intervals as 64‑bit bit‑vectors (`Interval`) and their 36‑bit sign‑extended counterparts as 72‑bit bit‑vectors (`Interval2`), providing utility functions for extracting lower/upper bounds, testing emptiness/fullness, wrap‑around, and computing a set’s size.  The three assertions state: (1) an interval whose low and high words are equal must be either the full or the empty set, (2) the size of a concrete 36‑bit interval `R` is strictly smaller than the size of the sign‑extended version of a 32‑bit interval `N`, and (3) every 32‑bit value contained in `N` (after sign‑extension to 36 bits) must also be contained in `R`.  Satisfiability of these constraints checks whether such a pair of intervals can exist, i.e., whether the LLVM constant‑range optimization preserves the required ordering and size properties.  The benchmark is typical of industrial SMT use‑cases, featuring quantified conditions, bit‑vector arithmetic, and custom interval abstractions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/363_oggenc.smt2",
    "description": "This file is a single‑assertion BV‑logic benchmark generated by the Alive2 translation‑validation tool for an optimization in the **oggenc** program (the file comes from the directory *BV/20210301‑Alive2/oggenc* and is tagged “industrial”).  The instance asks whether a complex arithmetic transformation—built from a sequence of 32‑bit multiplies, adds, signed divisions, extracts, concatenations and many conditional (ite) branches—is semantically equivalent to the original code for **all** possible choices of the “undef’’ bit‑vectors (undef!0 … undef!23) that model undefined values and the Boolean predicates np_%x0, np_%x1, np_%y0, np_%y1, etc., that encode the required preconditions.  Symbolically, the quantified formula equates two huge expressions (one on each side of the `=`) and also enforces side conditions such as non‑overflow (e.g., `not (= … (_ bv2147483648 32))`) and defined‑behaviour checks (`bvsle`, `bvsdiv`).  Satisfiability of the assertion means that the optimization is *refinement‑correct*: under any concrete instantiation of the undefined bits the transformed program produces exactly the same 32‑bit results as the original.  The benchmark is noteworthy for its size (≈ 506 k nodes, 31 universal quantifiers, term depth 243) and its heavy use of BV operators (over 16 k concatenations, 4 k lets, 1 k extracts), which makes it a challenging case for SMT solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/386_oggenc.smt2",
    "description": "**What the file is** – an Alive2‑generated bounded verification query for a 32‑bit LLVM transformation.  \n**Logic and size** – the problem is expressed in the BV logic (bit‑vectors of size 32, with a few auxiliary 33‑bit temporaries) and contains roughly 390 k characters, 37 declared constants and a single huge quantified assertion.  \n**Main structure** – the assertion universally quantifies over a collection of “undef” bit‑vectors that model undefined source‑program values; inside it a cascade of `let`‑bindings builds two parallel arithmetic expressions (adds, multiplications, signed divisions and extracts) that correspond to the original and the optimized implementation of a small Ogg‑encoder routine.  \n**Key constraints** – the query asserts that, assuming the “isundef” flags are set appropriately and that no intermediate 32‑bit overflow occurs (checked with `bvsle` and sign‑extension tricks), the two computed results are equal; auxiliary equalities also relate sign‑extended products (using a 33‑bit constant `8589934591`) to the expected mathematical result.  \n**Notable characteristics** – the formula is heavily engineered with explicit `concat`/`extract` patterns to emulate sign‑extension and carries, and it contains dozens of nested `ite` and `and`/`or` combinators, making it a typical, highly‑synthetic industrial test case for compiler‑optimization validation.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/sqlite3/773_sqlite3.smt2",
    "description": "This instance is a **BV‑logic** query generated by the **Alive2** translation‑validation tool (PLDI 2021) for an LLVM optimisation of the SQLite 3 code base; it belongs to the *Alive2‑partial‑undef* industrial benchmark and contains a single large quantified assertion (≈ 3.9 kB, 8 declared constants, 46 equalities, maximum term depth 52).  \n\nThe formula models two versions of a small fragment that returns error codes: the original (`%posixError`, `%sqliteIOErr`) and the transformed version, each possibly combined with an “undefined” bit‑vector flag (`isundef_%posixError`, `isundef_%sqliteIOErr`).  The query quantifies over four fresh 32‑bit placeholders (`undef!0 … undef!3`) that represent the unknown bits of the undefined values and builds the concrete result of each version using **bvand**, **bvor**, and **bvnot**.  \n\nKey constraints enumerate the admissible concrete error codes (37, 4, 16, 13, 11, 110, 1) and assert that, for every assignment to the undefined bits, the two versions either produce the same code or obey a prescribed fallback (choosing 5 or 3).  The final conjunct checks that the two computed results (`?x212` and `?x223`) are equal and that a guard involving the non‑nullness predicates `np_%posixError` / `np_%sqliteIOErr` holds, yielding a single Boolean that the solver must satisfy.  \n\nThus the problem is a bounded refinement check: **does the optimized SQLite error‑handling code preserve the observable behaviour of the original code for all possible undefined‑value choices?**  A `sat` result means the refinement is valid, while `unsat` would expose a mis‑compilation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/626_ph7.smt2",
    "description": "**Summary**  \nThe file is a 12 KB BV‑logic benchmark (logic BV, 21 declared bit‑vector constants, 1 quantified assertion) generated by the Alive2 “bounded translation validation” tool for LLVM‑IR optimizations (source = Alive2, category = industrial). It models a refinement query that compares two versions of a small code fragment containing two integer values – %nKeyID (32 bits) and %bCheckFunc (8 bits) – together with their “undef/poison” masks (the `undef!…` symbols and the `isundef_…` flags). Inside a single universal quantifier over all undefined‑value placeholders the script constructs the concrete values of the two programs by masking the original variables with `bvand`/`bvnot` and then merging the mask with the variable using `bvor`. A large conjunction of disequalities and equalities checks that the masked results never equal any of a set of constant bit‑vectors (37, 4, 41, 40, 10, 9, 43, 8192, 27, 42, 512, 15, 256, 128) unless the corresponding “non‑poison” predicates (`np_%nKeyID`, `np_%bCheckFunc`) are false, while a final `ite`/`or` web ties together the two sides of the optimization. The outermost `check‑sat` asks whether there exists an assignment to the undefined bits that violates the intended equivalence; a **unsat** result would certify that the optimized code preserves the semantics of the original under all defined/undefined cases.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210301-Alive2-partial-undef/ph7/659_ph7.smt2",
    "description": "The file is a single‑assertion SAT query in the **BV** logic (≈6.5 KB, 12 declared 32‑bit bit‑vectors and one Boolean “np_%c”). It was automatically generated by **Alive2** (the LLVM translation‑validation tool) to test a compiler‑optimization that introduces a series of range checks on a 32‑bit integer %c while propagating possible undefined bits (the many “undef!…’’ symbols). Inside a universal quantifier the term ?x20 = %c ∧ ¬isundef_%c is built, and a cascade of `bvsle` comparisons against constants 96, 103, 47, 58, 64, 71, etc. decides which of several constant offsets (e.g., 0xFFFF FFE9, 0xFFFF FF30) is added to the value; the query then asserts that the **sign‑extended** results of the original and the transformed computation are equal under all those branch conditions. The outermost conjunct additionally equates the Boolean predicates (np_%c, range‑check results) between the source and target, and finally negates the whole equivalence (`not $x376`). Hence the solver is asked whether a concrete assignment to %c, isundef_%c and the undefined bits can witness a violation of the claimed optimization; a SAT result would be a counterexample, while UNSAT would prove the transformation sound under the given partial‑undef model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-tptp/NUM917=1.smt2",
    "description": "This benchmark is a **BV** (fixed‑size bit‑vector) problem translated from the TPTP library by Mathias Preiner (file BV/2017‑Preiner‑tptp/NUM917=1.smt2, 607 characters, 1 assertion). It belongs to the *industrial* category of the Preiner‑tptp family and uses 32‑bit vectors only. The sole assertion is the negation of a quantified statement:  \n\n\\[\n\\neg\\;\\forall U,V{:}\\mathsf{BV}_{32}\\;.\\;\\exists W{:}\\mathsf{BV}_{32}\\;(U - W = V),\n\\]\n\ni.e., it asks whether there exists a pair \\(U,V\\) for which **no** 32‑bit word \\(W\\) makes the subtraction \\(U - W\\) equal to \\(V\\). Thus the solver must check the surjectivity of the bit‑vector subtraction operation over the full 32‑bit domain. The formula features a single quantifier alternation (∀∃) and a single `bvsub` term, making quantifier handling the primary difficulty despite the otherwise tiny term depth (6).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium2.smt2",
    "description": "The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** logic, drawn from the PEak hardware‑rewrite‑rule synthesis suite (category “industrial”).  It declares 26 bit‑vector and Boolean constants that model the configuration bits of a small processing element (e.g., ALU opcode, multiplexers, LUT contents, signedness flags, constants, and a 420‑bit input bus) and then builds a huge concatenated bit‑vector representing the full hardware state.  Inside a universal quantifier the benchmark assembles this state using thousands of nested `concat`, `extract`, `ite`, `zero_extend` and arithmetic/logic operations, and finally checks a complex Boolean condition that combines equality with a fixed 16‑bit constant, a series of unsigned/signed comparisons, additions, shifts, and multiplications.  The sole `assert` therefore asks whether **for all possible input values** the encoded hardware implementation can satisfy the required property (i.e., avoid the illegal case), effectively proving a safety/property‑preservation guarantee for the synthesized rule.  The instance is notable for its extreme size (≈7 M characters, >130 k let‑bindings, deep term nesting) and its use of a single universally quantified check rather than many separate clauses.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_unsat_subset/medium.smt2",
    "description": "This benchmark is a bit‑vector (BV) model from the PEak industrial suite (category “industrial”, family PEak) that was generated for hardware rewrite‑rule synthesis; the source annotation mentions the PEak project and targets solvers such as Boolector, CVC4, and Z3.  The file contains a single universally quantified assertion (∀ …) that builds a huge concatenated bit‑vector representing an instruction encoding (fields like cond, bit_alu, mul, const_data, mux inputs, signed flags, etc.) and then successively extracts sub‑words, performs arithmetic (add, mul, shifts, sign/zero extensions), logical (and, or, not, xor) and comparison operations (bvule, bvslt, bvsle).  The core property being checked is that, for **every** possible setting of the declared 2‑, 5‑, 16‑ and 1‑bit inputs, the 15‑bit result extracted at the end of the datapath must equal the constant 295 while the input and output bit‑vectors (`ib_0`, `ob_0`) satisfy a small set of flag constraints (e.g., `ob_0 = 1` and `ib_0` matches a fixed pattern).  In other words, the model asks whether there exists any input that can produce a different output than the prescribed constant, i.e., it checks the unsatisfiability of a subset of the hardware loop.  The instance is exceptionally large (≈ 11 M characters, ≈ 200 k term depth) and contains thousands of `extract`, `concat`, and `ite` nodes, making it a stress test for BV solvers.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210301-Alive2/oggenc/283_oggenc.smt2",
    "description": "**Description:**  \nThis instance is a bounded translation‑validation query generated by the Alive2 tool for LLVM, checking the correctness of an optimization in the `oggenc` benchmark (file 283_oggenc.smt2).  It works entirely in the quantifier‑rich BV logic (32‑bit bit‑vectors) and declares a large collection of “undef!” constants to model unknown input bits together with Boolean flags `np_%x`, `np_%y0`, `np_%y1` that capture non‑poison/definedness conditions.  The single top‑level assertion is a massive universally quantified formula that relates the original computation (expressed with `%x`, `%x0`, `%x1`, `%y0`, `%y1`) to the transformed one using a cascade of `bvmul`, `bvadd`, `bvsle`, `bvsdiv`, `ite`, `extract`, and `concat` operations; the formula enforces equality of sign‑extended results and overflow‑free behavior for every possible assignment to the undefined bits.  The key property being checked is that the transformed sequence of multiplications, divisions and additions yields the same 32‑bit result as the original sequence under all defined inputs, i.e., the optimization is semantics‑preserving.  Notable characteristics are the extremely deep term nesting (depth 252), the huge number of auxiliary constants (over 37 declared), and the extensive use of concatenations to simulate sign extensions, reflecting a highly non‑trivial arithmetic transformation typical of industrial compiler‑verification workloads.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium0.smt2",
    "description": "This instance is a BV‑logic benchmark (logic = BV) generated by the PEak hardware‑rewrite‑rule synthesis project and targets industrial‑strength solvers such as CVC4 and Z3.  It declares a single 840‑bit input word `ib_0`, a 1‑bit output flag `ob_0`, and dozens of auxiliary bit‑vector and Boolean components that model the fields of a processor instruction (condition codes, ALU operation, multiplexers, LUT contents, signedness flags, etc.).  The sole assertion is a universally quantified formula over a large set of input variables; inside the quantified body the model builds a huge concatenated bit‑vector representing the complete hardware state, extracts many sub‑fields, and then applies a cascade of arithmetic (add, sub, mul), logical (and, or, xor, not), shift (bvashr, bvlshr), and comparison (bvule, bvsle, bvslt) operations wrapped in nested `ite` constructs.  The final Boolean condition forces `ib_0` to equal a fixed 840‑bit constant (mostly zeros with a few ones), requires `ob_0` = 1, and imposes a long conjunction of extracted‑field relationships (e.g., `bvule` of a 5‑bit slice with `10010`, equality of certain bits, and the consistency of signed‑ness flags).  In effect, the benchmark asks the solver to determine whether there exist concrete input assignments that satisfy this elaborate hardware‑state predicate, i.e., whether the encoded rewrite rule is applicable.  The file is very large (≈15 M characters, 26 declared constants, >275 k `let` bindings) and typifies the challenging, deeply nested bit‑vector reasoning found in industrial hardware verification tasks.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard0.smt2",
    "description": "This instance is a single‑assertion verification problem in the BV (bit‑vector) logic, generated by the PEak hardware‑rewrite‑rule synthesis benchmark suite (source PEak, industrial category).  It declares thirty constants (six BV‑16 inputs, a 720‑bit “ib_0”, a 1‑bit “ob_0”, control flags, and a few Boolean parameters) and then builds a gigantic expression by repeatedly extracting, concatenating, zero‑/sign‑extending, and applying arithmetic (add, mul, shift, neg) and comparison (bvule, bvsle, bvult) operations on those vectors.  The sole assertion is a universally quantified formula that ties the 720‑bit input vector, a 163‑bit control word, and many intermediate sub‑expressions together with a cascade of ite‑based case selections, finally requiring that a particular 1‑bit output (ob_0) equals 1 only when a complex Boolean predicate over the extracted fields holds.  The predicate checks relationships such as “field 34 ≤ 0b10010”, equality of certain extracted slices to small constants, and consistency between signed‑extended and zero‑extended parts—essentially encoding the functional correctness of a candidate hardware rewrite rule.  Notable characteristics are the astronomically large term size (≈9.4 M characters, term depth > 170 k) and the huge number of let‑bindings (≈171 k), which make the instance a stress test for solvers’ handling of deeply nested bit‑vector operations.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/medium1.smt2",
    "description": "**What the file encodes**  \nThe instance is a single‑assertion verification problem in the quantifier‑free bit‑vector logic BV (the solver sees only bit‑vector and Boolean operators).  It comes from the PEak “hardware rewrite‑rule synthesis” benchmark suite (generated by the PEak project for a hardware rewrite‑rule check) and is labeled “industrial”, with a size of about 7 MB, 26 declared constants, more than 1 M AST nodes (over 137 k let‑bindings, 32 k extracts, 33 k ite’s, etc.), and a maximum term depth of 137 108.\n\n**High‑level structure**  \nThe formula builds a gigantic 192‑bit word by concatenating the values of a large number of declared components: LUT output, condition fields, ALU flags, multiply flag, constant‑data bits, three multiplexers (mux_in0, mux_in1, mux_in2) and their control bits, signed‑ness flags, and a 420‑bit input vector `ib_2`.  Each sub‑component is itself assembled from smaller bit‑vectors using `concat`, `zero_extend`, `sign_extend`, arithmetic (`bvadd`, `bvmul`), shifts (`bvlshr`, `bvashr`), and logical operators.  After the full word is constructed, the assertion extracts many slices (e.g., bits 0‑0, 1‑1, 4‑0, 16‑2, 77‑0, etc.) and relates them with comparisons (`=`, `bvule`, `bvsle`, `bvslt`) and Boolean combinations.\n\n**Key property being checked**  \nThe sole quantified assertion (`forall …`) essentially states that for every possible assignment to the 16‑bit inputs, the 420‑bit input vector `ib_2`, and the Boolean signals `ob_2` and `PE_wrapped_if_6`, the huge constructed datapath must produce a specific output pattern: the final 15‑bit slice must equal the constant `391`, the Boolean `ob_2` must be true, and a long chain of relational checks (bounds on extracted fields, equality of certain flags, and a final comparison of the entire 192‑bit word against a fixed 420‑bit constant) must all hold.  In other words, the model checks that the hardware rewrite rule preserves the intended functional semantics under all input combinations.\n\n**Notable characteristics**  \n- The model contains a massive amount of repetitive bit‑vector plumbing (many `ite`‑driven multiplexers and sign/zero extensions) typical of a hand‑unrolled datapath.  \n- It uses a single `forall` quantifier to bind all primary inputs, turning the problem into a universally quantified verification condition.  \n- The assert mixes arithmetic (addition, multiplication, shifts) with extensive bit‑level slicing, exposing a deep combinational circuit rather than a sequential one.  \n- The benchmark is deliberately challenging for SMT solvers: the term depth, the sheer number of intermediate let‑bindings, and the mixture of relational and arithmetic constraints stress preprocessing, term sharing, and decision‑procedure integration.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node677435.smt2",
    "description": "The file is a 2.6‑compliant SMT‑LIB benchmark (logic **BV**) containing 19 32‑bit bit‑vector constants and a single quantified assertion; it originates from the Keymaera hybrid‑systems verification suite (intersection‑example‑simple.proof, node 677435) and was translated to bit‑vectors by Mathias Preiner.  \nThe asserted formula is the negation of an **∃ ts** clause, so the solver must show that no time instant ts satisfies a conjunction of safety‑related inequalities; if it proves unsatisfiable, the corresponding safety property for a vehicle‑intersection scenario holds.  \nThe constraints model two cars with positions (*x1*, *x2*), velocities (*v1*, *v2*), braking parameters (*A*, *B*), a speed limit *V*, and a deadline *ep*.  They express, for example, that the stopping distance `bvsdiv(bvmul v v, 2*B)` added to the current position stays below the intersection point (*xI1*, *xI2*), and that all parameters are non‑negative and bounded by *V*.  \nNon‑linear arithmetic appears through bit‑vector multiplication and signed division, and the formula contains deep nesting (max term depth 20), a `let` binding, and a disjunction that captures either an exact‑position case or a time‑bound case, making it a challenging instance for quantified, non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node4106.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) taken from the **KeYmaera** verification suite for the European Train Control System (ETCS) – node 4106 – and was translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category, 2 365 characters, 1 top‑level assertion).  \nThe formula asserts the negation of an existential claim: “there exists a 32‑bit time stamp `ts2` such that a large conjunction of arithmetic constraints holds”, where the constraints involve lower/upper bounds (`bvsle`, `bvsge`), linear and quadratic relations (`bvmul`, `bvadd`, `bvsdiv`) among the declared constants (`v, b, A, m, ep, …`).  \nKey properties being checked are safety‑type inequalities such as \\\\(v·v ≤ b·(m‑z)\\\\) and \\\\((A·ts2+u)² ≤ b·(m‑½·(A·t₀²+2·t₀·u+2·z))\\\\), together with side conditions like non‑negativity of parameters and an upper bound on `ts2`.  \nBecause the outer `not` wraps the existential, the solver is asked to prove that **no** `ts2` can satisfy all those non‑linear bit‑vector constraints, i.e., that the verification condition is valid.  \nThe benchmark is notable for embedding genuine non‑linear arithmetic (quadratic terms and divisions) into pure bit‑vector logic, stressing solvers’ ability to handle mixed linear‑non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node24127.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera verification suite, originally a safety proof for a one‑lane traffic‑intersection hybrid system (see Loos & Platzer 2011).  It contains a single quantified assertion that negates an existential over a time variable `ts54uscore0`; the body is a large conjunct of linear and non‑linear (quadratic) bit‑vector arithmetic constraints linking positions (`xI`, `xuscore…`), speeds (`v`, `V`, `vuscore…`), accelerations (`A`, `B`) and deadlines (`t96…`, `ep`).  The constraints enforce that all variables stay within non‑negative bounds, that the travelled distance `A·ts + v` never exceeds the speed limit `V`, and that the safety condition `xI > xuscore + (v²)/(2·B)` holds for the given lane‑crossing scenario.  Because the outermost operator is `not (exists …)`, the solver is asked to prove that no assignment to the existential variable can violate the safety condition—i.e., the verification condition is unsatisfiable.  The benchmark is notable for combining several bit‑vector multiplications and a signed division, making it a small but non‑trivial example of non‑linear arithmetic encoded in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/hard1.smt2",
    "description": "This instance is a single‑assertion verification problem written in the SMT‑LIB 2.6 format using the **BV** (fixed‑width bit‑vector) logic.  It comes from the PEak hardware‑rewrite‑rule synthesis benchmark suite (generated by the project “Hardware Rewrite Rule Synthesis, PEak”) and is classified as an industrial‑category case.  The formula consists of a massive term (over 60 million symbols) built from 25 declared bit‑vector and Boolean variables that model a datapath fragment – including condition codes, multiplexers, signed/unsigned flags, a 16‑bit constant, a 1‑bit multiplier enable, and a 2520‑bit input bus – which are repeatedly concatenated, sliced with `extract`, and combined with arithmetic (`bvadd`, `bvmul`, `bvneg`), logical (`bvand`, `bvor`, `bvxor`), shift (`bvlshr`, `bvashr`) and comparison (`bvule`, `bvsle`, `bvslt`) operations.  A single `forall` quantifier introduces a large set of symbolic inputs, and the body of the assertion is a deeply nested chain of `ite`, `and`, `or`, and equality checks that essentially encodes the semantic equivalence between two implementations of the same hardware block (e.g., before and after a rewrite).  The problem therefore asks the solver to decide whether there exists any assignment to the inputs that violates this equivalence, i.e., whether the rewrite rule is unsound.  Its extreme term depth (over 600 k) and huge numbers of `let` bindings, `extract`s and concatenations make it a stress test for bit‑vector solvers such as Boolector, CVC4 and Z3.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532347.smt2",
    "description": "The benchmark is a 32‑bit‑bitvector (BV) instance (logic BV) of size 2820 characters, containing 19 declared constants and a single top‑level assertion; it comes from the KeYmaera hybrid‑system verifier (intersection‑example‑simple, node 532347) and is listed in the Preiner‑keymaera industrial family.  \nIt encodes a verification condition for a “safe intersection” scenario: the formula asserts the **negation of an existential** over a time variable `ts2519uscore0`, wrapped in a `let` that defines a linear term `?v_0 = -B·ts2519uscore0 + v1uscore2dollarskuscore771`.  \nThe inner conjunct lists a large conjunction of signed‑comparison constraints (bvsgt, bvsge, bvsle) that bound velocities `v1`, `v2`, positions `x1`, `x2`, and parameters `A`, `B`, `V`, `ep` to be non‑negative, to stay within a safety limit `V`, and to satisfy `B > 0`, `V > 0`, `ep > 0`.  \nA key non‑linear relation appears in the inequality  \n`xI1 > x1 + (v1·v1) / (2·B)`, expressed with `bvmul` and `bvsdiv`, together with other range constraints such as `xI2 < x2`.  \nThe overall goal is to prove that **no** assignment satisfies all these constraints, i.e., the outer `not (exists …)` must be unsatisfiable, establishing the safety property.  \nNotably, the instance mixes non‑linear bit‑vector multiplication, signed division, and deep nesting (max term depth 20), making it a challenging test for BV solvers that handle non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385461.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the hybrid‑systems prover KeYmaera for the “safe intersection” example described in Platzer et al. (ITS 2011).  The file contains 19 declared constants, one large quantified assertion and a single top‑level ¬∃ formula, resulting in 2851 AST nodes and a maximum term depth of 19.  The condition asserts, under a host of non‑negativity and upper‑bound constraints (e.g., 0 ≤ v₁,v₂ ≤ V, B > 0, V, ep > 0), that the positions xI1 and xI2 of two moving objects stay strictly ahead of safety‑margin expressions involving the squared speeds v₁², v₂² scaled by a factor 2·B, and that the intermediate time variable ts1798₀ remains within the interval [0, ep] while the derived expressions v₁·ts + v1₀ and –B·ts + v2₀ also stay inside [0, V].  The outer negated existential checks that there is **no** assignment to ts1798₀ that violates these safety inequalities, i.e., it proves the conjunction of constraints is unsatisfiable and thus the intersection scenario is safe.  The encoding is representative of industrial‑style non‑linear arithmetic verification problems that have been bit‑vector‑translated for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601999.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) drawn from an industrial safety proof of a traffic‑intersection hybrid system, originally generated by KeYmaera and translated to BV by Mathias Preiner (family Preiner‑keymaera).  It consists of a single, highly‑conjunctive assertion that negates an existential formula over a time variable ts2859uscore0, thereby asking the solver to show that no such ts2859uscore0 satisfies the following constraints.  The constraints encode bounds on many system parameters (I1, I2, A, B, V, ep, v1, v2, etc.), relational properties such as bvslt (xI1 < x1) and bvsgt (xI2 > x2 + v2²/(2·B)), and a non‑linear arithmetic term bvmul (A·ts2859uscore0) together with a signed division bvsdiv.  Additional logical structure appears as a disjunction that either equates xI1 with a constant or, under a chain of implications, imposes further range checks on v1uscore3dollarskuscore765, the computed term ? v_0, and the elapsed time ep.  The formula therefore tests a solver’s ability to handle quantified bit‑vector reasoning, mixed linear/non‑linear arithmetic, and deep nesting (max term depth 21) in a verification‑oriented context.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252045.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) encoding of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in the Loos‑Platzer 2011 paper; it was translated to BV by Mathias Preiner and appears in the Preiner‑keymaera industrial family (≈2.9 KB, 20 declared constants, max term depth 21).  \nThe single top‑level assertion is the negation of an existential formula over a time‑step variable `ts1172uscore0`, so the solver is asked to prove that no assignment can satisfy the quantified constraints (i.e., that the condition is safe).  \nThe quantified body contains a large conjunction of linear and non‑linear bit‑vector arithmetic constraints that model vehicle dynamics: non‑negative velocities (`v1`, `v2`), bounded speed limits (`V`), positive acceleration and braking parameters (`A`, `B`), and a quadratic term `bvmul v2 v2` divided by `2*B` representing stopping distance, together with ordering relations between positions (`xI1`, `x1`, `xI2`, `x2`).  \nAdditional side conditions enforce that certain indices have fixed values (`I1 = 2`, `I2 = 2`), that the elapsed time `ep` is positive, and that the computed position update `?v_0 = A*ts1172uscore0 + v1` stays within the speed limit.  \nThe overall structure therefore checks the unsatisfiability of a safety‑critical hybrid‑system invariant, using a single quantified BV formula that mixes linear inequalities, a division and a quadratic term, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365475.smt2",
    "description": "This benchmark is a 32‑bit BitVec (BV) instance (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it appears in the “Preiner‑keymaera” industrial family (size ≈ 2.8 KB, 19 declared constants and a single large assertion). The formula asserts the negation of an existential query for a time stamp ts₁₇₀₁₀ that would violate a safety condition of a simple intersection scenario, i.e. it checks that no such ts exists. The constraints combine linear signed inequalities with non‑linear arithmetic: quadratic terms v₁·v₁ and v₂·v₂, products A·ts and 2·B, and signed divisions, together with equalities fixing the mode identifiers I₁ = I₂ = 2 and bounding parameters A, B, V, ep to be non‑negative. The safety predicate requires the “future” positions xI1 and xI2 to stay ahead of the current positions x1, x2 by at least the distance covered under constant acceleration, while the time variables are constrained to lie within the horizon [0, ep]. Because the problem is expressed entirely with 32‑bit bit‑vectors, it serves as a challenging non‑linear BV verification benchmark derived from a real‑world traffic‑intersection proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21762.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** logic (32‑bit bit‑vectors) with 12 declared constants and roughly 2.3 k characters.  \nIt originates from the **KeYmaera** hybrid‑systems verification suite (intersection‑example‑onelane), translated to bit‑vectors by Mathias Preiner and submitted to SMT‑LIB as an industrial “preiner‑keymaera” instance.  \nThe core formula is a negated existential (`not (exists ts48 ...)`) that encodes the non‑existence of a time instant `ts48` violating several safety conditions of a one‑lane traffic‑intersection model.  \nThe constraints combine linear bounds on the time and speed variables (`bvsle`, `bvsge`), a quadratic term `vuscore2dollarskuscore78*vuscore2dollarskuscore78` (appearing inside a division by `2*B`), and non‑negative requirements on all physical parameters (`A`, `B`, `V`, `ep`, etc.).  \nThus the solver is asked to prove that, under the given parameter ranges, no reachable state can make the vehicle position `xI` exceed the calculated safe bound, i.e., the safety invariant holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391949.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) with 19 declared constants and a single large quantified assertion, coming from the KeYmaera hybrid‑systems verification suite (the “intersection‑example‑simple” VC from the safe‑intersection case study).  It encodes a verification condition for a hybrid vehicle‑intersection model: variables such as v₁, v₂, x₁, x₂, A, B, V and a time‑step ts₁₈₃₃₀ represent velocities, positions, physical parameters and a discretisation step, while ep is an ε‑margin.  The core of the formula is a negated existential over ts₁₈₃₃₀ together with a conjunction of non‑negativity, upper‑bound (≤ V) and safety inequalities (e.g., xI₁ > x₁ + (v₁²)/(2·B′) and similar for the second vehicle) that express that the cars remain inside a safe region before a target time.  Additional constraints bind the auxiliary terms ?v₀ = 2·B and ?v₁ = −2·B·ts₁₈₃₃₀ + v₂₄₃₅, require them to stay inside [0, V], and enforce a deadline ts₁₈₃₃₀ + 0 ≤ ep.  The final guard forces one of the two mode identifiers I₁₄₃₅ or I₂₁₄₃₅ to be equal to 2, linking the safety condition to a specific control mode.  Satisfiability of the whole formula (checked with check‑sat) determines whether the original safety property of the intersection model is violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8745.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera family of verification conditions; it was translated from a non‑linear arithmetic VC for the “binary_driver” example (node 8745) and submitted to SMT‑LIB by Dejan Jovanović, with the BV encoding done by Mathias Preiner.  \n\nIt consists of a single, large quantified formula that asserts the **negation** of an existential condition over a fresh 32‑bit variable `ts1uscore0`; the surrounding constraints encode a safety property of a hybrid‑systems model, relating timing, speed, and control parameters (`amax`, `b`, `d`, `v`, `ep`, `m`, `z`, etc.).  \n\nThe core of the formula is a conjunction of numerous linear and **non‑linear** bit‑vector inequalities—quadratic terms such as `bvmul v v`, `bvmul d d`, products of two auxiliary expressions, and divisions (`bvsdiv`) appear throughout, together with range restrictions (`bvsle`, `bvsge`, `bvsgt`) on all variables.  \n\nKey logical structure: a nested series of `let` bindings introduce intermediate expressions (e.g., `?v_0 = amax/b + 1`, `?v_5 = duscore²`), which are then used in an implication that combines safety bounds (e.g., `bvsle (bvmul ?v_4 ?v_4) …`) with domain constraints such as `bvsle 0 ≤ ts1uscore0 ≤ t1uscore0dollarskuscore0` and positivity of parameters (`bvsgt amax 0`, `bvsgt b 0`, …).  \n\nBecause the outermost assertion is a `not (exists …)`, the solver is asked to show that **no** assignment to `ts1uscore0` can satisfy all those non‑linear BV constraints, making the benchmark a hard, industrial‑style case for bit‑blasting and non‑linear reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node622752.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2865 bytes, drawn from the “keymaera” family of verification conditions for hybrid‑system safety (the safe‑intersection example from the KeYmaera prover).  It declares 19 unsigned 32‑bit variables (e.g., v1, v2, A, B, x1, x2, I1, I2, V, ep) and encodes a single, fairly deep formula (max term depth 20) that is negated and existentially quantified over a time‑step variable ts2980uscore0.  The core constraints enforce non‑negativity and upper bounds on the state variables (e.g., bvsge v1 0, bvsle v1 V, bvsgt V 0) as well as quadratic relationships such as bvmul v1 v1 and bvmul v2 v2 divided by a linear combination (bvmul A ts2980uscore0 + v2uscore4dollarskuscore541), which model vehicle dynamics in the intersection scenario.  Additional safety conditions require that the projected positions xI1 and xI2 exceed the current positions plus these quadratic terms, and that timing variables stay within the deadline ep.  The formula therefore checks whether there exists a reachable state violating the safety invariant; the surrounding (not …) makes the whole query an unsatisfiability check for the original verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5587.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera “bouncing‑ball‑simple” verification suite and translated to SMT‑LIB by Mathias Preiner (file BV/2017‑Preiner‑keymaera/bouncing‑ball‑simple‑node5587.smt2, 2352 bytes, 7 declared constants, 1 top‑level assertion).  \nThe formula asserts the **negation of an existential condition** on a fresh time variable `ts1uscore1`; equivalently it asks whether every admissible `ts1uscore1` satisfies a safety property derived from the ball dynamics.  \nThe core constraints encode the classic kinematic equations of a bouncing ball as non‑linear BV arithmetic:  \n* `huscore2 = 5·tuscore2² + vuscore2·tuscore2` (height after time `tuscore2`),  \n* `huscore2 ≥ 0`, `tuscore2 ≥ 0`, `tuscore2 ≤ 16/5`, and `vuscore2 ≤ –10·tuscore2 + 16` (bounds on time and velocity),  \n* an additional quadratic inequality must hold for every `ts1uscore1` with `0 ≤ ts1uscore1 ≤ t1uscore0`.  \nFinally, the outer implication requires that the quantity `(-10·t1uscore0 – vuscore2)/2` stays below the constant 16, and the whole assertion is checked for unsatisfiability with `check‑sat`. The benchmark therefore tests a solver’s ability to handle quantified, non‑linear bit‑vector reasoning that arises from a simple hybrid‑system safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672522.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety proof for a simple traffic‑intersection hybrid system, taken from the KeYmaera verification suite and translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category, 2 825 bytes, 19 declared constants, 1 top‑level assertion). The formula asserts the negation of an existential claim for a time stamp `ts3205uscore0`; inside the existential it defines auxiliary expressions for twice the bound `B` and the product `A·ts3205uscore0`, and then checks a large conjunction of linear and non‑linear constraints. The constraints enforce that the indices `I1` and `I2` are equal to 2, that all state variables (`v1`, `v2`, `A`, `B`, `V`, `ep`, etc.) are non‑negative and bounded above by a common limit `V`, and that the positions `xI1` and `xI2` exceed the current positions plus a term proportional to the squared velocities divided by `2·B` (capturing braking distance). Additional temporal conditions require the elapsed time `t3205uscore0` to lie between 0 and `ts3205uscore0`, and that `ts3205uscore0+1` does not exceed the episode length `ep`. The instance therefore checks whether the hybrid‑system safety invariant holds for all admissible integer time steps, using bit‑vector arithmetic to encode the originally real‑valued non‑linear dynamics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550504.smt2",
    "description": "This benchmark is a 2 966‑byte, 2 793‑node SMT‑LIB 2.6 file written in the quantifier‑free bit‑vector logic (BV) and belongs to the industrial “Preiner‑keymaera” family derived from the KeYmaera hybrid‑systems verifier. It encodes a safety‑condition check for a simple traffic‑intersection scenario (the “intersection‑example‑simple” proof node 550504) that was originally expressed in nonlinear real arithmetic and then translated to 32‑bit bit‑vectors by Mathias Preiner. The sole top‑level assertion is the negation of an existential formula over a time variable ts2626₀; the inner formula conjoins numerous bound constraints (non‑negative, ≤ V, etc.) on variables v₁, v₂, A, B, V, ep and integer‑indexed state variables (I₁, I₂, x₁, x₂, …), and relates them with linear and quadratic bit‑vector expressions such as `bvmul A ts2626₀` and `bvmul v₂ v₂ / (2·B)`. The key property being verified is that, under the assumed initial bounds and dynamics, no reachable state can violate the safety inequality `bvsle (bvadd ts2626₀ (_ bv0 32)) ep`, i.e., the time to the event must stay within the allowed horizon. Notably, the formula mixes arithmetic comparisons (`bvslt`, `bvsgt`, `bvsge`, `bvsle`) with non‑linear multiplication and division, leading to a relatively deep term structure (depth 20) and a single, heavily nested quantifier‑free constraint set that challenges both bit‑vector solvers and the underlying encoding of nonlinear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5981.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera “bouncing‑ball‑simple” verification condition (node 5981) and translated to bit‑vectors by Mathias Preiner.  It declares seven 32‑bit constants that model the ball’s height h, velocity v, time variables (ts1, t1, tu, tv) and auxiliary parameters, and then asserts the negation of an existential statement, i.e. it checks that a certain quantified implication holds for every possible ts1.  The implication encodes the kinematic equation h = h₀ + v₀·t + (−5)·t² together with bounds such as 0 ≤ t ≤ 16/5, non‑negativity of height and velocity, and a relation between the auxiliary variables (h = 5·tu² + vuscore·tu).  The final disjunction requires either the height expression to be zero (the ball reaches the ground) or the summed time to respect the same upper bound, thus forming a safety‑style invariant.  The instance is an industrial‑style non‑linear arithmetic benchmark, expressed with only bit‑vector operations (bvmul, bvadd, bvneg, etc.), containing a single quantified assertion and a moderate term depth of 18.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351731.smt2",
    "description": "The file is a 2.6‑compliant SMT‑LIB benchmark in the **BV** (fixed‑size bit‑vector) logic, taken from the industrial “Preiner‑keymaera” family (size ≈ 2.9 KB, 19 declared constants and a single, fairly deep, quantified assertion). It originates from a safety‑verification condition for the **Keymaera** hybrid‑systems prover, specifically the “intersection‑example‑simple” proof node that models a vehicular crossing scenario (see the cited Loos & Platzer paper). The core of the benchmark is the negated existential formula  \n\n```\n¬ ∃ ts₀.   ( … logical constraints … ) ⇒ ( … time‑bounds and dynamics … )\n```  \n\nwhere the constraints encode non‑negativity of parameters (A, B, V, ep, the velocities v₁, v₂, etc.), positivity of the denominator 2·B, quadratic terms v₁² and v₂² divided by 2·B, and signed comparisons that enforce the reachable positions xI₁, xI₂ to stay beyond the safety margins defined by the initial positions x₁, x₂. The assertion checks that **no** time value ts₀ exists that both respects the interval [0, t₀] and violates the safety condition, effectively turning the safety proof into a satisfiability query over bit‑vector encodings of non‑linear arithmetic. Notably, the benchmark uses a deep nesting of `let`, multiple `=>` chains, and mixed signed‐less/greater‐than operators, illustrating how non‑linear hybrid‑system invariants are compiled into bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node44538.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula of size ≈ 2700 characters, coming from the Keymaera family of verification conditions for the “Safe intersections” hybrid‑system case study (originally a proof node of a KeYmaera model, translated to BV by Mathias Preiner).  The single top‑level assertion is the negation of an existential query `∃ ts99` that asks whether a time variable `ts99uscore0` can be chosen so that a collection of arithmetic relations among positions (`xI`, `x_uscore4dollarskuscore52`), velocities (`v`, `V`), and parameters (`A`, `B`, `I1`, `ep`) hold.  The constraints combine linear bounds (e.g., `0 ≤ ts99 ≤ t183`, `0 ≤ v ≤ V`, `V > 0`) with non‑linear expressions such as squares (`v*v`) and products/divisions (`v*v / (2*B)`, `vuscore4dollarskuscore57*vuscore4dollarskuscore57 / (2*B)`).  Logical structure consists of nested `and`/`or`/`=>` conditions that encode safety requirements like “if the vehicle is within the lane and its speed respects the limits, then its position must remain ahead of a computed stopping distance”.  The formula therefore checks that no assignment to the quantified time can violate these safety inequalities, serving as a SAT/UNSAT query for a hybrid‑system safety proof.  Notably, the encoding features non‑linear bit‑vector arithmetic (multiplication, division, and squaring) which makes it a challenging instance for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172099.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera hybrid‑systems verification suite; it encodes the “intersection‑example‑simple” proof obligation (node 172099) from the safe‑intersection case study. The file contains 20 declared constants and a single, large quantified assertion that is negated (¬∃ ts), so the solver is asked to prove the original existential condition unsatisfiable. The core of the formula models a hybrid‑system step: it relates a time‑step variable ts to linear and quadratic expressions such as A·ts + v₁, the safety bound V, and a curvature term (v₁·v₁)/(2·B). The constraints assert non‑negativity of parameters (A, B, v₁, v₂, V, ep), upper bounds by V, and ordering conditions on the “intersection indices’’ I₁, I₂ (both equal to 2) together with inequality checks for the positions x₁, x₂ and their updates. Notably, the encoding uses non‑linear bit‑vector operations (multiplication, signed division, signed comparisons) and reaches a maximum term depth of 20, making it a relatively deep and industrial‑size test (≈2.8 KB, 2851 characters) for solvers that handle non‑linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488227.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition taken from the KeYmaera proof “intersection‑example‑simple” (node 488227), originally a hybrid‑system proof about safe intersections and later translated to bit‑vectors by Mathias Preiner.  \nThe file contains a single top‑level assertion of the form **¬∃ts** …, i.e., it asks the solver to show that no time ts within the interval \\([0,t]\\) can satisfy a conjunction of arithmetic constraints, which corresponds to proving a safety invariant for the traffic‑intersection model.  \nThe core constraints enforce non‑negativity and upper bounds (by the constant V) on velocities v₁, v₂, the parameters A, B, the deadline ep, and the time variables, together with mode‑related equalities such as I₁=0, I₂∈{0,2} and a dynamics equation A·ts+v₁₅₇₃ (= A·ts + v₁’) that must stay inside \\([0,V]\\).  \nAdditional relational constraints compare the “instantaneous” positions xI₁, xI₂ with the initial positions x₁, x₂ using expressions like xI₁ > x₁ + v₁²/(2·B) and xI₂ < x₂, capturing the continuous evolution of the vehicles.  \nThe benchmark is relatively small (≈2.8 KB, 19 declared constants, one assertion) but features deep nested bit‑vector signed comparisons (max term depth 22) and an unsatisfiable disjunct (= 1 2), which makes it a typical industrial‑style case for evaluating SMT solvers on non‑linear arithmetic translated into the BV domain.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node32497.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe‑intersection” scenario on a single lane (node 32497 of *intersection‑example‑onelane.proof*).  It originates from the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and was translated to BV by Mathias Preiner, giving a relatively small industrial instance (≈2.4 KB, 13 declared constants, one large conjunctive assertion with a nesting depth of 21).  The formula asserts the negation of an existential property: there must **not** exist a time variable ts71₀ satisfying a host of linear bounds (non‑negativity, upper limits V, A, B, ep) together with a non‑linear safety inequality  \n\\( x_I > x + \\frac{v·v}{2·B}\\) (encoded as bvsgt with bvmul and bvsdiv).  Additional side conditions tie constants together (e.g., I1 = 2, A, B, V ≥ 0) and include a final disjunction that either fixes I1 to 2 or forces the expression A·t₁₂₈₀ + ṽ ≥ 0.  Satisfiability of the whole file therefore checks whether the hybrid‑system safety invariant holds for all admissible bit‑vector valuations; the benchmark is used to stress non‑linear arithmetic handling in BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267466.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑system prover for the “safe‑intersection” example described in Loos & Platzer (2011).  It originates from the industrial family *Preiner‑keymaera* (file intersection‑example‑simple.proof‑node267466.smt2) and contains 18 declared constants, one large quantified assertion and a total of 2 721 characters.  The formula asserts (under a leading `not`) that there exists a time instant `ts1242_0` such that a set of linear and non‑linear relationships among the variables – chiefly velocity bounds `v1`, `v2`, acceleration limits `A`, `B`, a safety margin `V`, and position variables `x1`, `x2`, `xI1`, `xI2` – violates the safety property; the inner constraints use multiplication, division and quadratic terms (`bvmul (bvmul v2 v2)`) to model kinematic equations.  The surrounding implications and conjuncts encode typical hybrid‑system conditions: non‑negativity of physical quantities, upper bounds by `V`, a lower bound on the elapsed time `ep`, and a guard that the computed position update `?v_0` stays within `[0,V]`.  Satisfiability of the whole negated existential query would indicate a counter‑example to the safety proof, so the intended result is “unsat”, confirming the intersection safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node248047.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe intersection” example; it appears in the Jovanović‑de Moura IJCAR 2012 paper and was translated to BV by Mathias Preiner (file BV/2017‑Preiner‑keymaera/intersection‑example‑simple.proof‑node248047.smt2, size ≈ 2.8 KB, 19 constants, one top‑level assertion).  \nThe asserted formula is the negation of an existential query ∃ ts₁₂₅₅₀₀₀₀₀ : BV₍₃₂₎ that, under a large conjunction of arithmetic constraints, would witness a violation of the safety property.  \nThe constraints model a hybrid traffic‑intersection scenario: they bound non‑negative velocities v₁, v₂, a control parameter A, a positive constant B, and require ordering of positions (e.g., xI₁ < x₁, xI₂ > x₂ + v₂²/(2B)), together with a timing relation t₁₂₅₅₀₀₀₀ ≥ 0 and an overall horizon V > 0.  \nA key part of the condition checks that either the post‑state position xI₂ equals a stored value x₂′, or, if the time step is non‑negative, the linear combination A·ts + v₁′ stays within [0,V] while all other variables remain within their bounds; an auxiliary equality I₂′ = 2 is also enforced.  \nThus the instance asks the solver to prove that no assignment to the existential timestamp can satisfy all these nonlinear bit‑vector constraints, i.e., that the intersection controller is safe under the given discretised model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node38802.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition coming from the KeYmaera hybrid‑system proof “intersection‑example‑onelane” (node 38802) and was translated to SMT‑LIB by Mathias Preiner (family Preiner‑keymaera, industrial category, 3025 characters, 13 declared constants).  \nThe formula is a single, negated existential query of the form  \n\n```\n¬∃ ts86 : BV32 .  Φ(ts86)\n```  \n\nwhere Φ contains a large conjunction of linear and non‑linear arithmetic constraints that model a safety invariant for a single‑lane traffic‑intersection hybrid system (variables such as A, B, V, ep, xI, x, v, … denote distances, speeds, and timing parameters).  \nKey constraints enforce bounds (e.g., 0 ≤ ts86 ≤ t157, 0 ≤ A,V,B,ep,…), relationships between positions (e.g., xI > x + v²/(2·B)), and quadratic expressions encoded with bvmul and bvsdiv (e.g., (v·v)/(2·B) and terms like A·t² + 2·t·u).  \nThe goal is to prove that no assignment to ts86 satisfies all these conditions, i.e., the original safety condition holds; consequently the solver must show the formula is unsatisfiable.  \nNotably, the benchmark features deep (depth 24) nested non‑linear BV arithmetic, a mixture of inequalities and equalities, and a single quantified variable, making it a typical hard case for BV solvers handling translated real‑valued hybrid‑system properties.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node253609.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe intersection” example (node 253609 of *intersection‑example‑simple.proof*).  It declares 20 32‑bit constants that model system parameters (A, B, V, ep), vehicle velocities (v₁, v₂) and positions (x₁, x₂, xI₁, xI₂) together with auxiliary indices (I₁, I₂) and a time variable ts.  The single assertion negates an existential statement over ts, requiring that, assuming non‑negative parameters, bounded velocities (0 ≤ v₁,v₂ ≤ V), positive constants (A, B, V, ep > 0), and specific index values (I₁ = I₂ = 2), the derived expression ?v₀ = A·ts + v₂′ stays within the same bounds and that the safety inequality xI₂ > x₂ + (v₂²)/(2·B) holds throughout the time interval.  The outer `not` forces the solver to prove that no ts satisfying all these constraints exists, i.e., the safety property is invariant.  Notably, the formula mixes non‑linear arithmetic (multiplication, division) and quantifiers in the bit‑vector domain, has a depth of 21 and originates from an industrial‑style benchmark used in the IJCAR 2012 paper on non‑linear arithmetic solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node6814.smt2",
    "description": "This benchmark is a 32‑bit Bit‑Vector (BV) encoding (logic BV) of a verification condition that originates from the KeYmaera hybrid‑system verifier, specifically the “intersection‑example‑onelane” proof node 6814 described in the Loos‑Platzer safe‑intersection paper.  The file contains 13 declared bit‑vector constants, a single quantified assertion (an existential over the time variable ts13₀) and about 2.3 kB of SMT‑LIB code, with a maximum term depth of 21.  The condition asserts that, under a collection of linear bounds on the variables (non‑negative ranges for A, B, V, ep, v, and a linear combination A·ts13₀ + vu₂₀ staying within [0,V]), the safety property “xI < x” (and related equalities such as I1 = 2) holds for all admissible timestamps.  The outer (not …) wraps the existential, so the solver is asked to prove that **no** timestamp can violate the safety property, i.e., the original VC is valid.  Notably, the real‑valued hybrid‑system constraints have been mechanically translated into bit‑vector arithmetic, yielding a dense conjunction of signed‑less‑than/equal and multiplication expressions, a pattern typical of the Preiner‑keymaera industrial benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99986.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) SMT‑LIB 2.6 instance (logic BV) of size 2708 characters, containing 19 declared constants and a single, fairly large assertion. It originates from the KeYmaera hybrid‑systems verification suite (intersection‑example‑simple.proof, node 99986) and was translated to bit‑vectors by Mathias Preiner for the Preiner‑keymaera family of industrial benchmarks. The formula asserts the negation of an existential statement over a time variable `ts467uscore0`, where the body is a nested let‑binding that defines two linear expressions `?v_0 = -B·ts + v1` and `?v_1 = A·ts + v2`, and then requires a chain of implications that enforce non‑negativity, upper‑bounds by a maximum speed `V`, and strict positivity of parameters `B`, `V`, and `ep`. Additional constraints fix several indices (`I1 = I2 = 2`), relate position variables (`xI1 < x1`, `xI2 < x2`), and tie auxiliary variables (`I1uscore1dollarskuscore453`, `I2uscore1dollarskuscore453`) to the same constant 2. The instance therefore checks that, under these safety‑critical bounds, no reachable time step can cause the computed positions `?v_0` or `?v_1` to leave the admissible interval `[0,V]` before the deadline `ep`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271799.smt2",
    "description": "The file is a 32‑bit **BV** benchmark (size ≈ 2720 characters, one top‑level assert) taken from the KeYmaera hybrid‑systems verification suite (the “intersection‑example‑simple” proof node).  It encodes a **negated existential query** over a time variable `ts1267uscore0`; the body of the quantifier is a large conjunction of signed‑comparison and arithmetic constraints on constants and state variables such as `A`, `B`, `V`, `v1`, `v2`, the positions `x1`, `x2`, and indexed variables `I1`, `I2`.  Two auxiliary expressions are introduced with a `let`:  \n  `?v_0 = -B·ts1267uscore0 + v1uscore3dollarskuscore329` and  \n  `?v_1 = A·ts1267uscore0 + v2uscore3dollarskuscore329`; both are required to stay within the non‑negative interval `[0,V]`.  Additional safety conditions enforce non‑negativity of all parameters, ordering `I1 = 2`, `I2 = 2`, bounds `xI1 < x1`, a kinematic inequality `xI2 > x2 + v2²/(2·B)`, and deadline constraints `ts1267uscore0 ≤ t1267uscore0` and `ts1267uscore0 + 0 < ep`.  The instance is notable for translating a non‑linear real‑arithmetic verification condition into bit‑vector arithmetic, resulting in a relatively deep term structure (max depth 19) and a mix of multiplication, division, and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node618750.smt2",
    "description": "This benchmark is a single‑assertion, bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑systems verification suite, originally modeling a “safe intersection” scenario (see Loos & Platzer, ITSC 2011) and translated to 32‑bit bit‑vectors by Mathias Preiner. The formula asserts the negation of an existential statement over a time variable `ts2956uscore0`, meaning it asks whether there **exists** a concrete time step that satisfies a long conjunction of non‑linear arithmetic constraints on velocities (`v1`, `v2`), positions (`x1`, `x2`), accelerations (`A`, `B`), and a safety bound `V`. The constraints enforce positivity, upper bounds (`v ≤ V`), quadratic terms (`bvmul v v`), divisions (`bvsdiv`), and safety conditions such as `xI1 > x1 + v1²/(2·B·ts)` and analogous ones for the second vehicle, together with timing limits (`ts ≤ ep`). By negating the existential, the SMT query checks that **no** such violating time exists, i.e., that the intersection remains safe under the given bounded‑velocity and acceleration parameters. The instance is relatively small (2790 characters, 18 declared constants) but features deep (max depth 21) non‑linear bit‑vector arithmetic, making it a typical industrial benchmark for solvers’ handling of quantified, non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1377.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera verification suite (Jovanović & de Moura IJCAR 2012) and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial‑category instance and contains 9 declared constants, a single quantified assertion and about 2.3 kB of text (max term depth 17).  \n\nThe single assertion is a **negated existential** formula: it asks the solver to show that there is **no** 32‑bit value ts0 such that a large conjunction of arithmetic bounds holds, i.e. it checks the unsatisfiability of a safety condition.  \n\nThe conjunct encodes a hybrid‑system invariant: all variables (ts0, t7, A, B, v1, vsl, ep, x1, xsl) are required to lie in non‑negative ranges, linear relations such as ‑B·ts0 + v1 ≥ 0 and ts0 ≤ ep are imposed, and a non‑linear quadratic condition appears via expressions like ‑B·t7² + 2·t7·v1 + 2·x1 and a comparison of (‑B·ts0 + v1)² with vsl².  \n\nThe final disjunction states that either the linear term (‑B·ts0 + v1) is bounded by vsl, **or** the variable xsl must be at least a more complex expression involving the quadratic terms and the constant B, thus capturing a typical proof obligation from differential‑dynamic logic.  \n\nConsequently, the benchmark tests the solver’s ability to handle mixed linear/non‑linear arithmetic over fixed‑size bit‑vectors, quantified reasoning, and a combination of inequality and algebraic constraints that stem from a real‑world hybrid‑system verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268443.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑simple” proof node (ID 268443) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera family.  The file contains a single, large quantified assertion: it negates an existential statement over a time‑step variable `ts1247uscore0` that must satisfy a conjunction of arithmetic relations among 18 declared constants (positions, velocities, accelerations, bounds, etc.).  The constraints include non‑negativity and upper‑bound conditions (`bvsge`, `bvsle`), ordering relations (`bvslt`, `bvsgt`), a quadratic term (`bvmul v2 v2`) divided by a linear term, and a linear combination `bvmul A ts1247uscore0 + v1uscore3dollarskuscore309`.  The overall check therefore asks whether there exists any time value that violates the safety invariant encoded by those relations; the outer `not` makes the solver prove the invariant holds for all admissible times.  Because it mixes multiplication, division and quantified bit‑vector arithmetic, the instance is a non‑linear BV verification task of moderate size (≈2.8 kB, 20 `and`‑nodes, depth 21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node737898.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) that originates from the KeYmaera verification of a “safe intersection” hybrid‑system example, translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category). The file contains 19 declared 32‑bit variables and a single quantified assertion: it asserts the negation of the existence of a timestamp `ts3610uscore0` that would satisfy a large conjunction of arithmetic constraints. The constraints encode the kinematic safety conditions of two vehicles (variables `v1`, `v2`, `x1`, `x2`, etc.), requiring non‑negative velocities (`bvsgt`/`bvsge`), upper bounds by a common limit `V`, positivity of constants `A`, `B`, `ep`, and a quadratic relationship `bvsdiv (bvmul v_i v_i) …` that mimics the continuous‑time motion equations. A disjunction at the end either forces the final position of vehicle 2 to match a given value (`xI2 = x2uscore4dollarskuscore636`) or imposes a deadline condition on the time variables together with auxiliary bounds. The benchmark is relatively small (≈2.9 KB, max term depth 20) yet notable for containing non‑linear multiplications and a quantified bit‑vector sub‑formula, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3459.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera family of verification conditions for an adaptive cruise‑control example; it was translated from the original non‑linear arithmetic model by Mathias Preiner and appears in the IJCAR 2012 paper on solving non‑linear arithmetic. The file declares twelve 32‑bit constants (v1, v2, A, B, eps, several time‑stamped variables and their “$2” variants) and contains a single quantified assertion that negates the existence of a timestamp `ts1uscore2` satisfying a long conjunction of signed inequalities and equalities built from linear expressions such as `A*ts1 + v1`, `v1 + A*eps`, and bounds `0 ≤ ts1 ≤ t1`. The core property being checked is whether the conjunction of these constraints is **unsatisfiable** (i.e., the negated existential is true), which encodes safety conditions like non‑negative velocities, monotonic positions (`x1 < x2`), and positive parameters (`A, B, eps > 0`). It features a deep nesting of logical connectives (max term depth 20) and a mixture of signed ≤, ≥, <, > and multiplication, making it a demanding test for quantified bit‑vector solvers in the industrial category.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node621704.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) of size ≈2.8 KB, taken from the KeYmaera “intersection‑example‑simple” proof (node 621704) that was translated to bit‑vectors by Mathias Preiner for the Preiner‑keymaera family of industrial verification problems. The single top‑level assertion is a negated existential formula, i.e. it asserts that **no** 32‑bit timestamp ts1688₀ exists that can satisfy a large conjunction of arithmetic constraints; consequently the solver is asked to prove the safety property by showing the whole formula is unsatisfiable. The constraints encode a hybrid‑system safety condition for a vehicle intersection: non‑negative parameters A, B, V, ep; bounds 0 ≤ v₁, v₂ ≤ V; quadratic‐growth terms v₁² and v₂² divided by 2·B; and required forward‑reachability inequalities such as xI₁ > x₁ + v₁²/(2·B) and xI₂ > x₂ + v₂²/(2·B). Additional side conditions enforce that the discrete state identifiers I₁ and I₂ equal 2, that B > 0, and that the timestamp stays within the interval [0, ts1688₀] and before the deadline ep. The formula therefore checks that, under all admissible parameter values and for any reachable time, the system cannot violate the prescribed safety distances, making it a bit‑vector encoding of a non‑linear arithmetic safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270992.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the IJCAR 2012 paper on non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner (file BV/2017‑Preiner‑keymaera/intersection-example‑simple.proof‑node270992.smt2, 2 809 characters, 19 constants, one top‑level assertion).  \nThe formula asserts the **negation** of an existential statement: it asks the solver to show that there is no 32‑bit value ts1262₀ for which a whole conjunction of arithmetic constraints holds.  \nThe conjuncts encode a safety condition for a simple traffic‑intersection scenario: non‑negative bounds on velocities v₁, v₂, a maximum speed V, positive parameters A, B, ep, and relational constraints such as `bvslt xI1 x1`, `bvsgt xI2 (x2 + v2*v2/(2*B))`, together with a linear relationship `?v_0 = A*ts1262₀ + v2₃₋₃₂₄`.  \nAdditional side‑conditions require the time variable to lie between 0 and the global time t1262₀, keep the computed expression within `[0,V]`, and guarantee that `ts1262₀+0 ≤ ep`.  \nThus the instance checks that under these quantified safety hypotheses no reachable state violates the intersection invariant, making it a typical industrial‑style verification condition with nested BV arithmetic, quantifiers, and a mixture of linear and (effectively) quadratic terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node529901.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera verification suite that models a “safe intersection” hybrid‑system proof (see Loos & Platzer 2011).  It is an industrial‑category benchmark (file BV/2017‑Preiner‑keymaera/intersection‑example‑simple.proof‑node529901.smt2) of moderate size (≈2.8 kB, 19 declared constants, 1 quantified assertion, maximum term depth 20).  \n\nThe single top‑level assertion negates an existential formula over a time variable `ts2506uscore0`; the formula encodes that there exists a non‑negative time step at which all safety conditions for two vehicles (positions `xI1`, `xI2`, velocities `v1`, `v2`, accelerations `A`, braking coefficient `B`, and a speed limit `V`) are simultaneously satisfied.  \n\nKey constraints include: non‑negativity of all physical parameters (`A`, `B`, `V`, `ep`, `v1`, `v2`), upper bounds `v1, v2 ≤ V`, a braking distance condition `xI1 > x1 + v1²/(2·B)`, a strict ordering `xI2 < x2`, and a bound on the updated velocity `bvmul A ts + v1` staying within `[0,V]`.  \n\nThe formula also contains a disjunction that either identifies the second vehicle’s final position with a given constant (`xI2 = x2uscore2dollarskuscore530`) or enforces that the time step respects the overall horizon `ep`.  This makes the benchmark a non‑linear arithmetic verification condition expressed entirely in BV arithmetic, with many signed‑comparison operators and a relatively deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node54865.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑simple” proof node 54865 and was translated to BV by Mathias Preiner. The single top‑level assertion is the negation of an existential formula over a time‑step variable `ts248uscore0`, so the solver is asked to prove that no choice of this variable can satisfy the subsequent constraints. The constraints encode a simple hybrid‑system safety condition: non‑negative constants A, B, V, ep and variables v1, v2, x1, x2, xI1, xI2 together with linear relations of the form `v1 + A·t` and `v2 + (‑B)·t` must stay within the interval [0, V] while the indices I1, I2 are fixed to 2 and the ordering xI1 < x1, xI2 < x2, xI2 = x2′ are enforced. The formula also requires the time bounds `0 ≤ ts ≤ t248uscore0` and that the updated positions remain ≤ V and that the overall horizon `ep` is positive. Although the arithmetic is only piece‑wise linear, the use of bit‑vector multiplication makes the problem non‑linear for the BV solver, and its relatively deep term nesting (depth 19) and 19 declared constants give it a modest industrial size (≈2.7 kB, 1 assertion).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674647.smt2",
    "description": "The file is a 32‑bit BitVec benchmark (logic BV) taken from the “keymaera” family of verification conditions that model a safe‑intersection scenario for hybrid‑system traffic control; it was translated to bit‑vectors by Mathias Preiner and submitted to SMT‑LIB (size ≈ 2.8 k characters, 19 declared constants, a single large assertion).  \nThe assertion is the negation of an existential formula over the auxiliary time variable `ts3216uscore0`, i.e. it asks the solver to prove that **no** value of this variable can satisfy a conjunction of arithmetic constraints, thereby encoding a universally quantified safety property.  \nThe core constraints describe two vehicles with non‑negative speeds `v1` and `v2` bounded by a global limit `V`, non‑negative braking strength `B`, and a positive acceleration `A`; they require that the predicted stopping positions `xI1` and `xI2` (computed as `x + v² ÷ (2·B)`) stay ahead of the current positions `x1` and `x2`.  \nAdditional conditions bound the auxiliary times (`0 ≤ ts ≤ t3216uscore0`, `ts+0 ≤ ep`) and enforce positivity of several parameters (`V`, `ep`, `B`, `A`).  \nBecause the formula mixes non‑linear operations (multiplication and signed division) with bit‑vector comparisons, it serves as a challenging industrial case for BV solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node703624.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) from the KeYmaera verification suite, originally a safety proof for a vehicle‑intersection hybrid system (see Loos & Platzer ITSC 2011) and translated to bit‑vectors by Mathias Preiner (size ≈ 2.7 KB, 18 declared constants, 1 quantified assertion).  \nThe formula asserts the **negation of an existential** over a time variable `ts3389uscore0`, thereby checking that no reachable state violates the safety condition.  \nInside the quantified body a `let` defines `?v_0 = A·ts3389uscore0 + v2uscore2dollarskuscore885`; the core constraints require all physical quantities (`v1`, `v2`, `A`, `B`, `V`, `ep`) to be non‑negative and bounded by `V`, that the quadratic position update `x1 + (v1·v1) / (2·B)` stays below `xI1`, and that `xI2` stays below `x2`, together with the invariant that the discrete mode indices `I1` and `I2` equal 2.  \nThe outer implication checks that for any non‑negative timestamp `t3389uscore0` the computed quantities respect the same bounds and that the elapsed time (`ts3389uscore0 + 0`) does not exceed the deadline `ep`.  \nThus the instance encodes a non‑linear arithmetic safety condition (multiplication and signed division) of a hybrid traffic‑intersection model, transformed into bit‑vector arithmetic to be decided by a BV‑solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388424.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic = BV) taken from the Keymaera hybrid‑system verification suite; it originates from the “intersection‑example‑simple” proof node used in the IJCAR 2012 paper on non‑linear arithmetic and was translated to BV by Mathias Preiner.  It contains 19 declared bit‑vector constants and a single, fairly large assertion (size ≈ 2840 characters, max term depth 21) that is the negation of an existential formula, i.e. the benchmark asks the solver to show that no assignment to the time variable ts₀₁₈₁₂ can violate the safety property.  The core constraints encode a simple traffic‑intersection scenario: non‑negative speeds v₁, v₂ bounded by a common limit V, positive parameters A, B, and a positive horizon ep; they also require that the accelerated stopping distances ( v₁² / (2·B) and v₂² / (2·B) ) stay below the distances to the intersection (xI₁−x₁, xI₂−x₂).  Additional boolean conditions fix the mode indices I₁ and I₂ to the value 2 and relate auxiliary terms such as 2·B and A·ts₀₁₈₁₂ to the positions, while a final bound forces the elapsed time to stay within ep.  The benchmark thus tests a solver’s ability to handle quantified, non‑linear arithmetic over bit‑vectors in an industrial‑style safety‑verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532026.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera hybrid‑systems verification suite; it was generated for the “intersection‑example‑simple” proof (node 532026) and translated to bit‑vectors by Mathias Preiner.  The file is modest in size (≈2.8 KB, 19 declared constants and a single large assertion) and belongs to the industrial “Preiner‑keymaera” family.  \n\nThe assertion states the negation of an existential formula over a time‑stamp variable `ts2517_0`, together with a let‑binding that computes a linear combination `?v_0 = v1 – B·ts2517_0`.  Inside the existential, a conjunction encodes the safety conditions of a vehicular‑intersection scenario: non‑negative parameters (`A, B, V, ep`), velocity bounds (`0 ≤ v1, v2 ≤ V`), a braking distance inequality `xI1 > x1 + v1²/(2·B)`, a position ordering `xI2 < x2`, and a bound on the computed expression `?v_0` within `[0,V]`.  \n\nAdditional constraints link the auxiliary time variable `t2517_0` and a deadline `ep`, and a small disjunction handles a trivial case (`0 = 2`) that is always false.  The whole formula is wrapped in `not (exists …)`, so the solver is asked to show that no assignment to `ts2517_0` can satisfy all these conditions, i.e., that the safety property holds.  \n\nNotably, the benchmark encodes non‑linear arithmetic (products and a division) purely with BV operations, exposing the difficulty of reasoning about hybrid‑system invariants in the bit‑vector theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603757.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera verification suite for a “safe intersection” hybrid‑system proof; it was translated to bit‑vectors by Mathias Preiner and is classified as an industrial benchmark (size ≈ 2.8 kB, 19 declared constants, one quantified assertion).  \nThe core of the instance is the negation of an existential query ∃ ts2869uscore0 : … that would witness a violation of a safety invariant, so the solver is asked to prove that no such ts exists.  \nThe conjunctive premise encodes a collection of bounded‑range assumptions (e.g., all variables lie in [0,V] with V>0, B>0, ep>0, I1=I2=2) together with physical‑law relationships such as bvadd (bvmul (‑1) B ts) + v1 ≥ 0, a quadratic term v2·v2/(2·B) appearing in an upper‑bound on xI2, and ordering constraints like xI1 < x1 and xI2 > x2 + v2²/(2B).  \nThe final implication checks that, under those assumptions, the computed expression ?v_0 remains within [0,V] and that the time step plus a zero offset stays below ep, while also forcing either I2=2 or I1=2, which are already true.  \nThus the solver must show the formula is unsatisfiable, i.e., that the safety condition holds for all reachable states of the intersection model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384248.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition that originates from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 384248), translated to BV by Mathias Preiner and submitted to SMT‑LIB as part of the Preiner‑keymaera industrial family (size ≈ 2.8 kB, 18 declared constants and a single large assertion).  \nThe formula asserts the negation of an existential statement over a time variable `ts1792uscore0`; inside the existential a large conjunctive block specifies numeric relationships between positions (`x1`, `x2`), velocities (`v1`, `v2`), acceleration limits (`A`, `B`), a global speed bound `V`, and a deadline `ep`.  \nKey constraints are non‑linear: the safety distances `xI1` and `xI2` must exceed the current positions plus the braking distance `v^2 / (2·B)`, expressed with bit‑vector multiplication (`bvmul`) and signed division (`bvsdiv`); all variables are additionally bounded (e.g., `0 ≤ v1 ≤ V`, `0 ≤ A`, `0 < B`, `0 < V`, `0 < ep`).  \nThe outer implication ties these safety conditions to a timing requirement `t1792uscore0 ≥ 0` and ensures that the computed intermediate values stay within `[0,V]` and that the elapsed time plus a zero offset stays below `ep`.  \nThe whole assertion is wrapped in a `(not (exists …))`, so the solver is asked to prove unsatisfiability, i.e., to show that no reachable state violates the safety property under the given bounds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node676430.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  It comes from the Preiner‑keymaera family (file BV/2017‑Preiner‑keymaera/intersection‑example‑simple.proof‑node676430.smt2), contains 19 declared bit‑vector constants, one large conjunctive assertion (≈ 2.9 KB, max term depth 21) and a single existential quantifier over a time‑step variable `ts3229uscore0`.  The core of the formula asserts a collection of non‑linear arithmetic relationships—quadratic terms `bvmul v1 v1`, `bvmul v2 v2`, a product `bvmul A ts3229uscore0`, and a division `bvsdiv …`—all constrained to lie within non‑negative bounds (`v1, v2, A, B, V, ep ≥ 0`) and to respect upper limits (`v1, v2 ≤ V`).  The outer `not (exists … )` encodes the safety property: it is unsatisfiable only if there exists a time instant and parameter values that violate the required inequalities (e.g., the reachability conditions `xI1 > x1 + …` and `xI2 > x2 + …`).  Hence the solver is asked to prove that, under the given bounds, no counter‑example to the intersection safety condition can be found.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3457.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera suite of hybrid‑system verification examples; it is listed under the industrial category and occupies about 2.3 KB with 12 declared constants and a single, fairly large assertion (max term depth 20).  \nThe formula asserts the negation of an existential statement over a time variable `ts1uscore0`, i.e. it asks whether there **does not** exist a timestamp satisfying a conjunction of linear inequalities that model a simple adaptive‑cruise‑control scenario (velocities `v1`, `v2`, accelerations `A`, `B`, a small step `eps`, and position variables `x1`, `x2`).  \nThe constraints enforce: (1) the time lies between 0 and a bound `t1uscore0dollarskuscore0`; (2) non‑negativity of all physical quantities and positivity of the parameters `A`, `B`, `eps`; (3) the motion law `v1 + A·ts1 ≥ 0` and the safety condition `v1 + A·eps ≤ v2`; (4) the ordering of positions `x1 < x2` together with the ordering of velocities `v1 ≤ v2`.  \nBecause the outermost `not` wraps the existential, the solver is asked to prove that the safety condition holds for **all** possible timestamps, i.e. to show the formula is unsatisfiable.  \nThe benchmark is notable for encoding a real‑valued hybrid‑system safety proof entirely as bit‑vector arithmetic, resulting in a densely nested conjunction of 32‑bit signed‑comparison and arithmetic operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node1722.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera verification suite and translated by Mathias Preiner; it appears in the “Preiner‑keymaera” industrial family and is 2 303 characters long with ten declared constants. The single top‑level assertion is the negation of an existential formula, so the solver is asked to prove that no 32‑bit value for `ts1uscore0` can satisfy a conjunction of arithmetic constraints. The constraints combine linear bounds (e.g., `bvsle 0 ts1uscore0 ≤ t8uscore0`) with several non‑linear bit‑vector operations—multiplication, division, and addition—forming a complex inequality that encodes a safety invariant (involving variables such as `A`, `B`, `ep`, velocities `v*`, and positions `x*`). All variables are required to be non‑negative and related by inequalities like `bvadd (bvmul (-B) ts1uscore0) v1uscore3dollarskuscore2 ≥ 0` and a nested expression mixing `bvsdiv`, `bvmul`, and additive terms. Because it mixes non‑linear arithmetic, division, and a quantified variable, the instance is a challenging example of non‑linear BV verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709146.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (“BV”) instance (size ≈ 2.8 KB, 19 declared constants, 1 top‑level assertion) originating from the KeYmaera hybrid‑system verification suite, specifically the “intersection‑example‑simple” proof node 709146. The formula asserts the **negation of an existential** statement, so the solver is asked to prove that the existential condition is unsatisfiable (i.e., that the safety property holds). The quantified variable `ts3425uscore0` is a time instant that must lie between 0 and a given bound `t3425uscore0`; the body encodes a collection of hybrid‑system safety constraints: non‑negativity and upper bounds (`V`) for velocities `v1`, `v2`, and parameters `A`, `B`; a kinematic relation `xI2 > x2 + (v2·v2)/(2·B)`; and a derived velocity `?v_0 = A·ts3425uscore0 + v2uscore3dollarskuscore827` that must stay within `[0,V]` and finish before a deadline `ep`. Additional structural clauses tie the initial position `xI1` either to a constant `x1uscore3dollarskuscore569` or to a conditional that is trivially false unless `I2uscore3dollarskuscore827 = 2`, thereby enforcing a specific mode of the hybrid automaton. In short, the instance checks that, under the given non‑negative parameters and timing limits, no reachable state violates the safety invariant of the intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291962.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) taken from the Keymaera hybrid‑systems verification suite and translated to bit‑vectors by Mathias Preiner (file BV/2017-Preiner-keymaera/intersection-example‑simple.proof‑node291962.smt2, 2 844 bytes, 20 declared constants, a single top‑level assertion).  \nThe formula asserts the **negation** of an existential property: there must exist a time‑step variable `ts1362uscore0` such that a collection of arithmetic relations, encoded with `bvadd`, `bvmul`, `bvsdiv`, `bvslt`, `bvsle`, `bvsge` and `bvsgt`, hold.  \nThese relations express the safety conditions of a simple road‑intersection scenario – e.g. `xI2 > x2 + (v2·v2)/(2·B)`, non‑negativity of speeds `v1`, `v2`, bounds `0 ≤ v1,v2 ≤ V`, positivity of constants `A`, `B`, `V`, `ep`, and ordering constraints on timestamps (`0 ≤ ts ≤ t`).  \nThe outer implication also requires that the computed positions `?v_0 = A·ts + v1` and `?v_2 = A·ts + v2` stay inside the interval `[0,V]` and that the elapsed time does not exceed `ep`.  \nA final disjunction forces either `I1 = 2` (or its renamed counterpart) or `I2 = 2`, tying the integer mode variables to the same constant.  \nThe benchmark therefore checks whether the hybrid‑system verification condition is **unsatisfiable**, i.e., whether the safety property holds for all admissible integer (bit‑vector) parameters.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631857.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verifier – specifically the “intersection‑example‑simple” safety proof (node 631857).  The file contains 20 bit‑vector constants that model the positions (x₁, x₂), velocities (v₁, v₂), a common speed limit V, acceleration/deceleration parameters A and B, and several time‑related variables (ts₃₀₂₀, t₃₀₂₀, ep).  The single, top‑level assertion is the negation of an existential formula over a fresh time variable ts₃₀₂₀; the body encodes the usual stopping‑distance condition xᵢ > xᵢ₀ + vᵢ²/(2·B) for both vehicles, together with non‑negativity and upper‑bound constraints (0 ≤ A, B, V, vᵢ ≤ V) and a consistency requirement on the integer indices I₁, I₂ (I₁ = 0, I₂ = 2).  Additional side conditions restrict ts₃₀₂₀ to lie between 0 and t₃₀₂₀ and to keep the computed intermediate term (A·ts₃₀₂₀ + v₂) within the interval [0, V]; finally ep must be positive.  The solver is asked to decide whether the negated existential condition is satisfiable, i.e., whether the safety VC can be disproved; the instance is 2 940 bytes, contains 21 ∧‑nodes, a maximum term depth of 21, and belongs to the “industrial” category of the Preiner‑keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292166.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) of roughly 2.9 KB containing 20 declared constants and a single, fairly large assertion (max term depth 20).  It originates from the KeYmaera verification suite – specifically the “intersection‑example‑simple” proof node 292166 that models a safe‑intersection hybrid system, and was translated to BV by Mathias Preiner (see Jovanović & de Moura 2012).  The formula asserts the negation of an existential statement over a time variable ts1363uscore0; inside a let‑binding it builds a linear combination `A*ts + v1` and then imposes a cascade of implications that encode non‑negativity, upper bounds (by a constant V), and relational constraints such as `xI2 > x2 + v2*v2/(2*B)` and ordering of positions/velocities (`xI1 < x1`, `v1 ≥ 0`, `v2 ≥ 0`, etc.).  The core property being checked is whether there exists a concrete time instant satisfying all hybrid‑system safety conditions; the outer `not` makes the query a safety proof (unsat means the system respects the safety invariant).  Notably, the instance contains several non‑linear BV operations (multiplication, signed division) and mixed signed‑comparison predicates, which makes it a challenging industrial benchmark for non‑linear BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369871.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection’’ example described in Platzer et al.’s traffic‑intersection case study.  The file, contributed by Dejan Jovanovic and translated to bit‑vectors by Mathias Preiner, consists of a single huge quantified formula (∃ ts) wrapped in a outer ¬, so the solver is asked to prove that no assignment to the time‑stamp ts can invalidate the safety implication.  The antecedent gathers the usual hybrid‑system hypotheses: the two vehicles’ speeds v1, v2 are non‑negative and bounded by a common limit V>0, the braking constants A, B and a safety margin ep are positive, and the discrete mode identifiers I1, I2 are fixed to 2.  The consequent encodes the classic stopping‑distance inequality – expressed with bit‑vector multiplication and signed division (e.g., xI1 > x1 + (v1²)/(2·B) ) – for both vehicles, together with bounds ensuring the auxiliary expression ?v_1 = 2·B – 2·B·ts + v1 remains in [0, V].  The problem therefore checks that, under these parameter constraints, the hybrid system can never reach a state where a vehicle would violate its safe stopping distance, and it is a non‑linear arithmetic benchmark (size ≈ 2.8 KB, 19 declared constants, max term depth 19) taken from the industrial Preiner‑keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54870.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) of about 3 KB with a single quantified assertion, taken from the KeYmaera hybrid‑system verification suite (the “intersection‑example‑onelane” VC) and translated to bit‑vectors by Mathias Preiner.  It models a one‑lane traffic‑intersection scenario, declaring constants for positions (x, xI), velocities (v, V), accelerations (A, B), a time‑parameter ts, and other auxiliary quantities.  The core constraint is a universally‑quantified safety condition: for every time ts within the interval [0, t₁₈₉] it must hold that all physical bounds (non‑negative parameters, upper bounds V, ep, etc.) and the kinematic relation  \n x = x₀ + v·t + ½·A·t² (encoded with bit‑vector multiplications, divisions and squares) imply that the vehicle’s position xI either stays before a safe region or after it (the disjunction involving the quadratic term ?v₂).  \n  The outermost “not (exists …)” turns the check into a proof obligation: the solver must show that no counter‑example time exists violating the safety inequality, while also handling the non‑linear arithmetic encoded in bit‑vectors.  \n  Notably, the instance mixes many bv‑operations (22 multiplications, several divisions, and nested lets) and a relatively deep term structure (depth 24), making it a challenging industrial benchmark for non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195048.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula from the **Preiner‑keymaera** industrial family, extracted from a KeYmaera hybrid‑systems verification proof (the “intersection‑example‑simple” VC, node 195048).  \nThe file contains 20 declared bit‑vector constants and a single, large quantified assertion (the negation of an `exists`), totalling about 2.8 KB of text with a maximum term depth of 20.  \nThe core of the VC describes a safety condition for a traffic‑intersection scenario: all parameters (velocities v₁, v₂, constants A, B, the bound V, and the time horizon ep) are constrained to be non‑negative, and the discrete modes satisfy `I1 = 2` and `I2 = 2`.  \nKey arithmetic constraints encode kinematic relationships such as  \n`xI1 > x1 + (v₁·v₁) / (2·B)` and `xI2 < x2`, together with a reachability bound `0 ≤ A·ts + v₁' ≤ V` for a time variable `ts` that must lie between 0 and `t909`.  \nThe overall check asks whether, under all these linear and non‑linear (multiplication/division) BV constraints, the safety condition is violated; a `sat` result would expose a counterexample to the original hybrid‑system proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node1479.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) SMT‑LIB 2.6 file of size 2353 bytes, containing 13 declared constants and a single, highly nested assertion (assert‑count = 1). The assertion is the negation of an existential statement over a time variable `ts0uscore1`; it encodes a verification condition that originates from the KeYmaera hybrid‑system verifier (the “intersection‑example‑onelane” proof node 1479). The core constraints are linear arithmetic over 32‑bit words: non‑negativity and upper‑bounds for time, velocities (`A`, `v`, `V`), and a position term `?v_0 = A·ts0uscore1 + vuscore2dollarskuscore1`, together with ordering relations such as `bvsle` and `bvslt` that enforce `0 ≤ ts0 ≤ t1`, `0 ≤ ?v_0 ≤ V`, and `xI < x`. Additional domain constraints tie constants together (e.g., `I1 = 2`, `B > 0`) and a final disjunction requires either `I1uscore2dollarskuscore1 = 2` or the bound `A·t1 + vuscore2dollarskuscore1 ≤ V`. The file was contributed by Dejan Jovanović, translated to BV by Mathias Preiner, and belongs to the industrial “Preiner‑keymaera” family used in studies of non‑linear arithmetic solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node386295.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) extracted from the KeYmaera hybrid‑systems verifier; it is listed in the “Preiner‑keymaera” industrial family and occupies about 2.9 KB with 19 declared constants and a single, large assertion. The formula encodes a safety condition for a simple traffic‑intersection scenario (the “intersection‑example‑simple” proof node 386295), where the variables v₁, v₂ denote vehicle speeds, x₁, x₂ and xI₁, xI₂ denote positions before and after the intersection, and A, B, V, ep represent physical bounds such as maximal speed, braking distance, and a time‑headway limit. The core constraint is a non‑linear arithmetic relation expressed with bit‑vector multiplication and signed division, e.g. xI₁ > x₁ + (v₁·v₁)/(2·B) and similarly for the second vehicle, together with positivity and ordering conditions (B > 0, V > 0, v₁,v₂ ∈ [0,V], etc.). The outermost `not (exists ts)` quantifier checks that no value of the auxiliary time variable ts can violate a disjunction comprising either a state‑equality (`xI₁ = x₁$259`) or a set of timing and bound constraints (ts ≥ 0, ts ≤ t₁₈₀₂, derived speed‐distance bounds, and ts + 0 ≤ ep). Because the non‑linear arithmetic is encoded in bit‑vectors, the instance is a hard test for BV solvers, featuring several nested `and`, `or`, and implication patterns with a maximum term depth of 20.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369234.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2768 bytes, containing 18 declared constants and a single large quantified assertion; it originates from the KeYmaera verification of a “safe intersection” hybrid‑system example (node 369234 of *intersection‑example‑simple.proof*).  The formula is the negation of an existential claim over a time variable `ts1723uscore0`, stating that there exists a moment when the combined safety conditions of the two vehicles are violated.  The safety conditions encode non‑linear relations such as  \n `xI1 > x1 + (v1·v1) / (2·B)` and `xI2 > x2 + (v2·v2) / (2·B)`,  \nwith additional bounds that velocities `v1`, `v2` lie in `[0,V]`, accelerations `A` and braking `B` are non‑negative, and the overall time horizon `ep` is positive.  The assertion also requires that the intermediate expressions `?v_1 = -B·ts + v1` and `?v_2 = A·ts + v2` stay within `[0,V]` and that the time variable respects `0 ≤ ts ≤ t1723uscore0`.  By checking the unsatisfiability of the negated existential, the solver is asked to prove that for all admissible times the vehicles maintain a safe separation, a property that was originally expressed in real non‑linear arithmetic and then translated to bit‑vectors by Mathias Preiner.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node475811.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition extracted from the KeYmaera proof “intersection‑example‑simple” (node 475 811).  It originates from the Jovanovic‑de Moura 2012 paper on non‑linear arithmetic and was translated to BV by Mathias Preiner, so it appears in the industrial “Preiner‑keymaera” family of SMT‑LIB benchmarks (size ≈ 2.7 kB, 18 declared constants, one large conjunct).  The formula asserts the negation of an existential claim over a time stamp ts; the inner let‑binding computes the linear expression A·ts + v1’, and the surrounding constraints enforce non‑negative bounds on all variables (V, A, B, v1, v2, etc.) together with a nonlinear safety condition  \n  xI1 > x1 + v1² / (2·B)  \nand a simple ordering xI2 < x2, plus the requirement that the computed expression stays within [0,V] and that the total elapsed time does not exceed ep.  Satisfiability of the negated existential would falsify the safety property, so the benchmark is used to check that the original condition is unsatisfiable (i.e., the intersection is provably safe) while exercising bit‑vector reasoning about signed comparisons, multiplication, and signed division.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39725.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑onelane” proof (node 39725) and was translated to BV by Mathias Preiner.  The file contains 13 declared 32‑bit variables that model quantities such as positions (x, xI), velocities (v, V), accelerations (A, B), a time bound (t161…), and auxiliary constants (ep, I1, I1​′, …); the whole formula is a single assertion of the form ¬∃ts . φ(ts).  In φ, a cascade of conjuncts enforces non‑negativity, upper and lower bounds on the existential time variable ts88, and several non‑linear relationships (e.g., v·v, A·B, division by 2·B) that capture the safety condition xI > … or xI > x + v·v/(2·B).  The core property being checked is whether there exists any time ts88 within its allowed interval that violates the safety inequality; the outer negation makes the whole problem a satisfiability check for the *absence* of such a counter‑example.  Notably, the instance mixes linear and quadratic bit‑vector arithmetic, uses nested let‑bindings, has a maximum term depth of 24, and is classified as an industrial benchmark of size ≈ 2.7 KB with 17 logical‑and connectives.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287144.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition that originates from the KeYmaera hybrid‑system proof “intersection‑example‑simple”.  It is a single quantified assertion (¬∃ ts) that checks a safety property of a simple traffic‑intersection model: given non‑negative parameters A, B, V, ep and initial velocities v₁, v₂ bounded by V, the condition requires that for every time instant ts between 0 and a horizon t the computed velocity ?v₀ = A·ts + v₁ stays within the interval [0,V] and that the positions xI₁, xI₂ respect ordering constraints (xI₁ < x₁, xI₂ > x₂ + v₂²/(2·B)).  The formula also fixes several discrete mode identifiers (I₁ = 2, I₂ = 2, I₁′ = 0, I₂′ = 2) and imposes positivity of B, V and the episode length ep.  By asserting the negation of the existential, the solver is asked to prove that no ts can violate these bounds, i.e., that the hybrid‑system invariant holds for all reachable states.  The instance is relatively small (18 declared constants, 1 top‑level assertion, 2742 characters) but features non‑linear bit‑vector arithmetic (multiplication, division) and a mixture of signed comparison operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345166.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera family of hybrid‑systems verification problems; it was translated to bit‑vectors by Mathias Preiner and appears in the industrial “Preiner‑keymaera” collection (size ≈ 2.8 KB, 18 declared constants, 1 quantified assertion).  \nThe core of the instance is a single negated existential statement ‑ `(not (exists ((ts …)) …))` ‑ which asks the solver to prove that **no** time value `ts1606` can satisfy a conjunction of safety and range constraints.  \nThese constraints bind the variables to non‑negative ranges bounded by a global maximum `V`, enforce quadratic‐type relations such as  \n`xI1 > x1 + (v1·v1) / (2·B)` and `xI2 > x2 + (v2·v2) / (2·B)`, and require the intermediate quantities `A*ts + v1` and `A*ts + v2` to stay within `[0, V]` while also respecting an overall deadline `t1606` and an epsilon margin `ep`.  \nAuxiliary equalities fix several indices (`I1 = I2 = 2`) and create a contradictory branch `(or (= 0 2) ?v_4)`, making the whole formula a consistency check of the hybrid‑system safety conditions encoded in bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node350275.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑system prover for a “safe intersection” example.  The file contains a single, large quantified assertion that negates an ∃ ts₁₆₃₁ : BV₃₂ and then conjoins a chain of arithmetic constraints over variables that model two cars’ positions (x₁, x₂), velocities (v₁, v₂), a common speed limit V, and parameters A and B that appear in quadratic‑terms (v₁·v₁, v₂·v₂) and a linear term 2·B.  The constraints enforce non‑negativity of all quantities, upper bounds by V, positivity of the time horizon ep, and safety conditions such as x₁ > x₁ + (v₁² ÷ (2·B)) and analogous ones for the second car, together with a guard ensuring B > 0.  The outer implication also requires that, if the existential time variable is non‑negative, then a derived expression ?v₁ ( = A·ts₁₆₃₁ + v₂) stays within [0, V] and that ts₁₆₃₁ + 0 ≤ ep, while the disjunction at the end forces I₁ to be either 2 or 1 (encoded as a trivial equality).  The solver is asked to prove the negated existence unsatisfiable, i.e., that the safety condition holds for all admissible values; the instance is relatively compact (≈2.9 KB, 19 declared constants) but uses non‑linear bit‑vector arithmetic, making it a challenging industrial‑style benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560330.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the Keymaera “intersection‑example‑simple” verification case and translated to bit‑vectors by Mathias Preiner (size ≈ 2.8 KB, 19 declared constants, 1 top‑level assertion).  It encodes the negation of an existential statement that asks whether there exists a non‑negative time instant `ts2669uscore0` at which a set of hybrid‑system safety conditions can be violated.  The constraints jointly enforce non‑negativity and upper bounds (≤ V) for velocities `v1` and `v2`, positivity of parameters `A`, `B`, `V`, `ep`, and relationships such as `xI1 = x1` and `I2 = 2`, while also requiring a quadratic safety bound `xI2 > x2 + (v2·v2)/(2·B)`.  Additionally, the formula ties the state at time `ts2669uscore0` to a linear expression `?v_0 = A·ts2669uscore0 + v2`, forcing it to stay within `[0,V]` and that the overall elapsed time stays below `ep`.  Because the outermost operator is `not`, the solver is asked to prove that no such violating time exists; unsat would mean the intersection safety property holds for all reachable states.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272548.smt2",
    "description": "This benchmark is a 32‑bit BitVec (BV) encoding of a safety verification condition from the KeYmaera hybrid‑system prover, taken from the “intersection‑example‑simple” proof (node 272548) and translated to bit‑vectors by Mathias Preiner.  It belongs to the industrial category of the Preiner‑keymaera family, contains 18 declared constants, a single quantified assertion, and is 2 673 characters long with a maximum term depth of 19.  The core formula asserts the negation of an existential statement over a time variable `ts1272uscore0`; inside the quantifier a conjunction of linear and non‑linear signed constraints models vehicle speeds (`v1`, `v2`), positions (`x1`, `x2`), bounds (`A`, `B`, `V`, `ep`) and an invariant that the two cars remain safely separated at a crossing.  The constraints involve signed comparisons (`bvslt`, `bvsgt`, `bvsle`, `bvsge`), addition, multiplication, a single signed division, and a negated multiplication by ‑1, thereby encoding non‑linear arithmetic in the BV theory.  By negating the existence of a violating time, the SMT query checks whether the safety condition holds universally; consequently, the instance is a typical non‑linear BV safety‑property check arising from hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5586.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (size ≈ 2.3 KB, 7 declared constants and a single large conjunctive assertion).  \nThe formula expresses a verification condition for the simple bouncing‑ball hybrid system (node 5586 of the “bouncing‑ball‑simple” example), using variables that correspond to the ball’s height h, velocity v, time t, and auxiliary parameters (e.g., huscore2$…, vuscore2$…).  \nAt its core the condition asserts that there does **not** exist a time instant ts₁₀ (the quantified variable) satisfying a chain of nonlinear constraints: a quadratic invariant involving –5·t² (gravity), bounds on time (0 ≤ ts₁₀ ≤ t₁₀), non‑negativity of height and velocity, and algebraic relationships that tie the parameters (e.g., huscore = 5·t² + v·t).  \nThese constraints are encoded with BV arithmetic (bvadd, bvmul, bvneg, bvsgt, bvsle, bvsge, bvsdiv) and the outermost **not‑exists** turns the verification problem into a satisfiability check: the solver must show that the quantified conjunction is unsatisfiable, thereby proving the safety property of the bouncing‑ball model.  \nThe benchmark is notable for combining non‑linear arithmetic (quadratic terms, a division) with bit‑vector reasoning, making it a challenging case for SMT solvers that handle BV‑encoded real‑valued hybrid system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561763.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition from the KeYmaera hybrid‑system verifier, taken from the “safe intersections” example described in the IJCAR‑2012 and CADE‑2009 papers.  The file (≈2.8 KB, 19 declared constants, a single large assertion) was translated to bit‑vectors by Mathias Preiner and belongs to the Preiner‑keymaera industrial family.  The core of the problem is the negation of an existential statement over a timestamp `ts2678_0`; inside the `let` the term  \n`?v_0 = v1_589 - B·ts2678_0` is constrained to lie between 0 and a global bound `V`, while many auxiliary variables (velocities `v1`, `v2`, positions `x1`, `x2`, indices `I1`, `I2`, etc.) are required to satisfy signed inequalities such as `0 ≤ v1 ≤ V`, `0 ≤ v2 ≤ V`, `B>0`, `V>0`, `ep>0`, and geometric constraints on positions (`xI2 > x2 + v2²/(2·B)`).  The outer `not` wraps the existential, so the solver must prove that no timestamp can make all these conjuncts true, i.e., that the safety condition holds.  Notably, the encoding mixes non‑linear arithmetic (multiplication and a signed division) with bit‑vector signed comparisons, yielding a comparatively deep term structure (depth 20) that challenges BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/rbc-controllability-characterisation-node3299.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the **KeYmaera** hybrid‑system verification suite (rbc‑controllability‑characterisation, node 3299) and translated to BV by Mathias Preiner; it belongs to the industrial “Preiner‑keymaera” family and is 1 729 characters long with seven declared constants.  \nThe sole assertion is a doubly‑quantified formula `¬∃ zuscore2 ∃ vuscore2 ( P ⇒ Q )`, which is equivalent to a universal condition that **P must hold while Q is false** for all values of the two existential variables.  \n`P` is a conjunction of non‑linear and linear constraints: a quadratic inequality `vuscore2² – d² ≤ 2·b·(m – zuscore2)`, non‑negativity of `vuscore2`, `vdesuscore1dollarskuscore2`, `d`, a strict positivity of `b`, and the outer `not` makes this inequality required to be violated.  \n`Q` simply asserts the non‑negativity of `duscore1dollarskuscore2`.  \nThus the instance checks whether there exists any assignment to the quantified variables that can satisfy the complex arithmetic pre‑condition without violating the safety condition on `duscore1dollarskuscore2`; the outer negation turns this into a **unsatisfiability** check of the controllability condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node717892.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) drawn from the KeYmaera hybrid‑systems verification suite; it encodes a verification condition for a simple traffic‑intersection example (node 717 892 of *intersection‑example‑simple.proof*).  There are 18 declared constants (positions x1, x2, xI1, xI2, velocities v1, v2, parameters A, B, bounds V, ep, etc.) and a single quantified sub‑formula that existentially guesses a time stamp `ts3478uscore0`.  The core constraints are a conjunction of linear and non‑linear bit‑vector inequalities (≤, ≥, <, >) together with two multiplications and one division (e.g., `bvmul A ts3478uscore0`, `bvsdiv (bvmul v2 v2) (bvmul 2 B)`) that model the continuous dynamics and safety limits of the hybrid system.  The outermost `not` wraps the existential, so the solver is asked to prove that no assignment to the existential variable can satisfy all the safety‑related arithmetic conditions; an unsat result establishes the safety property.  Notably, the benchmark mixes quantifiers, let‑bindings, and non‑linear bit‑vector arithmetic, making it a relatively challenging industrial case for BV solvers (size ≈ 2.7 KB, depth 21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5607.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example with a single lane (node 5607 of *intersection‑example‑onelane.proof*).  The formula asserts the **negation of an existential** over a time variable `ts10uscore1`, together with a large conjunction that captures the hybrid dynamics: non‑negativity and upper bounds for positions, velocities (`v`, `V`), accelerations (`A`, `B`), and a timeout (`ep`), plus the discrete update equations derived from the system’s differential equations (quadratic terms in `t17uscore0dollarskuscore1`).  The key safety property being checked is that the vehicle’s position `xI` never exceeds a bound expressed as a quadratic expression in the state variables, unless a discrete flag `I1uscore2dollarskuscore16` takes a specific value, which corresponds to a safe mode change.  All arithmetic is encoded in bit‑vectors (including signed division and multiplication) to simulate the original non‑linear real arithmetic, and the single top‑level assertion is expected to be **unsatisfiable** if the safety condition holds.  The instance is relatively large (≈3 k characters, 13 declared constants, depth 23) and originates from an industrial‑style benchmark suite (Preiner‑keymaera).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369550.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (BV logic) taken from the Keymaera hybrid‑system verification suite; it appears in the industrial “Preiner‑keymaera” family and is 2 844 characters long with 19 declared constants.  The single top‑level assertion is the negation of an existential query over a time variable `ts1725uscore0`, i.e. it tries to prove that no assignment to this variable can satisfy a large implication that encodes a safety verification condition.  The antecedent of the implication contains the usual hybrid‑system hypotheses: non‑negative parameters `A`, `B`, `V`, `ep`; velocities `v1`, `v2` bounded between 0 and `V`; and quadratic distance bounds such as  \n`xI1 > x1 + (v1·v1) / (2·B)` and `xI2 > x2 + (v2·v2) / (2·B)`.  \nThe consequent branches on whether `xI2` equals a stored snapshot or, if a non‑negative auxiliary counter `t1725uscore0` is available, imposes additional bounds on `ts1725uscore0`, on the derived expression `?v_1 = -2·B·ts1725uscore0 + v1_331`, and on the auxiliary index `I2uscore4dollarskuscore331`.  \nThus the file checks that, under all the stated physical and timing constraints, the hybrid‑system safety invariant cannot be violated; the encoding is notable for representing non‑linear arithmetic (squares and divisions) entirely with 32‑bit bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174126.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector verification condition (BV logic, 2779 AST nodes, 19 declared constants) derived from the KeYmaera hybrid‑systems proof “intersection‑example‑simple”. It asserts the negation of an existential quantifier over a time variable `ts810uscore0`, i.e. it checks that for **all** reachable time steps the safety‑related implication holds. The premises encode a simple traffic‑intersection model: non‑negative parameters `A`, `B`, `V`, velocities `v1`, `v2` bounded by `0 ≤ vi ≤ V`, a quadratic braking distance term `v1*v1/(2*B)`, and positional constraints such as `xI1 > x1 + v1*v1/(2*B)` and `xI2 < x2`. Additional bounds enforce `0 ≤ ts ≤ t810uscore0`, `ts+0 ≤ ep`, and require either `I1 = 2` or `I2 = 2`. The single top‑level assertion therefore asks whether any choice of `ts` can violate the safety condition under these arithmetic constraints, making the instance a non‑linear arithmetic‑to‑BV encoding of a hybrid‑system safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node74776.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety‐condition proof obligation extracted from the KeYmaera hybrid‑system verifier, specifically the “intersection‑example‑simple” case (node 74776).  The single top‑level assertion negates an existential quantifier over a time‑step variable `ts343uscore0`; inside the quantified body a `let` defines two linear expressions `?v_0 = A·ts + v1` and `?v_1 = –B·ts + v2`, which model the updated positions of two vehicles after a time interval.  The formula then demands a suite of bit‑vector inequalities: all parameters (`A`, `B`, `v1`, `v2`, `V`, `ep`) are non‑negative, the velocities lie between 0 and a global bound `V`, the accelerations are non‑negative, the initial indices `I1` and `I2` equal 2, and the computed positions `?v_0` and `?v_1` stay within `[0,V]` while the elapsed time stays below the deadline `ep`.  Finally, it requires either `I1=2` or `I2=2` (the latter expressed as `or ?v_2 (= I2uscore1dollarskuscore333 (_ bv2 32))`).  The instance, originating from the 2012 IJCAR “Solving Non‑Linear Arithmetic” paper and translated to bit‑vectors by Mathias Preiner, is a compact (≈2.7 KB, depth 18) industrial benchmark used to test non‑linear arithmetic handling in SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node18278.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera family of verification conditions for hybrid‑system safety, specifically the “intersection‑example‑onelane” proof node 18278 that appears in the Jovanović & de Moura IJCAR‑2012 paper and the Loos & Platzer safe‑intersection case study.  It is a single, large assertion (size ≈ 2.6 KB, 13 declared constants, term depth 24) that asserts the **negation of an existential** over a time variable ts40₀, thereby checking whether a reachable‑state witness exists that violates a set of safety bounds.  The constraints bind several parameters (A, B, V, ep, v, etc.) with non‑linear bit‑vector arithmetic: linear inequalities (bvsle/bvsge), strict comparisons (bvsgt/bvslt), and products/divisions such as bvmul A ts40₀ and bvsdiv (vuscore2dollarskuscore64 vuscore2dollarskuscore64) / (bvmul 2 B).  The core safety condition requires the “intersection” variable xI to stay within a computed interval that depends on these parameters (e.g., xI > ?v₁ and xI ≤ bvadd ?...), while auxiliary variables are forced to be non‑negative and V, B, ep, etc., to be strictly positive.  Notably, the formula encodes a non‑linear arithmetic verification problem that has been mechanically translated from real‑valued hybrid dynamics into bit‑vector arithmetic, making it a challenging industrial benchmark for SMT solvers handling BV non‑linearities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348711.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example (node 348711 of *intersection‑example‑simple.proof*).  It originates from the IJCAR 2012 paper on solving non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner, giving a relatively large instance (≈2.9 KB, 19 declared constants, one conjunct with a nesting depth of 21).  \n\nThe single top‑level assertion states the negation of an existential formula over a time variable `ts1624uscore0`; the formula encodes physical‑style safety constraints such as non‑negative speeds (`v1`, `v2`), bounded velocities (`v1 ≤ V`, `v2 ≤ V`), positive parameters (`A`, `B`, `V`, `ep`), and kinematic relations like  \n\\[\nxI1 > x1 + \\frac{v1^2}{2 A\\;ts1624uscore0},\\qquad\nxI2 > x2 + \\frac{v2^2}{2 A\\;ts1624uscore0},\n\\]  \nwith additional bounds on `ts1624uscore0`, `t1624uscore0` and the auxiliary variables.  \n\nThe goal is to prove that no assignment to the bit‑vectors satisfies all these constraints simultaneously (i.e., the VC is valid), which amounts to checking unsatisfiability of the negated existential.  Notably, the instance mixes non‑linear arithmetic (multiplication, division) and linear comparisons, all rendered in fixed‑width bit‑vector arithmetic, making it a challenging case for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290877.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding of a verification condition that originates from the KeYmaera safety proof for a “simple intersection’’ hybrid‑system model (see Loos & Platzer 2011).  It is presented in the SMT‑LIB 2.6 format, uses the **BV** logic, and contains 18 declared bit‑vector constants and a single, large conjunctive assertion of depth 21 (≈2.7 KB).  The core of the formula is a negated existential quantifier over a time variable `ts1355uscore0`; inside the quantifier a network of linear and non‑linear (quadratic) constraints relates positions (`xI1`, `x1`, `xI2`, `x2`), velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`) together with safety bounds (e.g., `v2*v2 ≤ 2*B*(xI2‑x2)`, non‑negativity of all physical quantities, and the requirement that a derived position stays within the interval [0, V]).  Additional Boolean conditions capture discrete mode information (`I1`, `I2` being 0 or 2) and enforce that the elapsed time stays within the given horizon (`t1355uscore0 ≥ 0`).  The whole assertion is wrapped in a top‑level `not`, so the solver is asked to prove that **no** assignment to the quantified time can violate the safety constraints—i.e., that the original hybrid‑system safety property holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37018.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and originates from a safety proof for a one‑lane intersection (see Loos & Platzer 2011).  It consists of a single, large assertion that negates an existential statement over a time‑step variable `ts82uscore1`.  Inside the quantified formula a conjunction of linear and non‑linear arithmetic constraints relates the variables `xI`, `x`, `v`, `A`, `B`, `V`, `ep` and several auxiliary terms, enforcing non‑negativity, upper bounds (`V`, `A`, `B` > 0), a kinematic inequality `xI > x + (v·v)/(2·B)`, and a bound on the expression `‑B·ts + vuscore4…` to stay within `V`.  The outer `not` turns the whole goal into “prove that no such `ts82uscore1` exists”, i.e. the safety condition is unsatisfiable.  The instance is relatively large (≈2.4 KB, 13 bit‑vector constants, depth 23) and exemplifies the encoding of non‑linear hybrid‑system verification problems into pure bit‑vector logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534610.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 19 declared 32‑bit variables, 1 top‑level assertion, max term depth 20) taken from the Keymaera hybrid‑systems verification suite and translated to bit‑vectors by Mathias Preiner (see the “intersection‑example‑simple” proof node 534610).  \nIt encodes a safety‑property check for a simple traffic‑intersection hybrid model: the solver is asked to prove that there is **no** 32‑bit time value `ts2533uscore0` for which a whole conjunction of arithmetic relations (initializations, non‑negative parameters `A`, `B`, `V`, `ep`, bounds on velocities `v1`, `v2`, and a quadratic term `bvmul v1 v1 / (2*B)`) together with the hybrid guard `bvsgt xI1 (x1 + …)` and the unsafe condition `bvslt xI2 x2` can hold.  \nThe constraints involve non‑linear bit‑vector arithmetic (multiplication, signed division, and several signed inequalities) and a small disjunction that captures two alternative ways the unsafe state could be reached (either `xI1` equals a special constant `x1uscore2dollarskuscore536` or a chain of bounds on `t2533uscore0`, `v1`, `v2` and the elapsed time `ep`).  \nThus the benchmark checks the unsatisfiability of a quantified formula that would witness a violation of the intersection safety invariant, illustrating the challenge of reasoning about hybrid‑system verification using bit‑vector encodings of non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369000.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance of size ≈ 2.8 kB (19 declared constants, a single quantified assertion) that originated from the KeYmaera hybrid‑system verifier and was translated to BV by Mathias Preiner for the 2017 Preiner‑keymaera suite. The formula asserts the **negation of an existential** statement over a time‑step variable `ts1722uscore0`; the inner condition encodes a large conjunction of safety‑related inequalities involving positions (`x1`, `x2`), velocities (`v1`, `v2`), bounds (`A`, `B`, `V`, `ep`) and the intersection identifiers (`I1`, `I2`). These constraints combine non‑linear arithmetic (e.g. `bvmul v1 v1`, `bvmul v2 v2`) with linear relations and signed‑comparison operators (`bvsgt`, `bvsge`, `bvsle`) to capture the requirement that two vehicles remain within allowed speed limits and keep a safe distance while crossing an intersection. The outer implication checks that, for any non‑negative elapsed time `t1722uscore0`, the quantified conditions cannot be satisfied, i.e. the safety property should be **unsatisfiable** (the model is expected to be `unsat`). The benchmark is classified as “industrial” and demonstrates how hybrid‑system verification conditions are encoded as bit‑vector arithmetic for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269013.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula originating from the KeYmaera verification of a traffic‑intersection hybrid system (the “intersection‑example‑simple” VC).  It contains 20 declared BV constants that model parameters such as velocities (v1, v2), bounds (V, A, B), a time horizon (ep) and several indexed copies of the same logical variables (e.g., I1, I2).  The single top‑level assertion is the negation of an existential quantifier over a time step ts1251uscore0, expressing that no value of ts can satisfy a conjunction of safety constraints: non‑negativity and upper bounds for the variables, the algebraic relation I1 = I2 = 2, a quadratic term (bvmul v2 v2) / (2·B) that appears in a distance inequality, and a deadline condition ts + 0 ≤ ep.  The formula therefore encodes the proof obligation that the hybrid system never reaches an unsafe state within the given horizon.  It is notable for translating a non‑linear real‑arithmetic VC into BV using multiplication, division and nested let‑bindings, yielding a relatively deep term graph (depth 20) typical of industrial verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252371.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the Preiner‑keymaera family, extracted from the KeYmaera safety verification of a traffic‑intersection example; it is classified as “industrial” and contains 19 declared constants, one top‑level assertion and about 2.8 KB of text.  \nThe asserted formula is the negation of an existential quantifier over a time variable `ts1174uscore0`, which encodes a verification condition that must hold for every reachable time instant up to a global bound `t1174uscore0`.  \nWithin the quantified body a large conjunction establishes non‑negativity of parameters (`A`, `B`, `V`, `ep`), bounds `0 ≤ v1,v2 ≤ V`, a linear relationship `v1 = A·ts + v1₍…₎` and a “reverse” relationship `v2 = –B·ts + v2₍…₎`, and a safety inequality `xI2 > x2 + v2²/(2·B)`.  \nAdditional constraints tie the hybrid‑system state variables (`xI1`, `x1`, `I1`, `I2`) to concrete constants (e.g., `I1 = 2`, `I2 = 2`) and require the overall execution time `t1174uscore0` to be non‑negative and not exceed the deadline `ep`.  \nThe benchmark is notable for mixing many bit‑vector arithmetic operators (addition, multiplication, signed division and comparison) with quantifiers and let‑bindings, making it a non‑linear BV verification problem that challenges current SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10279.smt2",
    "description": "The file is a 32‑bit bit‑vector encoding (logic BV) of a verification condition that originates from the KeYmaera hybrid‑system verifier (binary_driver example, node 10279).  It contains a single quantified formula: the existential variable `ts3_0` is introduced and the whole condition is wrapped in a top‑level `(not …)` so that the solver is asked to prove the formula unsatisfiable (i.e., to show the original VC holds).  The predicate combines many non‑linear relationships among the 14 declared bit‑vector constants, e.g.  \n\n* non‑negativity and ordering constraints such as `b > 0`, `ep > 0`, `amax > 0`, `d ≥ 0`, `v ≥ 0`;  \n* a bound on the square of a velocity term `v*v – d*d ≤ 2*b*(m – z)`;  \n* a more involved inequality that mixes products, divisions and squares of other variables (`vs^2 – dus^2 ≤ 2*b*(mu – ½*(…))`) together with the range `0 ≤ ts3_0 ≤ t3_0`.  \n\nThe encoding uses a dense mix of `bvmul`, `bvadd`, `bvsub`, and signed division (`bvsdiv`), reaching a maximum term depth of 22, which makes it a challenging example of non‑linear arithmetic encoded in bit‑vectors.  The benchmark is classified as “industrial” in the Preiner‑keymaera family and is relatively small (≈3 KB, 14 constants, 1 top‑level assertion).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174360.smt2",
    "description": "This benchmark is a 32‑bit BitVec (BV) verification condition coming from the **KeYmaera** hybrid‑system prover; it was extracted from the “intersection‑example‑simple” proof (node 174360) and translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category, 2 710 bytes, 18 declared constants).  \nThe single top‑level assertion is a negated existential `∃ ts` that encodes the search for a time instant `ts` (bounded by a given horizon `t811uscore0`) at which the continuous dynamics of two vehicles satisfy a collection of safety constraints.  \nInside a `let` the terms `?v_0 = -B·ts + v1` and `?v_1 = A·ts + v2` represent the velocities of the two cars after time `ts`; the antecedent forces non‑negative parameters (`A,B,V,ep > 0`), bounds (`0 ≤ v1,v2 ≤ V`), and geometric conditions such as `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`.  \nThe consequent requires that, if `ts` lies in `[0,t811uscore0]`, the computed velocities stay within `[0,V]` and the elapsed time does not exceed `ep`, after which either mode‑indicator `I1` or `I2` must be equal to 2.  \nThus the solver is asked to prove **unsatisfiability of the negated existential**, i.e. that there indeed exists a feasible `ts` meeting all hybrid‑system safety constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node13832.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) with 13 declared constants, a single large conjunctive assertion and a total size of 2 363 characters.  It originates from the KeYmaera hybrid‑system verifier (intersection‑example‑onelane proof node 13832) and was translated to bit‑vectors by Mathias Preiner, so it belongs to the “Preiner‑keymaera” industrial family.  \n\nThe core formula is a negated existential statement over the time‑stamp variable `ts29uscore1`; the body is a huge conjunction of range conditions (e.g., `0 ≤ ts29uscore1 ≤ t49uscore0dollarskuscore1`, `0 ≤ vuscore2dollarskuscore45 ≤ V`, `0 ≤ xI < x`, etc.) together with linear arithmetic involving a single multiplication by the negated constant `B` (`bvmul (bvneg B) ts29uscore1`).  \n\nKey constraints enforce non‑negativity and upper bounds for all physical quantities (position, speed, time, velocity limits `V`, etc.) and relate them through the hybrid dynamics (e.g., `bvadd (bvmul (bvneg B) t49uscore0dollarskuscore1) vuscore2dollarskuscore45 ≤ V`).  \n\nBy asserting the **negation** of the existential, the query asks the solver to prove that no assignment can satisfy all these safety conditions simultaneously; thus a SAT result would indicate a violation of the modeled intersection safety property, while UNSAT confirms the property holds.  \n\nTypical characteristics are deep nesting (max term depth 23), extensive use of signed‑bit‑vector comparisons (`bvsle`, `bvsge`, `bvslt`, `bvsgt`), and a mixture of arithmetic and logical connectives that stem from the original non‑linear arithmetic proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550261.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 19 32‑bit bit‑vector constants, 1 quantified assertion) taken from the Keymaera verification suite and translated to bit‑vectors by Mathias Preiner.  It encodes a safety verification condition for a simple traffic‑intersection hybrid system (the “intersection‑example‑simple” proof node 550261).  The core of the formula is a single existential query over a time stamp `ts2625uscore0`; inside a `let` it defines `?v_0 = A·ts2625uscore0 + v1₍₅₃₄₎` and then asserts a large conjunction of linear and non‑linear (quadratic) BV inequalities that model non‑negative variables, upper bounds by a global limit `V`, and a kinematic relation `xI2 > x2 + v2²/(2·B)`.  The outermost `not` turns the verification condition into a check for a counterexample: the solver must find values satisfying all the arithmetic constraints while also violating the safety disjunction `xI2 = x2₍₃₇₈₎ ∨ …`.  Notably, the benchmark mixes arithmetic over signed bit‑vectors (e.g., `bvslt`, `bvsge`, `bvsdiv`) with Boolean structure (`and`, `or`, `=>`) and a single quantifier, making it a typical non‑linear arithmetic challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node630639.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition taken from the KeYmaera hybrid‑system tool; it appears in the Jovanović & de Moura “Solving Non‑Linear Arithmetic” paper and in the “Safe intersections” case study. The file (≈3 KB, 20 declared constants, 1 top‑level assertion) asserts the **negation of an existential formula** over a time variable `ts3014uscore0`, so the solver is asked to show that no such witness exists, i.e., that the original safety property holds. Inside the quantified term the model captures several non‑linear relationships—e.g. `xI1 > x1 + (v1·v1)/(2·B)` and `xI2 > x2 + (v2·v2)/(2·B)`—using bit‑vector multiplication, signed division, and signed comparison operators, together with bounds such as `0 ≤ v1, v2 ≤ V`, `B>0`, `V>0`, and a global time limit `ep`. The condition also ties the intermediate variables `I1`, `I2` to fixed constants (0 and 2) and requires that the computed intermediate velocities (`?v_1`, `?v_3`) stay within `[0,V]`. Notably, the benchmark translates real‑valued nonlinear arithmetic into bit‑vector arithmetic, resulting in deep term nesting (max depth 21) and a mixture of signed and unsigned comparisons that stress BV solvers on industrial‑scale verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/extern-loop_sat_subset/medium0.smt2",
    "description": "This SMT‑LIB file is a single‑assertion benchmark in the **BV** logic, generated by the PEak hardware‑rewrite‑rule synthesis project (see the PEak GitHub link).  The instance is industrial‑scale (≈92 million characters, 25 declared constants, more than 1 billion AST nodes) and contains a massive quantified formula that builds a 5040‑bit vector by repeatedly concatenating dozens of 2‑, 5‑, 16‑, 31‑ and 512‑bit fields, then extracts many sub‑ranges, compares them with constants, and combines the results with a long cascade of `ite`, arithmetic (`bvadd`, `bvsub`, `bvmul`, `bvneg`), shifts (`bvlshr`, `bvashr`) and relational operators (`bvule`, `bvsle`, `bvslt`).  The core property being checked is that, for **all** possible values of the input fields, a certain 15‑bit slice of the constructed word must equal a specific constant (`#b...`) while satisfying a set of relational bounds and a Boolean flag (`ob_0 = #b1`), essentially encoding a correctness condition for a candidate hardware rewrite rule.  The benchmark stresses solvers with an extreme term‑depth (over 1 million), a huge number of `let` bindings (≈1.2 million) and a dense mixture of bit‑vector operations, making it a heavyweight test of quantifier handling, bit‑vector arithmetic, and reduction strategies.  It is intended for tools such as Boolector, CVC4, and Z3 that target the BV logic in industrial verification contexts.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node34026.smt2",
    "description": "This benchmark is a 32‑bit‑vector verification condition (logic **BV**) taken from the **KeYmaera** hybrid‑system prover and translated to bit‑vectors by Mathias Preiner (file *intersection‑example‑onelane.proof* node 34026).  It encodes a safety VC for a one‑lane traffic‑intersection scenario, where the constants A, B, V, ep, v, x, xI, I1, etc. model physical parameters such as bounds on velocity, position and a control variable I1 that is required to equal 2.  The single assertion is a negated existential formula over a time variable ts75; the body contains a large conjunction of linear and non‑linear (quadratic) bit‑vector inequalities (e.g. bvmul v v, bvsdiv (bvmul v v) (2·B)) together with range constraints (bvsle/bvsge) that model the hybrid dynamics and the requirement that the state stays within the safe region.  The outer **not‑exists** means the solver is asked to show that no assignment to ts75 can violate all the premises, i.e., that the VC is valid.  Notable features are the use of a single quantified variable, mixed arithmetic (addition, multiplication, division) on 32‑bit vectors, a relatively deep term structure (depth 21) and a compact size of 2 3 2 7 characters, typical of industrial‑level non‑linear arithmetic benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369346.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) with 19 declared constants and a single quantified assertion, totalling about 2.8 KB and 2819 AST nodes (max term depth 19).  It originates from the Keymaera verification suite (intersection‑example‑simple.proof, node 369346) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera family.  The core of the formula is an `exists ts1724_0` that couples several linear and non‑linear BV arithmetic constraints: fixed integer parameters (A, B, V, ep), non‑negative velocities (v1, v2) bounded by V, and position‐related inequalities that enforce `xI1` and `xI2` to stay ahead of `x1` and `x2` by a safety margin computed as `v₁²/(2·B)` and `v₂²/(2·B)`.  Additional side conditions require the indices I1 and I2 to equal 2, A and B to be non‑negative, and the derived terms `?v_1 = -B*ts + v1` and `?v_2 = A*ts + v2` to lie within `[0,V]` while the elapsed time `ts` stays between 0 and a global bound `ep`.  The instance therefore checks that, under these hybrid‑system safety assumptions, there exists a feasible time step satisfying all bounds, a typical safety‑verification condition for a vehicle intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365878.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition that originates from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 365878), a safety example about a road intersection used in the IJCAR 2012 and CADE 2009 papers. It contains a single quantified assertion that states **¬∃ ts** such that a large conjunction of arithmetic constraints holds, i.e., the solver must show that the quantified formula is unsatisfiable. The constraints model non‑linear arithmetic (quadratic terms v₁·v₁ and v₂·v₂) together with divisions, and they enforce non‑negativity of all variables (A, B, V, ep > 0, 0 ≤ v₁, v₂ ≤ V) as well as safety inequalities like  \n\\(xI₁ > x₁ + \\frac{v₁^{2}}{2B}\\) and \\(xI₂ > x₂ + \\frac{v₂^{2}}{2B}\\).  \nAdditional temporal conditions relate the auxiliary timestamps ts₁₇₀₃ and t₁₇₀₃ (both ≥ 0) and bound their sum by the deadline ep. The instance is relatively small (≈2.8 kB, 18 declared constants, depth 21) but features a deep nesting of conjunctions, a let‑binding for reusable sub‑expressions, and a mixture of signed‑comparison and arithmetic operators, making it a typical industrial‑style non‑linear arithmetic benchmark for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559861.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example described in the Loos‑Platzer paper.  It originates from the industrial family *Preiner‑keymaera* (file BV/2017‑Preiner‑keymaera/intersection‑example‑simple.proof‑node559861.smt2) and contains a single, rather large assertion (≈2.8 KB, 19 declared constants, max term depth 20).  \n\nThe formula asserts the *negation* of an existential statement over a time‑offset variable `ts2668_0`; consequently the SAT check succeeds only if the original safety condition is universally true.  Inside the existential, a `let` binds two linear expressions `?v_0 = A*ts + v1` and `?v_1 = –B*ts + v2`, which model the evolution of two velocity‑like quantities over time, together with a quadratic term `bvmul v2 v2` appearing in a division that encodes the distance covered under constant deceleration.  \n\nThe constraints enforce:\n* non‑negativity and upper bound `V` for all variables (`v1, v2, A, B, V, ep`);\n* specific index values (`I1 = 2`, `I2 = 2`, `I2 = 2` and `I2 = 2` corresponds to a mode flag `?v_2`);\n* ordering relations among positions (`xI1 < x1`, `xI2 > x2 + v2²/(2·B)`);\n* that the computed velocities `?v_0` and `?v_1` stay within `[0, V]` during the interval `0 ≤ ts ≤ t2668_0`, and that the interval does not exceed a deadline `ep`.  \n\nOverall, the instance checks that, under the given non‑linear arithmetic model of vehicle motion, no reachable state violates the safety predicate (i.e., the intersection is never entered while both cars are moving), and it does so by translating the original real‑valued proof obligation into bounded‑width bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345278.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in Platzer et al.’s transportation‑system case study.  It comes from the Preiner‑keymaera family (file *intersection‑example‑simple.proof‑node345278.smt2*), originally a non‑linear arithmetic VC that has been translated to bit‑vectors by Mathias Preiner; the file contains 19 declared 32‑bit variables, a single quantified assertion and about 2.8 KB of SMT‑LIB text.  \n\nThe core formula asserts the *non‑existence* of a time‑step value `ts1607_0` that would violate a safety invariant: all vehicle speeds `v1`, `v2` must lie between 0 and a global bound `V`, the positions `xI1`, `xI2` must stay ahead of their respective start points by at least the signed division of the squared speeds by a non‑zero denominator, and several auxiliary constants (`A`, `B`, `I1`, `I2`, `ep`) are constrained to be non‑negative and consistent with the hybrid‑system dynamics.  \n\nThe condition combines non‑linear arithmetic (products `v1*v1`, `v2*v2`, and divisions `bvsdiv`) with linear signed comparisons (`bvsge`, `bvsle`, `bvsgt`) and uses a quantified `exists` together with `let`‑bound intermediate terms to keep the term depth moderate (max 20).  \n\nThe benchmark thus checks whether the encoded safety property is provable (i.e., the negated existential is unsatisfiable) for the given bit‑vector abstraction of the hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152733.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial‑type problem (size ≈ 2.8 KB, 19 declared constants and a single, fairly deep quantified assertion).  \nThe formula asserts the negation of an existential statement over a time variable `ts707uscore0`; it therefore checks that no witness for `ts707uscore0` can violate the safety condition encoded inside the `let`.  \nThe safety condition models a simple intersection scenario: two vehicles with positions `x1`, `x2` and velocities `v1`, `v2` (bounded by `V` and non‑negative) must satisfy relational constraints such as `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`, while the acceleration/deceleration parameter `B` is positive and the initial distances `I1`, `I2` are fixed to 2.  \nInside the quantified part the dynamics are expressed with bit‑vector arithmetic (`bvmul`, `bvadd`, `bvsdiv`) and the guard `bvsge ?v_0 (0)` where `?v_0 = -B·ts707uscore0 + v1uscore2dollarskuscore229` captures the reachable position after time `ts707uscore0`.  \nThe overall check therefore asks the solver to prove that, under all admissible parameter ranges (`A, B, V, ep > 0`, etc.), the unsafe condition (`xI2 = x2`) cannot occur, which is a typical safety‑verification condition for hybrid‑system models of road‑intersection control.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node733082.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition from the KeYmaera hybrid‑system prover, taken from a “safe‑intersection” example (node 733082) and translated to BV by Mathias Preiner.  It belongs to the industrial category, appears in the Preiner‑keymaera family, and consists of a single large assertion (size ≈ 2.9 KB, 19 declared constants, term depth 20).  The asserted formula is the negation of an existential statement over a time variable `ts3574uscore0`, and it encodes a set of non‑linear arithmetic constraints on positions (`x1`, `x2`), velocities (`v1`, `v2`), a common bound `V`, and parameters `A`, `B`, `ep` that model the dynamics of two vehicles approaching an intersection.  The constraints require non‑negative speeds, upper bounds by `V`, positive accelerations, and that the projected positions after a time step (using `bvmul` and `bvsdiv` for the quadratic terms `v^2/(2*B)`) remain ahead of the current positions, while also keeping the elapsed time within the allowed horizon `ep`.  Proving the negated existential unsatisfiable amounts to showing that under these safety assumptions no violating state exists, i.e., the intersection‑control invariant holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476116.smt2",
    "description": "The file is a 2‑solver (BV) benchmark of size 2793 characters containing a single, heavily nested assertion that is the negation of an existential formula; solving it amounts to proving that the existential is unsatisfiable. It originates from the KeYmaera hybrid‑systems verifier (intersection‑example‑simple.proof, node 476 116) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera benchmark suite. The core of the formula quantifies over a 32‑bit “time‑step’’ `ts2257uscore0` and relates a collection of 32‑bit variables (e.g., `I1`, `I2`, `A`, `B`, `V`, `v1`, `v2`, `x1`, `x2`) with a mixture of equalities, signed‐greater/less‑than comparisons and linear arithmetic such as `bvadd`, `bvmul`, and a signed division. The constraints enforce non‑negativity of parameters, bounds like `0 ≤ v1 ≤ V`, `0 ≤ v2 ≤ V`, and a safety condition `bvsgt V 0` together with a relationship between positions (`xI1`, `xI2`) and velocities (`v1`, `v2`) that models a safe vehicle intersection. A secondary implication checks that if a derived time variable `t2257uscore0` is non‑negative then the time step lies within `[0, t2257uscore0]`, the computed linear expression `A*ts2257uscore0+v2` stays in `[0,V]`, and the overall horizon `ep` exceeds the step, finally requiring either `ts2257uscore0 = 2` or a fixed flag `I2 = 2`. Proving unsatisfiability of the outer `not` therefore verifies that no execution can violate the prescribed safety constraints under the given integer‑bounded (32‑bit) model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601673.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety proof obligation that originates from the KeYmaera hybrid‑system verifier (the “intersection‑example” from a safe‑intersection case study).  It is an industrial‑style instance (size ≈ 2.7 kB, 18 declared constants, a single large quantified assertion) translated to BV by Mathias Preiner and taken from the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper.  \n\nThe formula asserts the **negation** of an existential statement: there must exist a time‑step variable `ts2858_0` such that a collection of arithmetic constraints on positions, velocities and parameters (`A`, `B`, `V`, `ep`, …) are simultaneously satisfied.  The constraints encode basic physics (e.g., `v1 ≥ 0`, `v2 ≥ 0`, `A ≥ 0`, `B > 0`, `V > 0`) together with safety conditions such as  \n`xI1 < x1` and `xI2 > x2 + v2²/(2·B)`, and also bound the linear expressions `A·ts + v1` and `‑B·ts + v2` inside the interval `[0,V]`.  \n\nKey properties being checked are whether any reachable state violates these bounds before a deadline `ep`; the outer `not` turns the goal into a validity check (the solver should return `unsat`).  The instance is notable for mixing non‑linear multiplication and signed division inside bit‑vector arithmetic, resulting in a relatively deep term structure (depth 19) and a dense conjunction of `and`, `bvsle`, `bvsge`, and equality atoms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152942.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe intersection” example; it appears in the Jovanovic‑de Moura IJCAR 2012 paper and was translated to bit‑vectors by Mathias Preiner (file intersection‑example‑simple.proof‑node152942.smt2, 2760 bytes, 18 declared constants, 1 top‑level assertion).  \nThe single assertion is the negation of an existential formula over a time‑step variable `ts708$0`; the body of the existential is a large conjunction of equalities, signed‑inequalities and arithmetic relations that model safety constraints such as non‑negative velocities (`v1`, `v2`), bounded speed (`v1 ≤ V`, `v2 ≤ V`), positive parameters (`A`, `B`, `V`, `ep`), and positional relationships (`xI1 > x1 + v1²/(2·B)`, `xI2 < x2`).  \nA key derived term `?v_0 = -B·ts708$0 + v1_230` is required to stay within `[0,V]` and to respect a deadline (`ts708$0 + 0 ≤ ep`), while another branch forces `I2 = 2` (the disjunct `or (= 0 2) ?v_1` reduces to `?v_1`).  \nThe overall check‑sat asks whether the negated existential is satisfiable; a SAT result would mean the original safety condition is violated, while UNSAT confirms the KeYmaera VC holds.  \nNotably, the instance uses only signed bit‑vector arithmetic to represent the original non‑linear real arithmetic, leading to deep term nesting (max depth 21) and a dense mix of `bvsgt`, `bvsle`, `bvmul`, and `bvsdiv` operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631164.smt2",
    "description": "The file is a 2‑KB BV‑logic benchmark (logic = BV, 20 declared 32‑bit constants, 1 top‑level assertion, max term depth 21) taken from the Keymaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (category = industrial, family = Preiner‑keymaera).  \nIt encodes a safety verification condition for a simple road‑intersection scenario: the quantified sub‑formula introduces an existential time stamp `ts3017uscore0` and then defines a long conjunction of arithmetic relationships among distances, velocities (`v1`, `v2`), bounds (`A`, `B`, `V`, `ep`) and intermediate variables (`xI1`, `xI2`, `I1`, `I2`).  \nKey constraints enforce non‑negativity of all parameters, upper bounds by a global limit `V`, and quadratic progress terms such as `bvsdiv (bvmul v1 v1) ?v_0` that model stopping distances; additional inequalities compare these progress distances with the current positions (`xI1 > x1 + …`, `xI2 > x2 + …`).  \nThe final part of the formula asserts that, if the time stamp lies within `[0, t3017uscore0]` and all the previous bounds hold, then either the absurd equality `1 = 2` or a specific Boolean flag `I2uscore4dollarskuscore578 = 2` must be true—making the whole assertion unsatisfiable under the intended safety assumptions.  \nThus the benchmark checks that the encoded safety condition cannot be violated, serving as a challenging non‑linear arithmetic‑to‑bit‑vector translation test for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351935.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (size ≈ 2.9 KB, 19 declared constants, a single large conjunct) taken from the **KeYmaera** hybrid‑system verification suite; it was extracted from the “intersection‑example‑simple” proof node 351 935 and translated to BV by Mathias Preiner.  \nIt encodes a safety condition for a road‑intersection scenario: two vehicles with positions `x1`, `x2`, velocities `v1`, `v2` and bounded accelerations `A`, `B` must stay ahead of the points `xI1`, `xI2` that represent the intersection entry, while a positive time‑step `ts1639_0` is allowed to elapse.  \nThe formula asserts **¬∃ ts1639_0** such that a whole set of arithmetic constraints holds; these constraints include linear and quadratic relations (`bvmul v1 v1`, `bvmul v2 v2`), division by a term `?v_0 = 2·B – 2·B·ts`, and interval bounds (`0 ≤ v ≤ V`, `0 ≤ A, B, V, ep`).  \nKey properties being checked are: (1) that the future positions computed with the given accelerations remain greater than the intersection positions (`bvsgt xI1 …`, `bvsgt xI2 …`), (2) that all state variables stay within prescribed non‑negative ranges, and (3) that the elapsed time does not exceed the deadline `ep`.  \nThe instance is notable for mixing non‑linear arithmetic (quadratic terms) with bit‑vector semantics, using a single existential quantifier and a heavyweight `let`‑binding, which makes it a challenging case for BV solvers handling arithmetic‑heavy hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node10952.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition that originates from the KeYmaera proof of the European Train Control System (node 10952).  It belongs to the industrial “Preiner‑keymaera” family, contains 15 declared constants, a single quantified assertion and about 3 kB of text (max term depth 23).  The formula asserts, under a universal quantification (the outer `not (exists …)`), a conjunction of linear and non‑linear inequalities such as `v² – d² ≤ 2·b·(m – z)`, `vuscore² – duscore² ≤ 2·b·(muscore – 0.5·… )`, and several bounds on time, acceleration, and auxiliary variables, all expressed with BV operations (`bvmul`, `bvsdiv`, `bvadd`, `bvsub`, `bvneg`, etc.).  The problem therefore checks whether the encoded safety lemma holds for *all* admissible timestamps `ts0`, i.e., whether the set of bit‑vector constraints is unsatisfiable.  It is notable for translating a nonlinear real‑arithmetic verification condition into fixed‑width bit‑vector arithmetic, resulting in a dense use of multiplication and division operators and a relatively deep term structure.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node534722.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition generated by the KeYmaera hybrid‑system prover for a “safe‑intersection” example (node 534722 of *intersection‑example‑simple.proof*).  It originates from the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and was translated to BV by Mathias Preiner, yielding a formula of about 2.9 KB with 20 declared constants and a single, fairly deep assertion (max term depth 20).  The core of the assertion is an existential quantifier over a time‑step variable `ts2534uscore0`, together with a large conjunction of linear and non‑linear (multiplication, division) inequalities that model positions (`xI1`, `xI2`, `x1`, `x2`), velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`).  These constraints enforce positivity and upper bounds on the parameters, require the two cars to start within safe speed limits, and express a safety property that the future position of car 1 never overtakes car 2 within the time horizon unless a trivial equality holds.  Notably, the formula mixes signed‑bit‑vector comparisons (`bvsgt`, `bvsge`, `bvsle`) with non‑linear arithmetic (`bvmul`, `bvsdiv`) and contains a disjunction that captures an alternative case for the invariant, making it a challenging industrial‑style verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287256.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  The single top‑level assertion is the negation of an existential formula over a time variable `ts1338uscore0`; the formula contains a `let` that defines two linear expressions `?v_0 = A·ts + v1` and `?v_1 = –B·ts + v2`, which model the positions of two vehicles after a time step.  The antecedent of the implication imposes a large conjunction of safety and domain constraints: mode indicators (`I1`, `I2`) are fixed, the initial velocities `v1`, `v2` lie in `[0,V]` with `V>0`, the deceleration/acceleration constants `A,B` are non‑negative, the initial positions satisfy `xI1 < x1` and `xI2 > x2 + v2²/(2·B)`, and the time step itself is bounded between 0 and a positive epsilon (`ep`).  The consequent requires that the computed positions `?v_0` and `?v_1` stay within `[0,V]` and that the time step does not exceed `ep`.  Thus the solver is asked to prove that **no** assignment to the quantified time variable can violate the safety bounds, i.e., to show the VC is unsatisfiable.  The instance is a non‑linear arithmetic problem translated to bit‑vectors, contains 18 declared constants, a single deep (`max_term_depth = 20`) assertion, and originates from the industrial‑style “Preiner‑keymaera” benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node247731.smt2",
    "description": "This benchmark is a 2 KB BV‑logic instance (32‑bit bit‑vectors) from the Preiner‑keymaera family, taken from the KeYmaera verification of a “safe intersection” hybrid‑system example (node 247731 of *intersection‑example‑simple.proof*).  It contains a single quantified assertion: the negation of an ∃ ts₁₁₅₀ ∀ t₁₁₅₀ implication that models a safety verification condition (VC) for the intersection controller.  The VC encodes numerous linear and non‑linear constraints on the system parameters (A, B, V, ep) and on the state variables (x₁, x₂, xI₁, xI₂, v₁, v₂), including positivity, upper‑bounds (≤ V), and a non‑linear term bvmul v₂ v₂ ⁄ bvmul 2 B that represents a quadratic velocity bound.  The core property being checked is that, under these premises, the computed positions (via ?v₀ = A·t + v₁ and ?v₂ = A·t + v₂) stay within the allowed interval [0, V] and that the elapsed time stays below a deadline ep.  Notably, the formula is heavily nested with lets, many Boolean connectives, and a maximum term depth of 21, illustrating the difficulty of handling bit‑vector encodings of mixed‑integer non‑linear arithmetic in industrial‑scale verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46832.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it originates from the “intersection‑example‑onelane” proof node 46832 and was translated to BV by Mathias Preiner.  The file contains a single, large assertion that negates an existential query over the variable ts105₀, so the solver is asked to show that no assignment to the quantified variable can satisfy a conjunction of numerous non‑linear arithmetic constraints.  The conjuncts enforce basic safety conditions on the system variables (e.g., A, B, V, ep, v are non‑negative and often strictly positive, B > 0, V > 0, ep > 0) and relate them through multiplications, divisions and additions such as bvadd xI ( … ) and bvmul (bvsdiv A B) …, capturing the vehicle dynamics at a road intersection.  Additional constraints bound the time variable ts105₀ between 0 and t195₀, restrict the control‑input I1 to specific constants (1 or 2), and require a final inequality bvadd (bvmul ?v_3 t195₀) vuscore4… ≥ 0, which together encode the safety proof obligation.  The instance is relatively large (≈ 2.7 k characters, 13 declared constants, max term depth 25) and typifies industrial verification problems that involve non‑linear bit‑vector arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559428.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) originating from the KeYmaera hybrid‑system verifier; it is listed in the Preiner‑keymaera family and was taken from the “intersection‑example‑simple” proof node 559428 (≈2.9 KB, 20 declared constants, one quantified assertion). The formula asserts the negation of an existential query over a time variable ts2665₀, encoding a safety verification condition for a road‑intersection scenario whose variables denote positions (x₁, x₂, xI₁, xI₂), velocities (v₁, v₂), bounds (V), and parameters (A, B, ep). The core constraints enforce non‑negativity and upper bounds (e.g., 0 ≤ v₁, v₂ ≤ V, 0 < V, 0 < B, 0 < ep), a strict ordering xI₁ < x₁, a lane‑change condition xI₂ > x₂ + v₂² / (2·B), and a linear relationship ?v₀ = A·ts2665₀ + v₁₅₇₆ that must stay within [0,V]. Additionally, the assertion includes auxiliary equalities (e.g., I2₅₇₆ = 2, I1₅₇₆ = 0) and a trivial disjunction (1 = 2 ∨ I2₅₇₆ = 2) that forces the quantified part to be examined. Satisfiability of the whole formula means a counterexample to the safety condition exists; the benchmark is notable for mixing non‑linear bit‑vector arithmetic (multiplication, division, signed comparisons) with a single quantifier and a relatively deep term structure (depth 21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704363.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example from the paper *Safe intersections: At the crossing of hybrid systems and verification* (Loos & Platzer, ITSC 2011).  It comes from the Preiner‑keymaera family (SBM‑2017) and contains 18 declared constants, a single quantified assertion and about 2.7 kB of text (max term depth 20).  The formula asserts the negation of an ∃ ts₀ such that a long conjunction of signed‑comparison constraints holds; the conjuncts encode bounds on two velocities (v1, v2), positions (x1, x2, xI1, xI2), a distance limit V, and timing variables (t₃₃₉₄, ts₀, ep) together with nonlinear relations (e.g., v₁·v₁ / (2·B) and a term ‑B·ts₀ + v₂).  The condition checks that, under the assumed non‑negative parameters (A, B, V, ep > 0) and the hybrid‑system dynamics, no reachable state violates the safety predicate (e.g., xI₂ < x₂ while other bounds hold).  Notably the encoding uses signed‑greater‑than/less‑than, multiplication, division and negation on 32‑bit bit‑vectors to simulate the original real‑valued arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271104.smt2",
    "description": "The benchmark is a single‑assertion verification condition originally generated by the KeYmaera hybrid‑systems prover and then bit‑vector‑encoded by Mathias Preiner; it lives in the BV logic of SMT‑LIB 2.6, has 20 declared 32‑bit bit‑vector constants, a depth‑20 term graph and a total size of about 2.9 KB (2860 characters).  \nIts structure is an existential quantification over a time‑step variable `ts1263uscore0`, followed by a large nested implication that couples several “parameter” variables (`A`, `B`, `V`, `ep`) with safety bounds on the state variables (`x1`, `x2`, `v1`, `v2`, `I1`, `I2`).  \nThe key constraints enforce non‑negativity of all parameters, upper bounds `v1 ≤ V`, `v2 ≤ V`, a quadratic relation `xI2 > x2 + (v2·v2)/(2·B)`, and a linear evolution `?v_0 = A·ts1263 + v2` that must stay within `[0,V]` while the elapsed time stays below `ep`.  \nThe formula also contains a Boolean guard `I1 = 2` (and similarly for `I2`) that selects a particular mode of the hybrid system, and the outermost `not` asserts that the whole existential condition should be unsatisfiable – i.e., that the safety property holds.  \nThus the instance checks that, under the given non‑linear arithmetic relationships encoded as 32‑bit bit‑vectors, no reachable state violates the prescribed intersection‑safety invariants.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node3458.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance from the **Keymaera** family, originally a safety proof for an adaptive cruise‑control controller and translated to BV by Mathias Preiner (size ≈ 2.5 KB, 12 declared constants, one large conjunct).  \nThe formula asserts the **negation of an existential condition**: it asks whether there exists a time stamp `ts1` (restricted to 0 ≤ ts1 ≤ t₁) such that a chain of pre‑conditions holds (non‑negative parameters A, B, ε, monotone speeds v₁ ≤ v₂, ordered positions x₁ < x₂, and a lower bound on ts1) and a **quadratic safety inequality** fails.  \nThe safety inequality is the classic hybrid‑system condition  \n\\[\n\\frac12\\bigl(A\\cdot t₁^{2}+2\\cdot t₁\\cdot v₁+2\\cdot x₁\\bigr)\\;<\\;t₁\\cdot v₂+x₂,\n\\]  \nexpressed with BV operations (`bvmul`, `bvadd`, `bvsdiv`).  \nThus the solver must prove that **no such ts1 exists**, i.e., the safety property holds for all admissible states.  \nThe problem is notable for embedding non‑linear real‑arithmetic reasoning (a quadratic term) into fixed‑size bit‑vectors, making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node154163.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the Keymaera verification suite for the “safe‑intersection” hybrid‑system example (node 154163 of *intersection‑example‑simple.proof*). It is an industrial‑style verification condition of modest size (≈2.7 KB, 18 declared constants and a single quantified assertion). The formula negates an existential statement over a time variable ts714₀, requiring that, under a collection of non‑negative parameters (A, B, V, ep) and invariant predicates (I1 = 2, I2 = 2, I1′ = 0, I2′ = 0), the linear reachability expressions  \n    _v₀ = A·ts714₀ + v1′_ and  _v₁ = –B·ts714₀ + v2′_ stay within the interval [0, V] while also respecting safety inequalities on the vehicle positions (e.g., xI1 > x1 + v1²/(2·B), xI2 < x2). The constraints combine linear arithmetic, a quadratic term (bvmul v1 v1) inside a signed division, and several signed‐comparison predicates (bvsgt, bvsge, bvsle). Satisfiability of the negated existential corresponds to proving that no reachable state violates the safety condition, i.e., that the intersection remains safe under the given bounds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171228.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera verification suite; it originates from the “intersection‑example‑simple” proof node 171228 that models a safe traffic‑intersection scenario. The single asserted formula is the negation of an existential statement over a time variable ts, meaning the solver must show that no value of ts can satisfy a conjunction of hybrid‑system constraints. The constraints encode two vehicles’ linear motion ( ?v₀ = A·ts + v₁₀, ?v₁ = ‑B·ts + v₂₀ ) together with bounds on accelerations (A,B ≥ 0), velocities (0 ≤ v₁,v₂ ≤ V), and a safety condition that the position of the first car stays ahead of a quadratic term (xI₁ > x₁ + v₁² / (2·B)) while the second car remains behind x₂, all within a time horizon ep. Additional side conditions force the mode variables I₁ and I₂ to be the constant 2 and require the overall time horizon ep and the maximum speed V to be positive. The problem therefore checks the non‑existence of a counterexample to the intersection safety invariant, and it is notable for embedding real‑arithmetic‑style non‑linear operations (multiplication, division, quadratic term) into a pure bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal4-node5686.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (size ≈ 3 KB, 15 declared constants, 1 quantified assertion) taken from the Keymaera verification of the European Train Control System (the “train_goal4” safety goal, node 5686). The sole formula is an *unsatisfiability* query: it asks the solver to prove that there is **no** value for the time variable `ts4uscore0` that can satisfy a large conjunction of arithmetic inequalities. The constraints model a train‑braking scenario – variables such as `b` (braking deceleration), `A` (acceleration), `v` (velocity), `d` (distance), `m`, `z`, etc., are required to be non‑negative and to obey quadratic relationships (e.g., `v² – d² ≤ …`, `b·ts + v ≤ 0`) and linear bounds that involve division and multiplication by constants. The property being checked is essentially a safety invariant (e.g., “the train never exceeds a safe stopping distance”) expressed as a set of non‑linear BV inequalities. Notably, the benchmark features extensive non‑linear BV arithmetic (21 `bvmul`, several `bvsdiv`, and nested `let`‑bindings) and a maximum term depth of 23, making it a challenging industrial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node14168.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic **BV**) that originates from the KeYmaera hybrid‑system verifier; it represents verification condition 14168 of the “intersection‑example‑onelane” proof (industrial‑category, size ≈ 2.3 KB). The formula introduces a single existentially‑quantified time variable `ts30uscore1` and, via a `let`, defines `?v_0 = A * ts30uscore1 + vuscore2dollarskuscore47`; the main body is a large implication whose antecedent conjoins range constraints on `ts30uscore1`, non‑negativity and upper‑bounds for parameters `A`, `B`, `V`, `ep`, `v`, and `vuscore2dollarskuscore47`, as well as ordering constraints such as `xI < xuscore2dollarskuscore41`, `xI < x`, and `I1 = 2`. The consequent asserts a safety bound `bvadd (bvmul A t51uscore0dollarskuscore1) vuscore2dollarskuscore47 ≤ V`. The whole assertion is wrapped in a `not (exists …)` which asks the solver to prove that **no** choice of `ts30uscore1` can satisfy all those constraints for any assignment to the remaining free constants. Hence the SMT problem checks the validity of a hybrid‑system safety condition that involves non‑linear (multiplicative) arithmetic encoded as bit‑vector operations, a characteristic feature of the Preiner‑keymaera benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19598.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition that originated from a KeYmaera proof of a “safe intersection” hybrid‑system model; it was translated to BV by Mathias Preiner and appears in the Preiner‑keymaera industrial family (size ≈ 2.6 KB, 13 declared constants, 1 quantified assertion).  \nThe single top‑level assertion is the negation of an existential formula over a time variable `ts43uscore0`, so the solver is asked to show that no value of this variable can satisfy a large conjunction of arithmetic constraints.  \nThe constraints express typical safety invariants: non‑negativity and upper bounds for timestamps (`ts43uscore0` between 0 and `t75uscore0dollarskuscore0`), bounds on velocities (`v`, `V`), positivity of parameters (`A`, `B`, `ep`), and a complex inequality that combines positions `xI`, `x`, a linear term in `ts43uscore0`, and several non‑linear terms such as `(bvmul vuscore2dollarskuscore68 vuscore2dollarskuscore68)` and divisions by `B`.  \nThe formula also fixes the discrete mode variables `I1` and `I1uscore2dollarskuscore64` to specific values (1 and 2) and requires `xI` to be greater than a computed expression, modelling a reachability or collision‑avoidance condition.  \nBecause the outermost operator is `not (exists …)`, the check succeeds only if the encoded safety property is universally true; the presence of non‑linear multiplications and divisions makes the instance challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node170139.smt2",
    "description": "The benchmark is a 32‑bit Bit‑Vector (BV) instance (logic BV) coming from the “keymaera” family of verification conditions; it was translated from a KeYmaera proof of a safe‑intersection hybrid‑system example (see Loos & Platzer, ITSC 2011) and submitted by Dejan Jovanović (Preiner’s 2017 BV collection).  It contains a single, fairly large assertion (≈2.7 KB, 18 declared constants, max term depth 21) that is the negation of an existential formula — the solver must show that no value of the existential time variable ts787₀ can satisfy the inner constraints.  \n\nThe inner formula encodes a hybrid‑system VC: linear and non‑linear relationships among variables that model positions (x₁,x₂), velocities (v₁,v₂), a braking constant B, a speed limit V, and other parameters (A, ep).  Key constraints assert non‑negativity of all physical quantities, upper bounds v₁,v₂ ≤ V, positivity of B, V, ep, and a quadratic kinematic relation `xI1 > x1 + v1²/(2·B)`.  Additional bounds force the derived expressions `?v_0 = -B·ts787₀ + v1'` and `?v_2 = -B·ts787₀ + v2'` to stay within `[0,V]`, and the elapsed time `ts787₀` to be between 0 and a deadline `t787₀`, with the overall time budget `ts787₀+0 ≤ ep`.  \n\nThus the problem checks whether the hybrid‑system safety condition holds for all admissible time steps; its difficulty stems from the combination of quantified bit‑vector arithmetic, non‑linear multiplication and division, and multiple nested inequalities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392932.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2721 with 18 declared constants, taken from the KeYmaera “intersection‑example‑simple” proof (node 392932) and translated to bit‑vectors by Mathias Preiner for the SMT‑LIB “Preiner‑keymaera” industrial family.  The single top‑level assertion is the negation of an existential formula ∃ ts1839uscore0 … , so the solver is asked to show that no value of this time‑parameter can satisfy the safety constraints.  The constraints encode a hybrid‑system safety condition for a road‑intersection: they require non‑negative bounded variables (velocities v1,v2, limits V, A, B, etc.), quadratic terms v1·v1 and v2·v2 scaled by 2·B, and comparisons asserting that the future positions xI1, xI2 exceed the current positions plus these scaled squares while staying within the overall bound V.  Additional bounds enforce ts1839uscore0 to lie between 0 and a global time t1839uscore0, to keep the accumulated time (ts1839uscore0+0) below a deadline ep, and to respect a mode‑switch indicator (I1, I2 equal to 2).  The formula therefore checks the unsatisfiability of a non‑linear arithmetic safety condition encoded entirely with 32‑bit bit‑vector operations, making it a challenging benchmark for solvers that must handle multiplication, division and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node694990.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition extracted from the KeYmaera hybrid‑system verifier, specifically the “intersection‑example‑simple” proof node 694990 that models a safe traffic‑intersection scenario.  It is a single, fairly large assertion (≈ 2.9 KB, 20 declared constants and a maximum term depth of 21) that states the negation of an existential formula over a fresh time variable `ts3337uscore0`; the solver is therefore asked to prove the original condition unsatisfiable.  The formula combines linear and non‑linear arithmetic on bit‑vectors, featuring multiplications (`bvmul`) of variables such as `A` and `ts3337uscore0`, a signed division (`bvsdiv`) of a square (`v1*v1`), and several inequalities (`bvslt`, `bvsle`, `bvsgt`, `bvsge`) that encode physical constraints like non‑negative speeds, bounded velocity `V`, and a positive safety margin `ep`.  Important logical structure includes a chain of conjuncts that enforce relationships between positions (`xI1`, `xI2`), velocities (`v1`, `v2`), and control parameters (`A`, `B`), together with an `or` that captures a case split on a trivial equality (`1 = 2`) and the fixed condition `I2 = 2`.  Because the instance comes from an industrial case study (category “industrial”, family “Preiner‑keymaera”) and uses non‑linear bit‑vector arithmetic, it is a typical hard benchmark for solvers that must handle both quantifier reasoning and mixed arithmetic in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392708.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera hybrid‑system verification suite and translated to SMT‑LIB by Mathias Preiner (see the cited “intersection‑example‑simple” proof node).  It contains a single quantified assertion (an existential over the time‑stamp `ts1837uscore0`) that encodes the safety conditions of a simple vehicle‑intersection scenario: non‑negative parameters `A`, `B`, `V`, `ep`; bounds `0 ≤ v1, v2 ≤ V`; and distance updates `xI1 > x1 + (v1·v1)/(2·B)` and `xI2 > x2 + (v2·v2)/(2·B)`.  The core arithmetic mixes non‑linear multiplication (`bvmul v1 v1`, `bvmul v2 v2`) with a division (`bvsdiv …`) and several linear constraints, all expressed over 32‑bit bit‑vectors.  The outer implication also requires that the auxiliary variable `?v_1` (a linear combination of `B`, `ts1837uscore0` and `v1`) stays within `[0,V]` and that the elapsed time stays below `ep`.  The whole formula is negated and checked for unsatisfiability, i.e., it verifies that no reachable state violates the safety invariant.  With 18 declared constants, a maximum term depth of 20 and 2785 characters, the instance is a typical non‑linear arithmetic benchmark used to stress bit‑vector solvers on industrial‑style hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node19624.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) taken from the KeYmaera family of hybrid‑system verification examples, specifically the “intersection‑example‑onelane” safety proof (node 19624) used in the Jovanovic‑de Moura IJCAR‑2012 paper and translated to BV by Mathias Preiner.  It consists of a single, large quantified assertion (size ≈ 3 kB, 13 declared constants, max term depth 25) that negates an ∃‑quantifier over a time variable ts43, thereby reducing the safety‑condition check to an unsatisfiability query.  The body of the assertion encodes a system of linear and quadratic inequalities over the bit‑vectors A, B, V, ep, xI, v, etc., which correspond to physical quantities such as acceleration, braking distance, speed limits and vehicle positions in a one‑lane intersection scenario.  Central to the formula are two competing constraints: either the vehicle’s position xI is less than a computed quadratic trajectory term ?v_3, or it exceeds that term plus a safety margin derived from \\((?v_4)^2 / ?v_5\\); all other conjuncts ensure non‑negativity of parameters and consistency of the motion model.  The instance is characteristic of industrial‑style verification challenges: it mixes non‑linear arithmetic (via bit‑vector multiplication and division) with many nested let‑bindings, and its satisfiability hinges on whether the encoded safety invariant can be violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479619.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) taken from the KeYmaera verification suite for a simple traffic‑intersection safety proof (node 479619 of *intersection‑example‑simple.proof*). It comes from an industrial case study (the “keymaera” family) and was translated to bit‑vectors by Mathias Preiner; the file contains 19 declared constants, a single large quantified assertion and about 2.8 KB of text.  \n\nThe formula is the negation of an existential statement over a time‑step variable `ts2279uscore0`; inside the `exists` a `let` defines a linear expression `?v_0 = v2_535 –  B·ts2279uscore0` (with `B` multiplied by the negated constant 1) and a Boolean `?v_1` that fixes `I1_535` to 2. The body conjunctively imposes a collection of safety constraints on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), accelerations (`A`, `B`), and a global speed bound `V`, all expressed with signed‑comparison (`bvsgt`, `bvsge`, `bvsle`) and arithmetic (`bvadd`, `bvmul`, `bvsdiv`).  \n\nKey properties being checked are that the vehicles’ positions stay within the interval `[x1, x2]`, the velocities remain non‑negative and bounded by `V`, the accelerations are non‑negative, and that a reachable time instant respecting these bounds cannot violate the safety condition (the implication involving `t2279uscore0`).  \n\nBecause the outermost `assert` is a `not (exists … )`, the solver is asked to prove that the existential witness does **not** exist; consequently a `sat` result certifies that the safety invariants hold for all admissible bit‑vector values.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603232.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (size ≈ 2.8 kB, 19 declared constants, one top‑level assertion) taken from the Keymaera verification suite for a “safe‑intersection” hybrid‑system example and translated to bit‑vectors by Mathias Preiner.  The single assertion is the negation of an existential property over a time‑stamp variable `ts2866uscore0`; it is wrapped in a `let` that defines two intermediate expressions `?v_0` and `?v_1` representing the positions of two moving objects under linear acceleration (`A`, `B`) and initial velocities (`v1`, `v2`).  The core constraints require that both objects start with non‑negative velocities bounded by a common maximum `V`, that accelerations `A` and `B` are non‑negative, and that at every step `0 ≤ ts ≤ t2866uscore0` the computed positions stay within `[0,V]` and obey a safety inequality (`xI2 > x2 + v2²/(2·B)`).  Additional side conditions enforce that the overall time horizon `t2866uscore0` and the episode length `ep` are non‑negative and that `ep` exceeds the final time index.  Thus the formula checks whether the hybrid system can violate the safety condition for any reachable time, making it a typical non‑linear arithmetic verification problem expressed in quantifier‑free bit‑vector logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node13791.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic **BV**) taken from the KeYmaera verification suite and translated to bit‑vectors by Mathias Preiner; it belongs to the industrial “Preiner‑keymaera” family and contains 14 declared constants, a single large assertion and about 3 k AST nodes (max term depth 22). The top‑level formula is `¬ ∃ ts7. …` – i.e., it asks the solver to show that no 32‑bit value for the auxiliary time variable `ts7` can satisfy a long conjunction of arithmetic constraints, which corresponds to proving a verification condition. Inside the conjunction there are numerous linear and non‑linear relations among the variables (e.g., `b > 0`, `ep > 0`, `amax > 0`, `v ≥ 0`, `d ≥ 0`) together with quadratic inequalities such as `v·v – d·d ≤ 2·b·(m – z)` and bounds linking squares of other terms (`vuscore…²`, `duscore…²`). The constraints also involve divisions and mixed products (e.g., `bvsdiv amax b`, `bvsdiv … ?v_1 ?v_2`) that emulate the original real‑valued non‑linear arithmetic of the KeYmaera model. Because the outer negation turns the existential check into a universal one, the benchmark is essentially a SAT‑unsat check for the validity of a hybrid‑systems safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290002.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover; it appears in the “intersection‑example‑simple” proof node 290002 from the Keymaera family of industrial benchmarks (≈2.7 KB, 18 declared constants, max term depth 19).  \nThe single asserted formula is the negation of an existential query, i.e. it asks the solver to show that there is **no** choice of the time variable `ts1351uscore0` that can satisfy a huge conjunction of linear arithmetic‑like constraints.  \nThe constraints model a simple traffic‑intersection scenario: two indexed cars have non‑negative speeds `v1`, `v2` bounded by a common limit `V` (with `V>0`), non‑negative parameters `A`, `B` (with `B>0`), and initial positions `x1`, `x2`. Additional safety conditions require `xI1 < x1`, `xI2 > x2 + v2²/(2·B)`, and that the intermediate expressions `?v_0 = -B·ts + v1_410` and `?v_1 = A·ts + v2_410` stay within `[0,V]` while the elapsed time `ts` lies between 0 and a bound `t1351uscore0` and does not exceed a deadline `ep`.  \nA crucial part of the encoding is the disjunction `or ?v_2 (= 0 2)`, which forces the auxiliary flag `I1_uscore3...` to equal 2, thereby eliminating the trivial alternative; the whole formula is therefore a universally quantified safety condition rendered as a negated existential over bit‑vectors.  \nBecause the original problem involves non‑linear real arithmetic (e.g., the term `v2*v2/(2*B)`), the benchmark tests solvers’ ability to handle such nonlinearities after they have been translated into fixed‑size bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346170.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector encoding (SMT‑LIB 2.6, logic **BV**) of a verification condition generated by the KeYmaera hybrid‑system prover; it appears in the Jovanović & de Moura IJCAR 2012 paper and in the “intersection‑example‑simple” proof node 346170.  \nThe file contains 19 declared bit‑vector constants and a single, large quantified assertion that negates an **exists**‑formula, so the solver is asked to show that the existential condition is unsatisfiable (i.e., that the original safety condition holds).  \nThe condition constrains a set of non‑negative variables (v1, v2, A, B, V, ep, etc.) and a bound V, and links them through non‑linear arithmetic such as v1² / (2·B) and v2² / (2·B) appearing inside **bvsdiv** and **bvmul** terms.  \nKey relational constraints include inequalities like  \n xI1 > x1 + v1² / (2·B), xI2 > x2 + v2² / (2·B), B > 0, V > 0,  \nand domain restrictions on the existential time variable ts1611_0 (e.g., 0 ≤ ts1611_0 ≤ t1611_0).  \nThe instance is fairly large (≈2.9 k characters, max term depth 21) and features a mix of linear and non‑linear bit‑vector operations, making it a challenging industrial‑style case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197075.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition generated by the KeYmaera theorem prover for a “safe‑intersection’’ hybrid‑system example; it appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic’’ paper and is classified as an industrial‑category instance (size ≈ 2.8 KB, 19 declared constants, one large quantified assertion).  \nThe formula asserts the **negation** of an existential statement over a time variable `ts921uscore0`, so the check is equivalent to proving that no reachable state violates the safety property.  \nInside the quantified body a `let` defines `?v_0` as a linear combination involving the product `‑B * ts921uscore0` and the constant `v2uscore2dollarskuscore435`, while the surrounding conjuncts impose a rich set of bounds: non‑negativity of parameters (`A, B, V, ep`), velocity limits (`0 ≤ v1, v2 ≤ V`), discrete mode identifiers (`I1 = I2 = 2`), and a nonlinear distance condition `xI1 > x1 + (v1·v1)/(2·B)`.  \nFurther constraints relate the timed variable to the system’s evolution (`bvsge t921uscore0 0`), require the computed intermediate term `?v_0` to stay within `[0,V]`, and bound the total time `ts921uscore0 + 0 ≤ ep`.  \nThus the instance checks that, under the given linear and quadratic dynamics encoded as 32‑bit unsigned arithmetic, the vehicle cannot exceed the safety envelope before the deadline `ep`, a characteristic non‑linear arithmetic challenge that motivated the benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node6709-new.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑system verification suite; it encodes a verification condition for an adaptive cruise‑control example (node 6709 of the dccs‑example) that was translated to bit‑vectors by Mathias Preiner.  The file is relatively small (≈2.5 KB, 10 declared constants, a single quantified assertion) but the assertion is dense, containing nested let‑bindings, arithmetic over 32‑bit signed bit‑vectors, and an existential quantifier over a time variable `ts4uscore2`.  The core property being checked is that, under the assumptions that the parameters `A`, `B`, `eps`, the velocities `v1`, `v1_uscore7`, and the time bounds `ts4uscore2`, `t4uscore0dollarskuscore2` are non‑negative, a certain quadratic safety inequality—essentially `x1 + v1²/(2·B) < x2` together with a more complex bound involving `A/B` and `eps`—cannot be falsified; the outer `not` turns the check into a satisfiability query for a counterexample.  The constraints model hybrid dynamics (e.g., position updates `x + v²/(2·B)`) and require positivity of physical constants, while the final disjunction allows either the velocity variable to be zero or a stricter inequality to hold, making the formula a non‑linear arithmetic challenge expressed entirely in bit‑vector arithmetic.  Because it mixes divisions, multiplications, and signed comparisons on 32‑bit words, the instance is a typical “industrial” stress test for SMT solvers’ BV arithmetic and quantifier handling capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node31555.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera hybrid‑system verification suite; it originates from the “intersection‑example‑onelane” proof node 31555 and was translated to bit‑vectors by Mathias Preiner (≈3 kB, 13 declared constants, one quantified assertion).  \n\nIts single top‑level assertion is the negation of an existential formula ∃ts69 such that a large conjunction of arithmetic constraints holds; consequently the solver is asked to show that no time instant satisfying all those constraints exists.  \n\nThe constraints model a one‑lane traffic intersection: variables like xI, x, v, V, A, B, ep represent positions, velocities, bounds and physical parameters, while quadratic terms (e.g., (v·v), (ep·ep), (t·t)) encode kinematic equations for motion and safety distances.  \n\nKey properties enforced include non‑negativity of times and parameters (bvsle 0 … ), positivity of the denominator B, upper bounds on velocities (v ≤ V), and a safety condition comparing the current position xI against a bound that depends on the computed future position using the motion equations; the final disjunction expresses a case split on the lane index I1.  \n\nBecause the arithmetic is non‑linear, it is encoded via 32‑bit bit‑vector operations (bvmul, bvsdiv, bvadd, etc.), making the instance a challenging industrial test for SMT solvers that handle bit‑vector non‑linear reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20210330-PEak/no-extern-loop_sat_subset/hard1.smt2",
    "description": "**Instance summary** – The file is a single‑assertion SMT‑LIB 2.6 benchmark in the **BV** (bit‑vector) logic, generated by the PEak hardware‑rewrite‑rule synthesis suite (family PEak, industrial category). It encodes a massive combinational circuit: dozens of 1‑bit and multi‑bit signals (mux inputs, ALU bits, LUT tables, signed flags, constant data, clock‑enable, etc.) are concatenated into a 192‑bit word, shredded with many `extract` operations, and combined with arithmetic (`bvadd`, `bvmul`, `bvsub`), shifts, and logical operators. A universal quantifier wraps the whole construction, and the sole constraint relates the resulting word to a small set of output bits (`ob_0`, `PE_wrapped_if_1`) through a cascade of `ite`, `bvule`, `bvsle`, and relational checks. The benchmark is extremely large (≈114 million characters, term depth ≈ 1.6 million) and contains over 400 k `let` bindings, hundreds of thousands of extracts, and thousands of arithmetic and bitwise operations, making it a stress test for bit‑vector solvers. Its purpose is to ask whether there exists an assignment to the input bit‑vectors (`ib_0` and a 5040‑bit vector) that satisfies all the encoded hardware properties.",
    "is_truncated": true
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389601.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) taken from the **KeYmaera** hybrid‑system verifier; it encodes the verification condition of the “safe‑intersection” example (node 389601 of *intersection‑example‑simple.proof*) that appears in the IJCAR 2012 and ITSC 2011 papers.  The file is 2 916 characters long, declares 20 32‑bit constants and contains a single, large conjunctive assertion wrapped in a negated existential quantifier over the time variable `ts1819uscore0`.  \n\nThe core of the condition asserts several non‑linear relationships between the variables, e.g.  \n`bvsgt xI1 (bvadd x1 (bvsdiv (bvmul v1 v1) (bvadd (bvmul A ts1819uscore0) v1uscore4dollarskuscore421)))` and the analogous inequality for `xI2`, which model the evolution of positions under quadratic acceleration terms.  Together with a suite of domain constraints (all involved quantities are non‑negative, `V > 0`, `B > 0`, and upper bounds `v1, v2 ≤ V`), the formula checks whether a reachable state violating the safety property exists.  \n\nThe instance is notable for translating a genuinely non‑linear arithmetic verification condition into pure bit‑vector arithmetic, leading to deep nested terms (max depth 20) and a mixture of signed comparisons, divisions and multiplications that make it a challenging industrial‑style SMT test case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45116.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (2557 characters, 13 declared 32‑bit bit‑vectors) taken from the Keymaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (see Jovanović & de Moura 2012).  It encodes a single verification condition that asserts the *negation* of an existential property over a time variable `ts101$1`; the solver must therefore prove that no assignment to this variable can satisfy the complex conjunction of arithmetic constraints.  \n\nThe conjunctive core describes a hybrid‑system safety claim for a one‑lane intersection: it relates positions (`xI`, `x`, `x_uscore4$54`), velocities (`v`, `V`, `vuscore4$59`), a constant acceleration term (`B`), and timing bounds (`t187$0$1`, `ep`).  The constraints are non‑linear: they contain products of bit‑vectors (`bvmul v v`, `bvmul vuscore4$59 vuscore4$59`) and divisions (`bvsdiv (…)`) together with linear ordering (`bvsle`, `bvsge`, `bvsgt`, `bvslt`).  \n\nThe final top‑level check is a SAT query: if the solver returns **unsat**, the original safety property holds for all reachable states of the modeled intersection.  Notably, the benchmark mixes several BV‑theories (signed comparisons, multiplication, division) and tests the solver’s ability to handle non‑linear arithmetic after bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193438.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (BV logic) of a safety proof obligation taken from the KeYmaera hybrid‑system verifier; it appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and is listed under the industrial “Preiner‑keymaera” family (file BV/2017‑Preiner‑keymaera/intersection-example‑simple.proof‑node193438.smt2, 2 733 characters, 1 top‑level assert and 18 declared constants).  \n\nThe formula asserts the negation of an existential condition on a time variable `ts899uscore0`, i.e. it checks that no witness exists satisfying a conjunction of arithmetic constraints that model a vehicle‑intersection scenario.  \n\nKey constraints enforce non‑negativity and upper bounds (`V`, `A`, `B`), bounds on velocities `v1`, `v2`, and a quadratic term `bvmul v1 v1` divided by `2·B` that appears in a safety distance condition `xI1 > x1 + (v1·v1)/(2·B)`. Additional constraints couple the discrete mode indices `I1`, `I2` (both equal to 2) with relational checks on positions (`xI2 < x2`) and on the elapsed time (`ts899uscore0` lies between 0 and a bound `t899uscore0`).  \n\nThe instance is notable because it encodes a non‑linear hybrid‑system verification problem entirely in fixed‑size bit‑vectors, featuring multiplication, signed division, and a mixture of relational and equality constraints, which makes it a challenging case for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606769.smt2",
    "description": "This benchmark is a single‑assertion SMT‑LIB 2.6 file in the **BV** logic, containing 19 32‑bit bit‑vector constants, one quantified formula and a total of 2 796 characters (max term depth 19).  It originates from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node 606769) and was translated to bit‑vectors by Mathias Preiner, so it represents a safety verification condition for a vehicle‑intersection scenario.  The core of the assertion is a negated existential statement over a time variable `ts2888_0`; the body asserts that, assuming non‑negative parameters `A`, `B`, `V`, `v1`, `v2` and the ordering `xI1 < x1`, `xI2 > x2 + v2²/(2·B)`, a linear expression `?v_0 = -B·ts + v2_` stays within the interval `[0,V]` for all `0 ≤ ts ≤ t2888_0 ≤ ep`.  The formula also encodes case distinctions on the integer flags `I1` and `I2` (both equal to 2) and requires `ep > 0` and `V > 0`.  Thus the instance checks whether any reachable state violates the intersection safety invariant; unsat would mean the invariant holds for all admissible bit‑vector executions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254826.smt2",
    "description": "The file is a 2‑KB **BV** benchmark (logic BV, 18 bit‑vector constants of width 32, 1 quantified assertion, 2705 total nodes) taken from the *Keymaera* family of verification conditions and translated to bit‑vectors by Mathias Preiner (see Jovanović & de Moura 2012).  \nIt encodes a safety VC for a hybrid‑systems model of a road intersection (the “intersection‑example‑simple” proof node 254826), where the variables `x1`, `x2`, `I1`, `I2`, `A`, `B`, `V`, `ep` and a time offset `ts1185uscore0` represent positions, intervals, bounds on velocities, and a deadline.  \nThe core of the formula asserts, under a block of linear and quadratic *bit‑vector* inequalities (e.g., `bvsge v1 0`, `bvsle v1 V`, `bvsgt B 0`, `bvsge A 0`, `bvsgt V 0`, `bvsgt ep 0`), that for any non‑negative time `ts1185uscore0` satisfying the dynamics expressed by the auxiliary terms  \n`?v_0 = v1uscore3dollarskuscore250 + (-1·B)·ts1185uscore0` and  \n`?v_2 = v2uscore3dollarskuscore250 + (-1·B)·ts1185uscore0`,  \nthe resulting positions stay within the admissible interval `[0,V]` and the deadline `ep` is not exceeded.  \nA single Boolean guard `?v_3` (testing whether `I1uscore3dollarskuscore250 = 2`) appears both in the antecedent and in the consequent, linking the hybrid‑system mode to a trivial disjunction (`?v_3 ∨ (1 = 2)`).  \nThus the benchmark checks the satisfiability of a non‑linear arithmetic VC after bit‑vector encoding, featuring nested `let`s, an existential quantifier, and a mixture of addition, multiplication and signed division on 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345482.smt2",
    "description": "The file is a 2.6‑compliant SMT‑LIB benchmark in the **BV** logic (32‑bit bit‑vectors), coming from the industrial “keymaera” family of verification conditions for hybrid‑system safety – specifically a simple intersection proof from the KeYmaera tool (node 345482).  It contains 19 declared bit‑vector constants and a single, large assertion that negates an **∃ ts₁₆₀₈**​₀‑quantified formula; the solver therefore has to prove that no such timestamp can satisfy the conjunctive constraints.  The core of the formula is a conjunction of non‑linear arithmetic constraints (multiplications, a division and several additions) together with ordering relations (signed ≤, ≥, >) that encode safety conditions such as `bvsgt xI1 (x1 + v1·v1 / (2·B + A·ts))`, bounds on velocities `v1`, `v2`, and positivity of parameters (`A`, `B`, `V`, `ep`).  The condition also includes a disjunction linking the final state `xI2` to either an unchanged position or a timed evolution governed by `t₁₆₀₈₀` and the same non‑linear bounds.  With a size of 2849 characters, a maximum term depth of 20 and many nested `and`/`or`/`=>` operators, the benchmark stresses solvers’ ability to handle quantified, non‑linear bit‑vector arithmetic typical of hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488018.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition extracted from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” proof node used in the *Safe intersections* case study.  The file contains 20 BV constants (positions, velocities, parameters A, B, V, ep, etc.) and a single quantified assertion that negates the existence of a time‑step variable `ts2315_0` satisfying a conjunction of arithmetic constraints.  The core constraints enforce that the two cars’ initial positions (`xI1`, `xI2`) and velocities (`v1`, `v2`) lie within the admissible interval [0,V], that the parameters A, B, V, ep are strictly positive, and that the motion law `xI1 > x1 + v1²/(2·B)` (a non‑linear quadratic term encoded as `bvmul` and `bvsdiv`) holds together with a bound on the computed distance `?v_0 = A·ts2315_0 + v1_572`.  The formula also includes a disjunction requiring either `xI2` to equal a pre‑computed bound or, if the time variable is non‑negative, that a set of linear bounds on `ts2315_0`, `?v_0`, and `v2_572` are respected and that the overall horizon `ep` is not exceeded.  Satisfiability of the negated existential (i.e., UNSAT) would certify that no reachable unsafe state exists under these hybrid‑system dynamics, and the instance is typical of industrial‑scale, non‑linear arithmetic problems translated to bit‑vectors, with a depth of 21 and a total size of about 2.9 KB.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619055.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2841 characters, generated from a KeYmaera hybrid‑system verification proof for a “safe intersection” example (see Loos & Platzer 2011) and translated to bit‑vectors by Mathias Preiner.  It contains a single, large verification condition that is existentially quantified over a time‑stamp variable `ts2958uscore0`; the outer `not` makes the solver look for a counterexample to the condition.  The condition encodes bounds on the vehicle parameters `v1`, `v2`, the maximal speed `V`, the accelerations `A` and `B`, and a positive horizon `ep`, together with kinematic relations such as  \n\n\\[\nxI1 > x1 + \\frac{v1^2}{2B},\\qquad\nxI2 > x2 + \\frac{v2^2}{2B},\n\\]\n\nexpressed with bit‑vector multiplication (`bvmul`) and signed division (`bvsdiv`).  Additional conjuncts require all quantities to be non‑negative and to stay within the global speed limit `V`, while the innermost implication checks that, for any non‑negative time step, the computed intermediate values remain within `[0,V]` and that the time does not exceed the horizon `ep`.  The formula therefore tests the safety invariant of the intersection scenario using non‑linear arithmetic encoded as bit‑vector operations, a characteristic feature of the Preiner‑keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392183.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) of size 2768 with 18 declared constants and a single, fairly large quantified assertion (max term depth 19). It originates from the KeYmaera hybrid‑system verifier (intersection‑example‑simple) and was translated to bit‑vectors by Mathias Preiner; the file is classified as an industrial benchmark in the Preiner‑keymaera family. The formula asserts, under a `not (exists ts) …` wrapper, that there is **no** time instant `ts1834_0` (0 ≤ ts ≤ t) for which a set of safety conditions can be satisfied; the outer `not` therefore checks the unsatisfiability of the existential sub‑formula. The safety conditions encode a simple intersection scenario: non‑negative parameters `A`, `B`, `V`, `ep`; bounds `I1 = I2 = 2` (or `I2 = 0`); velocity limits `0 ≤ v1, v2 ≤ V`; and safety distances expressed as  \n`xI1 > x1 + v1²/(2·B)` and `xI2 > x2 + v2²/(2·B)`.  \nAdditional constraints require the derived accelerations `?v_1 = -2·B·ts + v1` and `?v_2 = A·ts + v2` to stay within `[0,V]` and the total elapsed time `ts+0 ≤ ep`, ensuring that any reachable state respects the intersection’s timing and distance guarantees. The instance therefore checks the validity of a hybrid‑system verification condition using non‑linear arithmetic encoded in bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node719994.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size ≈ 3 kB taken from the KeYmaera hybrid‑system verification suite (the “intersection‑example‑simple” proof node 719 994), submitted by Dejan Jovanović and translated to BV by Mathias Preiner.  \nThe single assertion is the negation of an existential statement over a time variable `ts3496uscore0`; proving the formula unsatisfiable amounts to showing that no reachable time can satisfy the safety constraints encoded for a road‑intersection scenario.  \nThe constraints conjoin many arithmetic relationships among constants and state variables (`xI1`, `xI2`, `v1`, `v2`, `A`, `B`, `V`, `ep`, etc.), requiring non‑negative parameters, upper bounds on velocities (`v1`, `v2` ≤ `V`), positivity of `A`, `B`, `V`, `ep`, and that the positions after a time step (expressed with `bvadd`, `bvmul`, `bvsdiv`) exceed the current positions plus a quadratic term (`bvsdiv (bvmul v v) …`).  \nNon‑linear arithmetic appears through products such as `bvmul v1 v1` and divisions `bvsdiv`, all encoded as 32‑bit bit‑vector operations, and the formula also contains a small disjunctive case distinguishing whether `xI1` equals a particular constant or a timing condition holds.  \nThus the benchmark checks the infeasibility of a set of hybrid‑system safety conditions under a bit‑vector encoding of real‑valued non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53911.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (see the cited KeYmaera paper on safe intersections). It is a relatively small industrial instance (≈2.4 KB, 13 declared constants, a single quantified assertion) that encodes the safety condition for a one‑lane traffic intersection. The core formula asserts, after negation, that no value of the auxiliary time variable ts₁₂ can satisfy a conjunction of bounds on the system variables (e.g., 0 ≤ ts₁₂ ≤ t₂₂₉, A·ts₁₂+v₄ ∈ [0,V], ts₁₂ ≤ ep) together with physical constraints such as non‑negative parameters (A, B, v, V, ep) and the stopping‑distance inequality  \n\\(x_I > x + \\frac{v^2}{2B}\\).  \nAn additional disjunction finally states that either a flag I₁₄₃ equals 2 or the accumulated distance A·t₂₂₉+v₄ does not exceed V.  \nThus the solver is asked to prove that the existential conjunction is unsatisfiable, i.e., that the intersection scenario is safe under the encoded non‑linear arithmetic conditions. The benchmark features a relatively deep term structure (depth 22) and a mix of bit‑vector arithmetic (addition, multiplication, signed division) with quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node535359.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition generated by the KeYmaera hybrid‑system prover, originally taken from the “Safe intersections” case study and translated to bit‑vectors by Mathias Preiner (size ≈ 2.8 KB, 19 declared constants, 1 top‑level assertion).  The formula asserts the **negation of an existential** over a time variable `ts2538uscore0`, i.e. it checks that no assignment to this variable can satisfy the large conjunctive set of arithmetic constraints.  The constraints model a simple traffic‑intersection scenario: they enforce non‑negative parameters (`A`, `B`, `V`, `ep`), bound the velocities `v1` and `v2` by `V`, require the “braking distance” condition `xI1 > x1 + v1²/(2·B)`, keep the second vehicle’s position `xI2` below `x2`, and relate the discrete mode identifiers `I1`, `I2` (both fixed to 2).  Additional conditions ensure that a derived expression `?v_0 = -B·ts2538uscore0 + v2` stays within `[0,V]` and that the elapsed time plus the start time does not exceed `ep`.  The instance therefore tests whether the hybrid‑system safety invariant holds under all reachable bit‑vector states; its unsatisfiability would confirm the original KeYmaera proof obligation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368427.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) of size ≈2.9 KB with one massive quantified assertion and 19 declared constants, originating from the KeYmaera verification of a “safe intersection” hybrid‑system example (paper Loos & Platzer 2011) and translated to bit‑vectors by Mathias Preiner.  The single top‑level formula asserts the **negation** of an existential statement over a time‑step variable `ts1718uscore0`; equivalently it checks that no assignment to the time step can violate a conjunction of safety conditions.  The conjuncts encode non‑linear relationships among vehicle‑like quantities – positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), acceleration bounds (`A`, `B`), a global speed limit `V`, and a positive horizon `ep` – using bit‑vector multiplication, addition, and signed division to model quadratic terms such as `bvsdiv (bvmul v1 v1) (…)` and `bvsdiv (bvmul v2 v2) (…)`.  Additional constraints require all parameters to be non‑negative (`bvsge … (_ bv0 32)`) and enforce ordering relations like `xI1 > x1 + v1²/(2·B)` and `xI2 > x2 + v2²/(2·B)`, together with bounds on the velocities (`0 ≤ v1,v2 ≤ V`).  The instance therefore tests an SMT solver’s ability to handle quantified, non‑linear arithmetic encoded in bit‑vectors, featuring a deep term structure (depth 21), many conjuncts (≈20 `and`s), and a mixture of arithmetic and ordering operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node351044.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the Keymaera family, originally a safety proof for a vehicle‑intersection hybrid system and translated to bit‑vectors by Mathias Preiner (industrial category, 20 declared constants, one large assertion, 2 940 characters and a maximum term depth of 21).  \nIt encodes a verification condition that asserts the **non‑existence** of a counterexample (the outer `not (exists …)`) to a set of safety constraints on positions (`x1`, `x2`), velocities (`v1`, `v2`), bounds (`V`, `A`, `B`), and discrete mode indicators (`I1`, `I2`).  \nKey constraints are non‑linear: quadratic terms `v1*v1` and `v2*v2` appear inside divisions (`bvsdiv`) and are compared with linear expressions involving the time variable `ts1635uscore0`; all variables are required to be non‑negative and bounded by `V`, while `B` and `V` must be strictly positive.  \nThe formula also contains relational conditions linking the “indexed” variables (e.g., `xI1 = x1uscore4dollarskuscore187`) and mode checks such as `I1 = 2` and `I2 = 2`, together with a final disjunction that forces `I1 = 2` or the trivial equality `1 = 2`.  \nBecause it mixes quantifiers, let‑bindings, and non‑linear bit‑vector arithmetic, the instance is a known hard case for SMT solvers handling the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290415.smt2",
    "description": "This file is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈2.7 k characters, 18 declared constants and a single complex assertion) originating from the KeYmaera hybrid‑system verifier; it was translated to bit‑vectors by Mathias Preiner and appears in the Jovanović & de Moura “Non‑Linear Arithmetic” paper. The formula asserts the *negation* of an existential statement over a time stamp variable `ts1353uscore0`, i.e. it tries to prove that no assignment to this variable can satisfy a conjunction of safety conditions derived from a simple traffic‑intersection model. The safety conditions involve linear ordering of positions (`xI1 < x1`, `xI2 > x2 + v2²/(2·B)`), non‑negativity and upper bounds for velocities (`v1`, `v2`) and a global bound `V`, as well as positivity of parameters `A`, `B`, `ep`. Central to the check is a non‑linear term `bvmul v2 v2` divided by `2·B`, encoded with bit‑vector multiplication and signed division, and the whole premise is wrapped in nested implications and a `let`‑binding for a derived expression `?v_0`. The instance therefore exercises bit‑vector reasoning about mixed linear/non‑linear arithmetic, quantifiers, and conditional properties typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672726.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition generated by the KeYmaera hybrid‑system prover for the “intersection‑example‑simple” case; it appears in the Jovanović‑de Moura IJCAR 2012 paper and was translated to BV by Mathias Preiner. The single quantified assertion is a negated existential formula over the time variable `ts3206uscore0`, which states that no concrete assignment can satisfy a conjunction of non‑linear arithmetic constraints (quadratic terms such as `v1·v1` and `v2·v2`) together with a number of bounds on positions (`xI1`, `xI2`), velocities (`v1`, `v2`), parameters (`A`, `B`, `V`, `ep`) and integer constants. The core safety property checks that the evolved positions of two vehicles remain greater than their initial positions plus a term proportional to the square of their velocities divided by a linear combination of `A` and the time, while all physical quantities stay non‑negative and within a global upper bound `V`. The formula also includes auxiliary disjunctions that model a branching case (“either the second vehicle’s position equals a stored value or a timing condition holds”) and a trivial equality `(_ bv0 32)=(_ bv2 32)` that forces one branch to be impossible. Because the outermost `not (exists …)` is used, the benchmark is satisfiable exactly when the original safety condition holds for all reachable states; its size (≈2.8 k characters, 19 constants, depth 20) and heavy use of bit‑vector multiplication make it a typical industrial, non‑linear BV test case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3897.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑systems verification suite (the “dccs‑example” from an adaptive cruise‑control case study) and was translated to bit‑vectors by Mathias Preiner; it appears in the Preiner‑keymaera industrial family and is 2 475 bytes long with 10 declared constants and a single, very deep quantified assertion (max term depth 22).  \n\nThe formula asserts the negation of an existential statement over a fresh time variable `ts1uscore2`, i.e., it checks that **no** value of this variable can satisfy a long conjunction of arithmetic constraints.  \n\nThe conjunction encodes a mixture of linear and non‑linear relations among the constants (`A`, `B`, `eps`, `v1`, `x1`, `x2`, …): bounds on the time variables (`0 ≤ ts1 ≤ t1 ≤ …`), non‑negativity of velocities, safety conditions expressed as strict inequalities (`x1 < x2`, `x1+v1²/(2·B) < x2`, etc.), and hybrid‑system dynamics such as `A·ts1 + v1 ≥ 0`.  \n\nAll arithmetic is done with BV operations (`bvadd`, `bvmul`, `bvsdiv`, `bvslt`, `bvsge`, etc.), so the instance mixes bit‑vector overflow semantics with the intended real‑valued non‑linear reasoning, making it a challenging case for solvers that must handle non‑linear multiplication and division together with quantifier elimination.  \n\nThus the benchmark tests a solver’s capability to prove the universal safety property of the cruise‑control model by showing the existential sub‑formula is unsatisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node672976.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition that originates from the KeYmaera hybrid‑systems prover, specifically the “intersection‑example‑simple” case study on safe vehicle intersections.  It contains a single, heavily quantified assertion: the negation of an existential formula over a time‑step variable *ts3207₀* together with a large conjunct of arithmetic constraints on positions (*x₁, x₂*), velocities (*v₁, v₂*), bounds (*A, B, V, ep*) and auxiliary constants.  The constraints enforce non‑negativity, upper bounds by *V*, and several non‑linear relations such as  \n  *xI₁ > x₁ + (v₁·v₁)/(2·B·ts₃₂₀₇₀)* and  \n  *xI₂ > x₂ + (v₂·v₂)/(2·B·ts₃₂₀₇₀)*,  \nas well as time‑window conditions (0 ≤ *ts₃₂₀₇₀* ≤ *t₃₂₀₇₀*) and a final bound *ts₃₂₀₇₀ + 0 ≤ ep*.  \nThe overall check asks whether the negated existential is unsatisfiable, i.e., whether the safety property holds for all admissible values.  \nThe instance is modest in size (≈ 2.8 KB, 19 declared constants, depth 20) but notable for its combination of bit‑vector non‑linear multiplication/division and a mixture of linear and quadratic constraints that stem from the original hybrid‑system model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172570.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) originating from the KeYmaera hybrid‑systems verifier; it encodes a verification condition for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  The file contains 18 declared bit‑vector constants (positions x1,x2,intermediate points xI1,xI2, velocities v1,v2, bounds A,B,V, a time‑step constant ep, etc.) and a single, complex assertion that negates an existential quantifier over a time variable ts800₀.  The core constraint expresses that, under non‑negative parameters (A,B,V,ep) and bounded velocities (0 ≤ v₁,v₂ ≤ V), the positions reachable after a time step satisfy safety inequalities such as xI1 > x₁ + v₁²/(2·B) and xI2 < x₂, together with the hybrid‑system mode conditions I₁ = 2, I₂ = 2, and a relation I₁′ = 2.  The formula also enforces that the computed update v₁·ts800₀ + v₂ is within [0,V] and that the time step stays within the overall horizon [0,ep].  Because the outermost operator is (not exists …), the solver is asked to prove that no such time step exists, i.e., that the safety property holds for all admissible executions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197946.smt2",
    "description": "This benchmark is a 32‑bit Bit‑Vector (BV) instance (logic BV) originating from the KeYmaera verification suite; it was translated to SMT‑LIB by Mathias Preiner and appears in the “intersection‑example‑simple” proof node 197946 (industrial, size ≈ 2.8 KB, 19 declared constants, one top‑level assertion). The formula asserts the negation of an existential claim: it checks that there is **no** value for the time variable `ts926uscore0` that can satisfy a large conjunction of arithmetic constraints derived from a hybrid‑system model of a safe traffic intersection. The constraints enforce non‑negativity and upper bounds (by the constant V) for velocities `v1`, `v2`, and other parameters (`A`, `B`), equality conditions linking positions (`xI2 = x2…`) and indices (`I1 = I2 = 2`), a quadratic term `bvmul v1 v1` divided by `2*B`, and a linear expression `?v_0 = -B*ts + v1_440` that must stay within `[0,V]`. Additional ordering constraints (e.g., `xI1 > x1 + v1²/(2B)`, `xI2 < x2`) and deadline conditions (`ts ≤ t926uscore0 ≤ ep`) encode the safety condition that a car cannot cross the intersection after the green light expires. By wrapping the whole conjunction in a `not (exists …)` the solver is asked to prove unsatisfiability, i.e., that the verification condition holds for all admissible bit‑vector values. The benchmark is notable for combining non‑linear arithmetic (quadratic term) with bit‑vector encoding and for its relatively deep term nesting (depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node633178.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example described in Loos & Platzer 2011.  It originates from the Preiner‑keymaera family (BV/2017‑Preiner‑keymaera) and contains 19 declared constants, one large quantified assertion, and about 2.9 KB of SMT‑LIB code (max term depth 20).  The formula asserts (by negating an ∃‑quantifier) that there exists no assignment to the time‑stamp ts₃₀₂₈₀ satisfying a conjunction of algebraic safety constraints: non‑negative parameters A, B, V, ep; velocities v₁, v₂ bounded between 0 and V; and position updates xI₁, xI₂ that must stay ahead of the bounds x₁ + v₁²/(2·B) and x₂ + v₂²/(2·B).  The constraints are expressed with BV‑encoded multiplication, addition, signed division and signed comparisons, effectively modeling the underlying nonlinear real arithmetic of a vehicle‑intersection scenario.  A notable characteristic is the heavy nesting of `and`/`=>` and the use of a single existential variable together with a `let`‑binding to factor out the common term `2·B`, which makes the instance challenging for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389285.smt2",
    "description": "The file is a single‑assertion benchmark in the BV (fixed‑width bit‑vector) logic, coming from the Preiner‑keymaera industrial suite (size ≈ 2.8 KB, 19 declared 32‑bit variables and a maximum term depth of 21).  It encodes a safety verification condition for the “intersection‑example‑simple” proof node of the KeYmaera hybrid‑systems verifier, translated from real‑valued non‑linear arithmetic into 32‑bit bit‑vector arithmetic.  The core of the formula is a negated existential query over a time‑step variable ts1817uscore0, asserting that no assignment can satisfy a large conjunct of arithmetic constraints: positivity of parameters (A, B, V, ep), bounds on velocities v1, v2, quadratic inequality checks such as xI1 > x1 + (v1·v1)/(2·B), and timing relationships linking ts1817uscore0, t1817uscore0 and the deadline ep.  The constraints also enforce integer‑range limits (e.g., 0 ≤ ?v_1, ?v_3 ≤ V) and discrete mode conditions (I1 = 2, I2 = 2, with a special case when I1uscore4dollarskuscore419 = 2).  The solver is asked to prove the formula unsatisfiable, i.e., to show that the safety property holds for all possible bit‑vector interpretations of the model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5920.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2 183 characters, taken from the KeYmaera “bouncing‑ball‑simple’’ verification condition (node 5920) and translated to bit‑vectors by Mathias Preiner.  It encodes a safety property of a ball that bounces under constant gravity, where the variables t₁, t₂, v, h, h₂, v₂ and a quantified time ts₁ represent the initial time, the current time, velocity, height, and intermediate quantities.  The single top‑level assertion states that there is **no** value of ts₁ within [0, t₁] for which the quadratic height expression  \n\\(h₂ = 5·t₂² + v·t₂\\) (and its related constraints on velocity and height) becomes negative while all other physical bounds (non‑negative times, heights, and a linear upper bound on the velocity) hold.  The formula combines non‑linear arithmetic (squared terms) and linear inequalities, all encoded with BV operations such as `bvmul`, `bvadd`, `bvsle`, and `bvsge`.  Consequently, the problem tests an SMT solver’s ability to handle quantified, non‑linear arithmetic after bit‑vector translation in an industrial‑style verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node195519.smt2",
    "description": "The file is a 2‑K‑bit‑vector (BV) benchmark (logic BV) of moderate size (≈2.7 KB, 18 declared constants and a single huge assertion) taken from the KeYmaera hybrid‑system verifier and translated to bit‑vectors by Mathias Preiner.  It encodes a verification condition for the “intersection‑example‑simple” proof node 195519, i.e. a safety property of a traffic‑intersection hybrid model (see Loos & Platzer 2011).  \n\nThe core of the assertion is the negated existential formula  \n`(not (exists ((ts …)) … ))`, which states that there is **no** time `ts` satisfying a collection of linear and non‑linear constraints on the vehicle velocities (`v1`, `v2`), positions (`x1`, `x2`), and parameters (`A`, `B`, `V`, `ep`).  The constraints enforce non‑negativity, upper bounds by a common limit `V`, positivity of `A`, `B`, `V`, `ep`, and relational conditions such as  \n`bvsgt xI1 (x1 + (v1*v1)/(2*B))` and `bvslt xI2 x2`, together with a derived term `?v_0 = A*ts + v2`.  \n\nKey properties being checked are that the derived term stays within `[0,V]`, the time `ts` lies between 0 and `t911`, and the final safety condition `or (= I1 …) (= I2 …)` holds.  The benchmark is notable for mixing bit‑vector arithmetic with non‑linear operations (multiplication, signed division) and for its relatively deep term structure (depth 21), which makes it a hard industrial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5581.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example (one‑lane traffic) described in the IJCAR 2012 and ITSC 2011 papers.  The file contains 13 declared 32‑bit variables (positions, velocities, bounds A, B, V, a time‑step ts10, etc.) and a single, negated existential formula that asserts the existence of a time instant ts10 satisfying a large conjunction of safety constraints; the outer `not` makes the overall problem a proof‑obligation that the condition is **unsatisfiable**.  The constraints involve non‑linear bit‑vector arithmetic: quadratic terms such as \\(v^2\\), products with the constant B, and divisions (`bvsdiv`) appear inside bounds like `bvsle (bvmul ?v_1 ts10 + v) V`, together with ordering requirements (`bvsle`, `bvsge`, `bvsgt`, `bvslt`) that model physical limits (non‑negative time, positive speed, bounded acceleration).  The assertion also encodes a case split on a control flag (`I1uscore2dollarskuscore15`) and ensures consistency of control mode variables (`I1 = 2`, `I1uscore2dollarskuscore15 = 1 or 2`).  With a size of 2 649 characters, a maximum term depth of 23 and 16 nested `and`s, the instance is a typical industrial‑style, non‑linear bit‑vector verification problem used to stress SMT solvers’ handling of quantified, arithmetic‑heavy benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631052.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) coming from the **Keymaera** family of hybrid‑system verification problems; it was translated to BV by Mathias Preiner and is classified as an industrial benchmark (≈ 19 declared constants, 1 assertion and a term depth of 22).  \nThe single top‑level assertion is the negation of an existential formula that quantifies over a time variable `ts3016uscore0`. Inside the quantifier the model encodes a simple intersection scenario: two agents with initial positions `x1`, `x2` and speeds `v1`, `v2` evolve under constant acceleration `A` and braking `B`, with the usual kinematic term `v²/(2·B)` appearing as a bit‑vector division.  \nA collection of linear BV constraints enforces non‑negativity and upper bounds (`0 ≤ v1,v2,A,B,V ≤ V`, `B>0`, `V>0`, `ep>0`), fixes several index variables (`I1 = I2 = 2`, `I2uscore… = 2`), and requires that the projected positions `xI1` and `xI2` exceed the safety distances (`xI1 > x1 + v1²/(2·B)`, `xI2 > x2 + v2²/(2·B)`).  \nAdditionally, the time variable must lie in the interval `[0, ep]` and the expression `bvmul A ts + v1uscore…` must stay within `[0,V]`.  \nThus the benchmark checks whether there exists any time instant that violates the safety condition; the outer `not` makes the whole query a **validity** check (i.e., “no such violating time exists”).  The encoding is notable for representing non‑linear arithmetic (quadratic terms and division) entirely with 32‑bit bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node21162.smt2",
    "description": "The file is a 2 KB benchmark in the BV (32‑bit bit‑vector) logic, contributed by Dejan Jovanović and translated to bit‑vectors by Mathias Preiner as part of the Preiner‑keymaera family of industrial verification examples.  It encodes a safety proof obligation from the KeYmaera hybrid‑systems verifier for the “intersection‑example‑onelane” scenario, where variables such as **xI**, **v**, **A**, **B**, **V**, and **ep** model positions, velocities and timing bounds of a vehicle at a traffic intersection.  The single top‑level assertion is a negated existential formula over a time variable **ts46uscore1**, asserting that no assignment can simultaneously satisfy a collection of signed ≤/≥ constraints, a non‑linear term **(v·v) / (2·B)**, and a linear combination **(‑B·t81 + v) ≤ V** together with several domain bounds (e.g., **B>0**, **V>0**, **ep>0**, **I1 = 2**).  The core constraints therefore check that, under the assumed bounds on time and speed, the vehicle’s computed stopping distance never exceeds the allowed safety distance V, which is exactly the condition proved in the original KeYmaera proof node 21162.  Notably, the benchmark contains deep term nesting (depth 23), many signed comparisons, and a single quantified block, making it a compact but challenging bit‑vector encoding of a non‑linear hybrid‑systems safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node489032.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) SMT‑LIB 2.6 file (size ≈ 2.9 KB) coming from the Preiner‑keymaera industrial family; it was generated by translating a KeYmaera hybrid‑systems verification condition for a simple traffic‑intersection example.  \n\nThe single top‑level assertion is a negated existential formula over a time variable `ts2320uscore0`; inside a `let` it defines the auxiliary term `?v_0 = A·ts2320uscore0 + v2_577` and then imposes a large conjunction of bounds on the declared 32‑bit variables (velocities `v1`, `v2`, parameters `A`, `B`, speed limit `V`, horizon `ep`, and positions `x1`, `x2`, `xI1`, `xI2`).  \n\nKey constraints express that all parameters are non‑negative and at most `V`, that the quadratic safety condition `xI1 > x1 + v1·v1/(2·B)` holds, that the ordering `xI2 < x2` is maintained, and that the integer flags satisfy `I2_577 = 2` and `I1 = 2`.  \n\nThe inner implication further requires that, whenever `0 ≤ ts2320uscore0 ≤ t2320uscore0`, the computed term `?v_0` stays within `[0, V]` and the elapsed time (`ts2320uscore0 + 0`) does not exceed the deadline `ep`.  \n\nBecause the outermost connective is a `not (exists ...)`, the benchmark checks that **no** assignment to the variables can violate all these safety inequalities; thus the problem is essentially a safety‑property proof (unsatisfiable if the system is safe).  \n\nNotably, the formula mixes linear and quadratic relations via `bvmul` and `bvsdiv`, giving it a relatively high term‑depth (21) and making it a challenging non‑linear BV verification condition for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156618.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the 2012 IJCAR paper on non‑linear arithmetic and models the “safe‑intersection” example (node 156618 of *intersection‑example‑simple.proof*).  \nThe file contains 19 declared bit‑vector constants and a single, large quantified assertion that negates an existential statement over a time variable `ts725uscore0`.  \nThe assertion combines many conjuncts that enforce non‑negativity and upper bounds (by a constant `V`) on velocities `v1`, `v2`, and parameters `A`, `B`, while relating positions `x1`, `x2`, `xI1`, `xI2` through non‑linear arithmetic such as `v1·v1`, `B·ts`, and a signed division `bvsdiv`.  \nA `let` term (`?v_0`) captures the expression `v2uscore2dollarskuscore246 – B·ts725uscore0`, which is required to stay within `[0,V]` and to respect a deadline `ep`.  \nThe benchmark therefore checks whether there exists a time step satisfying all these hybrid‑system safety constraints; the outer `not` makes the solver look for a counterexample, exposing the interaction of non‑linear multiplication, signed division, and quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node12552.smt2",
    "description": "The file is a single‑assertion BV (32‑bit bit‑vector) benchmark (logic BV, 3 KB, 15 declared constants, 1 ∃‑quantifier) taken from the “keymaera” family of verification conditions and translated to bit‑vectors by Mathias Preiner.  The asserted formula is the negation of an existential claim over a time‑step variable `ts6$0`; it therefore asks the solver to prove that no valuation of this variable can satisfy a large conjunction of arithmetic constraints.  The constraints encode a non‑linear safety condition for the “binary driver” hybrid‑system model: they relate positions, velocities (`v`, `vuscore…`), accelerations (`b`, `d`), bounds (`amax`, `ep`), and auxiliary terms (`muscore…`, `zuscore…`) using multiplications, divisions, and quadratic expressions (e.g., `v*v - d*d ≤ …`, `vuscore² – … ≤ …`).  Additional linear bounds enforce non‑negativity of all physical quantities, ordering of time variables (`0 ≤ ts6 ≤ t6$0`), and a strict positivity condition on parameters such as `b`, `ep`, and `amax`.  The benchmark is notable for its depth (max term depth 23) and heavy use of nested bit‑vector arithmetic, making it a challenging industrial example for solvers that handle non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43329.smt2",
    "description": "The file is a 32‑bit Bit‑Vector benchmark (logic BV) from the Preiner‑Keymaera family, taken from the Keymaera hybrid‑system verification suite (safe‑intersection case) and translated to bit‑vectors by Mathias Preiner; it is 2 KB in size, contains one large asserted formula and 12 declared constants.  \nThe single assertion is the negation of an existential query: it asks whether there exists a 32‑bit time stamp `ts97uscore0` that satisfies a long conjunction of range constraints (e.g., `0 ≤ ts ≤ t179…`, `0 ≤ B`, `0 ≤ v ≤ V`, `0 ≤ ep`, `0 ≤ vuscore4… ≤ V`) together with a safety implication.  \nThe implication’s antecedent ensures that the vehicle’s state stays within prescribed bounds (speed, position, and a linear combination `-B*ts + vuscore4…` is non‑negative), while the consequent encodes a physical safety condition `xI > x + (v·v)/(2·B)` and forces `I1 = 2`.  \nThus the benchmark checks that no reachable time makes the vehicle violate the stopping‑distance inequality under the given acceleration `B`, speed limits, and other parameters – i.e., it verifies a safety invariant for the one‑lane intersection scenario.  \nBecause all arithmetic is expressed with bit‑vector multiplication and signed division, the problem is a non‑linear BV verification task with a nesting depth of 22 and a relatively dense use of relational operators (`bvsle`, `bvsge`, `bvsgt`, `bvslt`).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node156170.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition for the “intersection‑example” hybrid system from the KeYmaera family, originally used to prove that two vehicles never occupy the crossing simultaneously.  The single top‑level assertion is the negation of an existential formula over the time variable ts723uscore0, stating that there is **no** assignment to the system’s parameters (initial positions x1, x2, velocities v1, v2, acceleration A, braking B, and a bound V) that can make the unsafe predicate true.  The unsafe predicate combines non‑linear arithmetic (e.g., bvadd (bvmul A ts) v2, bvsdiv (bvmul v1 v1) (bvmul 2 B)) with signed comparisons (bvsgt, bvsle, bvsge) to express that the projected positions xI1 and xI2 violate the separation condition while all physical bounds (non‑negative parameters, V > 0, ep > 0, etc.) hold.  Because the whole formula is wrapped in a not, the SAT query checks whether the safety condition is **valid**; a satisfiable result would exhibit a counterexample to safety.  At 2883 characters, 20 declared bit‑vector constants and a maximum term depth of 21, the instance features several nonlinear bvmul and a division, making it a representative and relatively large industrial benchmark for non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node191763.smt2",
    "description": "The benchmark is a 32‑bit Bit‑Vector formula (logic BV) stemming from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑simple” proof node 191763 of the Preiner‑keymaera family (≈2.7 KB, 18 declared constants, one top‑level assertion). It encodes the negation of an existential statement over a time variable `ts891uscore0`, asserting that no reachable state can satisfy a collection of safety predicates that involve non‑negative bounds on velocities `v1`, `v2`, a global upper bound `V`, and a relation  \n`xI1 > x1 + v1²/(2·B)` together with `xI2 < x2`, while also linking `A`, `B`, and the auxiliary term `?v_0 = A·ts891uscore0 + v2`. The constraints are expressed with signed‑greater/less‑than comparisons (`bvsgt`, `bvslt`, `bvsge`, `bvsle`) and include non‑linear bit‑vector operations (`bvmul`, `bvsdiv`). An additional bookkeeping condition forces `ts891uscore0` to lie in the interval [0, t891uscore0] and to keep the derived term `?v_0` within `[0, V]`, while also requiring the overall deadline `ep` to be positive. Satisfiability of the outer `not …` therefore asks whether the safety condition is universally true; the instance is a typical industrial non‑linear BV verification problem that stresses quantifier handling, let‑bindings, and mixed arithmetic‑logic reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192976.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑simple” proof node 192 976 of the IJCAR 2012 paper on non‑linear arithmetic.  \nThe file declares 18 32‑bit constants (velocities, positions, time variables, bounds A, B, V, ep, etc.) and contains a single top‑level assertion that negates an existential quantifier over a time variable ts897₀.  \nInside the quantified formula a `let` term defines a linear expression ?v₀ = v₁·(‑B·ts) + v₁′, and the subsequent constraints enforce: both “modes” I₁ and I₂ equal 2, non‑negative bounds on all variables, upper bounds by a global limit V, a safety condition on positions (`xI1 > x1 + v1²/(2·B)` and `xI2 < x2`), positivity of the parameters B, V and ep, and finally that the computed expression ?v₀ stays within [0, V] together with a deadline ts ≤ ep.  \nThe outer implication ⇒ requires that if the start time t₈₉₇₀ is non‑negative, then the whole conjunctive state must hold; the final `or` clause forces either `I1 = 2` (already true) or the trivial equality 0 = 2, making the quantified block unsatisfiable unless a counterexample exists.  \nThus the solver is asked to prove that no assignment to ts897₀ can violate the safety invariant—i.e., that the hybrid‑system model of a vehicle intersection is safe—while exercising BV non‑linear arithmetic (multiplication of two variables and signed division).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node16159.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition coming from the KeYmaera hybrid‑system prover; it was extracted from the “intersection‑example‑onelane” proof (node 16159) and translated to BV by Mathias Preiner.  The file contains a single, fairly large assertion (≈ 2.7 KB, 23‑deep term nesting) that negates an existential quantifier over a time variable `ts35uscore2`.  Inside the quantifier a chain of linear and quadratic arithmetic constraints is built with `bvmul`, `bvsdiv`, `bvadd` etc., modelling a vehicle’s position (`xI`, `x`, `xuscore2dollarskuscore50`), velocity (`v`, `vuscore2dollarskuscore56`), and bounds (`A`, `B`, `V`, `ep`).  The core property being checked is a safety invariant: under non‑negative bounds on time, velocities and parameters, the current position must stay within a computed reachable interval; the final disjunction asserts that the position either lies below a quadratic lower bound or above an upper bound derived from the parameters.  By asserting the negation of the existential, the solver is asked to prove that no time instant can violate the safety condition, i.e., the hybrid‑system model of a one‑lane intersection is safe.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node723526.smt2",
    "description": "This benchmark is a 32‑bit‐vector encoding (logic BV) of a safety proof obligation generated by the KeYmaera hybrid‑system verifier for a simple road‑intersection scenario (the “intersection‑example‑simple” VC, node 723526).  It originates from the Jovanović & de Moura paper on non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner, resulting in a 2 948‑character instance with 20 declared constants and a single, fairly large, quantified assertion.  The formula asks whether there exists a time‑step variable `ts3515uscore0` such that a conjunction of numeric conditions holds: non‑negative parameters A, B, V, ep; velocities v1, v2 bounded between 0 and V; positions xI1, xI2 exceeding their initial positions plus a term proportional to the squared velocities divided by 2·B; and auxiliary constraints linking auxiliary variables (e.g., `I1 = 2`, `I2 = 2`).  The outer disjunction requires either `xI1` to equal a specific constant or, if a non‑negative time bound holds, a series of additional bounds on the same variables together with a trivial equality (`1 = 2`) that forces the other branch to be taken.  Thus the instance checks the existence of a reachable unsafe state under the encoded hybrid‑system dynamics, exercising non‑linear arithmetic (multiplication, division) within the bit‑vector theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194065.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the Keymaera hybrid‑system verifier and translated to bit‑vectors by Mathias Preiner; it appears in the “intersection‑example‑simple” proof node 194065 and is classified as an industrial‑category VC. The formula is a single negated existential claim: it asserts that there **does not** exist a time stamp `ts903` (a 32‑bit word) satisfying a constellation of safety constraints for a road‑intersection scenario. The constraints encode non‑negative bounds on velocities `v1`, `v2` and a global speed limit `V`, positivity of the braking coefficient `B`, fixed mode identifiers (`I1 = 0`, `I2 = 2`), a quadratic deceleration term `v1*v1/(2*B)`, and a linear distance expression `A*ts903 + v1_...` that must stay within `[0,V]` while the elapsed time stays within `[0,ep]`. The outer `not` forces the solver to prove that no such `ts903` can violate these conditions, i.e. that the safety property holds. The file contains 19 declared bit‑vector constants, a maximum term depth of 20, and uses several non‑linear BV operations (multiplication, signed division) typical of the Preiner‑Keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node709258.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “intersection‑example‑simple” proof node 709258 (≈2.9 KB, 20 constants, one quantified assertion). The formula asserts the **negation of an existential** over a time‑step variable ts3426₀, so the solver must prove that no value of ts3426₀ can satisfy a large conjunction of arithmetic constraints. The constraints encode a safety condition for a vehicular intersection: non‑negative accelerations A, B, speeds v₁, v₂ bounded by a global limit V, a positive safety margin ep, and a collision‑avoidance inequality that mixes linear terms with non‑linear operations such as bvmul (A·ts), bvmul (v₂·v₂) / (2·B). Additional equalities tie auxiliary variables (e.g., xI₁ = x₁, I₁ = 2) to concrete constants, while disjunctions handle alternative case splits. Notably, the instance combines quantified reasoning, mixed linear/non‑linear bit‑vector arithmetic, and relatively deep term nesting (max depth 21), making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166868.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (`(set‑logic BV)`) originating from the KeYmaera hybrid‑systems verifier; it encodes the “intersection‑example‑simple” safety proof (node 166868) used in the Jovanović & de Moura IJCAR 2012 paper on non‑linear arithmetic. The problem size is modest (18 declared constants, a single quantified assertion, 2742 characters, maximum term depth 20) and falls into the “industrial” category of the Preiner‑keymaera family. The formula asserts the **negation** of the existence of a time‑step variable `ts771_0` such that a collection of linear bounds (e.g., `0 ≤ A, B, V, ep` and `0 ≤ v1,v2 ≤ V`) and a quadratic relation (`bvmul v1 v1` appears inside a division) are simultaneously satisfied, together with safety conditions on the positions `xI1`, `xI2` (e.g., `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`). The constraints are expressed with signed‑comparison operators (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) and mixed arithmetic (`bvmul`, `bvsdiv`, `bvadd`, `bvneg`). By translating the original real‑valued non‑linear arithmetic verification condition into bit‑vectors, the benchmark tests solvers’ ability to handle quantified, non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391376.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition extracted from the **KeYmaera** hybrid‑system proof “intersection‑example‑simple” (node 391376).  It originates from the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and is part of the Preiner‑keymaera industrial family; the file is 2 857 bytes long, declares 19 constants and contains a single, fairly deep (depth 21) quantified assertion.  \n\nThe assertion is of the form **¬∃ ts** … , i.e., it asks the solver to prove that no time‑stamp ts (a 32‑bit bit‑vector) can satisfy a collection of safety constraints.  The constraints relate variables that model positions (x₁, x₂), velocities (v₁, v₂), bounds (V, A, B), and a deadline ep, and they involve non‑linear arithmetic such as v₁·v₁, v₂·v₂ and divisions (bvsdiv), all translated into bit‑vector operations (bvmul, bvadd, bvsgt, etc.).  \n\nKey properties asserted are: the velocities lie between 0 and a maximal speed V, the accelerations A and B are non‑negative, the quadratic “distance” terms stay within bounds, and a timing relation 0 ≤ ts ≤ t holds while staying before the deadline ep.  The overall goal is to show that the safety condition (the conjunction of these inequalities) is unsatisfiable, i.e., the intersection scenario is safe under the given hybrid‑system dynamics.  \n\nNotably, the benchmark mixes several BV comparison operators (bvsle, bvsge, bvsgt) and a single existential quantifier, making it a representative case of non‑linear arithmetic problems that have been bit‑vector‑encoded for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190062.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 190062 of *intersection‑example‑simple.proof*).  The single assertion is the negation of an existential formula, so the solver is asked to prove that no assignment to the time variable `ts883uscore0` can violate the safety property.  The formula relates a number of constants (e.g., `A`, `B`, `V`, `ep`) and state variables (`x1`, `x2`, `v1`, `v2`, `xI1`, `xI2`) with non‑negative and upper‑bound constraints, a quadratic‑like motion term `bvmul v1 v1 / (2*B)`, and linear inequalities that capture the condition “vehicle 1’s position stays ahead of the collision point while both velocities stay within `[0,V]`”.  The core of the problem is a conjunction of signed‑comparison predicates (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) together with arithmetic expressions built from `bvadd`, `bvmul`, and a single signed division `bvsdiv`.  Because the original real‑valued non‑linear arithmetic was translated to bit‑vectors, the instance tests the solver’s ability to handle non‑linear integer arithmetic and deep nested let‑bindings (max term depth 21) in an industrial‑style verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5964.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector instance (logic BV) of modest size (≈2 kB, 7 declared constants and a single, deeply nested assertion). It originates from the Keymaera verification suite (bouncing‑ball‑simple, node 5964) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera collection. The formula asserts the negation of an existential query over a time‑step variable `ts1uscore7`; inside the quantifier a let‑bound term `?v_0` computes a quadratic expression involving the squares of the state variables and the quantified time. The antecedent of the implication encodes the dynamics of a simple bouncing‑ball hybrid system: bounds on time (`0 ≤ ts1 ≤ t1`), non‑negativity of height `h` and velocity `v`, algebraic relations linking height, velocity, and control variables (`huscore… = 5·tuscore² + vuscore²`), and linear safety constraints (`v = 16`, `h = 0`). The consequent merely requires that the computed expression `?v_0` be non‑negative, so the outermost `(not …)` checks that no reachable state violates the safety condition, i.e., it verifies a safety invariant of the bouncing‑ball model using non‑linear arithmetic encoded as bit‑vector multiplication.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548485.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV, 20 declared constants, 1 quantified assertion, ≈2.9 KB) taken from the Keymaera hybrid‑system verification suite; it originates from a safety‑proof for a simple traffic‑intersection example (KeYmaera proof node 548485, translated to BV by Mathias Preiner). The single top‑level constraint is a negated existential formula that searches for a time `ts2613uscore0` witnessing an unsafe state: two vehicles with velocities `v1` and `v2` (both non‑negative and bounded by a global limit `V`) and a positive braking constant `B` must satisfy a quadratic braking distance condition `xI2 > x2 + v2²/(2·B)` while the mode variables `I1` and `I2` are fixed to the value 2. Additional side constraints enforce that the positions `xI1`, `xI2` lie within the current positions `x1`, `x2`, that the global time horizon `ep` and a local bound `t2613uscore0` are non‑negative, and that the auxiliary term `?v_0 = A·ts2613uscore0 + v2uscore3dollarskuscore521` stays inside `[0,V]`. By wrapping the whole condition in `(not (exists …))` the benchmark asks the solver to prove that **no** such time exists, i.e., that the safety property holds for all reachable states. Notably, the encoding uses bit‑vector multiplication and signed division to represent the non‑linear arithmetic of the original hybrid‑system model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12517.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera hybrid‑system verifier and translated to bit‑vectors by Mathias Preiner (see the cited “intersection‑example‑onelane” proof node 12517).  It contains 13 declared constants, one large quantified assertion, and a total of 2 978 characters; the assertion is the negation of an existential check over a time variable ts26uscore2.  The main body is a big implication that enforces a hierarchy of safety‑relevant bounds: non‑negativity and upper limits for positions (xI, x), velocities (v, vuscore2dollarskuscore41) and parameters (A, B, V, ep), a time interval 0 ≤ ts ≤ t43, and a discrete dynamics relation linking the current position xI to a quadratic expression built from the constants (essentially the reachable‑set formula for a vehicle on a lane).  The final condition is a disjunction stating that xI must lie either below that quadratic term or above it plus a correction term, i.e., that the vehicle’s position stays outside the unsafe interval.  Satisfiability of the whole formula would falsify the safety property, so the benchmark is used to prove that the safety condition is invariant for the modeled intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live2.proof-node640.smt2",
    "description": "This benchmark is a 32‑bit Bit‑Vector (BV) problem (logic BV) taken from the Keymaera verification suite for the European Train Control System case study; it was translated to BV by Mathias Preiner and appears in the industrial family “Preiner‑keymaera”.  The file is modest in size (≈1.6 kB, 7 declared constants and a single top‑level assertion) and includes an existential quantifier over a 32‑bit variable *dollarnuscore0*.  \nThe assertion checks the negation of “∃ dollarnuscore0 . (P ⇒ Q)”, where the premise P enforces that the variables vo, ep, b are strictly positive and A is non‑negative (signed comparisons bvsgt and bvsge).  \nThe consequent Q requires a signed‑greater‑or‑equal inequality that involves a non‑linear term (bvmul (bvmul dollarnuscore0 ep) vo) added to zo and compared with puscore0dollarskuscore0; a trivial tautology bvsge vo vo is also present.  \nThus the solver is asked to prove that no such *dollarnuscore0* can satisfy the mixed linear‑non‑linear signed constraints, i.e., to show the formula is unsatisfiable.  \nThe benchmark is notable for combining existential quantification, signed arithmetic, and multiplication of three 32‑bit terms, which makes it a small yet challenging instance for BV solvers handling non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node4261.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition extracted from the KeYmaera hybrid‑system proof “intersection‑example‑onelane” (node 4261), originally modelling a vehicle‐intersection scenario.  It belongs to the Preiner‑keymaera industrial family, was submitted by Dejan Jovanović, and consists of a single large assertion (size ≈ 2.6 KB, 13 declared constants, max term depth 23) that negates an existential statement over a time variable **ts7₀**.  The quantified formula combines a cascade of linear and non‑linear constraints—bounds on timestamps, positions (**x**, **xI**, **x₉**), velocities (**v**, **V**, **vu**) and parameters (**A**, **B**, **ep**) expressed with bit‑vector addition, multiplication, division and ordering (e.g., `bvsle`, `bvsge`, `bvsgt`).  The core property being checked is that no admissible assignment to the variables can satisfy all the hybrid‑system dynamics and safety predicates simultaneously, i.e., the negated existence should be unsatisfiable, thereby proving the intersection safety condition.  Notably, the original real‑valued non‑linear arithmetic of the KeYmaera proof has been translated into fixed‑width bit‑vectors, preserving multiplications and divisions, which makes the instance a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559749.smt2",
    "description": "This benchmark is a single‑assertion BV (fixed‑width bit‑vector) problem originating from the KeYmaera hybrid‑system verification suite, specifically the “intersection‑example‑simple” proof node 559749, and was translated to 32‑bit bit‑vectors by Mathias Preiner.  The file contains 20 declared 32‑bit constants (representing quantities such as positions x₁, x₂, velocities v₁, v₂, parameters A, B, and a time bound ep) and one quantified formula that asserts the **negation** of an existential property over a fresh time variable ts.  The core of the formula encodes a safety condition for a vehicle intersection: it requires all relevant variables to be non‑negative, the velocities bounded by a maximal value V, the acceleration parameter A ≥ 0, the braking constant B > 0, and a geometric inequality bvsgt xI₂ ( x₂ + v₂² / (2·B) ) that captures a stopping-distance constraint.  Additional conjuncts tie the variables together (e.g., I₁ = 0, I₂ = 2, I₁uscore = 2, I₂uscore = 2) and enforce simple ordering (xI₁ < x₁, xI₂ > x₂).  The solver is asked to show that the negated existential is unsatisfiable, i.e., that a reachable unsafe state does **not** exist under the given non‑linear arithmetic‑derived bounds, making this a typical industrial non‑linear verification instance encoded into bit‑vector logic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291616.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” proof node 291616 that appears in the Jovanović–de Moura IJCAR 2012 paper and the Loos‑Platzer safe‑intersection case study.  The file contains a single quantified assertion (∼∃ ts) whose body defines three auxiliary terms: ?v₂ testing whether the constant I₂$418 equals 2, ?v₀ = A·ts + v₁$418 and ?v₁ = (‑B)·ts + v₂$418, thus introducing non‑linear multiplications of bit‑vectors.  The antecedent of the main implication is a large conjunction of linear bounds (variables are non‑negative and bounded by a common limit V > 0, B > 0, ep > 0, etc.) together with relational constraints on the “intersection” variables (e.g.,  xI₁ < x₁, xI₂ > x₂ + v₂²/(2·B)).  The consequent merely requires that either I₁$418 = 2 or I₂$418 = 2; since the antecedent forces I₁$418 = 0, the condition reduces to checking that the other constant is indeed 2, which is already asserted.  Consequently the whole formula asks the solver to prove that no ts satisfying all the safety‑related arithmetic constraints exists, i.e., that the hybrid‑system safety condition holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node152045.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera‑generated verification conditions for a “safe intersection” hybrid‑system example, translated to bit‑vectors by Mathias Preiner (size ≈ 2.8 KB, 19 declared constants and a single quantified assertion). The sole assertion states that **no** 32‑bit value for the time variable `ts704uscore0` can satisfy a large conjunctive hypothesis together with a safety conclusion; in other words it checks the unsatisfiability of an existential witness. The hypothesis encodes the usual traffic‑safety constraints: non‑negative speeds `v1`, `v2` bounded by a maximum `V`, a positive braking constant `B`, positivity of the overall bound `V` and a deadline `ep`, plus kinematic relations such as `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`. The safety conclusion either identifies the initial position `xI1` with a reference point `x1…` or, when a lower‑bound on a start time `t704uscore0` holds, forces `ts704uscore0` to stay within `[0,ep‑1]` while the derived velocity expression `v2 – B*ts704uscore0` remains in `[0,V]`. The problem therefore tests a non‑linear arithmetic verification condition after it has been bit‑vector‑encoded, featuring mixed signed comparisons, multiplication, division and a quantifier, which makes it a challenging industrial benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node5338.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) problem (logic BV) taken from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner; it appears in the “industrial” category of the Preiner‑keymaera family and contains 13 declared constants, a single quantified assertion and 2 769 characters. The single top‑level formula is a negated existential over a time variable `ts9uscore0`, asserting that no value of this variable can satisfy a large conjunction of linear and non‑linear bit‑vector constraints. The constraints encode bounds on vehicle‑related quantities (speed `vuscore2dollarskuscore14`, position `xI`, lane limits `A`, `B`, etc.), non‑linear relations such as `vuscore2dollarskuscore14²/(2·B)` and mixed terms like `xI > x + …`, and positivity conditions (`B>0`, `V>0`, `ep>0`). The core property being checked is a safety invariant for a one‑lane intersection scenario (e.g., that the vehicle’s position never violates the lane or collision distance). Notably, the instance uses several bit‑vector divisions and multiplications to simulate real‑valued non‑linear arithmetic, leading to a deep nesting of `and`, `or`, and `=>` operators (max term depth 23).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732272.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic BV, 2841 characters, 19 declared constants) originating from the KeYmaera hybrid‑systems verifier and translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category).  Its single top‑level assertion is the negation of an existential formula that quantifies a fresh time variable `ts3568uscore0`; the surrounding implication encodes the safety condition that, for all admissible time steps, the “intersection” variables stay inside the interval \\([0,V]\\) and the velocities `v1`, `v2` are non‑negative and bounded by `V`.  The core constraints are non‑linear: they involve products `bvmul A ts…`, `bvmul v1 v1`, `bvmul v2 v2` and signed divisions `bvsdiv …`, together with ordering relations (`bvsgt`, `bvsge`, `bvsle`).  Additional arithmetic bounds require the constants `A`, `B`, `V`, and `ep` to be positive, and enforce that the derived expressions `?v_1 = A*ts + v2` and `?v_0 = 2*B` stay within the same interval.  The benchmark therefore checks that no reachable state violates the intersection safety invariant, turning a non‑linear real‑valued verification condition into a bit‑vector problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node99874.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the **Keymaera** hybrid‑system verifier; it appears in the industrial “Preiner‑keymaera” family and is 2 657 characters long, declaring 18 constants and a single large assertion.  \nThe assertion negates an **existential** formula that introduces a fresh time‑step variable `ts466uscore0` and then defines two intermediate linear expressions `?v_0` and `?v_1` as affine combinations of the constants `A`, `B`, `v1uscore1dollarskuscore452`, `v2uscore1dollarskuscore452` and the time variable.  \nThe body of the existential quantifier encodes a set of **range constraints**: all variables and the two expressions must lie between 0 and a positive bound `V`; the parameters `A` and `B` are required to be non‑negative, `V` and `ep` must be strictly positive, and several ordering conditions (`xI1 < x1`, `xI2 < x2`, `I1 = 2`, `I2 = 2` or `I2 = 2`) are also asserted.  \nFinally, the outer implication checks that if the time step is non‑negative and respects the interval `[0, t466uscore0]`, then the computed expressions stay inside `[0,V]` and the elapsed time does not exceed `ep`, while also forcing either `I1uscore1dollarskuscore452 = 2` or `I2uscore1dollarskuscore452 = 2`.  \nThus the benchmark tests a solver’s ability to handle **non‑linear (multiplication) arithmetic on 32‑bit bit‑vectors together with nested quantifiers and a dense mix of signed inequality constraints** that arise from a safety verification condition for a traffic‑intersection hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dynamic_reaction_to_static_bounds.proof-node849.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic **BV**) taken from the Keymaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the 2012 IJCAR paper on non‑linear arithmetic.  It consists of a single quantified assertion: the solver is asked to prove that the **existential** statement over the variable `ts0uscore3` is **unsatisfiable** (the outermost `not` negates the `exists`).  The quantified body is a long conjunction of linear bit‑vector inequalities that model a safety condition for a dynamic reaction to static bounds, e.g. `0 ≤ ts0 ≤ t1`, `ts0 < Tr`, `a2*ts0+v2 ≥ 0`, together with parameter ordering constraints such as `‑B ≤ a2 ≤ A`, `B ≤ b`, `A ≥ 0`, `b > 0`, `Tr > 0`, and `v2 ≥ 0`.  The final inequality `v2 ≤ a2*t1 + v2 + B*Tr` links the parameters and the existential time variable, checking that the accumulated value never exceeds a prescribed bound.  Apart from the quantifier, the problem contains only basic BV operations (`bvsle`, `bvsge`, `bvadd`, `bvmul`, `bvsgt`, `bvslt`), has 8 declared constants, a single assertion, and a modest size of 1 708 characters, making it a typical industrial‑style verification condition encoded in bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347607.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “intersection‑example‑simple” proof node 347607 of the keymaera family (industrial category, 2 876 characters, 19 declared constants). The single top‑level assertion negates an existential formula over a time variable ts₁₆₁₉ and encodes a safety condition for a hybrid‑system model of two vehicles approaching an intersection. The core constraints bound all parameters (A, B, V, ep, the velocities v₁, v₂, and the time stamps) to be non‑negative, require the velocities to stay within the common limit V, and ensure that the future positions xI₁, xI₂ are larger than the current positions plus a term proportional to v² ÷ (2·B) (expressed with bvmul, bvsdiv, and bvadd). An additional disjunction either equates xI₂ to a specific value or demands that the time variable respects a series of bounds, together with the condition that a linear combination (2·B·ts₁₆₁₉ − v₁·v₁) stays in [0, V]. The instance therefore checks whether the encoded reachability/safety property is violated under all admissible integer‑valued (32‑bit) parameters.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node619900.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera family of hybrid‑system verification problems, specifically the “intersection‑example‑simple” proof node 619900 (≈3 KB, 20 declared constants, one large conjunct of depth 21).  The formula asserts the *negation* of an existential statement over a time variable `ts2963uscore0`; the existential part encodes a potential safety violation for a vehicle intersection model, where positions `xI1`, `xI2` must stay ahead of the nominal positions `x1`, `x2` by at least the braking distance `v^2/(2·B)` and the acceleration effect `A·t + v₂`.  The core constraints enforce non‑negative, bounded parameters (`0 ≤ v1,v2,A,B,V,ep`) and the usual signed‑comparison relations (`bvsgt`, `bvsge`, `bvsle`) that capture speed limits (`v ≤ V`) and positive acceleration (`B>0`).  A disjunction links the state either to a special case (`xI1 = x1uscore4dollarskuscore330`) or to a time‑bound condition (`t ≥ 0 ∧ t ≤ t ∧ ts+0 ≤ ep`), together with a trivial arithmetic equality (`?v_2` or `1=2`).  The problem therefore checks whether, under all admissible physical parameters, no reachable state can violate the intersection safety condition, i.e., whether the safety invariant holds for the encoded hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267257.smt2",
    "description": "The file is a 2‑KB BV‑logic benchmark (32‑bit bit‑vectors) originating from the KeYmaera safety‑verification suite; it was extracted from the “intersection‑example‑simple” proof (node 267257) in the Jovanović & de Moura non‑linear arithmetic paper and translated to bit‑vectors by Mathias Preiner.  It contains a single, large quantified assertion that negates the existence of a time‑step variable `ts1241uscore0` satisfying a conjunction of arithmetic relations over positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), constants (`A`, `B`, `V`, `ep`) and auxiliary terms.  The constraints encode the hybrid‑system dynamics of two vehicles approaching an intersection (e.g., `xI2 > x2 + v2²/(2·B)`, `v1 ≥ 0`, `V > 0`) together with safety conditions such as bounded speeds (`v1 ≤ V`, `v2 ≤ V`) and a deadline (`ts1241uscore0 ≤ ep`).  The outermost `not (exists …)` therefore asks the solver to prove that no violating assignment exists, i.e., that the safety property holds for all reachable states.  Notably, the benchmark mixes non‑linear operations (multiplication, division, negation) with signed comparisons, testing the solver’s ability to handle arithmetic‑heavy bit‑vector encodings of hybrid‑system verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264965.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera hybrid‑system verification suite; it originates from the “intersection‑example‑simple” proof node (264965) used in the IJCAR 2012 paper on non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner.  It contains a single quantified assertion: the negation of an ∃‑quantifier over a time variable ts1230uscore0, together with a large conjunctive block of arithmetic constraints on nineteen 32‑bit variables that model positions, velocities (v1, v2), bounds (V, A, B), and constants (I1, I2, ep).  The constraints enforce that all variables lie in the interval [0,V] (e.g., bvsge v1 0, bvsle v1 V, bvsge A 0, bvsgt V 0), that certain identifiers equal the constant 2, and that a derived expression ?v_0 = A·ts + v1 remains within the same bounds while also satisfying a safety condition bvsle ( bvadd ts 0 ) ep.  Non‑linear reasoning appears through the term bvmul v2 v2 and the division bvsdiv (bvmul v2 v2) (bvmul 2 B), which encode a quadratic velocity bound used in the hybrid‑system safety proof.  The benchmark therefore checks whether any time instant satisfying all these safety‑critical inequalities exists; proving the outer not of the existential unsatisfiable demonstrates that the intersection model meets its safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-node3896.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition that originates from the KeYmaera proof of an adaptive cruise‑control system (the “dccs‑example” node 3896). It was extracted from the Jovanović–de Moura non‑linear arithmetic collection and translated to BV by Mathias Preiner, making it an industrial‑style test case (size ≈ 2.6 KB, 10 declared constants, 1 quantified assertion, maximum term depth 22). The formula asserts the **negation** of an existential statement over a time variable `ts1uscore1`; the body contains a chain of conjuncts that model safety properties such as non‑negative velocities (`v1`, `v1uscore2…`), positive parameters (`A`, `B`, `eps`), bounds on the elapsed time (`0 ≤ ts1 ≤ t1`), and ordering of positions (`x1 < x2`, `x1uscore2… < x2`). The constraints also encode non‑linear dynamics using bit‑vector multiplication (e.g., `v1*v1`, `A*ts1*ts1`) and a division by `2*B`, reflecting the hybrid‑system differential equations in a discrete setting. The overall check (`(check-sat)`) asks whether the negated existential is unsatisfiable, i.e., whether the safety condition holds for all admissible values. Notably, the instance combines quantifiers, nested `let`s, and several non‑linear BV operations, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682405.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition coming from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 682405), translated to bit‑vectors by Mathias Preiner and taken from the industrial benchmark suite used in Jovanović & de Moura 2012.  \nThe single top‑level assertion is the negation of an existential formula that quantifies a fresh time variable `ts3263uscore0` and encodes the safety VC for a road‑intersection scenario: it relates the positions `xI1`, `xI2` of two vehicles, their initial distances (`I1`, `I2`), velocities (`v1`, `v2`) and the parameters `A`, `B`, `V`, `ep`.  \nKey constraints require all physical quantities to be non‑negative (`bvsgt`/`bvsge`), the accelerations `A` and `B` to be non‑negative, the velocity bounds `v1, v2 ≤ V`, and that the linear updates `?v_0 = -B·ts + v1'` and `?v_1 = A·ts + v2'` stay within `[0,V]` while the elapsed time stays below `ep`.  \nThe formula also forces the initial conditions `I1 = 2`, `I2 = 2`, `I1' = 0`, and a strict ordering `xI1 < x1`, `xI2 < x2`.  \nSatisfiability of the asserted `not (exists …)` would give a concrete counterexample to the safety property; the instance contains 19 declared bit‑vector constants, a single quantified block, a maximum term depth of 20, and 2751 characters.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551039.smt2",
    "description": "This benchmark is a 2.8 KB Bit‑Vector (BV) problem (logic BV, 19 declared 32‑bit constants, maximum term depth 20) taken from the Keymaera hybrid‑system verification suite and translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category). The single assertion is the negation of an existential formula, i.e. it asks the solver to show that no assignment to the time variable ts1246₀ can satisfy a chain of safety constraints, so the query is essentially a verification‑condition unsatisfiability check. The constraints encode a simple “intersection” scenario: non‑negative parameters A, B, V, ep, with V > 0, vehicle speeds v1, v2 bounded by 0 ≤ v1, v2 ≤ V, and lane‑index variables I1 = I2 = 2; they also require that the position xI2 exceeds x2 plus the braking distance v2²/(2·B), and that a time‑dependent position v1 + A·ts stays within [0, V] during the interval 0 ≤ ts ≤ t1246₀ ≤ ep. Additional side conditions tie together the “prime” copies of variables (e.g., v1₀ = v1, I1₀ = 2) and enforce that either the post‑state position equals a given constant or the time bounds hold. The problem therefore checks that, under these linear‑and‑quadratic (encoded via multiplication and division) relationships, no reachable state can violate the safety invariant for the intersection.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48996.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera verification suite; it originates from the “intersection‑example‑onelane” proof (node 48996) used in the IJCAR 2012 paper on non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner.  It declares twelve 32‑bit variables that model quantities such as a vehicle’s speed (v), acceleration (A), position (x), a safety distance (V), a time‑step (ts₁₁₀), and other auxiliary terms (e.g., B, ep).  The single assertion is the negation of an existential formula: it asks whether there exists a time‑step ts₁₁₀ satisfying a large conjunction of linear and non‑linear inequalities (bounds, non‑negativity, and quadratic terms like (v·v) or (vus·vus) divided by 2·B).  These constraints encode the safety condition that, for the given lane‑intersection scenario, the vehicle’s position after the time step remains strictly ahead of a computed safety margin while all physical variables stay within admissible ranges (e.g., 0 ≤ v ≤ V, A ≥ 0, V > 0, ep > 0).  The benchmark is therefore a satisfiability‑checking version of a safety‑property verification condition: it is unsatisfiable iff the original hybrid‑system proof obligation holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289727.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance from the **Preiner‑keymaera** family (size ≈ 2.8 KB, 18 declared constants and a single large conjunct). It encodes a verification condition extracted from the KeYmaera hybrid‑system proof **intersection‑example‑simple**, originally a real‑valued safety proof for vehicle intersections, which has been translated into bit‑vectors by Mathias Preiner. The formula asserts the negation of an existential statement over the time variable `ts1350uscore0`; the body consists of a long conjunction of bounds (e.g., `v1, v2, A, B, V, ep ≥ 0`), ordering constraints (`xI1 < x1`, `xI2 > x2 + v2·v2/(2·B)`), and a non‑linear arithmetic term `bvmul v2 v2` divided by `2·B`. The key property being checked is whether, under these preconditions, the derived constraints (including `0 ≤ ts ≤ t1350`, `0 ≤ v1 ≤ V`, `0 ≤ v2 ≤ V`, and `ts + 0 ≤ ep`) can ever be satisfied; the outer `not` turns the query into a **validity** check. Notably, the instance mixes quantifiers, bit‑vector arithmetic, and non‑linear multiplications, making it a challenging industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174997.smt2",
    "description": "This benchmark is a 2 322‑byte bit‑vector (BV) instance (logic BV, 19 declared 32‑bit variables) that originates from the KeYmaera verification of a “safe‑intersection” hybrid‑system example and was translated to bit‑vectors by Mathias Preiner.  The single top‑level assertion is the negation of an existential formula, i.e., it asks whether there **does not** exist a time‑step value `ts815uscore0` that can satisfy a conjunction of arithmetic bounds and a non‑linear safety condition.  The constraints encode non‑negative ranges for several state variables (`v1`, `v2`, `A`, `B`, `V`, `ep`), equalities linking auxiliary copies (e.g., `I1 = 2`, `I2 = 2`), and a key inequality `?v_0 = -B*ts815uscore0 + v1'` that must stay within `[0,V]` while also respecting `ts815uscore0 ≤ t815uscore0 ≤ ep`.  Additional side‑conditions enforce relationships such as `xI1 > x1 + v1²/(2·B)`, `xI2 < x2`, and positivity of `B`, `V`, and `ep`.  Because the formula contains quantified bit‑vector multiplication, signed division, and several nested comparators, it serves as a challenging industrial non‑linear arithmetic benchmark for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node403505.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula taken from the KeYmaera verification of a “safe intersection” hybrid‑systems example, translated by Mathias Preiner and classified as an industrial “Preiner‑keymaera” benchmark.  The single top‑level assertion negates an existential query over a time variable `ts1901uscore0`, so the solver must prove that no assignment to this variable can satisfy the embedded safety conditions.  The core constraints are linear‑affine expressions such as `?v_0 = -B·ts1901uscore0 + v1’` and `?v_1 = A·ts1901uscore0 + v2’`, together with non‑negativity and upper‑bound (`≤ V`) requirements on the state variables `v1`, `v2`, `A`, `B`, and the time bounds `0 ≤ ts1901uscore0 ≤ t1901uscore0 ≤ ep`.  Additional literals fix the mode indices (`I1 = 2`, `I2 = 2`) and require positivity of the constants `B`, `V`, and `ep`.  The formula contains 18 declared bit‑vector constants, 19 conjunctions, and a modest term depth of 20, illustrating how a hybrid‑systems verification condition is encoded purely in BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5980.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the “bouncing‑ball‑simple” verification condition of the KeYmaera hybrid‑systems prover, translated to bit‑vectors by Mathias Preiner (file BV/2017‑Preiner‑keymaera/bouncing‑ball‑simple‑node5980.smt2, 2082 bytes, 7 declared constants, 1 top‑level assertion).  The formula encodes the physics of a single ball bounce: variables such as height h, velocity v, time t₁, and parameters t_uscore, v_uscore, h_uscore appear in quadratic expressions (e.g., 5·t², ‑10·t·t_uscore) that model the ball’s trajectory under gravity.  An existential quantifier introduces a free time instant ts₁ constrained to lie between 0 and t₁, and the body asserts a conjunction of non‑negative bounds on height, velocity, and the derived quadratic expression, together with several linear relationships linking the parameters.  The outermost “not” turns the existential condition into a safety check: the solver must show that no ts₁ can satisfy all those constraints given the fixed assignments h = 0 and v = 16.  Thus the instance tests an SMT solver’s capability to handle non‑linear arithmetic encoded as bit‑vector operations, with a moderate term depth (19) and a mix of addition, multiplication, division, and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node392295.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition (BV logic, 19 declared constants, 1 assertion, 2 819 bytes) taken from the KeYmaera hybrid‑system prover and translated to SMT‑LIB by Mathias Preiner.  It encodes the safety of a simple traffic‑intersection scenario: the variables v₁,v₂ are (bounded) vehicle speeds, A and B are acceleration/braking limits, V is a speed upper bound, and x₁,x₂ (with auxiliary copies xI1, xI2) denote positions along the two crossing lanes.  The core of the formula is a negated existential over a time stamp ts₁₈₃₅₀, asserting that there is **no** reachable state in which all of the following hold simultaneously: the loop counters I₁ and I₂ equal 2, the positions satisfy xI1 > x₁ + v₁² / (2·B) and xI2 > x₂ + v₂² / (2·B), the speeds are non‑negative and bounded by V, the accelerations are non‑negative, and the elapsed time stays within a given horizon ep.  The condition also requires the computed distances ?v₁ = −2·B·ts + v₁ and ?v₂ = A·ts + v₂ to stay inside [0,V] and that the time t₁₈₃₅₀ is non‑negative.  Because it mixes non‑linear multiplications, signed division and quantified bit‑vector arithmetic, the instance is a typical industrial‑style VC that stresses SMT solvers’ support for quantified non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node166425.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for a “safe‑intersection” example; it appears in the Jovanović–de Moura IJCAR 2012 paper and was translated to bit‑vectors by Mathias Preiner (size ≈ 2.7 KB, 18 constants, one quantified assertion).  \nThe single top‑level assertion negates an existential formula over a time variable `ts769uscore0` and then checks a large conjunction of signed‑comparison constraints that model the kinematics of two vehicles (`v1`, `v2`, `A`, `B`, `V`, `ep`, etc.) together with safety predicates such as  \n`xI1 > x1 + v1²/(2·B)`, `xI2 < x2`, and bounds `0 ≤ v1,v2 ≤ V`, `A,B,ep > 0`.  \nWithin the body of the existential, the term `?v_0 = A·ts769uscore0 + v1` and `?v_2 = A·ts769uscore0 + v2` are required to stay in `[0,V]`, and the elapsed time must respect `ts769uscore0 + 0 ≤ ep`.  \nAn additional parity‑like condition forces either `I1 = 2` (encoded as `?v_3`) or the constant equality `0 = 2`, effectively making the whole clause depend on the value of `I1`.  \nOverall, the instance tests the solver’s ability to handle non‑linear arithmetic (multiplication, division) and a mixture of existential quantification and many signed bit‑vector comparisons arising from hybrid‑system safety verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-simple-node5963.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “bouncing‑ball‑simple” example (node 5963) and was translated to BV by Mathias Preiner (family Preiner‑keymaera).  The file is relatively small (≈2.4 KB, 7 declared constants and a single quantified assertion), but the assertion is dense: it contains a nested *let* term, an existential quantifier over a time variable `ts1uscore6`, and many nonlinear bit‑vector operations (14 `bvmul`, 9 `bvadd`, etc.) with a maximal term depth of 19.  \n\nThe core of the formula expresses the physics of a bouncing ball: it relates the ball’s height `h`, velocity `v`, and parameters `t1`, `tu`, `vu`, `hu` through quadratic equations (e.g., `‑5·t1² + t1·vu + hu`) and inequality constraints that enforce non‑negativity of time, height, and velocity, as well as bounds on the control variables.  The outermost `(not (exists … …))` asks the solver to prove that **no** value of the intermediate time `ts1` can violate these constraints, i.e., the verification condition is unsatisfiable.  \n\nThus the instance tests a solver’s ability to handle non‑linear arithmetic encoded in bit‑vectors, with mixed equalities/inequalities and a single existential quantifier, a characteristic pattern of industrial hybrid‑system verification problems.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2228.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑system verification suite and translated to BV by Mathias Preiner; it is classified as an industrial‑category problem and contains 10 declared constants, a single large assertion and about 2.8 kB of text.  The assertion is the negation of an existential formula ∃ts₂₁ …, where the body is built from a deep (depth 19) conjunction of range constraints (e.g., 0 ≤ ts₂₁ ≤ t₁₀, t₁₀ ≥ 0, B > 0, ep > 0) and several non‑linear relationships involving products and divisions of the bit‑vectors (e.g., v₁³, v₁·v₁, A·B, ep²).  Central to the VC is a quadratic inequality that compares a term bvmul (a₁·ts₂₁ + v₁) with vsl₆, and another inequality that relates the state variable xsl₆ to a complex expression containing v₁², (v₁·v₁), A/B, ep, and squared‑time terms.  The formula therefore checks whether a safety condition (encoded by the two disjunctive branches) holds for all admissible time values; if the outer not makes the whole formula unsatisfiable, the original verification condition is proved.  Notably, the instance mixes linear bit‑vector inequalities with genuine non‑linear arithmetic (multiplication and division) and uses a let‑binding to factor out recurring sub‑terms, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361630.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (size ≈ 2.8 kB, 18 declared constants, 1 top‑level assertion) taken from the Keymaera hybrid‑system verification suite and submitted by Dejan Jovanović; it was translated to BV by Mathias Preiner and belongs to the industrial “Preiner‑keymaera” family.  \nThe asserted formula is a negated existential: it asks whether there exists a 32‑bit time‑step `ts1682_0` such that a conjunction of arithmetic and ordering constraints can be satisfied; the outer `not` therefore requires the conjunction to be unsatisfiable for **all** possible `ts1682_0`.  \nThe constraints model a simple road‑intersection scenario: non‑negative velocities `v1`, `v2` bounded by a common speed limit `V`; a positive braking constant `B`; mode indices `I1`, `I2` fixed to 2; and safety distances `xI1`, `xI2` that must exceed the current positions plus the stopping distance (`xI1 > x1 + v1²/(2·B)` and similarly for `xI2`).  Additional bounds enforce `0 ≤ ts ≤ t ≤ ep`, and the derived expression `?v_1 = A·ts + v1_...` must stay within `[0,V]`.  \nThe whole assertion therefore checks that **no** intermediate time exists that violates these safety inequalities, i.e., the intersection remains safe under the given speed and braking limits.  \nBecause the original non‑linear arithmetic proof obligation is encoded entirely with 32‑bit bit‑vector operations (including signed division and multiplication), the benchmark is a typical example of a non‑linear arithmetic VC that has been bit‑blasted for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267053.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition taken from the KeYmaera hybrid‑system proof‑tool (intersection‑example‑simple, node 267053) and translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑keymaera” industrial family and is 2 704 bytes long, with 18 declared constants and a single, large quantified assertion.  \nThe formula asks the solver to refute an existential statement over the time‑step variable `ts1240uscore0`: it asserts a conjunction of arithmetic bounds (non‑negative positions, velocities, and parameters A, B, V, ep) together with several relational constraints that encode the dynamics of two vehicles approaching an intersection (e.g., `xI2 > x2 + v2²/(2·B)`).  \nKey constraints include linear inequalities (`bvsle`, `bvsge`), strict orderings (`bvsgt`, `bvslt`), and non‑linear multiplications/division (`bvmul`, `bvsdiv`) that model kinematic equations such as `v = A·t + v0` and safety conditions like “the distance ahead must stay larger than the stopping distance”.  \nThe outermost `(not (exists …))` turns the safety condition into an unsatisfiability query: the solver must prove that no assignment to the intermediate time `ts1240uscore0` can violate the safety predicate, i.e., the hybrid system is safe under the given parameter ranges.  \nNotably, the benchmark mixes many bit‑vector operations, a nested `let` binding, and a mixture of equalities and inequalities, making it a typical non‑linear arithmetic challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node272436.smt2",
    "description": "This benchmark is a single‑assertion BV problem (32‑bit bit‑vectors) with 19 declared constants and a quantifier, totalling about 2.8 KB of SMT‑LIB text (size 2788, max term depth 19). It originates from the Keymaera hybrid‑systems verification suite (the “intersection‑example‑simple” proof node 272436) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera benchmark set.  \n\nThe asserted formula is the negation of an existential condition over a time‑step variable `ts1271uscore0`; it encodes a safety invariant for a vehicle‑intersection scenario, requiring all relevant variables (speeds `v1`, `v2`, bounds `A`, `B`, the horizon `V`, etc.) to stay non‑negative and within the upper bound `V`, while enforcing relational constraints such as `xI2 > x2 + (v2*v2)/(2*B)` and a linear combination `?v_0 = v1_333 – B*ts1271uscore0` to stay within `[0,V]`.  \n\nKey constraints involve mixed arithmetic: several signed‑less/greater‑than comparisons, a division (`bvsdiv`) and multiple multiplications (`bvmul`), making the problem a non‑linear bit‑vector instance that also features a single existential quantifier and a nested `let`.  \n\nThus the solver is asked to prove that no assignment to the quantified time variable can violate the safety conditions—i.e., that the safety invariant holds for all reachable states of the encoded hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254296.smt2",
    "description": "This benchmark is a 2 KB BV‑logic file (logic = BV, 19 declared 32‑bit bit‑vectors, 1 quantified assertion, 2803 characters) taken from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner.  The formula asserts the *negation* of an existential safety condition: there must not exist a time‑step `ts1182uscore0` that satisfies a large conjunct of arithmetic constraints derived from the “intersection‑example‑simple” hybrid‑system proof node 254296.  The constraints enforce non‑negativity of parameters (A, B, V, ep, t‑variables), upper bounds by a common speed limit V for velocities v₁, v₂, and lower bounds for positions xI₁, xI₂, while also encoding the dynamics x ← x + v·t + ½·a·t² via bit‑vector multiplication and a division term `bvsdiv (bvmul v2 v2) (bvmul 2 B)`.  Additional safety clauses require that the projected position of vehicle 2 (`xI2`) stays ahead of vehicle 1 (`xI1`) by a margin computed from the velocities and braking constant B, and that certain discrete choices (`I1 = 2`, `I2 = 2`) hold.  In short, the instance checks whether the encoded hybrid‑system safety property is universally valid; the solver must prove unsatisfiability of the outer `not (exists …)` to confirm that no unsafe time step exists.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287914.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial instance in the Preiner‑keymaera family (file BV/2017‑Preiner‑keymaera/intersection-example-simple.proof‑node287914.smt2, 2 793 characters, 19 declared constants and a single top‑level assertion).  \n\nThe asserted condition is the negation of an existential statement over a fresh time variable `ts1341uscore0`, i.e., it claims that there exists a valuation of the system variables for which a complex safety condition fails.  \n\nThe core constraints describe a hybrid‑system safety invariant: all state variables (`v1`, `v2`, `A`, `B`, `V`, `ep`) are constrained to lie between 0 and a positive upper bound `V`; discrete counters `I1`, `I2` must equal 2; and relational bounds such as `bvslt xI1 x1`, `bvsgt xI2 (x2 + v2·v2 / (2·B))`, together with non‑linear arithmetic (`bvmul`, `bvsdiv`) linking speeds, distances and braking parameters.  \n\nAdditional temporal constraints require the computed expression `?v_0 = A·ts1341uscore0 + v1uscore3dollarskuscore401` to stay within `[0, V]` and to finish before a deadline `ep`, while a simple disjunction forces either `I1 = 2` or the constant 0 = 2 (which is unsatisfiable, thereby tightening the invariant).  \n\nThus the solver is asked to prove that no assignment satisfies all these bounded, non‑linear bit‑vector conditions, effectively checking the absence of a counterexample to the safety property of the “simple intersection” hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node601561.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera verification suite and translated to bit‑vectors by Mathias Preiner; it belongs to the “Preiner‑keymaera” industrial family and contains 19 declared constants, a single quantified assertion and a total of 2793 characters (max term depth 20).  \nThe core formula asserts **¬∃ ts₀** such that a collection of arithmetic relations—derived from a hybrid‑system model of a vehicle intersection—holds; the let‑binding introduces the term `?v_0 = A·ts₀ + v1'`, which together with the other constraints describes bounds on velocities (v₁, v₂), positions (x₁, x₂), and timing variables (ts₀, ep).  \nKey constraints require all physical parameters to be non‑negative (`A ≥ 0`, `B > 0`, `V > 0`, `ep > 0`), enforce consistency between indices (`I₁ = I₂ = 2`), relate positions by inequalities (`xI₁ < x₁`, `xI₂ = x₂'`), and impose a non‑linear relation involving a division (`bvsgt xI₂ (x₂ + (v₂·v₂) ÷ (2·B))`).  \nThe outer implication further demands that, whenever `t₀ ≥ 0`, the computed value `?v_0` stays within `[0, V]`, that the auxiliary variable `v₂'` also lies in `[0, V]`, and that the elapsed time plus a zero offset does not exceed the deadline `ep`.  \nThus the solver is asked to show that no assignment to the existential time variable can violate these safety bounds, i.e., the original safety property of the intersection model is satisfied.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node348040.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition taken from the KeYmaera hybrid‑systems prover, specifically the “intersection‑example‑simple” proof node 348040.  The file (≈2.7 KB, 18 declared constants, one large conjunctive assertion) comes from the industrial Preiner‑keymaera family and was submitted by Dejan Jovanović for the SMT‑LIB 2.6 benchmark suite.  The formula asserts, under a “not‑exists” quantifier, that there is **no** 32‑bit value for the auxiliary time variable ts1622 that simultaneously satisfies a collection of kinematic constraints: the initial indices I₁ and I₂ are fixed to 2, the braking parameter B is positive, the velocities v₁, v₂ are non‑negative and bounded by a global speed limit V, and the positions xI₁, xI₂ must lie beyond the stopping distances x₁ + v₁²/(2·B) and x₂ + v₂²/(2·B).  Additional constraints bound the elapsed time t1622 and require the summed time ts1622 to stay within a positive safety margin ep, while all variables A, V, ep are required to be strictly positive.  The instance therefore checks the unsatisfiability of a counterexample to the safe‑intersection property, using non‑linear arithmetic (multiplied and divided bit‑vectors) that has been bit‑blasted for a BV solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node389810.smt2",
    "description": "The file is a single‑assertion BV benchmark (logic BV, 19 declared 32‑bit constants, 2 857 characters, one quantified formula) taken from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (family “Preiner‑keymaera”, industrial category).  \nIt encodes the safety condition for a simple traffic‑intersection scenario: the formula asserts the negation of an existential witness ts₁₈₂₀ for which a collection of nonlinear relations among positions (x₁, x₂, xI₁, xI₂), velocities (v₁, v₂), acceleration parameters (A, B), a speed bound V and a time horizon ep can all hold simultaneously.  \nThe constraints are expressed with bit‑vector multiplication, signed division and signed comparisons ( bvsgt, bvsge, bvsle) and enforce positivity of all physical quantities, the kinematic update xI₁ > x₁ + v₁²/(2·(2·B)) etc., and that the elapsed time ts₁₈₂₀ lies between 0 and the overall time bound t₁₈₂₀ while staying within the horizon ep.  \nA secondary implication checks that, under these conditions, either a particular mode flag I₁ equals 2 or the flag I₂ also equals 2, linking discrete control choices to the continuous dynamics.  \nThus the benchmark tests an SMT solver’s ability to handle non‑linear arithmetic, mixed arithmetic‑logic constraints and a quantified existential search over 32‑bit bit‑vectors that arise from a real‑world hybrid‑system verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node193953.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  It was translated to bit‑vectors by Mathias Preiner (see the BV/2017‑Preiner‑keymaera family) and submitted to SMT‑LIB with the identifier intersection‑example‑simple.proof‑node193953.smt2; the file contains 18 declared 32‑bit variables, a single top‑level assertion, and 2 749 characters of input (max term depth 21).  \n\nThe assertion states the negation of an existential formula over a time variable ts902₀, requiring that for all such ts the conjunction of numerous safety inequalities—bounds on velocities (v1, v2), accelerations (A, B), a positive safety margin V, and the condition that a vehicle’s position xI1 stays ahead of a quadratic‐term estimate (x1 + v1²/(2B)) while another position xI2 stays behind x2—cannot be violated.  The constraints involve non‑linear operations (bit‑vector multiplication and signed division) and a linear combination A·ts902₀ + v1₍416₎, all compared with signed ≤/≥/> relations.  \n\nThus the instance checks that no reachable state violates the intersection safety invariant, effectively encoding a non‑linear arithmetic safety proof in the BV theory.  It is classified as an industrial‑category benchmark and is notable for its dense use of signed bit‑vector arithmetic to model real‑valued hybrid‑system dynamics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349276.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  The file contains 20 declared 32‑bit variables and a single, deeply nested assertion (depth 21) that states the negation of an existential property over a time‑stamp variable `ts1627uscore0`.  The core of the condition is a conjunction of linear and non‑linear arithmetic constraints (multiplications `bvmul`, divisions `bvsdiv`, and additions) that enforce positivity of parameters (e.g., `A`, `B`, `V`, `ep`), bounds on velocities `v1`, `v2` (0 ≤ v ≤ V), and safety inequalities such as `xI1 > x1 + (v1*v1)/(2*B)` and `xI2 > x2 + (v2*v2)/(2*B)`.  The outer implication checks that, for any non‑negative time `t1627uscore0` satisfying `0 ≤ ts1627uscore0 ≤ t1627uscore0`, the computed positions remain within `[0,V]` and that `ts1627uscore0 + 0 ≤ ep`, while also encoding a trivial disjunction `I1=2 ∨ 1=2`.  The benchmark originates from the Preiner‑keymaera family, is classified as “industrial”, and is 2.9 KB in size with 2924 characters and 20 logical symbols, making it a compact yet non‑linear BV instance used to stress‑test solvers on hybrid‑system safety proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node292487.smt2",
    "description": "This benchmark is a single‑assertion, quantifier‑rich verification condition written in the **BV** (fixed‑size bit‑vector) logic, originating from the Keymaera hybrid‑system verifier and translated to bit‑vectors by Mathias Preiner (see the “intersection‑example‑simple” proof node 292487).  The formula asserts the **negation of an existential** over a time‑step variable `ts1365uscore0`; the inner clause encodes a safety condition for a vehicular intersection model, using 20 32‑bit constants that represent positions, velocities, bounds (`V`), and parameters (`A`, `B`).  Core constraints bound all variables to the interval [0, V], relate the two vehicles’ velocities via `bvsgt` and `bvslt`, enforce a kinematic relation `?v_0 = A·ts + v1` (non‑linear multiplication) and a quadratic term `bvmul v2 v2` divided by `2·B`.  The condition also fixes the discrete modes `I1` and `I2` to the value 2 and includes ordering constraints such as `xI1 < x1` and `xI2 > x2 + (v2²)/(2·B)`.  Satisfiability of the negated existential corresponds to proving that no reachable state violates the safety invariant, making the benchmark a typical industrial‑size (≈2.8 KB, 20 declarations, term depth 20) non‑linear arithmetic VC.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node559637.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) containing 19 declared constants and a single, fairly large quantified assertion (size ≈ 2.8 kB, max term depth 22). It originates from the KeYmaera hybrid‑systems verification suite (the “intersection‑example‑simple” proof node 559637) and was translated to bit‑vectors by Mathias Preiner for the 2017 Preiner‑keymaera benchmark set. The formula encodes a safety verification condition for a road‑intersection scenario: variables such as V, A, B, v1, v2, x1, x2, I1, I2 represent velocities, accelerations, distances and timing intervals, and the constraints enforce non‑negative ranges, ordering of intervals (e.g., I1 = 0, I2 = 2), and a classic braking distance inequality v2² ≤ 2·B·(xI2‑x2). The core property is expressed as a negated existential over a time‑stamp ts2666₀; the outer (not (exists …)) asks whether there is **any** assignment that violates the safety conditions, so the solver must show the formula is unsatisfiable. Notably, the instance mixes linear bit‑vector relations with non‑linear operations (multiplication and signed division), and even contains a trivial disjunction (1 = 2 ∨ …) that forces the quantified part to dominate the proof effort.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node93152.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition that originates from the KeYmaera hybrid‑system prover; it appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and in the KeYmaera “intersection‑example‑simple” case study. The file (≈2.7 KB, 19 declared constants, one large conjunctive assertion) asserts the negation of an existential statement over a time variable `ts430uscore0`, i.e., it checks that **no** assignment to that time can satisfy a collection of arithmetic constraints. The constraints model a simple road‑intersection scenario: they enforce non‑negative parameters `A`, `B`, `V`, `ep`; velocities `v1`, `v2` bounded between 0 and `V`; integer interval identifiers `I1`, `I2` equal to 2; and the computed positions  \n\n```\nv0 = A*ts430uscore0 + v1\nv1' = -B*ts430uscore0 + v2\n```  \n\nwhich must also lie inside the interval [0, V]. Additional guards require `ts430uscore0` to be within `[0, t430uscore0]` and that the total elapsed time `ts430uscore0+0` does not exceed the safety horizon `ep`. The instance therefore checks a bounded‑time safety property of the hybrid system using non‑linear (multiplicative) bit‑vector arithmetic, a typical industrial‑style verification condition from the Preiner‑keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node150970.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition (logic BV) taken from the KeYmaera hybrid‑system proof “intersection‑example‑simple”, node 150970, and was translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category, 2 694 bytes, 18 declared constants). The single top‑level assertion negates an existential quantifier over a time variable ts698₀ and encodes a safety property of a road‑intersection scenario: the vehicles’ positions xI₁, xI₂, their speeds v₁, v₂, and a common speed bound V must respect non‑negative acceleration A, braking B, and stay within prescribed intervals while preserving a minimum distance. Inside the quantified formula a `let` introduces two derived expressions ?v₀ = A·ts698₀ + v₁₍₂₂₀₎ and ?v₁ = (‑B)·ts698₀ + v₂₍₂₂₀₎, and the constraints require these to stay between 0 and V, the elapsed time to be non‑negative and bounded by a deadline ep, and several relational conditions such as `xI₁ > x₁ + v₁²/(2·B)` and `xI₂ < x₂`. The overall formula checks that no assignment can satisfy all these inequalities together; thus the solver is asked to prove the verification condition unsatisfiable. Notably, the instance mixes non‑linear bit‑vector multiplications, signed divisions and comparisons, and a mixture of equality, ordering and Boolean connectors, making it a challenging example for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54847.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of moderate size (≈2.6 kB, 13 constants, 1 top‑level assertion) derived from the KeYmaera hybrid‑system verifier and submitted to the SMT‑LIB “Preiner‑keymaera’’ family.  It encodes the verification condition of the “intersection‑example‑onelane’’ safety proof (node 54847), i.e., whether there exists a time instant ts₁₁₃ such that a set of safety‑related inequalities over positions, velocities and parameters can be satisfied.  The condition is a single quantified formula of the form  \n\n```\n¬ ∃ ts₁₁₃ .  ( … conjunction of bounds … ∧\n               xI > x + v·v/(2·B) ∧ … )  →  ( xI < q  ∨  xI > q+Δ )\n```  \n\nwhere the conjuncts express lower/upper bounds on the variables (e.g., 0 ≤ v ≤ V, 0 ≤ B, V>0, ep>0), linear relations between timestamps, and a non‑linear quadratic term v·v as well as a squared term vuscore4dollarskuscore94²/(2·B).  The benchmark therefore tests solvers on quantified, non‑linear bit‑vector arithmetic with nested lets, divisions, and mixed inequality/disjunction structures that stem from a real‑world hybrid‑system safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190266.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem of moderate size (≈2.9 KB, 20 constants, one large conjunct) drawn from the **Keymaera** hybrid‑systems verification suite; it originates from the “safe‑intersection” example used in the IJCAR 2012 and CADE 2009 papers and was translated to bit‑vectors by Mathias Preiner.  The single assertion is the negation of an existential formula, so the solver must show that no assignment to the quantified time variable `ts884uscore0` can satisfy a chain of arithmetic constraints.  The constraints encode a hybrid‑system safety condition: non‑negative bounds on velocities `v1`, `v2`, a global speed limit `V`, positivity of parameters `A`, `B`, `ep`, and relational bounds such as  \n`xI1 > x1 + v1² / (2·B)` and `xI2 < x2`, together with a linear combination `A·ts884uscore0 + v1uscore2dollarskuscore400` that must stay within `[0,V]`.  Additional disjunctive cases relate the post‑state positions `xI2` and `x2uscore2dollarskuscore285` and enforce that the elapsed time stays below `ep`.  Overall, the instance checks the unsatisfiability of a non‑linear arithmetic safety condition encoded entirely in bit‑vector arithmetic, making it a typical industrial‑style verification benchmark for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673414.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 673414 of *intersection‑example‑simple.proof*). It appears in the industrial Preiner‑keymaera family, has 19 declared constants, one large conjunctive assertion (size ≈ 2.9 KB, max term depth 21) and uses a single existential quantifier over the variable `ts3209uscore0`. The formula asserts (via a surrounding `not … exists`) that there is **no** assignment to `ts3209uscore0` satisfying a collection of non‑negative bounds (e.g., `v1, v2, A, B, V, ep ≥ 0`) together with nonlinear relationships such as  \n`xI1 > x1 + (v1·v1) / (2·B)` and `xI2 > x2 + (v2·v2) / (2·B)`, plus additional range constraints on the auxiliary terms `I1`, `I2`, and the derived expression `?v_1 = A·ts3209uscore0 + v2_765`.  \n\nThe condition also ties the “intersection” variables (`xI1`, `xI2`) to either a fixed value (`x1_523`) or a timing condition (`t3209uscore0 ≥ 0` and `ts3209uscore0 ≤ t3209uscore0`). By checking satisfiability of the negated existential, the solver is asked to prove that the safety property holds for all admissible parameter values in the original hybrid‑system model. The instance thus tests BV solvers on non‑linear arithmetic patterns (multiplication, signed division) that arise from translating real‑valued differential dynamics into fixed‑width bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551029.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance taken from the Preiner‑keymaera family, encoding a verification condition generated by the KeYmaera hybrid‑system prover for the “intersection‑example‑simple” safety proof (node 551029) and listed in the Jovanović–de Moura IJCAR 2012 paper.  It contains 19 declared bit‑vector constants, one quantified assertion (a negated ∃ ts2629uscore0) and has a modest size of 2 820 characters with a maximum term depth of 20.  The formula asserts that, under a set of pre‑conditions—positivity of parameters A, B, V and ep; bounds 0 ≤ v1, v2 ≤ V; the indices I1, I2 both equal 2; ordering constraints on positions x1, x2 and their indexed copies; and a linear expression ?v₀ = ‑B·ts + v2 (with ?v₀ constrained to the interval [0,V])—any choice of the time variable ts that also satisfies 0 ≤ ts ≤ t2629uscore0 must respect the deadline ts + 0 ≤ ep.  By asserting the negation of this existential condition, the benchmark checks the unsatisfiability of the negated safety property, i.e., whether the original hybrid‑system safety invariant holds.  Notably, it encodes non‑linear arithmetic (multiplication and division) entirely within pure BV logic, illustrating how KeYmaera VCs can be translated to bit‑vector problems for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node704546.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) coming from the KeYmaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (≈2.8 KB, 19 declared constants, one large quantified assertion).  \nThe sole assertion is the negation of an existential formula over a time variable `ts3396uscore0`, which encodes a safety‑condition for a simple intersection scenario: two vehicles with speeds `v1` and `v2` (bounded between 0 and a global limit `V`) must respect distance constraints involving the positions `x1`, `x2` and the parameters `A`, `B`.  \nInside the quantified body a let‑bound term `?v_0` represents the linear expression `‑B·ts + v2` and a Boolean `?v_1` forces `I1uscore2dollarskuscore891 = 2`; the core constraints include (i) a quadratic‐term bound `xI1 > x1 + v1²/(2·B)`, (ii) positivity of the parameters (`A,B,V,ep > 0`), and (iii) ordering constraints `xI2 < x2`.  \nThe outer implication checks that, for any non‑negative `t3396uscore0`, the time `ts3396uscore0` lies within `[0,ep]` and that the computed speed‐related expression `?v_0` stays within the admissible interval `[0,V]`.  \nThus the benchmark asks the solver to show that the quantified safety condition is unsatisfiable, i.e., that the intersection model cannot violate the encoded bounds under the given non‑linear arithmetic translated into bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node682293.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) translated from a KeYmaera hybrid‑system verification condition for a “safe intersection” example; it appears in the Preiner‑keymaera industrial family and is about 2.7 KB in size with 18 declared constants and a single large assertion. The assertion is the negation of an existential formula over a fresh time variable `ts3262uscore0`, describing a set of linear inequalities that model non‑negative parameters A, B, V, ep and bounds on two state variables v1 and v2 (both required to lie in [0,V]). Inside the quantifier the formula defines two affine expressions  \n`?v_0 = -B * ts + v1_840` and `?v_1 = A * ts + v2_840` and requires each of them to stay within the same interval [0,V], while also enforcing ordering constraints `xI1 < x1`, `xI2 < x2`, equalities `I1 = I2 = 2` and `I1_840 = I2_840 = 0`, and positivity of B, V and ep. The outer implication further demands that for any non‑negative `t3262uscore0` the time‑point `ts3262uscore0` lies between 0 and `t3262uscore0` and that the affine expressions respect the interval, with a final trivial disjunction `(1 = 2) ∨ (I2_840 = 2)` that makes the whole condition unsatisfiable if the other constraints hold. Thus the solver is asked to prove that no bit‑vector assignment can satisfy all these safety constraints simultaneously, effectively checking the safety proof obligation of the intersection hybrid system. Notably, the problem uses only bit‑vector arithmetic to encode what originates as non‑linear real arithmetic, has a maximum term depth of 20, and contains a mixture of equality, ordering, and arithmetic constraints typical of translated KeYmaera verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251841.smt2",
    "description": "The file is a single‑assertion benchmark in the BV logic (32‑bit bit‑vectors) coming from the KeYmaera hybrid‑systems verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “intersection‑example‑simple” proof node used in the Jovanović‑de Moura non‑linear arithmetic paper.  \nThe assertion is the negation of an existential formula \\(\\exists ts\\) that encodes a verification condition for a safe‑intersection scenario, where the quantified term represents a time offset and the surrounding constraints describe the kinematics of two vehicles (variables v₁, v₂, A, B, V, ep, etc.).  \nInside the antecedent there are a cascade of linear and non‑linear bit‑vector relations: equalities linking the current positions \\(x_{I1},x_{I2}\\) to symbolic states \\(x_1,x_2\\), positivity constraints on parameters (\\(A,B,V,ep\\ge0\\)), and quadratic terms such as \\(v_2·v_2\\) divided by \\(2·B\\) that appear in a safety distance inequality.  \nThe outermost implication checks that, whenever the quantified time satisfies the basic bounds (\\(0\\le ts\\le t\\)), the derived positions (\\(?v_0,?v_2\\)) stay within the allowed interval \\([0,V]\\) and the overall deadline \\(ep\\) is respected; the final disjunction \\((I1\\!=2)\\lor (1=2)\\) forces the condition \\(I1=2\\) to hold.  \nThus the solver is asked to prove that the existential witness cannot exist, i.e., that the safety property of the intersection model is guaranteed under the given numeric bounds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17882.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance of size ≈ 2.5 KB (2501 characters) containing 13 declared constants and a single, fairly deep quantified assertion (max term depth 24). It originates from the KeYmaera hybrid‑systems verification suite (intersection example for a one‑lane crossing) and was translated to bit‑vectors by Mathias Preiner for the Preiner‑keymaera family of industrial benchmarks. The core formula is the negation of an existential statement over a time variable `ts39uscore1`; inside the quantifier a large conjunction encodes a safety condition using linear and non‑linear BV arithmetic (addition, multiplication, division, and several signed ≤/≥/</> comparisons). The constraints relate positions (`xI`, `x`, `xuscore2dollarskuscore56`), velocities (`v`, `V`, `vuscore2dollarskuscore62`), bounds (`A`, `B`), and timing parameters (`t67uscore0dollarskuscore1`, `ep`), asserting, for example, that the vehicle’s position does not exceed a reachable‑set bound and that all physical quantities remain non‑negative. Satisfiability checking therefore amounts to proving that no assignment to the quantified time can violate the safety predicate, i.e., that the verification condition is valid. Notably, the benchmark features non‑linear BV multiplications and a division, which make it a challenging case for solvers handling bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node39751.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera verification suite; it encodes the safety proof “intersection‑example‑onelane” (node 39751) from the paper *Safe intersections* and was translated to bit‑vectors by Mathias Preiner.  It contains 13 declared constants and a single quantified assertion of the form **¬∃ts₈₈ … (ϕ ⇒ ψ)**, where ϕ states a collection of bounds on the time variable ts₈₈ (e.g., 0 ≤ ts₈₈ ≤ t₁₆₁) together with linear and non‑linear relationships among the system parameters A, B, V, ep, x, xI, etc.  The consequent ψ is a disjunction that forces the position variable xI to lie outside a quadratic “danger zone” defined by several bvmul and bvsdiv terms, essentially expressing that a vehicle cannot enter the intersection while violating the invariant.  The formula therefore checks that, for all admissible values of the quantified time, the safety condition holds; satisfiability of the outer ¬∃ would mean the invariant is violated.  Notably, the instance uses deep (depth 24) non‑linear bit‑vector arithmetic with many multiplications and divisions, making it a challenging industrial‑style verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node349694.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (2940 characters, 20 bit‑vector constants) taken from the KeYmaera safety‑verification suite; it originates from the “intersection‑example‑simple” proof node 349694 of the paper *Safe intersections* and was translated to 32‑bit bit‑vectors by Mathias Preiner.  \n\nThe single top‑level assertion is the negation of an existential query over a time‑stamp variable `ts1629uscore0`; inside a `let` the query builds auxiliary expressions such as `2·B` and `A·ts + v1₍₂₎`.  \n\nThe conjunctive core encodes a hybrid‑system safety condition for two vehicles approaching an intersection: non‑negativity and upper‑bounds (by `V`) for speeds `v1`, `v2` and accelerations `A`, `B`; a positive time horizon `ep`; and braking‑distance formulas `xI1 > x1 + v1²/(2·B)` and `xI2 > x2 + v2²/(2·B)`.  \n\nAdditional constraints tie auxiliary indices (`I1`, `I2`, `I1₍₂₎`, `I2₍₂₎`) to concrete constants (e.g., `I1 = 2`) and force the time variables to lie within `[0,ep]`.  \n\nThus the benchmark checks whether, under the given bounds on speeds, accelerations and time, there exists any timestamp that would violate the safety distance condition; proving the formula unsatisfiable would imply the intersection is safe under the modeled parameters.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294860.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic **BV**) of a verification condition taken from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” proof node 294860 that appears in the paper *Safe intersections* (Loos & Platzer, ITSC 2011).  The file contains 19 declared bit‑vector constants (e.g., velocities v1, v2, bounds V, parameters A, B, and time variables t and ts) and a single, fairly large assertion (≈2.8 kB, max term depth 18) formed as the negation of an existential formula.  The formula asserts that, under a collection of safety‑related hypotheses—non‑negative parameters, velocity bounds 0 ≤ v₁,v₂ ≤ V, a quadratic distance bound bvsgt xI2 (x₂ + v₂²/(2·B)), and the invariant that I1 = I2 = 2—the intermediate expressions  \n\\(?v_0 = -B·ts + v₁\\) and \\(?v_1 = A·ts + v₂\\) stay within the same bounds and the overall time stays below a positive deadline ep.  \nThe outer `not (exists …)` therefore asks the solver to prove that **no** such time ts exists, i.e., that the safety condition holds for all admissible executions.  \nBecause the original arithmetic was over the reals, the benchmark is notable for translating a non‑linear hybrid‑system safety proof into fixed‑size bit‑vector arithmetic, making it a challenging industrial‑style case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node532235.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example (node 532235 of *intersection‑example‑simple.proof*).  It originates from the Jovanović‑de Moura non‑linear arithmetic paper and was translated to BV by Mathias Preiner, yielding a relatively small industrial instance (≈2.8 KB, 18 declared constants, 1 top‑level assertion).  The asserted formula is the negation of an existential statement over a time variable `ts2518uscore0`; inside the quantifier a `let`‑bound expression computes a linear combination of the variables `B`, `v1`, and the quantified time, and the body consists of a large conjunction of range constraints (non‑negativity, upper bound `V`) together with several non‑linear relations such as `bvmul` and `bvsdiv` that model the dynamics of the intersection system.  The overall goal is to prove that no assignment to the quantified time can violate the safety property, i.e., the outer `not (exists …)` should be satisfiable, which corresponds to the VC being discharged.  Notably, the instance mixes classic bit‑vector arithmetic with non‑linear multiplications and divisions, making it a representative challenge for solvers handling BV‑encoded hybrid‑system proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673526.smt2",
    "description": "This benchmark is a 32‑bit BV encoding of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 673526 of *intersection‑example‑simple.proof*).  It originates from the Jovanović‑de Moura non‑linear arithmetic paper (IJCAR 2012) and was translated to bit‑vectors by Mathias Preiner, thus belonging to the industrial Preiner‑keymaera family.  The single assertion negates an existential formula over a time stamp `ts3210uscore0`; the body contains a large conjunction of non‑linear constraints (quadratic terms `v1*v1`, `v2*v2`, a division by `2·B`, and many lower/upper‑bound inequalities) together with constants `A`, `B`, `V`, `ep` that must be positive.  The condition essentially checks that, under the assumed bounds on velocities (`v1`, `v2` ∈ [0, V]) and positions (`xI1`, `xI2`), the derived safety inequality is never violated; the outer `not` turns the problem into an UNSAT check.  Because the arithmetic is non‑linear, the benchmark stresses bit‑vector solvers with deep term nesting (max depth 21) and a mix of signed comparisons, multiplications, and divisions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node367444.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it appears in the “intersection‑example‑simple” proof node (node 367444) of the IJCAR 2012 paper on non‑linear arithmetic.  The file contains 18 declared 32‑bit constants (velocities v1, v2, bounds V, parameters A, B, time‑related symbols, and several intermediate variables) and a single, fairly large quantified assertion (≈2800 characters, max term depth 21).  \n\nThe core of the formula is a negated ∃‑quantifier over a time variable ts₁₇₁₂, inside a let‑binding that defines the linear combination ?v₁ = A·ts₁₇₁₂ + v₂₍₃₁₈₎ and the constant ?v₂ = (I₁₍₃₁₈₎ = 2).  The antecedent encodes a safety condition for a road‑intersection scenario: non‑negative velocities bounded by a global limit V, positive parameters A, B, V and ep, and two quadratic position‑growth constraints  \n  bvsgt xI1 (x1 + (v1·v1) ÷ (2·B)) and bvsgt xI2 (x2 + (v2·v2) ÷ (2·B)).  \nThese express that the simulated positions xI1, xI2 stay ahead of their initial positions plus a braking distance term.  \n\nThe consequent demands that the time‑stamp t₁₇₁₂ is non‑negative, that ts₁₇₁₂ lies between 0 and t₁₇₁₂, that the computed value ?v₁ stays within [0, V], and that ts₁₇₁₂+0 ≤ ep, while also forcing either I₁₍₃₁₈₎ = 2 or I₂₍₃₁₈₎ = 2.  In short, the SMT problem checks whether the safety invariant can be violated for any admissible time ts₁₇₁₂; a SAT result would indicate a counterexample to the intersection safety proof.  \n\nNotably, the benchmark mixes arithmetic (addition, multiplication, signed division) with signed comparison operators and a single existential quantifier, making it a typical non‑linear BV verification condition that stresses solvers’ handling of quantifier‑instantiation and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/to_left-node1505.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 7 32‑bit bit‑vector constants, one quantified assertion, 13 bvmul occurrences, max term depth 18) taken from the KeYmaera verification suite and translated to bit‑vectors by Mathias Preiner.  Its only top‑level constraint is a negated existential: it asserts that there is **no** 32‑bit value ts2uscore0 that simultaneously satisfies a conjunction of linear and non‑linear BV inequalities involving the parameters v, d, b, m, z and t2uscore1dollarskuscore0.  The core of the condition encodes a polynomial inequality of the form  \n\n\\[\n(b\\cdot(-1))\\cdot t_{2}^{2}+2b\\cdot t_{2}\\,v+2b\\cdot z \\le m,\n\\]  \n\ntogether with side constraints \\(0\\le ts2uscore0\\le t_{2}\\), \\(b>0\\), \\(d\\ge0\\), \\(v\\ge0\\), \\(z\\le m\\) and a bound relating \\(v\\), d and b: \\((b\\cdot(-1))\\cdot ts2uscore0+v\\ge0\\) and \\((b\\cdot(-1))\\cdot t_{2}+v\\le d\\).  In effect the benchmark checks whether the combination of these bounds can ever be satisfied, i.e. whether a safety‑property violation is possible in the underlying train‑control hybrid system model.  It is representative of industrial non‑linear arithmetic problems where multiplication of bit‑vectors (and a division by 2) creates a challenging verification condition for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node14896.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) drawn from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (file binary_driver‑2007‑10‑09‑node14896.smt2, 2.5 KB, 15 declared constants).  \nThe single top‑level assertion negates an existential formula over the variable ts8_1, effectively asking whether the quantified constraints are **unsatisfiable**.  \nInside the quantified block a large conjunctive condition combines many non‑linear arithmetic constraints: squares and products such as (v·v − d·d) ≤ 2·b·(m − z), a similar inequality for (vu·vu − du·du), and a linear relation b·ts8 + vu ≥ 0, together with a host of lower‑bound requirements (all variables ≥ 0, b > 0, ep > 0, amax > 0, state = 1, etc.).  \nThese constraints encode a verification condition from the “binary_driver” example, checking that certain safety bounds (e.g., velocity and distance limits) hold for all admissible time steps.  \nThe instance is notable for featuring heavy use of non‑linear bit‑vector multiplication (bvmul) and nested arithmetic comparisons, making it a challenging industrial‑style benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11162.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner; it appears in the 2012 IJCAR paper on non‑linear arithmetic and is classified as an industrial “keymaera” benchmark (size ≈ 2700 characters, 13 declared constants, one large conjunctive assertion).  \nThe single top‑level assertion is the negation of an existential formula over a fresh time variable ts23, which encodes a safety condition for a one‑lane intersection scenario (node 11162 of *intersection‑example‑onelane.proof*).  \nInside the existential, a series of nested conjunctions constrain the variables to lie within the interval [0,V], enforce non‑negativity of parameters (A, B, v, ep, V), and relate them through non‑linear arithmetic expressions such as \\(B·ts + v\\), quadratic terms \\(B·t^2\\), and a term \\(\\frac{1}{2}(B·t^2 + 2·t·v + 2·x)\\).  \nThe final property to be checked is a disjunction stating that the initial position xI must lie either below this computed “border” value or above it by a margin proportional to \\(\\frac{(B·t+v)^2}{2·B}\\); the outer `not` turns the whole formula into a safety‑verification query (unsat means the safety condition holds).  \nNotably, the model mixes linear and genuinely non‑linear bit‑vector arithmetic (multiplications of variables, a division by a constant, and a quadratic expression), leading to a relatively deep term graph (max depth 23) that stresses SMT solvers’ handling of non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node194936.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera family of verification conditions for hybrid‑system safety (the “intersection‑example‑simple” proof node 194936). It contains a single, large quantified assertion that negates an existential statement over a time variable ts₉₀₈, thereby asking the solver to prove that no reachable state violates the safety property. The conjunctive core encodes bounds on several system parameters (A, B, V, ep > 0; 0 ≤ v₁, v₂ ≤ V; 0 ≤ I₁, I₂ = 2) together with a non‑linear inequality  \n\\(x_{I1} > x_1 + \\frac{v_1^2}{2B}\\)  \nand a linear relation \\(?v_0 = A·ts + v_{1,422}\\) that must stay within [0,V] and respect a deadline ep. The formula also forces ordering constraints on the hybrid‑system clocks (e.g., 0 ≤ ts ≤ t₉₀₈) and includes a disjunction distinguishing two cases for the integer flag I₁₄₂₂. It is an industrial‑style benchmark (≈280 bytes, depth 21) used to test solvers’ ability to handle bit‑vector encodings of non‑linear arithmetic arising from hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node190475.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (≈2.8 KB, 19 declared constants and a single quantified assertion).  \n\nThe core of the file is a negated existential formula `(not (exists ((ts885uscore0 (_ BitVec 32))) …))` that encodes a safety condition for a simple intersection scenario: the quantified variable `ts885uscore0` stands for a time instant, while the other symbols (`v1`, `v2`, `A`, `B`, `V`, `ep`, `x1`, `x2`, `xI1`, `xI2`, `I1`, `I2`, …) model positions, velocities, and parameters of two vehicles.  \n\nInside the quantified body a conjunction of signed‑inequality constraints (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) and arithmetic expressions (`bvadd`, `bvmul`, `bvsdiv`) captures the intended continuous dynamics (e.g., non‑negative velocities bounded by `V`, position ordering `xI1 > x1 + v1²/(2·B)`, time bounds `0 ≤ ts885uscore0 ≤ t885uscore0 ≤ ep`).  \n\nThe assertion therefore checks that **no** assignment to the time variable can simultaneously satisfy all the dynamics and the “bad” condition (the disjunction `or ?v_1 (= 0 2)`), i.e., it verifies that the intersection is safe under the given parameter constraints.  \n\nNotably, the model mixes non‑linear arithmetic (products of variables) with integer division, all encoded as bit‑vector operations, and includes a `let`‑binding and a modest maximum term depth of 20, making it a characteristic example of nonlinear arithmetic translated into the BV theory for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2442.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera verification suite and translated to SMT‑LIB by Mathias Preiner; it is 3 KB long (≈3 200 characters), contains 14 declared constants and a single, very large assertion. The property is expressed as the negation of an existential query over a timestamp variable `ts0_1`, so the solver is asked to prove that no assignment satisfying the subsequent constraints exists. Inside the quantified body a chain of linear and non‑linear signed bit‑vector constraints is built with many squares, products and signed divisions (e.g., `v1^2`, `vsl^2`, `(A/B)`, `(ep*ep)`) together with interval bounds on timestamps, velocities, and safety thresholds (`vmin > 0`, `B > 0`, etc.). One of the key safety conditions forces the Boolean‑encoded alert flag `alerted_2$1` to be zero while simultaneously requiring a strict inequality between a computed position term and a bound derived from the system dynamics. The formula is characteristic of industrial verification problems: it mixes non‑linear arithmetic, signed comparisons, and a mixture of existential quantification and Boolean structure, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node172682.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic BV, 19 declared constants, 2800 characters) taken from the KeYmaera suite of hybrid‑system verification conditions; it originates from the “intersection‑example‑simple” proof node used in the paper *Safe intersections* and was translated to BV by Mathias Preiner.  \nThe single top‑level assertion is the negation of an existential formula over a fresh time variable `ts801uscore0`; the solver is therefore asked to prove that no such time exists satisfying the embedded constraints.  \nThese constraints capture a hybrid‑system safety invariant: non‑negative speeds `v1`, `v2` bounded by a maximal speed `V`, non‑negative acceleration parameters `A`, `B`, a positive safety margin `ep`, and relational conditions derived from the vehicle dynamics (e.g., `xI1 > x1 + v1²/(2·B)`, `xI2 < x2`).  \nAll arithmetic is encoded with 32‑bit bit‑vector operations (`bvadd`, `bvmul`, `bvsdiv`, signed comparisons), including the non‑linear term `v1·v1` that represents the square of the speed.  \nThe benchmark thus checks the unsatisfiability of a safety‑property VC: that, under the given bounds, the system can never reach a state violating the intersection safety condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node37008.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it appears in the “Preiner‑keymaera” industrial family and occupies about 2.4 KB with one top‑level assertion and 13 declared constants. The core of the instance is a single quantified condition: the solver is asked to prove that **no** 32‑bit time stamp `ts82uscore0` can satisfy a conjunction of arithmetic constraints, i.e., it checks the unsatisfiability of the negated existential. The constraints model a traffic‑intersection safety scenario, relating positions (`xI`, `x`), velocities (`v`), and parameters (`A`, `B`, `V`, `ep`) through bounds (≤ 0, ≥ 0), linear inequalities, and a non‑linear term `bvmul v v` divided by `2·B`. Additional side conditions enforce that timestamps lie between 0 and a deadline `t149uscore0dollarskuscore0`, that derived expressions stay within `[0,V]`, and that constants such as `B`, `V`, `ep` are strictly positive. Notably, the formula encodes non‑linear arithmetic (quadratic term and division) entirely in bit‑vector arithmetic, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269426.smt2",
    "description": "The file is a 2‑solver‑compatible BV benchmark (logic BV, 2 966 bytes, 19 declared 32‑bit bit‑vectors) taken from the Keymaera hybrid‑systems verification suite and translated to bit‑vectors by Mathias Preiner.  It asserts the negation of an existential query over a time variable `ts1253uscore0`, thereby encoding a safety‑property that must hold for *all* admissible time steps.  The conjunctive antecedent describes a simple traffic‑intersection scenario: constants such as `v1`, `v2`, `A`, `B`, `V` and `ep` represent velocities, accelerations, a braking bound, a global speed limit and a time horizon, while predicates like `bvslt xI1 x1`, `bvsgt xI2 (bvadd x2 (bvsdiv (bvmul v2 v2) (bvmul (_ bv2 32) B))))` enforce that one vehicle stays behind another and that the stopping distance of the second vehicle does not exceed the available gap.  Additional constraints require all physical quantities to be non‑negative and bounded by `V`, and they tie the position after time `ts1253uscore0` (`?v_0 = A*ts + v1`) to the same bounds, also relating the control mode variables `I1` and `I2`.  The single quantified assertion is wrapped in a `not`, so the solver is asked to prove that no witness for `ts1253uscore0` can violate the safety condition—i.e., that the intersection scenario is safe under the given non‑linear (multiplication/division) bit‑vector arithmetic.  The benchmark is notable for its deep term nesting (max depth 21) and for encoding real‑valued non‑linear arithmetic entirely with 32‑bit bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node270758.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic BV) from the Preiner‑keymaera family, originally derived from a KeYmaera hybrid‑system proof about a “safe intersection” (see Loos & Platzer ITSC 2011) and translated to bit‑vectors by Mathias Preiner; it is 2 737 characters long, declares 18 constants and contains a single, fairly deep formula (max term depth 20).  \n\nThe single asserted clause is the negation of an existentially‑quantified verification condition: it states that there is **no** assignment to the time‑stamp variable ts1261₀ that satisfies a large conjunction of linear and non‑linear bit‑vector inequalities.  \n\nThe conjuncts enforce non‑negativity and upper bounds (e.g., 0 ≤ v₁, v₂, A, B, V, ep) and ordering relations such as v₁ ≤ V, v₂ ≤ V, xI₁ < x₁, xI₂ > x₂ + (v₂·v₂)/(2·B), together with a quadratic term encoded as bvmul v₂ v₂ divided by bvmul 2 B.  \n\nAdditionally, the formula ties the auxiliary variable v₁′ (named v1$3_323) to V, fixes several control‑state variables (I₁, I₂) to concrete values (0 or 2), and requires the elapsed time ep to be positive and larger than ts1261₀.  \n\nThus the instance checks the unsatisfiability of the negated safety condition—i.e., whether the encoded hybrid‑system safety property (no collision at the intersection) holds for all 32‑bit integer interpretations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node254500.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) coming from the KeYmaera hybrid‑systems verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (≈2.8 KB, 19 constants, 1 top‑level assertion). The single assertion is the negation of an existential formula over a fresh time variable `ts1183uscore0`, so the solver is asked to prove that no such `ts` can satisfy the inner condition. Inside the condition a large conjunction encodes a safety verification condition for a vehicle‑intersection scenario: all physical parameters (`A`, `B`, `V`, `ep`) are required to be non‑negative, velocities `v1`, `v2` are bounded by a common limit `V`, and the position update `xI2 > x2 + v2²/(2·B)` together with relational bounds on initial positions (`xI1 < x1`) and a discrete assignment `I1 = I2 = 2`. A key arithmetic term `?v_0 = v1 – B·ts` is constrained to lie between 0 and `V`, and the formula also includes a simple disjunction that either equates two position variables or forces non‑negative time `t1183uscore0`. Satisfiability of the negated existential therefore corresponds to the correctness of the hybrid‑system proof obligation, making the benchmark a non‑linear arithmetic VC encoded in pure bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488451.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in the Loos‑Platzer 2011 paper.  It comes from the Preiner‑keymaera family (BV/2017‑Preiner‑keymaera) and contains 19 declared constants, a single quantified assertion, and about 20 kB of terms (max depth 20).  The formula asserts the *negation* of an existential statement over a time variable `ts2318uscore0`; the inner condition encodes the hybrid dynamics of two vehicles (positions `x1`, `x2`, velocities `v1`, `v2`, acceleration parameters `A`, `B`) together with safety bounds such as non‑negative accelerations, velocity limits `V`, and a separation inequality `bvsgt xI1 (bvadd x1 (bvsdiv (bvmul v1 v1) (bvmul (_ bv2 32) B))))`.  The key constraints are linear and non‑linear (multiplication, division) bit‑vector arithmetic combined with relational operators (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) that capture the hybrid system’s continuous evolution and discrete guard conditions.  Satisfiability of the top‑level `not (exists …)` thus checks whether a counter‑example to the safety property exists; the benchmark is intended to be unsatisfiable, proving the intersection is safe under the given assumptions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531822.smt2",
    "description": "This benchmark is a single‑query verification condition generated from the KeYmaera hybrid‑system prover (the “intersection‑example‑simple” proof) and then translated to 32‑bit bit‑vector arithmetic by Mathias Preiner.  It is expressed in the BV logic, contains 19 declared bit‑vector constants and one quantified assertion (an existential over a time variable ts2516₀), and its size is about 2.8 KB (2803 characters) with a maximum term depth of 20.  \n\nThe asserted formula states that **no** assignment to the time variable can satisfy a conjunction of bounds on several parameters (A, B, v₁, v₂, V, ep) together with non‑linear relationships such as  \n\n\\[\nv_1' = A·ts + v_2,\\qquad\nv_0 = -B·ts + v_1,\n\\]\n\nand quadratic terms like \\(\\frac{v_1·v_1}{2·B}\\) that appear in a safety condition for a vehicle at an intersection.  All these constraints are encoded with BV operations (bvadd, bvmul, bvsdiv, bvsgt, bvsle, etc.), and the outermost `not (exists …)` asks the solver to prove that the conjunction is unsatisfiable – i.e., that the safety property holds for every reachable state.  \n\nThe instance is classified as “industrial” in the Preiner‑keymaera family and is notable for embedding non‑linear real‑arithmetic reasoning into pure bit‑vector logic, making it a challenging test for SMT solvers’ arithmetic and quantifier handling capabilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node603436.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (SMT‑LIB 2.6) coming from the KeYmaera hybrid‑systems verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (file BV/2017‑Preiner‑keymaera/intersection‑example‑simple.proof‑node603436.smt2, 2 828 bytes, 19 declared constants, max term depth 20).  \n\nThe single top‑level assertion is the negation of an existential formula over a time variable `ts2867_0`; the formula encodes a safety verification condition for a simple intersection scenario, relating the positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), acceleration bounds (`A`, `B`), a maximum speed `V`, and a positive horizon `ep`.  \n\nInside the quantified part a chain of signed inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) enforces that the initial positions lie within the allowed interval, that the vehicles’ speeds stay between 0 and V, that the distance between them respects a clearance condition involving the term  \n`bvadd (bvmul (bvmul (bvneg 1) B) ts2867_0) v1_773` (i.e., a linear expression in the time variable), and that the time stays within `[0,ep]`.  \n\nA final disjunction either identifies equality of a position variable with a fresh constant (`xI2 = x2_541`) or, when a non‑negative auxiliary time `t2867_0` exists, requires the same set of bounds together with the trivial equality `0 = 2` or the condition `I2 = 2`.  \n\nThus the solver is asked to show that no assignment to the existential time can satisfy all these signed arithmetic constraints, i.e., that the intersection safety property holds under the given bit‑vector arithmetic model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node46589.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera verification suite and translated to bit‑vectors by Mathias Preiner; it is a 2 835‑character industrial benchmark (13 constants, one large quantified assertion, max term depth 26). The core of the file is a single negated existential formula ∃ ts104… . … that encodes a verification condition for the “intersection‑example‑onelane” hybrid‑system model (a safe‑intersection scenario with one traffic lane). Inside the quantifier a network of non‑linear arithmetic constraints relates the state variables v, V, A, B, ep and the position variable xI to derived terms such as (v·v)/(2·B) and x + v²/(2·B), while also enforcing non‑negativity, upper bounds (e.g., v ≤ V, A ≥ 0) and safety inequalities (e.g., xI > … or xI < …). The outer (not…) turns the check into an unsatisfiability query, so the solver must prove that no assignment to ts104 (and the other bit‑vectors) can violate the safety condition, i.e., that the original safety property holds. Notably the instance mixes bit‑vector division, multiplication and conditional arithmetic, making it a challenging non‑linear BV benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node732160.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic **BV**) of a safety verification condition that originates from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof).  It contains a single quantified assertion `(not (exists ((ts3567uscore0 (_ BitVec 32)))) …)`; thus the solver is asked to show that no value of the time‑step variable `ts3567uscore0` can make the inner conjunction true.  The core of the conjunct describes a hybrid‑system model of two vehicles: non‑negative parameters `A`, `B`, `V` (max speed), velocities `v1`, `v2` bounded by `0 ≤ vi ≤ V`, and positions `x1`, `x2` that must stay ahead of the distance covered using the nonlinear expressions `bvsdiv (bvmul vi vi) (2*B)` and `bvsdiv (bvmul vi vi) (bvmul 2 A ts…)`.  Additional constraints force the time horizon `ep` and the step `ts3567uscore0` to be positive and to respect `ts3567uscore0 ≤ ep`.  The instance, drawn from an industrial case study on safe intersections, is relatively large (2790 characters, 18 declared constants, max term depth 21) and exercises both quantified reasoning and non‑linear arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171004.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition for the **KeYmaera** hybrid‑systems proof “intersection‑example‑simple”, translated by Mathias Preiner and taken from the Jovanović‑de Moura IJCAR‑2012 non‑linear arithmetic suite. It contains 18 declared bit‑vector constants (e.g., velocities v₁, v₂, a speed bound V, parameters A, B, and positions x₁, x₂) and a single, large conjunctive formula that is negated and wrapped in an existential quantifier over a time variable ts₇₉₁. The core of the constraint models a safety invariant for two vehicles approaching an intersection: it mixes linear inequalities (bounds on the variables) with a **non‑linear term** `bvmul v1 v1` appearing inside a signed‑division and added to a position update `(bvmul A ts + v1′)`. The outer `not (exists ...)` therefore asks the solver to refute any witness to a violation, i.e., to prove that under the given pre‑conditions (non‑negative parameters, `V>0`, `ep>0`, etc.) the unsafe region cannot be reached. With 2749 characters, a maximum term depth of 21 and 20 occurrences of `and`, the instance exemplifies how hybrid‑system safety proofs are reduced to bit‑vector non‑linear arithmetic problems for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node345732.smt2",
    "description": "This benchmark is a 2 322‑byte BV‑logic instance (logic = BV) taken from the KeYmaera verification suite for hybrid‑system safety proofs, translated to bit‑vectors by Mathias Preiner and listed in the 2012 IJCAR “Solving Non‑Linear Arithmetic” paper. It contains 19 32‑bit bit‑vector constants and a single, large quantified assertion that encodes a safety verification condition for a simple intersection scenario of two moving objects (variables v1, v2 are velocities, x1, x2 are positions, A, B, V, ep are parameters, and I1, I2 index the objects). The body of the existential quantifier over a time stamp ts1609uscore0 asserts non‑negativity of all parameters, positivity of the safety margin V and the episode length ep, and two quadratic‑inequality constraints of the form  \n\n```\nxI1 > x1 + (v1·v1)/(2·B)   and   xI2 > x2 + (v2·v2)/(2·B)\n```  \n\nwhich capture that each vehicle must travel farther than a distance proportional to the square of its speed before reaching the intersection. A final conjunct forces the index I2 to equal 2, while the outer ¬ turns the whole formula into a safety check: the solver must prove that no time ts1609uscore0 exists that violates the inequalities, i.e., the VC is unsatisfiable. The instance features deep nesting (max term depth 20) and many signed‐comparison and arithmetic operations, making it a typical industrial‑style non‑linear arithmetic benchmark expressed in the bit‑vector theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54859.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example (intersection‑example‑onelane).  It comes from the Preiner‑keymaera family (industrial category) and is 2 822 bytes long, declaring thirteen 32‑bit constants that model parameters such as the initial position xI, velocity v, bounds A, B, V, a time‑step ts₁₁₀, and a deadline ep.  The single top‑level assertion is the negation of an existential over ts₁₁₀, stating that there is **no** value of the time‑step that satisfies a large conjunction of linear and non‑linear (quadratic) bit‑vector inequalities together with the safety implication  \n\\[\nx_I > x + \\frac{v^2}{2B} \\;\\wedge\\; B>0 \\;\\wedge\\; \\dots \\;\\Rightarrow\\; (x_I < \\phi \\;\\lor\\; x_I > \\phi + \\frac{(\\psi)^2}{2B}),\n\\]  \nwhere φ, ψ are arithmetic expressions built from A, t₂₀₅, v, x, and the auxiliary variable v₄₉₅.  The constraints enforce non‑negativity of all physical parameters (A, B, V, ep ≥ 0), upper bounds (e.g., v ≤ V, v₄₉₅ ≤ V), and a quadratic relation that captures the stopping distance of a vehicle.  Satisfiability of the negated exists would falsify the safety invariant, so the solver is asked to prove the formula unsatisfiable, i.e., that the intersection safety condition holds for all admissible parameter values.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node363688.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for a simple intersection safety example; it originates from the Jovanovic & de Moura “Solving Non‑Linear Arithmetic” paper and is classified as an industrial‑category benchmark (size ≈ 2.8 kB, 18 declared constants, one quantified assertion). The formula asserts the negation of an existential statement over a time variable `ts1692uscore0`, with a `let` block that introduces two auxiliary terms: the product `2·B` and the expression `A·ts1692uscore0 + v2'`. The core of the condition is a large implication that enforces non‑negativity and upper bounds (`V`) on two velocity variables, positivity of the constants `A`, `B`, `V`, and `ep`, and safety inequalities such as  \n`xI1  >  x1 + (v1·v1) / (2·B)` and  \n`xI2  >  x2 + (v2·v2) / (2·B)`,  \nwhich correspond to braking distance requirements at the intersection. Additional constraints bound the auxiliary expression `A·ts1692uscore0 + v2'` between 0 and `V` and require the elapsed time plus a zero offset to be no larger than `ep`. The instance is notable for encoding non‑linear arithmetic entirely with bit‑vector arithmetic, producing deep term nesting (max depth 21) and a single, heavily quantified assertion that challenges SMT solvers’ support for quantified bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-node3023.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) of about 2.4 kB containing a single, large quantified assertion that is negated before the check‑sat call. It originates from the Keymaera family of verification conditions (ETCS‑essentials, node 3023) and was translated to bit‑vectors by Mathias Preiner, so it models a hybrid‑system proof obligation in an “industrial’’ context.  \n\nThe core formula asserts that there **does not exist** a 32‑bit variable ts1 satisfying a conjunction of bounds ( 0 ≤ ts1 ≤ t1 ) and several non‑linear relationships among the other declared constants (b, A, m, v, ep, z, …); these relationships involve products, squares, and divisions (e.g., b·ts1 + v² ≥ 0, b·(m−z) ≥ v², b·(m−z) ≥ (ts1·b + v)², etc.). Additional side constraints force b > 0, A ≥ 0 and relate auxiliary terms such as b², A/b, m−z, and quadratic combinations of ep and v.  \n\nOverall the benchmark checks the unsatisfiability of a non‑linear arithmetic verification condition encoded in fixed‑size bit‑vectors, exercising many nested multiplications, divisions and comparisons that stem from the underlying differential dynamic logic model.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node265077.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the Keymaera verification suite for a “safe‑intersection” hybrid‑system example; it was translated to bit‑vectors by Mathias Preiner and appears in the Preiner‑keymaera industrial family (`BV/2017‑Preiner‑keymaera/...`).  It is relatively small (≈2.8 KB, 19 declared constants, one top‑level assertion, maximum term depth 20) and encodes a single quantified condition that existentially selects a time variable `ts1231uscore0`.  Inside the assertion a let‑binding defines two linear expressions `?v_0 = A·ts1231uscore0 + v1` and `?v_1 = (‑B)·ts1231uscore0 + v2`; the formula then requires, under a large conjunction of pre‑conditions (non‑negativity of the parameters A, B, V, v1, v2, bounds on indices I1, I2, and ordering constraints on xI1, xI2, x1, x2), that both `?v_0` and `?v_1` stay within the interval [0, V] and that the total elapsed time `ts1231uscore0` does not exceed a deadline `ep`.  The outer implication also forces consistency between a global time variable `t1231uscore0` (non‑negative) and the existentially chosen `ts1231uscore0`.  Thus the benchmark checks the reachability/ safety condition of the intersection model by encoding a non‑linear arithmetic invariant into quantifier‑free BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node269538.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, size ≈ 2.9 KB, 20 bit‑vector constants) taken from the KeYmaera hybrid‑systems verification suite and translated to 32‑bit bit‑vectors by Mathias Preiner.  It encodes a single verification condition – the negation of an existential formula – that originates from a safety proof for a “simple intersection” hybrid system (the KeYmaera node 269538).  The condition ties together variables that model time, positions (x₁, x₂), velocities (v₁, v₂), and parameters (A, B, V, ep) and asserts a chain of linear and non‑linear constraints such as non‑negativity, upper bounds by V, the relation v₂² ≤ 2·B·(x₂‑x₁), and a linear combination A·t + v₁ ≥ 0 that must stay within the interval [0,V].  The outer “not (exists …)” turns the safety requirement into an unsatisfiability query, so the solver is asked to show that no assignment to the existential time variable ts₁₂₅₄ violates all the conjunctive safety constraints.  Because the original arithmetic was non‑linear, the benchmark exercises the solver’s ability to handle bit‑vector encodings of division, multiplication and signed comparisons in a relatively deep term graph (max depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node251490.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera hybrid‑systems verification suite and translated to bit‑vectors by Mathias Preiner; it is an industrial‑category instance of size ≈2.8 KB with 19 declared constants and a single large quantified assertion.  The assertion states the **negation of an existence** of a time‑step variable `ts1169uscore0` such that a long conjunction of equalities and signed inequalities holds, effectively asking the solver to prove that no admissible time exists.  The conjuncts encode a simple traffic‑intersection safety model: non‑negative velocities `v1`, `v2` bounded by a maximum `V`, non‑negative parameters `A`, `B`, `ep`, and a kinematic relation `xI2 > x2 + v2²/(2·B)` together with a linear update `?v_0 = A·ts + v1` that must stay within `[0,V]`.  Additional constraints fix several “mode” variables (`I1`, `I2`, `I1uscore…`, `I2uscore…`) to the constant 2 or 0, and require `ts` to lie between 0 and a given horizon `t1169uscore0`.  By asserting the outer `not`, the benchmark checks the **safety property** that the system can never reach a state violating these bounds, a typical non‑linear arithmetic verification condition rendered in bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476763.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2 816 bytes, taken from the KeYmaera family of hybrid‑system verification problems (the “intersection‑example‑simple” proof node 476 763) and translated to BV by Mathias Preiner.  It encodes a safety‑property check for a traffic‑intersection scenario: the variables v1, v2, A, B, V, ep, x1, x2 and the auxiliary “I1”, “I2” counters represent velocities, accelerations, bounds, a deadline, and positional indices of two vehicles.  The single asserted formula is the negation of an existential query over a time step ts711₀, asserting that there exists a non‑negative ts711₀ within the interval [0, t711₀] such that the computed positions ( ?v₀ = A·ts + v1₅₁₆ , ?v₂ = A·ts + v2₅₁₆ ) stay inside the allowed range [0, V] while all the side conditions (non‑negative parameters, strict ordering xI1 > x1 + v1²/(2·B), xI2 < x2, B > 0, V > 0, ep > 0) hold.  The outer negation turns the check into a validity problem: the solver must show that no such ts711₀ exists, i.e., the intersection remains safe under the given bounds.  Notably, the model uses only bit‑vector arithmetic (including signed division and comparisons) to simulate the original nonlinear real arithmetic, leading to a relatively deep term structure (depth 22) and many conjuncts (≈20 ‘and’ nodes).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node267578.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition coming from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” proof node 267578 that models a safe traffic‑intersection scenario.  It is encoded in SMT‑LIB 2.6, uses the BV logic, and contains 18 declared constants, one large quantified assertion (¬∃ ts1243uscore0 …) and a total of 2705 characters.  The assertion encodes a safety proof obligation: a conjunction of non‑negativity and upper‑bound constraints on velocities (v1, v2), a braking distance term (v2·v2 / (2·B)), and position relations (xI2 > x2 + … , xI1 < x1), together with positivity of timing parameters (V, ep) and a control‑mode indicator (I1 = I2 = 2).  The core property to be checked is that, under these assumptions, the time‑bounds t1243uscore0 and ts1243uscore0 cannot both satisfy the nested implication unless an impossible disjunction (I1uscore3dollarskuscore306 = 2 ∨ 0 = 2) holds, i.e., the VC should be unsatisfiable.  Notably the real‑valued arithmetic from the original hybrid system proof has been translated into fixed‑width bit‑vector operations, resulting in deep nesting (max term depth 20) and extensive use of signed comparisons (bvslt, bvsgt, bvsle, bvsge).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189817.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 189817 of *intersection‑example‑simple.proof*).  The single asserted formula is the negation of an existential query over a time variable `ts882uscore0`; it asks whether there exists a non‑negative time instant at which a collection of arithmetic constraints on positions (`x1, x2, xI1, xI2`), velocities (`v1, v2`), parameters (`A, B, V, ep`) and integer indices (`I1, I2`) can all hold simultaneously.  The constraints enforce basic safety properties: non‑negative speeds bounded by a global limit `V`, positive acceleration/deceleration parameters (`A, B`), ordering of positions (`xI2 < x2`, `xI1 > x1 + v1²/(2·B)`), and that the computed forward and backward distances (`?v_0`, `?v_1`) stay within `[0,V]` and fit inside the overall time horizon `ep`.  By asserting the outer `not`, the instance checks that no such violating time exists, i.e., that the intersection safety invariant is maintained.  The problem originates from the Preiner‑keymaera industrial benchmark suite and contains 18 declared bit‑vectors, 1 top‑level assertion, and a maximum term depth of 20.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node167638.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) verification condition originating from the KeYmaera hybrid‑system prover; it was extracted from the “Safe intersections” case study (intersection‑example‑simple.proof, node 167638) and translated to BV by Mathias Preiner.  It lives in the industrial “Preiner‑keymaera” family, contains 19 declared constants, a single quantified assertion, and is 2 793 characters long with a maximal term depth of 20.  \n\nThe core formula states, under a large conjunction of safety‑related assumptions (non‑negative velocities v₁,v₂, bounds A,B, a maximal speed V, a positive time‑headway ep, and discrete domain constraints on indices I₁,I₂), that there is **no** value of the existential time variable ts775₀ (the let‑bound “ts775uscore0”) satisfying a set of arithmetic relations.  Inside the let‑binding, two linear expressions ?v₀ = A·ts + v₁′ and ?v₁ = –B·ts + v₂′ are built (where v₁′, v₂′ are shifted versions of the original velocities), and the body requires these expressions to stay within the interval [0,V] while also respecting a quadratic safety bound involving  xI₁ > x₁ + v₁²/(2·B).  \n\nThus the instance checks the unsatisfiability of a safety‑property violation for a vehicle‑intersection hybrid model, encoded entirely with bit‑vector arithmetic (including multiplication and signed division) to emulate the original non‑linear real arithmetic.  The presence of a single existential quantifier wrapped in a top‑level negation makes it a classic “no‑bad‑state” proof obligation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288026.smt2",
    "description": "The benchmark is a 32‑bit BitVec (BV) encoding of a safety verification condition taken from the KeYmaera hybrid‑systems prover (the “intersection‑example‑simple” proof node 288026).  It comes from the Jovanović & de Moura paper on non‑linear arithmetic and from the Platzer et al. “Safe intersections” case study, and is classified as an industrial‑style instance (size ≈ 2.8 kB, 19 declared constants and a single large conjunctive assertion).  The formula asserts the **negation of an existential** over a timestamp `ts1342_0`, requiring that, for all admissible timestamps, a collection of bounds on positions, velocities (`v1`, `v2`), accelerations (`A`, `B`), and a safety margin (`ep`) are simultaneously satisfied.  The constraints encode linear and non‑linear relationships such as `v1 + A·ts`, `v2 – B·ts`, a quadratic term `v2*v2/(2·B)`, and ordering conditions like `0 ≤ ts ≤ t1342_0 ≤ ep`, together with non‑negativity and upper‑bound (`V`) limits on the variables.  The instance therefore checks whether the hybrid‑system model of two vehicles approaching an intersection can ever violate the safety envelope; it is a bit‑vector translation of a non‑linear arithmetic verification condition, featuring deep nested Boolean structure (max term depth 19) and multiple BV multiplications/divisions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171462.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic **BV**) extracted from the KeYmaera hybrid‑system verification suite; it appears in the “intersection‑example‑simple” proof (node 171462) of the paper *Safe intersections* and was translated to bit‑vectors by Mathias Preiner. The file contains 19 declared 32‑bit constants and a single quantified assertion that negates an existential statement over a time‑step variable `ts794uscore0`. The core of the formula encodes a safety condition for a traffic‑intersection hybrid model: it relates positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), bounds (`A`, `B`, `V`), and a positive time horizon `ep`, asserting that, under non‑negative parameters and a quadratic‑term bound `bvsdiv (bvmul v1 v1) (bvmul 2 B)`, the evolved positions stay within the interval `[0,V]` and the elapsed time stays below `ep`. The constraint also distinguishes two modes of the controller via the Boolean test `I1 = 2` (or `I2 = 2`), and it requires that the intermediate expressions `?v_0 = A*ts + v1` and `?v_2 = A*ts + v2` remain non‑negative and bounded by `V`. With a maximum term depth of 21 and 2784 characters, the instance is a compact but non‑linear arithmetic verification condition that tests the solver’s ability to handle mixed arithmetic, divisions and quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node23307.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verification suite, specifically the “intersection‑example‑onelane” proof node 23307, and it is classified as an industrial‑style instance (size ≈ 2.3 kB, 12 declared constants, 1 top‑level assertion). The formula asserts the *negation* of an existential claim over a time variable `ts52uscore0`, i.e. it checks whether there exists a value of this variable that can satisfy a large conjunction of arithmetic constraints. The constraints encode lower‑ and upper‑bounds on several state variables (`v`, `V`, `A`, `ep`, `B`, `I1`, etc.), ordering relations between timestamps (`0 ≤ ts52uscore0 ≤ t92uscore0dollarskuscore0`), and a safety condition involving a nonlinear term `vuscore2dollarskuscore82 * vuscore2dollarskuscore82 / (2*B)` that appears in a comparison with `xI`. Additional requirements enforce positivity of parameters (`B`, `V`, `ep`), monotonicity of a derived expression (`bvmul ?v_1 ts52uscore0 + vuscore2dollarskuscore82 ≥ 0`), and a strict inequality `bvsgt xI (xuscore2dollarskuscore76 + …)`. Thus the instance tests a solver’s ability to handle quantified nonlinear bit‑vector arithmetic that originates from a hybrid‑system safety proof.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476753.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) problem from the *Preiner‑keymaera* family, originally generated by translating a KeYmaera hybrid‑system proof about safe vehicle intersections (node 476753 of *intersection‑example‑simple.proof*) into SMT‑LIB 2.6.  The file contains 18 declared 32‑bit constants and a single top‑level assertion that negates an existential query over a time variable `ts2261uscore0`; the solver is asked to show that no such time can satisfy the embedded safety conditions.  The encoded conditions model a simple traffic‑intersection scenario: they constrain velocities (`v1`, `v2`), positions (`x1`, `x2`), maximal speed `V`, and parameters `A`, `B`, `ep`, together with inequalities such as `bvsgt v1 V` or `bvsle v1 0`, and a non‑linear relation `bvsdiv (bvmul v1 v1) (bvmul 2 B)` that appears inside a safety distance check.  All arithmetic is expressed with signed‑comparison BV operators (`bvsge`, `bvsle`, `bvsgt`, `bvslt`), multiplication, addition, negation and a single signed division, thereby encoding the original real‑valued nonlinear arithmetic as bit‑vector arithmetic.  The benchmark is relatively small (≈2.7 k characters, depth 20) but dense, featuring 19 conjunctions and several nested implications, and is intended to test solvers’ ability to handle quantified, non‑linear BV encodings of hybrid‑system verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node479629.smt2",
    "description": "This benchmark is a 2 KB Bit‑Vector (BV) instance (32‑bit words) from the Preiner‑keymaera family, originally generated by the KeYmaera hybrid‑system verifier for a “safe intersection” proof and then translated to BV by Mathias Preiner (category industrial, source IJCAR 2012).  The single top‑level assertion is the negation of an existential formula ∃ ts₇₉₀, which encodes a verification condition (VC) that a hybrid‑system model of two vehicles at a crossing cannot reach an unsafe state.  The VC constrains 32‑bit variables that stand for positions (x₁, x₂, xI₁, xI₂), velocities (v₁, v₂), parameters (A, B, V, ep) and a time step ts; it contains signed inequalities (≤, ≥, <, >) expressing safety envelopes such as \\(x_{I1}>x_1+ \\frac{v_1^2}{2B}\\), bounds \\(0\\le v_i\\le V\\), positivity of A, B, V, ep and a dynamic update \\(v' = A·ts + v_{1,536}\\).  Additional constraints force the updated velocity to stay within \\([0,V]\\) and the time variable to respect \\(0\\le ts\\le t_{790}\\) while guaranteeing \\(ts+0\\le ep\\).  The overall check‑sat query asks whether there exists a ts violating all these conditions; unsatisfiability would confirm that the intersection controller satisfies its safety property.  Notably, the instance uses bit‑vector arithmetic to model non‑linear real arithmetic (multiplication, division) and contains a nested let‑binding, several quantified implications, and a maximal term depth of 20.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268901.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic = BV) of size ≈ 2.8 KB with a single quantified assertion, originating from the KeYmaera hybrid‑systems verification suite (intersection‑example‑simple.proof, node 268901) and translated to bit‑vectors by Mathias Preiner.  \nThe formula encodes a safety verification condition for a vehicular intersection scenario: it relates the positions (x₁, x₂), velocities (v₁, v₂), acceleration A, braking‑factor B, a global speed bound V, and a time horizon ep, asserting that all physical parameters are non‑negative and bounded by V, and that a derived position update stays within the safe region.  \nThe core of the constraint is an existential quantifier over a time‑step variable ts₁₂₅₀₀, with a let‑binding that computes the traveled distance ?v₁ = A·ts and the updated positions ?v₀ = ?v₁ + v₁ and ?v₂ = ?v₁ + v₂; the safety condition requires both ?v₀ and ?v₂ to stay between 0 and V and the total elapsed time to remain below ep.  \nNon‑linear arithmetic appears through bit‑vector multiplications (bvmul) and a signed division (bvsdiv) used to model the quadratic term v₂·v₂ / (2·B).  \nThe assertion is wrapped in a negated exists, so the solver is asked to prove that no assignment to the quantified time variable can violate the safety predicates, making the benchmark a challenging case for BV solvers handling non‑linear operations and deep conjunctions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250605.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (BV logic) of a safety verification condition that originates from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” proof node 250605 used in the safe‑intersection case study.  The formula asserts the *negation* of an existential statement over a time variable `ts1166uscore0`, thereby checking that no reachable state violates the safety bounds of two vehicles whose positions (`xI1`, `xI2`) and velocities (`v1`, `v2`) are represented as bit‑vectors together with constants `A`, `B`, `V`, and `ep`.  The core constraints enforce positivity and ordering of all physical quantities (e.g., `v1 ≥ 0`, `v2 ≥ 0`, `B > 0`, `V > 0`), relate the vehicles’ positions through a non‑linear update (`xI2 > x2 + (v2·v2)/(2·B)`), and bound the reachable positions within the interval `[0, t]` so that `ts + 0 ≤ ep`.  The condition also includes a multiplicative term `bvmul (bvneg 1) B ts` and a division `bvsdiv (bvmul v2 v2) (bvmul 2 B)`, making the instance a small but genuine non‑linear arithmetic problem.  It was translated from a real‑valued KeYmaera proof to bit‑vectors by Mathias Preiner and appears in the 2017 Preiner‑keymaera industrial benchmark suite.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node54892.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition for the KeYmaera hybrid‑systems model of a one‑lane vehicle approaching an intersection (the “intersection‑example‑onelane” proof node 54892).  The single assertion negates an existential‐quantified time variable ts, thereby asking whether, for every admissible ts (0 ≤ ts ≤ t₈₅), the antecedent kinematic constraints—non‑negative acceleration A, bounded velocity v∈[0,V], a braking factor B > 0, and the quadratic position law x = x₀ + v·t + ½·A·t²—imply the safety disjunction that the vehicle position xI lies either strictly before or strictly after the unsafe interval computed from those same quantities.  The core arithmetic combines several non‑linear operations (multiplication, squaring, division by 2) expressed with BV operators such as bvmul, bvsdiv, and bvadd, yielding a term depth of 23 and a total size of 2763 characters.  Auxiliary constraints enforce non‑negativity of all physical parameters (A, V, ep, etc.) and a sign condition B·v² < 0 that models a braking requirement.  The instance originates from the Preiner‑keymaera family of industrial‑style benchmarks derived from the paper “Solving Non‑Linear Arithmetic” and is intended to test SMT solvers’ ability to handle quantified, non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490353.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark (logic BV) of moderate size (≈2.8 KB, 19 declared constants and a single quantified assertion). It originates from the Keymaera hybrid‑system verifier, specifically the “intersection‑example‑simple” proof node used in the 2011 safe‑intersection case study, and was translated to bit‑vectors by Mathias Preiner. The core of the problem is an ∃‑quantified time variable ts2328₀ that must satisfy a conjunction of safety premises (non‑negative positions and velocities, upper bounds by a global speed limit V, and relational “collision‑avoidance” inequalities involving the vehicles’ positions x₁, x₂ and velocities v₁, v₂). Under these premises the benchmark asserts that a derived expression ?v₀ (bvadd (bvmul (bvneg 1) B) ts2328₀ …) stays within the interval [0,V] and that the overall schedule respects a deadline ep, which is encoded as an implication inside a negated existential, i.e. it checks that no violating time exists. Notably the encoding mixes non‑linear operations (multiplication, signed division) with signed comparisons (bvsgt, bvslt, bvsle, bvsge) and reaches a maximal term depth of 20, making it a representative industrial benchmark for bit‑vector reasoning over arithmetic‑heavy verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287501.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the “Preiner‑keymaera” industrial family (size ≈ 2.8 KB, 19 declared constants, 1 quantified assertion).  \n\nThe single top‑level assertion is the negation of an ∃‑quantified formula over a time variable ts₁₃₃₉, meaning that the solver is asked to prove that no assignment to the system variables can satisfy the inner safety conditions.  \n\nInside the quantified body the model describes a simple traffic‑intersection scenario: two vehicles with velocities v₁, v₂ and positions xI₁, xI₂ must obey non‑negativity, upper bounds V, and a braking condition xI₂ > x₂ + v₂²/(2·B).  Additional constraints tie the positions at time ts₁₃₃₉ to linear expressions v₁·ts + v₁₍₃₉₉₎ and v₂·ts + v₂₍₃₉₉₎, requiring them to stay within [0,V] and the overall horizon ep to be positive.  \n\nThus the benchmark checks the unsatisfiability of a quantified safety invariant for a hybrid system, featuring non‑linear bit‑vector arithmetic (multiplication, signed division) and a relatively deep term structure (depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node688713.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example (node 688713 of *intersection‑example‑simple.proof*).  It was translated to bit‑vectors by Mathias Preiner and appears in the Preiner‑keymaera family of industrial‑oriented benchmarks, occupying about 2.7 KB and containing 18 declared constants and a single, fairly deep (depth 20) quantified assertion.  The formula asserts the **negation of an existential witness** for a time stamp `ts3302uscore0` such that, under a collection of non‑negative parameters (`A`, `B`, `V`, `v1`, `v2`, `ep`) and fixed initial indices (`I1 = I2 = 2`, `I1₈₈₇ = 2`, `I2₈₈₇ = 0`), the linear hybrid dynamics  \n\n```\nv1' = -B·ts + v1₈₈₇\nv2' =  A·ts + v2₈₈₇\n```  \n\nstay within the interval `[0, V]` and the overall time bound `ep` is respected.  The constraint block combines comparison operators (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) with bit‑vector addition and multiplication, embodying a bounded safety property of the intersection model.  Satisfiability of the whole file therefore proves that no such violating time exists, i.e., the safety condition holds for all admissible parameter values.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151296.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (32‑bit bit‑vector) logic, drawn from the KeYmaera hybrid‑systems verification suite (the “intersection‑example‑simple” VC) and translated to bit‑vectors by Mathias Preiner; it appears in the industrial “Preiner‑keymaera” family and is 2 840 bytes long with 19 declared constants.  \nThe sole assertion is a **negated existential**: it states that there is **no** value for the auxiliary time variable `ts699uscore0` that can satisfy a large conjunction of polynomial‑like constraints over the bit‑vectors representing positions, velocities, and parameters (`x1`, `x2`, `v1`, `v2`, `A`, `B`, `V`, `ep`, etc.).  \nThese constraints encode a safety condition for a traffic‑intersection scenario: the “incoming” position `xI1` must exceed `x1 + v1²/(2·B)`, the other incoming position `xI2` must be less than `x2`, all velocities and parameters are required to be non‑negative and bounded by a maximum speed `V`, and a linear combination `?v_0 = A·ts + v2` must stay within `[0,V]`.  \nAn additional disjunct alternates between the trivial equality `xI1 = x1uscore2dollarskuscore177` and a guarded block that further restricts `ts699uscore0` (e.g., `0 ≤ ts ≤ t699uscore0`, `ts+0 ≤ ep`) while re‑checking the same bounds on `v1`, `v2`, and `?v_0`.  \nThus the benchmark checks whether the encoded hybrid‑system invariant is **unsatisfiable** (i.e., the safety property holds) and is notable for its deep nesting (max term depth 21) and for representing non‑linear arithmetic using bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node17304.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the hybrid‑system prover KeYmaera for the “safe‑intersection” example from the paper *Safe intersections: At the crossing of hybrid systems and verification*.  The formula asserts, after a series of non‑negative side‑conditions on variables such as the vehicle position x, the leader position xI, a score variable vuscore₂₆₀, and parameters A, B, V, that for every admissible time instant ts37 the safety disjunction  \n\n```\nxI = x̂   ∨   xI <  x̂ + Δ  ∨   xI >  x̂ + Δ + γ\n```  \n\nholds, where x̂, Δ and γ are bit‑vector expressions involving multiplications, divisions and a quadratic term (bvsdiv (bvmul vuscore₂₆₀ vuscore₂₆₀) (bvmul 2 B)).  The surrounding constraints enforce ordering of timestamps (0 ≤ ts37 ≤ t₆₄), non‑negativity of all physical quantities (e.g., B > 0, V > 0, ep > 0) and relational bounds between the leader and the following vehicle (e.g., bvslt xI x).  The instance is an industrial‑style benchmark (size ≈ 2.6 kB, 13 declared constants, 1 quantified assertion) that tests solvers’ ability to reason about non‑linear arithmetic that has been bit‑vector‑translated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node20269.smt2",
    "description": "The file is a single‑assertion BV‑logic benchmark (size ≈ 2.4 kB, 13 bit‑vector constants, term depth 22) taken from the Keymaera family of verification conditions; it was extracted from the “intersection‑example‑onelane” proof (node 20269) in the KeYmaera hybrid‑system verifier and translated to fixed‑width bit‑vectors by Mathias Preiner.  \nThe asserted formula is the negation of an existential statement over a 32‑bit timestamp `ts44uscore0`, which models a moment inside a time interval bounded by `t77uscore0dollarskuscore0`.  \nInside the let‑binding a linear combination `?v_0 = A·ts44 + vuscore2dollarskuscore71` is introduced, and the body consists of a large conjunction of arithmetic bounds: all variables (`A`, `B`, `V`, `ep`, `v`, `vuscore…`) are required to be non‑negative and below given upper limits, the speed‑related term `xI` must exceed a quadratic expression `xuscore2dollarskuscore65 + (vuscore²)/(2·B)`, and several equalities fix control‑mode identifiers (`I1 = 2`, `I1uscore2dollarskuscore67 = 2`).  \nThe constraints together encode a safety condition for a one‑lane vehicle intersection: the vehicle’s position `xI` must stay ahead of a computed stopping distance while all timing and physical parameters respect their physical ranges.  \nNotably, the benchmark contains non‑linear bit‑vector arithmetic (multiplication and division) and deep nested implications, making it a typical hard case for solvers handling quantified non‑linear BV arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368539.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance of size ≈ 2.9 KB (20 declared constants, a single quantified assertion) taken from the Keymaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category).  \nAll variables (e.g., v1, v2, A, B, V, x1, x2, I1, I2, ep) are declared as 32‑bit vectors and are intended to model velocities, positions, and physical parameters of a traffic‑intersection scenario.  \nThe core formula asserts the **negation of an existential safety condition**: `not (exists ((ts …)) … )`, so the solver must prove that no time `ts` can satisfy the conjunction of constraints that follow.  \nInside the quantified body the constraints combine non‑linear arithmetic (squares via `bvmul v1 v1`, `bvmul v2 v2`, divisions `bvsdiv`, and products `bvmul A ts`) with linear ordering facts such as `v1 ≥ 0`, `v1 ≤ V`, `B > 0`, `V > 0`, `ep > 0`, and kinematic inequalities like `xI1 > x1 + v1²/(2·B)` and `xI2 > x2 + v2²/(2·B)`.  \nThe problem is notable for using a single, deeply nested quantified bit‑vector expression (max term depth 20) that mimics real‑world hybrid‑system verification, making it a challenging case for BV‑capable SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node368193.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) verification condition taken from the KeYmaera hybrid‑system verifier, originally modelling a “safe intersection” example (intersection‑example‑simple.proof, node 368193) and translated to BV by Mathias Preiner.  It belongs to the Preiner‑keymaera industrial family, contains 18 declared constants and a single large quantified assertion (size ≈ 2.8 KB, max term depth 20).  The formula asserts the negation of an existential witness for a time variable ts₀, using a let‑binding to pre‑compute the expressions ?v₀ = 2·B and ?v₁ = B·(‑1)·ts₀ + v₂, and then requires a conjunction of non‑linear safety constraints: the initial velocities v₁ and v₂ lie between 0 and a bound V, the braking distance terms (v₁²)/(2·B) and (v₂²)/(2·B) are non‑negative and bounded by V, the future positions xI₁ and xI₂ exceed the current positions plus those distances, and all parameters A, B, V, ep are positive.  In addition, the quantified part checks that the time bounds 0 ≤ ts₀ ≤ t₀ hold and that the computed term ?v₁ remains within [0, V] while the overall deadline ep exceeds the elapsed time.  The overall assertion‑negation (`(assert (not (exists …)))`) means the solver is asked to prove that no such ts₀ can satisfy all these constraints, i.e., that the safety property of the intersection holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node151408.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the Keymaera family of verification conditions; it originates from the “Safe intersections” hybrid‑system example (node 151408) and was translated to bit‑vectors by Mathias Preiner (size ≈ 2.9 KB, 20 declared constants, one large quantified assertion).  \nThe formula asserts the negation of an existential statement over a time variable `ts700uscore0`, so the solver is asked to show that the quantified constraints are **unsatisfiable** (i.e., that a suitable `ts700uscore0` does exist).  \nThe core constraints encode a hybrid‑system safety condition: non‑negative bounds on velocities `v1`, `v2` and parameters `A`, `B`, `V`; upper bounds `v1 ≤ V`, `v2 ≤ V`; a kinematic inequality `xI1 > x1 + v1²/(2·B)` together with `xI2 < x2`; and a linkage between `ts700uscore0`, a global time `t700uscore0`, and a deadline `ep`.  \nAll arithmetic is expressed with bit‑vector operations (`bvadd`, `bvmul`, `bvsdiv`, signed comparisons), thus embedding the original non‑linear real arithmetic constraints into a decidable BV fragment.  \nThe problem is characteristic of industrial verification workloads: it combines quantified reasoning, non‑linear relations, and a mix of equality/inequality constraints, making it a challenging benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node95128.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of about 2.6 KB with a single, large assertion, taken from the Keymaera family of verification conditions for hybrid‑system safety (the “safe‑intersection” example).  The formula is the negation of an existential query over a time variable `ts439uscore0`; the query asks whether there exists a time at which several linear arithmetic relations—derived from the dynamics `?v_0 = –B·ts439uscore0 + v1` and `?v_1 = A·ts439uscore0 + v2`—remain within the interval [0, V] while the system parameters satisfy non‑negativity and positivity constraints (e.g. `A≥0`, `B>0`, `V>0`, `ep>0`, `I1=I2=2`).  Additional safety premises enforce ordering of positions (`xI1 < x1`, `xI2 < x2`) and non‑negative bounds on the state variables (`v1`, `v2`).  The outermost `not` turns the existential check into a universal safety condition: the instance is satisfiable exactly when the safety property is violated.  Notably, the nonlinear real arithmetic of the original KeYmaera proof has been encoded entirely with bit‑vector operations, and the benchmark contains a modest depth of nested let‑bindings and Boolean connectives (19‑deep term trees).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node48396.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) encoding of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example described in the Loos‑Platzer traffic‑intersection paper.  It originates from the industrial‑style Preiner‑keymaera family (file BV/2017‑Preiner‑keymaera/intersection‑example‑onelane.proof‑node48396.smt2, 2 515 bytes, 13 declared constants) and was translated from the original real‑valued model by Mathias Preiner.  The single top‑level assertion is the negation of an existential formula over a time variable `ts108_1`; the body of the quantifier consists of a large conjunction of linear and non‑linear bit‑vector constraints that bound timestamps, velocities (`v`, `vuscore4…`), positions (`xI`, `x`), and constants (`A`, `B`, `V`, `ep`).  Key constraints include a quadratic term (`v*v` and `vuscore4…*vuscore4…`) multiplied by a constant, a division by `2*B`, and inequalities enforcing non‑negativity, upper bounds (`≤ V`), and safety conditions such as `xI > x + (v*v)/(2*B)`.  By asserting `not (exists …)` the solver is asked to show that no reachable configuration violates the safety condition; thus the problem tests SMT solvers’ ability to handle non‑linear arithmetic expressed in bit‑vector form.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node173665.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera verification of a “safe‑intersection” hybrid‑system example; it was translated to bit‑vectors by Mathias Preiner and appears in the industrial Preiner‑keymaera family. The file is relatively small (≈2.9 KB, 20 declared constants, one quantified assertion) but contains a deep term structure (max depth 20) that mixes linear and non‑linear arithmetic through bvmul, bvsdiv and quadratic expressions such as (v1·v1)/(2·B). The core of the formula is a negated safety VC: it asserts that there exists a time stamp ts₈₀₇₀ such that, under a host of side‑conditions (all parameters A, B, V, v₁, v₂, ep are non‑negative, v₁, v₂ ≤ V, I₁=I₂=2, xI₁ > x₁ + v₁²/(2B), xI₂ < x₂, etc.), a derived value ?v₀ = A·ts + v₂ also stays within [0,V] and the interval [ts, ts+0] fits before ep. The outermost implication then requires either I₁=2 (which is true) or I₂=2, linking the existential part to the overall safety condition. Consequently the solver is asked to show that the negated VC is unsatisfiable, i.e., that the original safety property of the intersection model holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node602111.smt2",
    "description": "The file is a 32‑bit‑vector benchmark (logic BV, size ≈ 2.9 kB, 20 declared constants, 1 top‑level assertion) derived from the KeYmaera hybrid‑systems verifier and translated to bit‑vectors by Mathias Preiner.  It encodes a verification condition for the “safe intersection” example (intersection‑example‑simple.proof, node 602111) that models two cars approaching an intersection with parameters A, B, V, ep, etc.  The core of the formula is an existential quantifier over a time‑step variable ts2860₀, inside a large conjunction that ties together linear and non‑linear relations such as bvadd, bvmul and a signed division bvsdiv, together with ordering constraints (≤, ≥, <, >) on positions (xI1, xI2, x1, x2) and velocities (v1, v2).  The outer `not` turns the check into an unsatisfiability query: it asks whether there exists any concrete bit‑vector assignment that violates the safety invariants (e.g., cars colliding or exceeding speed bounds) while respecting the system dynamics.  Consequently the SMT problem tests the solver’s ability to handle quantified, non‑linear arithmetic over fixed‑size bit‑vectors in an industrial‑style verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node30209.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size ≈2.7 KB, coming from the Keymaera hybrid‑system verification suite (the “intersection‑example‑onelane” proof node 30209) and translated to bit‑vectors by Mathias Preiner.  It encodes a safety condition for a single‑lane traffic‑intersection scenario: a set of linear and non‑linear arithmetic relationships between constants A, B, V, ep and variables representing the vehicle’s position xI, its initial position x, velocity v, and a time variable ts66 that ranges between 0 and a deadline t118.  The core formula is a single negated existential (¬∃ts66 …) that requires, for every admissible ts66, a conjunction of bounds (e.g., non‑negativity of all quantities, upper bounds by V), positivity of parameters (B, V, ep, A), and two key safety inequalities that compare the current position xI with a complex expression involving quadratic terms like (v·v) and (vuscore4·vuscore4) divided by 2·B.  The final disjunction forces either a specific mode indicator (I1uscore4 = 2) or a non‑negative value of a linear combination (A·t118 + vuscore4).  Satisfiability of the whole negated formula therefore checks that no time ts66 can violate the safety invariant; the benchmark is used to assess solvers’ ability to handle non‑linear arithmetic encoded in bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264195.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera verification of a “safe intersection’’ hybrid‑system example (node 264195 of *intersection‑example‑simple.proof*), and it is listed in the Preiner‑keymaera industrial family (size ≈ 2.7 kB, 18 constants, 1 top‑level assertion).  \nIt asserts the negation of an existential formula over a time variable `ts1226uscore0`; the body is a large conjunction of arithmetic constraints that model the hybrid system’s dynamics and safety bounds.  \nKey constraints include non‑negative parameters (`A ≥ 0`, `B > 0`, `V > 0`, `ep > 0`), bounds on velocities (`0 ≤ v1 , v2 ≤ V`), fixed mode identifiers (`I1 = 2`, `I2 = 2`), and a nonlinear relation `xI2 > x2 + (v2·v2) / (2·B)` that introduces multiplication and division on bit‑vectors.  \nThe formula also ties several variables together (`v2uscore… = V`, `v1uscore… = …`) and requires ordering of timestamps (`0 ≤ ts1226uscore0 ≤ t1226uscore0`).  \nOverall the problem checks whether the described safety condition is unsatisfiable, i.e., whether no concrete timestamp can violate the hybrid‑system invariant, which makes it a challenging non‑linear BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/safety-lemma-node14050.smt2",
    "description": "The file is a 32‑bit Bit‑Vector benchmark (logic BV) from the **Preiner‑keymaera** industrial family, originally generated from a safety proof obligation of the KeYmaera hybrid‑system verifier (European Train Control System case study). It contains 15 declared 32‑bit constants and a single, rather large, quantified assertion; the whole instance is 3 244 characters long, with a maximum term depth of 23 and over 20 non‑linear bit‑vector multiplications.  \n\nThe assertion is the negation of an existential statement over a time‑step variable `ts7_0`, so the solver is asked to show that **for all** admissible time steps the conjunction of many arithmetic constraints is unsatisfiable – i.e., a safety invariant holds universally. The constraints encode typical hybrid‑system conditions: non‑negativity of physical quantities (speed `b`, acceleration `A`, epoch `ep`, etc.), bounds on the time variable (`0 ≤ ts7 ≤ t7_0`), and several quadratic relations such as  \n- `bvsle (bvsub (bvmul v v) (bvmul d d)) (bvmul (2·b) (bvsub m z))` (a velocity‑/distance‑type invariant),  \n- `bvsle (bvsub (bvmul ?v_4 ?v_4) ?v_5) (bvmul (2·b) (bvsub muscore6 …))` (a more complex safety inequality involving acceleration, position and a term `vuscore6`),  \n\ntogether with division and linear combination sub‑constraints that couple the variables (`A/b`, `A/2`, etc.).  \n\nBecause the original real‑valued non‑linear arithmetic proof was translated to fixed‑width bit‑vectors, the benchmark features mixed use of signed comparisons, signed division, and multiplication, making it a hard case for BV solvers that must reason about overflow‑free, non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node550289.smt2",
    "description": "This benchmark is a 2 822‑character BV instance (logic BV, 32‑bit bit‑vectors) drawn from the KeYmaera hybrid‑systems verifier and the non‑linear arithmetic paper of Jovanović & de Moura; it belongs to the Preiner‑keymaera industrial family and contains 19 declared constants and a single, rather deep (depth 20) assertion.  \nThe formula asserts the negation of an existential statement over a time variable `ts1232uscore0`, thereby encoding a universally‑quantified safety condition for a simple intersection scenario (vehicle speeds `v1`, `v2`, positions `x1`, `x2`, braking parameters `A`, `B`, etc.).  \nKey constraints include non‑negativity and upper‑bound limits (`0 ≤ v1,v2 ≤ V`, `V > 0`), a braking‑distance inequality `xI2 > x2 + (v2*v2)/(2*B)`, positivity of the braking constant `B`, and a linear evolution rule `?v_0 = A*ts + v2_535` that must stay within `[0,V]` for all admissible `ts`.  \nThe statement also fixes the interval identifiers `I1 = I2 = 2` and links the initial and final positions (`bvslt xI1 x1`, `or (= xI1 x1uscore3dollarskuscore341) …`).  \nBecause the VC is wrapped in a top‑level `(not (exists …))`, the solver is asked to prove that no counterexample exists, a pattern that makes the problem a hard, quantifier‑heavy BV verification task with non‑linear multiplication and signed division.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561425.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) coming from the KeYmaera hybrid‑systems verifier; it originates in the “safe intersections” case study and was translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category).  The single top‑level assertion is the negation of an existential query over a time variable `ts2676uscore0`, expressing that no concrete time can satisfy a conjunction of arithmetic constraints derived from the hybrid model.  The constraints enforce non‑negativity and upper bounds (by the constant `V`) on two velocity variables `v1` and `v2`, positivity of parameters `A`, `B`, `V`, `ep`, and relations such as  \n\n* `?v_0 = A*ts + v1` and `?v_1 = B*ts + v2` are each required to lie in the interval [0, V],  \n\n* the position inequality `xI2 > x2 + v2²/(2*B)` (encoded with `bvsgt` and `bvsdiv`),  \n\n* and a safety condition that the time‑step `ts` stays within `[0, t2676uscore0]` and the overall horizon `ep`.  \n\nThe formula therefore checks the unsatisfiability of a verification condition that a hybrid vehicle‑collision model respects the safety distance under all admissible parameter values, illustrating how non‑linear arithmetic (quadratic terms) is encoded into BV operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node290206.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) coming from the **Keymaera** hybrid‑systems verifier; it was translated to bit‑vectors by Mathias Preiner and appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper (industrial category, file BV/2017‑Preiner‑keymaera/intersection-example‑simple.proof‑node290206.smt2, size ≈ 2.8 kB with 1 top‑level assertion and 19 declared constants).  \n\nThe formula encodes a verification condition for a **safe intersection** scenario: it asserts the *negation* of an existential statement over a timestamp variable `ts1352uscore0` that should satisfy a suite of bounds and relational constraints on positions (`x1`, `x2`, `xI1`, `xI2`), velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`).  \n\nKey constraints include non‑negativity and upper‑bound checks (`bvsge`/`bvsle`), strict ordering of positions (`bvslt`/`bvsgt`), and a nonlinear relation `bvsgt xI2 (bvadd x2 (bvsdiv (bvmul v2 v2) (bvmul (_ bv2 32) B)))` that mirrors a safety distance formula involving a quadratic term `v2*v2`.  \n\nA disjunction ties the condition to either equality `xI2 = x2uscore3dollarskuscore288` or, when the global time `t1352uscore0` is non‑negative, a chain of inequalities that also restricts the computed expression `?v_0 = bvadd (bvmul (bvmul (bvneg 1) B) ts1352uscore0) v1uscore3dollarskuscore411` to lie within `[0,V]`.  \n\nOverall the instance tests a solver’s ability to handle mixed linear and non‑linear bit‑vector arithmetic together with quantifiers and conditional branching, a characteristic pattern of the Keymaera verification‑condition family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node45106.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic **BV**) taken from the Keymaera verification suite; it originates from the “intersection‑example‑onelane” proof node 45106 that models a safe‑intersection hybrid system (see Jovanovic & de Moura IJCAR 2012 and Platzer et al. CADE 2009).  The file contains a single, large assertion that is the negation of an existential formula over a time‑step variable `ts101uscore0`, together with a cascade of quantified conjuncts that encode the hybrid dynamics (position updates, velocity bounds, acceleration limits) using 32‑bit bit‑vector arithmetic.  The constraints involve non‑linear operations—multiplication of variables (`bvmul`), division (`bvsdiv`), and quadratic terms like `v·v` and `vuscore4dollarskuscore58·vuscore4dollarskuscore58`—and a mixture of signed inequalities (`bvsle`, `bvsge`, `bvsgt`, `bvslt`).  The main safety condition being checked is that the “following” vehicle’s position `xI` always stays ahead of the leading vehicle’s reachable position (`x + v²/(2·B)` and similar expressions) for any admissible time step within the horizon `t187uscore0dollarskuscore0`.  Because the assertion is negated, the solver is asked to prove that **no** such time step exists, i.e., that the safety property holds for all reachable states.  The benchmark is relatively large (≈2.5 KB, depth 24, 13 bit‑vector constants) and illustrates how hybrid‑system verification problems are encoded as non‑linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node198058.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of moderate size (≈2.6 KB, 18 declared constants, one large quantified assertion) taken from the KeYmaera hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner.  The single top‑level assertion checks the negation of an existential formula, i.e. it asks the solver to prove that no assignment to the time variable `ts927uscore0` can violate the safety condition encoded inside the `let`‑expression.  The core constraints model a simple traffic‑intersection scenario: they enforce non‑negative velocities `v1`, `v2` bounded by a maximum speed `V`, a positive braking parameter `B`, and a quadratic stopping‑distance term `bvsdiv (bvmul v1 v1) (bvmul 2 B)` that must be less than the distance between the current position `xI1` and the lead vehicle `x1`.  Additional integer‑style conditions tie the discrete mode variables `I1`, `I2` (both required to be 2), the position bounds `xI2 < x2`, and the elapsed‑time bounds `0 ≤ ts927uscore0 ≤ t927uscore0` together with a deadline `ep`.  The formula thus encodes the verification condition “the vehicles can always stop before the intersection under the given bounds”, and its satisfiability (or unsat of the negated form) certifies the safety property of the hybrid system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node365013.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) containing 18 declared constants, a single quantified assertion and about 2.7 kB of terms (max depth 20); it comes from the “keymaera” family of industrial verification problems and was translated to BV by Mathias Preiner from a KeYmaera proof of a safe‑intersection hybrid‑system example. The core formula is a negated existential ∃ ts₀ that would witness a violation of a set of safety inequalities, so the whole problem asks whether **no** such ts₀ exists. The constraints model simple kinematics: positions xI₁, xI₂ must be greater than the current positions x₁, x₂ plus the term v² ÷ (2·B) (realised with bit‑vector multiplication and signed division), velocities v₁, v₂ are bounded between 0 and a global limit V, accelerations A, B are non‑negative, and a deadline ep must be respected (ts₀ lies between 0 and t₁₆₉₉). Additional side conditions tie auxiliary variables (e.g., I₁, I₂ = 2) and enforce that the computed intermediate values stay within [0,V]. Because the non‑linear arithmetic is encoded using bit‑vectors, the instance is a hard test of solvers’ ability to handle mixed‑sign multiplication, division and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node10280.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) problem (logic BV) of size 2615 characters, containing 14 declared constants and a single, heavily nested assertion; it comes from the KeYmaera “binary_driver” verification suite (pre‑translated to BV by Mathias Preiner) and is classified as an industrial‑level instance.  \nThe assertion is a negated existential formula `(not (exists ((ts3_1 (_ BitVec 32))) …))`, so the solver is asked to show that **no** 32‑bit value for the time variable `ts3_1` can falsify the safety condition that follows.  \nInside the quantifier a `let` introduces auxiliary terms (e.g., `?v_0 = bvsdiv amax b + 1`, `?v_1 = vuscore² − duscore²`, `?v_2 = 2·b`, `?v_3 = muscore – zuscore`) and the body is an implication whose antecedent enforces simple bounds (`0 ≤ ts3_1 ≤ t3_0`, `b>0`, `ep>0`, `amax>0`, non‑negativity of scores, etc.) while the consequent asserts a complex non‑linear inequality mixing additions, subtractions, multiplications, squares and signed divisions.  \nKey constraints encode a safety invariant such as  \n`(v² – d²) ≤ ?v_2·(m – z)` together with energy‑like relations like `?v_3 ≤ …` and `vuscore ≥ vdesuscore`, capturing the dynamics of a binary‑driver hybrid system.  \nNotably, the instance uses bit‑vector arithmetic to model real‑valued non‑linear arithmetic, leading to deep terms (max depth 21) and a dense combination of `bvmul`, `bvsdiv`, `bvadd`, `bvsub`, and comparison operators, which is characteristic of the Preiner‑keymaera benchmark family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node490015.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) containing 19 declared constants and a single quantified assertion, with a total size of about 2.8 KB (max term depth 20). It originates from the Keymaera hybrid‑system verifier – specifically the “intersection‑example‑simple” proof node 490015 – and was translated to bit‑vectors by Mathias Preiner for the Preiner‑keymaera family of industrial benchmarks. The formula asserts the **negation** of an existential witness for a time variable ts2326₀ that would satisfy a collection of safety conditions on positions (x₁, x₂, xI₁, xI₂), velocities (v₁, v₂), bounds (A, B, V, ep) and discrete mode indices (I₁, I₂). These conditions involve non‑linear arithmetic (multiplications of variables and the time variable, a signed division, and several linear inequalities such as bvsge, bvsle, bvsgt) that encode a hybrid‑system invariant for a traffic‑intersection scenario. The overall check‑sat query therefore asks whether the safety invariant is violated; a satisfiable result would exhibit a counterexample, while unsat confirms the encoded safety property. Notably, the instance mixes both linear order constraints and true non‑linear bit‑vector arithmetic, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node52492.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it originates from the “intersection‑example‑simple” proof node 52492 and was translated to bit‑vectors by Mathias Preiner.  The file contains 18 declared bit‑vector constants and a single, fairly large quantified assertion (≈ 2.6 KB, max term depth 19), whose negation is asserted before the final `check‑sat`.  \n\nThe core of the problem is a safety condition for a traffic‑intersection hybrid system: it asks whether there exists a non‑negative time “ts235uscore0” such that, under a set of linear‑arithmetic constraints on positions (x1, x2, xI1, xI2), velocities (v1, v2), bounds (V) and parameters (A, B, ep), the system can evolve while staying within the allowed speed interval [0, V] and respecting the dynamics  \n\n   v1 + A·t and v2 − B·t.  \n\nThese dynamics are encoded with bit‑vector addition and multiplication (bvmul), and the formula also enforces non‑negativity of A, B, V, ep and that the two “intersection” identifiers I1, I2 equal the constant 2.  \n\nThus the solver is asked to refute the existence of a reachable unsafe state; a **unsat** result would certify that, for all admissible parameter values, the intersection model cannot violate its safety invariants within the given time horizon.  The instance is notable for being a non‑linear arithmetic verification problem expressed entirely in the BV theory, making it a typical industrial challenge for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node12481.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a hybrid‑system verification condition from the KeYmaera proof “intersection‑example‑onelane”, originally presented in the IJCAR 2012 paper on non‑linear arithmetic and in a 2009 KeYmaera case study on safe intersections.  It belongs to the Preiner‑keymaera family, was translated to bit‑vectors by Mathias Preiner, and contains a single, large quantified assertion (size ≈ 2.6 KB, 13 declared constants, max term depth 24).  The formula asserts the negation of an existential claim over a time variable ts26₀, where the body is a conjunction of range constraints (e.g., all variables non‑negative, V > 0, B > 0, ep > 0) and several non‑linear relationships involving multiplication and division of 32‑bit quantities (e.g., bvmul B ts, bvsdiv (A B), bvsdiv (v·v, 2·B)).  The core property being checked is that, under these arithmetic and ordering constraints, the expression (bvmul (−B) t43) + v remains non‑negative, which corresponds to a safety invariant of the intersection model.  Thus the instance tests an SMT solver’s ability to handle quantified, non‑linear bit‑vector arithmetic arising from industrial hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347816.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic **BV**) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection’’ example described in Loos & Platzer 2011. It comes from the Preiner‑keymaera family (BV/2017‑Preiner‑keymaera) and is 2 817 bytes long, containing 18 declared constants and a single large quantified assertion. The formula asserts the **negation of an existential** over a time‑step variable `ts1620uscore0`; if the negated formula is unsatisfiable the original safety property holds. The constraints model a hybrid traffic‑intersection scenario: non‑negative positions (`x1`, `x2`), velocities (`v1`, `v2`), and a common speed bound `V`, together with quadratic distance‑change terms (`bvmul v1 v1`, `bvmul v2 v2`) divided by a factor that depends on a control parameter `B`. Additional requirements enforce ordering of time (`0 ≤ ts ≤ t1620`), positivity of parameters (`A, B, V, ep > 0`), and that the computed positions stay within the allowed interval `[0,V]`. The instance therefore checks that no reachable state violates the intersection safety condition, and its structure (nested `let`, many signed‐comparison operators, and a mix of arithmetic and division) makes it a challenging case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node252840.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 19 declared 32‑bit bit‑vectors, 1 top‑level assertion, max term depth 21) taken from the KeYmaera hybrid‑system verifier and translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category).  \nIt encodes a single verification condition that originates from the “intersection‑example‑simple” proof node (252 840) of the safe‑intersection case study (Platzer et al., ITSC 2011).  \nThe condition is written as a negated existential: it asserts that there is **no** 32‑bit value ts1175uscore0 for which a large conjunct of arithmetic constraints holds; the outer `check‑sat` therefore tests the validity of the original VC.  \nThe conjunct includes signed inequalities (`bvslt`, `bvsgt`, `bvsle`, `bvsge`) that bound all variables between 0 and a positive upper bound V, require positivity of the parameters A, B, V and ep, and contain non‑linear terms such as `bvmul A ts1175uscore0`, `bvmul v2 v2`, and a signed division `bvsdiv (bvmul v2 v2) (bvmul (_ bv2 32) B)`.  \nA secondary implication ties the auxiliary term `?v_0 = A*ts1175uscore0 + v2uscore3dollarskuscore240` to the same bounds and to the overall time horizon `ep`, while a final disjunction forces `I1uscore3dollarskuscore240` to be either 2 or 1, mirroring a case split in the original hybrid‑system proof.  \nThus the benchmark checks that, under the given positivity and range assumptions, the hybrid‑system safety condition cannot be violated, expressed entirely in quantifier‑free bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node289202.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) from the Preiner‑Keymaera family (size ≈ 2.7 kB, 18 declared constants, one huge assertion) that originates from the “intersection‑example‑simple” verification condition of the KeYmaera hybrid‑system prover, as cited in Jovanović & de Moura 2012 and the safe‑intersection case study of Platzer et al. 2009.  \n\nThe single top‑level assertion is the negation of an existential formula over a time variable `ts1347uscore0`; the inner part is a massive conjunction of signed‐comparison constraints that encode the hybrid dynamics of two vehicles (variables such as `v1`, `v2`, `A`, `B`, positions `x1`, `x2`, and indexes `I1`, `I2`).  \n\nKey constraints enforce non‑negativity and upper bounds (`v1`, `v2`, `A`, `B`, `V`, `ep` > 0, `v1`, `v2` ≤ `V`), specific discrete mode values (`I1 = 0`, `I2 = 2`), a safety condition on the distance between the cars (`bvsgt xI2 (bvadd x2 (bvsdiv (bvmul v2 v2) (bvmul (_ bv2 32) B)))`), and a linear relationship for the evolution of `v1` (`?v_0 = A*ts1347uscore0 + v2`).  \n\nThe outer implication checks that if the time variable stays within its bounds and the evolution respects the same bounds, then the mode predicate `I1uscore3dollarskuscore406 = 2` must hold, otherwise a contradiction is derived.  \n\nThus the solver is asked to prove unsatisfiability of the existential (i.e., that no reachable state violates the safety condition), effectively verifying the intersection safety property after translation of the original nonlinear hybrid‑system model into 32‑bit bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node673088.smt2",
    "description": "The file is a 2.7 KB BV‑logic benchmark (logic = BV) taken from the KeYmaera hybrid‑systems verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the industrial “Preiner‑keymaera” family.  The single top‑level assertion is the negation of an existential formula that asks whether there exists a 32‑bit time‑step variable `ts3208uscore0` satisfying a collection of arithmetic constraints derived from the safety proof of a simple traffic‑intersection hybrid model.  The constraints enforce that the discrete mode indices `I1` and `I2` equal 2, that parameters `A`, `B`, `V`, `ep` are non‑negative (with `B`, `V`, `ep` > 0), and that the state variables `v1`, `v2` lie in `[0,V]`.  They also contain non‑linear terms such as `bvmul v1 v1` and `bvmul v2 v2` divided by `2*B`, and they relate the “augmented” positions `xI1`, `xI2` to the base positions `x1`, `x2` via signed‑greater‑than comparisons.  Additional temporal bounds require `0 ≤ ts ≤ t3208uscore0` and `ts + 0 ≤ ep`, while a final disjunction forces either a constant equality (`0 = 2`) or `I2uscore4dollarskuscore764 = 2`.  Thus the benchmark checks that the hybrid‑system safety condition is unsatisfiable under the given parameter ranges, using a deep (depth 19) bit‑vector encoding of non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605043.smt2",
    "description": "This benchmark is a 2 966‑byte BV‑logic instance (logic = BV) from the *Preiner‑keymaera* family, originally extracted from the KeYmaera hybrid‑systems verifier (the “intersection‑example‑simple” proof node 605043) and translated to bit‑vectors by Mathias Preiner.  It contains a single, fairly large quantified assertion: the outermost `(not (exists … …))` encodes the negation of a safety condition that would guarantee the absence of a reachable bad state in a traffic‑intersection hybrid model.  Inside the body, a conjunction of signed comparisons (`bvsge`, `bvsle`, `bvslt`, `bvsgt`) constrains a set of 32‑bit variables (e.g., velocities v1, v2, parameters A, B, a bound V, a time horizon ep) together with non‑linear arithmetic terms such as `bvmul A ts` and `bvsdiv (bvmul v2 v2) (bvmul (_ bv2 32) B)`.  The formula also relates the positions `xI1`, `xI2` of two vehicles to their initial positions `x1`, `x2` and asserts that either the first vehicle’s position equals a special constant or, if a time variable `t1343uscore0` is non‑negative, a set of additional bounds on the auxiliary variable `ts1343uscore0` and the computed expression `?v_0 = A*ts + v2uscore3dollarskuscore788` must hold.  Because it mixes quantified bit‑vector arithmetic, non‑linear multiplications, and divisions, the instance is a challenging industrial verification condition for SMT solvers that support BV and quantifier reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node29839.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the **keymaera** family, originally generated to verify a safety property of a one‑lane intersection (KeYmaera proof node 29839) and translated to bit‑vectors by Mathias Preiner; it contains 13 declared constants, one quantified assertion, and a total of 2 795 characters.  \n\nThe single top‑level assertion is the negation of an existential formula **∃ ts65**; inside the quantifier a large conjunction of linear and non‑linear BV constraints (bounds on timestamps, velocities v, positions x, and parameters A, B, V, ep) is built with let‑bindings that introduce intermediate expressions such as ?v₀ = −B, ?v₁ = 2·B, and quadratic terms like bvmul v v.  \n\nThe core safety condition checks that, for any admissible timestamp ts65 within [0, t116], the vehicle’s position xI never violates a reachable‑set inequality: either the lane‑index I1uscore4… equals 2 or the current position lies outside a computed quadratic “braking” region (expressed by the disjunction of `bvslt xI ?v_2` and `bvsgt xI (bvadd ?v_2 (bvsdiv (bvmul ?v_3 ?v_3) ?v_4))`).  \n\nAll arithmetic is non‑linear (multiplication of BV variables and division by constants) and the formula mixes order‑relations (≤, ≥, <, >) with equalities, making it a challenging industrial‑style BV instance that tests solvers’ support for quantified non‑linear bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node47513.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) from the Preiner‑keymaera industrial family, originally derived from a KeYmaera safety proof for a one‑lane traffic‑intersection example (node 47513 of *intersection‑example‑onelane.proof*).  It contains a single, large assertion that negates an existential formula over a time variable `ts106uscore1`; the outer `not` turns the whole check into a validity question (i.e., “does no model satisfy the quantified constraints?”).  Inside the quantified block, a conjunction of arithmetic constraints bounds several quantities (`A`, `B`, `v`, `vuscore…`, `V`, `ep`, `t197…`) to be non‑negative and below a global limit `V`, forces `I1 = 2`, and relates them through linear and quadratic bit‑vector expressions such as `A·ts + vuscore`, `v²`, and `vuscore²/(2·B)`.  The key condition is a pair of inequalities asserting that the position variables `xI` exceed the current positions `x` plus the corresponding (non‑linear) distance updates, modeling a safety margin in the hybrid system.  The benchmark is notable for encoding non‑linear arithmetic (multiplication of variables and division) entirely in fixed‑size bit‑vectors, which makes it a challenging case for SMT solvers handling non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal6-node8607.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition (BV logic) taken from the **Keymaera** family of VCs for the European Train Control System case study, translated to bit‑vectors by Mathias Preiner (file train_goal6‑node8607.smt2, 3408 characters, 16 declared constants).  The single top‑level assertion states the **negation of an existential property**: it asserts that there is **no** value for the auxiliary time variable `ts6` that can satisfy a large conjunction of signed‑bit‑vector inequalities describing the train’s kinematics (bounds on acceleration `auscore4…`, velocity `vuscore2…`, distance `duscore2…`, etc.).  The constraints involve non‑linear arithmetic such as squares, products of variables, and signed divisions, and they encode safety requirements like non‑negative positions, upper‑ and lower‑bounds on speed, and a relationship between braking distance and control parameters.  The solver is asked to check `(check-sat)` after wrapping the property in a `not`, so a **sat** result means the original safety property is violated, while **unsat** confirms that the VC holds for all bit‑vector assignments.  The instance is representative of industrial‑scale non‑linear arithmetic verification problems that require reasoning about many intertwined BV multiplications and divisions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node43393.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the Keymaera family of verification conditions for hybrid‑system models of a safe traffic intersection; it was translated to bit‑vectors by Mathias Preiner and appears in the 2012 IJCAR paper on nonlinear arithmetic. The file contains a single, highly compound assertion that is the negation of an existential quantifier over a time variable `ts97uscore2`, which makes the whole formula equivalent to a universal safety property that must hold for every reachable time instant. Inside the quantifier the condition combines linear and non‑linear arithmetic on the 32‑bit variables (e.g., `bvmul v v`, `bvmul ?v_3 ?v_3`, and divisions by two), and asserts a disjunction that bounds the position variable `xI` between two quadratic expressions derived from the system dynamics. The constraints also enforce non‑negativity and upper bounds on parameters such as `A`, `B`, `V`, `v`, and `ep`, and they encode the hybrid‑system guard “if the vehicle is within the lane then its position stays inside a safe interval”. Notably, the benchmark features deep term nesting (max depth 23), multiple let‑bindings, and a mix of linear ordering (`bvsle`, `bvsge`) with non‑linear multiplications, making it a challenging industrial example for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node560442.smt2",
    "description": "The file is a BV‑logic benchmark (logic BV, 20 bit‑vector constants of width 32) taken from the Keymaera hybrid‑systems verifier; it was generated for the “safe‑intersection” example in the KeYmaera paper and later translated to bit‑vectors by Mathias Preiner (category industrial, size ≈ 2.9 kB, 1 assertion, depth 21).  \nThe sole assertion is the negation of an existential formula over a time variable ts2670₀, whose body contains a large conjunctive block that ties together many symbolic state variables (I₁, I₂, x₁, x₂, v₁, v₂, A, B, V, ep) to concrete constants (0, 2) and imposes linear and non‑linear relations such as xI₂ > x₂ + (v₂·v₂)/(2·B) and ?v₀ = A·ts2670₀ + v₂′ ∈ [0, V].  \nSafety‑related constraints enforce positivity (B, A, V, ep, v₁, v₂ ≥ 0) and upper bounds (v₁, v₂ ≤ V), together with ordering conditions (xI₁ < x₁, xI₂ > …); these are expressed with signed‑bit‑vector comparisons (bvslt, bvsgt, bvsle, bvsge).  \nThe outer implication also requires a non‑negative concrete time t2670₀ and a trivial disjunction (1 = 2 ∨ …) that forces the inner conjuncts to be unsatisfiable, so the solver is asked to prove that no such ts2670₀ exists.  \nOverall the benchmark encodes a non‑linear arithmetic verification condition for a hybrid‑system traffic‑intersection model, presented as a single, heavily nested quantified bit‑vector formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node488920.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic **BV**) of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe intersection” example described in Platzer et al.’s transportation‑safety case study.  It originates from the Preiner‑keymaera suite (paper *Solving Non‑Linear Arithmetic*, IJCAR 2012) and contains 19 declared bit‑vector constants, a single quantified assertion and roughly 2.8 KB of SMT‑LIB text.  \n\nThe core of the formula asserts, via a negated ∃, that there is **no** time‑step variable `ts2319uscore0` satisfying a large conjunction of safety hypotheses (initial positions, velocities bounded by a global limit `V`, non‑negative acceleration `A`, braking `B`, and a positive time horizon `ep`) together with a dynamical relation `?v_0 = A*ts + v2…`.  Under these hypotheses the consequent requires the time step to stay within `[0, t2319uscore0]`, the computed state to remain inside the bounds `[0,V]`, and finally forces the condition `I2 = 2` (encoded as `or (= 1 2) ?v_1`).  \n\nThus the instance checks whether the hybrid system can ever violate the safety invariant within the given horizon; unsatisfiability means the invariant holds.  It is notable for mixing non‑linear arithmetic (multiplication and division) with signed bit‑vector comparisons, making it a challenging non‑linear BV verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561875.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size ≈2.7 kB with 18 declared constants and a single quantified assertion, taken from the Keymaera verification suite (intersection‑example‑simple) and contributed by Dejan Jovanovic (pre‑processed by Mathias Preiner).  \nThe formula is a negated existential statement `(not (exists ((ts2679uscore0 (_ BitVec 32))) …))` that encodes a safety verification condition for a hybrid‑system model of a road intersection, as described in the KeYmaera papers.  \nInside the existential block a large conjunction ties together linear and non‑linear constraints such as `bvmul`, `bvsdiv`, and several signed inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) on variables representing positions, velocities, and parameters (e.g., `A`, `B`, `V`, `ep`).  \nKey properties enforced are non‑negativity of physical quantities (`B > 0`, `V > 0`, `ep > 0`), bounds on velocities (`0 ≤ v1, v2 ≤ V`), and a relational condition on the future state (`xI2 > x2 + v2·v2/(2·B)`).  \nThe benchmark is notable for embedding a non‑linear arithmetic verification condition into bit‑vector logic, using `let`‑bindings and a mixture of arithmetic and Boolean operators, which makes it a challenging industrial‑style SAT/SMT test case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node264307.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (BV logic) taken from the **Keymaera** hybrid‑system verification suite and translated to bit‑vectors by Mathias Preiner; it is listed in the industrial “Preiner‑keymaera” family and has 18 declared constants, a single massive assertion and a term depth of 20 (size ≈ 2.7 kB).  \nThe assertion is the negation of an existential formula ∃ ts₁₂₂₇ : ℕ₍₃₂₎; inside a *let* it defines two linear expressions v₀ = A·ts + v₁′ and v₁ = (−B)·ts + v₂′, where v₁′ and v₂′ are also 32‑bit parameters.  \nThe antecedent of the implication gathers a large conjunction of safety‑type constraints: initial indices I₁, I₂ are fixed (I₁ = 0, I₂ = 2), A, B, v₁, v₂, V, ep are required to be positive, the derived positions xI₁ < x₁ and xI₂ > x₂ + v₂²/(2·B) must hold, and the computed values v₀, v₁ are forced to stay in the interval [0,V] while ts itself is bounded by t₁₂₂₇ and ep.  \nThe outermost “not (exists … (=> …))” therefore asks the solver to prove that **no** value of ts₁₂₂₇ can violate the safety implication; in other words it checks universal safety of the hybrid‑system transition under the given numeric bounds.  \nNotably the model mixes non‑linear arithmetic (the quadratic term v₂·v₂ and division by 2·B) with bit‑vector reasoning, a characteristic of the Keymaera encoding that makes the instance challenging for BV‑solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node295273.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it is an industrial‑category instance of size ≈ 2.7 KB with 18 declared constants and a single, large quantified assertion.  The assertion is the negation of an existential formula over a time variable `ts1381uscore0`, so the solver is asked to prove that no assignment to `ts1381uscore0` can satisfy the body of the formula (i.e., to discharge a verification condition).  The body mixes a long conjunction of linear bounds (`bvsle`, `bvsge`, `bvslt`, `bvsgt`) on variables such as `v1`, `v2`, `A`, `B`, `V`, and `ep` with two non‑linear sub‑terms: a quadratic term `bvmul v2 v2` divided by `2*B`, and a product `bvmul (bvneg 1) B ts1381uscore0` that appears inside an addition with `v1uscore3dollarskuscore439`.  The condition also contains a small disjunction `or (= I1uscore3dollarskuscore439 2) ?v_1` that links the auxiliary Boolean `?v_1` (which tests `I2uscore3dollarskuscore439 = 2`) to the value of `I1uscore3dollarskuscore439`.  Because the benchmark originates from the “intersection‑example‑simple” proof node of a KeYmaera model of safe traffic intersections, it encodes a safety property that involves both linear ordering of positions (`xI1 < x1`, `xI2 > x2 + …`) and non‑linear timing constraints, making it a notable example of non‑linear arithmetic translated into bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node551337.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the Keymaera hybrid‑system verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the Jovanović & de Moura “Solving Non‑Linear Arithmetic” paper.  The file (≈2.8 KB, 19 constants, a single quantified assertion) encodes a safety verification condition for a simple traffic‑intersection hybrid model, where the goal is to show that no execution time ts can violate the prescribed bounds.  The core of the assertion is a negated existential over ts, combined with a large conjunct of linear and non‑linear constraints: equalities fixing several counters to 2, positivity constraints on parameters A, B, V, ep, range constraints 0 ≤ v₁,v₂ ≤ V, a non‑linear term v₀ = A·ts + v₂′ that must stay within [0,V] and below ep, and relational conditions on positions xI₁, x₁, xI₂, x₂ that model the intersection geometry.  The formula also contains a disjunction linking the start‑position equality xI₁ = x₁′ with a guarded implication that enforces the above bounds when t ≥ 0.  Because the outermost operator is (not (exists …)), the SMT query asks whether the verification condition is unsatisfiable, i.e., whether the hybrid system is provably safe under the given bit‑vector encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/controllability-lemma-disturbed.proof-node770.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance of size 2208, taken from the Keymaera verification suite that models a controllability lemma for the European Train Control System; it was translated to BV by Mathias Preiner and submitted by Dejan Jovanović. The formula consists of a single quantified assertion: the negation of an ∃ t₀ ∀ ts₀ block that encodes a chain of implications relating the variables t₀, ts₀, b, u, v, d, l, m, z. Inside the implication there are several non‑linear constraints, notably quadratic terms (v·v, d·d) and products such as b·t₀², u·t₀, and mixed terms involving (b‑u)·(m‑z), all expressed with 32‑bit bit‑vector arithmetic. The constraints also include ordering conditions (e.g., b > u, all variables non‑negative, ts₀ ∈ [0, t₀]) and a division by 2 (bvsdiv 1 2) that appears in a safety bound. Because the outermost `not` is asserted, the problem asks the solver to prove that no t₀ violates the universally quantified safety conditions, making it a heavy non‑linear BV verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node369759.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition generated by the KeYmaera hybrid‑system prover for the “safe‑intersection” example described in Loos & Platzer (ITSC 2011). It appears in the Preiner‑keymaera collection (BV/2017‑Preiner‑keymaera) and consists of a single large quantified assertion (≈ 2.8 KB, 18 declared constants, 19 conjunctions, max term depth 20). The formula negates an existential over a time variable ts₁₇₂₆₀ and then checks that, under a host of linear and non‑linear constraints on the parameters A, B, V, v₁, v₂ (which model speeds, distances and safety margins), the safety property “the predicted intersection positions xI₁ and xI₂ stay beyond a safe buffer” cannot be violated. Key constraints involve signed‑greater/less comparisons, non‑negativity of all physical quantities, a quadratic term (v₁²) and (v₂²) divided by a linear expression ?v₀, and bounds linking ts₁₇₂₆₀, a global time horizon t₁₇₂₆₀ and an endpoint ep. The problem therefore tests an SMT solver’s ability to handle non‑linear arithmetic encoded as bit‑vector multiplication/division together with extensive signed comparisons, typical of industrial hybrid‑system verification tasks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node291850.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector file (logic BV) of the “Preiner‑keymaera” industrial family, taken from the Keymaera hybrid‑systems verification suite (intersection‑example‑simple, node 291850) and translated to bit‑vectors by Mathias Preiner. The file contains 19 constant declarations and a single, fairly large assertion (≈2.8 KB, max term depth 21) that is the negation of an existential formula over a time‑step variable `ts1361uscore0`. The quantified core encodes the dynamics of two intersecting traffic participants (`I1`, `I2`) together with safety bounds on velocities (`v1`, `v2`), positions (`x1`, `x2`), and parameters (`A`, `B`, `V`, `ep`), using non‑linear operations such as multiplication and division, and a mixture of ordering constraints (`bvslt`, `bvsgt`, `bvsle`, `bvsge`). The overall property being checked is that, under the given positivity and range assumptions, the computed positions (`?v_0`, `?v_2`) always stay within the allowed interval `[0,V]` and that the elapsed time stays below `ep`; the outer `not` turns the query into a safety‑verification goal (“is the unsafe condition unsatisfiable?”). Notably, the instance contains nested `let` bindings and a mixture of linear and non‑linear bit‑vector arithmetic, making it a representative challenge for solvers handling quantifiers and non‑linear BV reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/train_goal3-node5717.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition taken from the KeYmaera train‑control case study, translated to BV by Mathias Preiner and submitted to SMT‑LIB as an “industrial” instance (family Preiner‑keymaera, size ≈ 3.4 KB, 16 declared constants).  The formula asserts the negation of an existential query over the time variable `ts3uscore0`; thus the solver must show that no assignment satisfying the body exists, i.e., that the underlying safety property holds.  The body consists of a large conjunction of non‑linear arithmetic constraints (products of variables, squares, and mixed divisions) together with simple bounds such as `bvsge`/`bvsle` on each variable, and a final disjunction that either a derived inequality or the state flag `stateuscore2dollarskuscore0 = 1` must hold.  Key relations involve terms like `bvmul (_ bv2 32) b`, `bvmul vuscore2dollarskuscore0 vuscore2dollarskuscore0`, and `bvsdiv` divisions, making the problem an instance of non‑linear BV reasoning with a moderate term depth (21) and many multiplication occurrences (21).  The instance therefore tests an SMT solver’s ability to handle quantified, non‑linear bit‑vector arithmetic that originates from hybrid‑system verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node169818.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the hybrid‑system prover KeYmaera for the “safe‑intersection” example described in Loos & Platzer (ITSC 2011).  It originates from the Preiner‑keymaera industrial suite (file intersection‑example‑simple.proof‑node169818.smt2) and contains 19 declared bit‑vector constants, a single quantified assertion and about 2 800 characters of input.  \n\nThe formula asserts the **negation** of an existential statement over a time variable `ts785uscore0`; consequently the solver is asked to prove that no reachable state violates the safety predicate.  The predicate ties together a number of linear and non‑linear relationships on the 32‑bit variables: it enforces non‑negative velocities (`v1`, `v2`), upper bounds by a maximal speed `V`, positivity of parameters `A`, `B`, `ep`, and a quadratic term `bvmul v1 v1` divided by `2*B` that appears in a position update (`xI1 > x1 + v1^2/(2B)`).  Additional constraints fix indices `I1`, `I2` to the constant 2, set `v2 = 0`, and relate the “intersection” positions `xI1`, `xI2` to the road positions `x1`, `x2`.  \n\nThe overall check therefore asks whether the safety condition (vehicle 1’s position stays ahead of a safety envelope and vehicle 2 does not overtake) can be violated for any non‑negative time instant; the expected result is *unsat* (the condition holds).  The instance features a modest depth (max term depth 20) but includes non‑linear arithmetic (quadratic term) translated into bit‑vector operations, making it a typical challenge for SMT solvers handling BV‑encoded hybrid‑system proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node155401.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition that originates from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 155401).  It is a single quantified assertion (¬∃ ts719₀) that combines a large conjunction of linear and non‑linear constraints over 19 bit‑vector constants (e.g., v1, v2, A, B, V, ep, xI1, xI2) together with an implication that enforces bounds, non‑negativity, and a quadratic term (bvmul v1 v1) divided by 2·B.  The inner formula also contains relational conditions such as bvsgt xI1 (x1 + (v1·v1)/(2·B)) and bvslt xI2 x2, expressing that the positions of two vehicles at a crossing satisfy a safe‑distance invariant.  The outer negation turns the problem into a proof‑obligation: it asks the solver to show that no assignment to the existential time variable ts719₀ can violate the safety property, i.e., that the condition is unsatisfiable.  The instance is relatively small (≈2.8 kB, 19 declarations, depth 21) but features mixed linear/non‑linear arithmetic and division, which makes it a challenging benchmark from the industrial “Preiner‑keymaera” family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node631276.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (2851 characters, 19 declared 32‑bit vectors, 1 quantified assertion) taken from the KeYmaera hybrid‑systems verification suite; it originates from the “intersection‑example‑simple” proof node used in the IJCAR‑2012 and ITSC‑2011 papers on safe traffic‑intersection verification.  \n\nThe single top‑level constraint is a negated ∃‑quantifier over a timestamp `ts3018_0`; inside the quantifier a `let` defines three auxiliary expressions that correspond to the kinematic distances `v₁²/(2·B)`, `v₂²/(2·B)` and the position update `A·ts + v₁₀`.  \n\nThe body asserts a large implication: under a collection of safety hypotheses (non‑negative constants, upper bounds `V` on speeds, positive acceleration `B`, positive parameters `A` and `ep`, and the condition that the two cars’ positions `xI1`, `xI2` lie beyond their respective braking distances) it must hold that, for any non‑negative timestamp, the computed positions stay within the interval `[0,V]` and the elapsed time does not exceed `ep`.  \n\nKey constraints are therefore a set of linear and non‑linear (quadratic) inequalities over bit‑vectors, encoded with `bvmul`, `bvsdiv`, and signed comparisons; the final disjunction forces either the trivial equality `1 = 2` (which is false) or that `I2 = 2`, linking the proof node to a specific case split.  \n\nThus the benchmark encodes the safety‑condition checking of a hybrid traffic‑intersection model, translated from real arithmetic into 32‑bit bit‑vector arithmetic, and is used to stress SMT solvers’ handling of non‑linear arithmetic and quantifiers in an industrial verification context.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/FTRM-entry-tang-feasible-node1796.smt2",
    "description": "The benchmark is a 2‑KB BV (fixed‑width bit‑vector) instance (32‑bit vectors) from the **Preiner‑keymaera** family, originally extracted from the Keymaera verification of a curved‑flight collision‑avoidance maneuver (FTRM entry‑tang feasibility, node 1796).  It uses the BV logic of SMT‑LIB 2.6, contains eight declared constants, one quantified assertion (two nested ∃ over h₁₀ and h₂₀), and a total of 16 bvmul occurrences, giving a maximum term depth of 12.  \n\nThe core of the formula encodes a set of non‑linear geometric constraints: a “Pythagorean” relation (bvmul r r) = (d₁² + d₂²), a scaled‑radius condition (x₁² + x₂²) = 3·r², and definitions linking d₁ and d₂ to the differences (x₂ – h₂) and (x₁ – h₁) respectively, together with a non‑negativity requirement on the scalar tuscore0dollarskuscore0.  \n\nThe outermost (not …) turns the quantified conjunction into a **feasibility** query: the solver must show that no assignment to the existential variables can satisfy all the equalities and the inequality t ≥ 0 together with the linear equations x₁ + t·d₁ = 0 and x₂ + t·d₂ = 0.  \n\nThus the benchmark tests a solver’s ability to handle quantified non‑linear arithmetic that has been bit‑vector‑encoded, combining arithmetic, algebraic circles, and a simple linear “time‑to‑collision” condition within an industrial verification context.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548277.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the Keymaera hybrid‑systems verification suite; it was translated to bit‑vectors by Mathias Preiner and appears in the Jovanović‑de Moura “Non‑Linear Arithmetic” paper (IJCAR 2012).  The single assertion checks the unsatisfiability of a negated existential formula, i.e. it tries to prove that a certain verification condition (VC) for a simple traffic‑intersection safety proof holds.  The VC quantifies a time‑step variable `ts2612uscore0` and contains a mixture of linear and non‑linear constraints: non‑negativity of all physical quantities (velocities v₁,v₂, bounds A,B,V, epoch ep), upper bounds `v₁≤V`, `v₂≤V`, a quadratic term `bvsdiv (bvmul v₂ v₂) (bvmul 2 B)` that models a stopping distance, and a relation `bvadd (bvmul (bvneg 1) B) ts2612uscore0` combined with `v₂` to express a reachable position.  Additional Boolean structure enforces consistency of indexed constants (e.g. `I1 = 2`, `I2 = 2`) and ties the existential time to the epoch (`ts2612uscore0 ≤ ep`).  The formula is relatively deep (max term depth 19) and uses a range of BV operators (addition, multiplication, signed division, comparisons), making it a representative industrial‑style non‑linear arithmetic VC encoded in the bit‑vector theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node606132.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2868 with 20 declared constants and a single, rather large conjunctive assertion (assert‑count = 1). It originates from the KeYmaera hybrid‑system verifier: the VC corresponds to the “intersection‑example‑simple” proof node 606132, modelling a safety condition for vehicles at a crossing, and was translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category). The formula asserts the negation of an existential over a timestamp ts2884₀, i.e. it tries to prove that no valuation of ts2884₀ can satisfy a set of linear and non‑linear arithmetic constraints encoded with BV operations. The key constraints enforce non‑negativity and upper bounds (by V) on velocities v₁, v₂, positivity of parameters A, B, V, ep, ordering of positions (xI₁ < x₁, xI₂ > x₂ + v₂²/(2·B)), and a linear relation ?v₀ = A·ts + v₂₍₇₉₄₎ that must stay within [0, V] while ts stays between 0 and t2884₀. The benchmark therefore checks whether the safety invariant holds for all reachable time steps, and its difficulty stems from the combination of bit‑vector multiplication, division and signed comparisons together with a deep nesting of logical connectives (max term depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node362512.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a safety verification condition drawn from the KeYmaera hybrid‑systems proof “intersection‑example‑simple” (node 362512).  It belongs to the Preiner‑keymaera family, was submitted by Dejan Jovanović, and contains 19 declared bit‑vector constants and a single, large quantified assertion (≈ 2.9 kB, max term depth 20).  The core of the formula asserts, after negating an existential over a time variable `ts1687uscore0`, that no reachable state can violate a set of signed inequality constraints linking positions (`xI1`, `xI2`), velocities (`v1`, `v2`), acceleration parameters (`A`, `B`), a speed bound `V`, and a time horizon `ep`.  These constraints encode non‑linear arithmetic (quadratic terms `v1*v1`, `v2*v2`) and division using BV operations (`bvmul`, `bvsdiv`) together with linear bounds such as `0 ≤ v1 ≤ V`, `0 ≤ v2 ≤ V`, `A ≥ 0`, `B > 0`, and `ep > 0`.  The outer negation together with the implication structure forces the solver to prove that the quantified safety condition is unsatisfiable, i.e., that the intersection is provably safe under the given numeric parameters.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node288860.smt2",
    "description": "The file is a 32‑bit bit‑vector encoding (logic BV) of a verification condition taken from the KeYmaera hybrid‑systems benchmark “intersection‑example‑simple”, translated by Mathias Preiner and posted in the Preiner‑keymaera industrial family (≈2.8 KB, 19 constants, one top‑level assertion).  The assertion is the negation of an existential quantifier over a time variable `ts1346uscore0`; it therefore states that **no** choice of `ts` can make a large implication true, i.e., it checks a universal safety property.  The antecedent of the implication collects a suite of linear and non‑linear constraints on the variables `v1`, `v2`, `A`, `B`, `V`, `ep`, and on derived quantities such as `‑B*ts + v2uscore...` and `x2 + (v2*v2)/(2*B)`, enforcing non‑negativity, upper bounds by `V`, positivity of `B`, `V`, `ep`, and a separation condition `xI2 > x2 + (v2*v2)/(2*B)`.  The consequent requires either equality of two position variables or, under the assumption `t1346uscore0 ≥ 0`, that the same bounds hold for the time‑dependent expression together with a trivial disjunction that is already satisfied by `I1uscore… = 2`.  Thus the formula encodes the absence of a time instant that would violate the safety invariant of the intersection scenario, using bit‑vector arithmetic to model the originally real‑valued non‑linear arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-essentials-live-range2.proof-node577.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera verification suite for the European Train Control System and translated to bit‑vectors by Mathias Preiner; it belongs to the industrial category and contains 7 declared constants and a single quantified assertion (size ≈ 1.6 kB). The formula asserts the negation of an existential query: there must **not** exist a 32‑bit value *dollarnuscore0* such that, assuming the signed variables vo, ep, b are all > 0 and A ≥ 0, the signed‑greater‑or‑equal relation  \n\n  bvadd z (bvmul (bvmul dollarnuscore0 ep) vo) ≥ puscore0dollarskuscore0  \n\nholds (together with the trivial equality vo = vo). In other words, the solver is asked to prove that no assignment to *dollarnuscore0* can satisfy the non‑linear inequality under those positivity preconditions. The instance therefore tests SMT solvers on non‑linear arithmetic encoded via bit‑vector multiplication and signed comparisons, with a modest term depth (8) and a single quantified block.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node53901.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) taken from the KeYmaera verification suite; it appears in the “intersection‑example‑onelane” proof node 53901 and was translated to BV by Mathias Preiner (size ≈ 2.4 KB, 13 declared constants, one top‑level assertion).  \nThe formula asserts the negation of an existential statement over a time variable `ts122uscore0`, whose body is a large conjunction of linear and nonlinear bit‑vector constraints generated from a hybrid‑system safety proof (vehicle position `xI`, velocity `v`, acceleration `A`, distance bounds `B`, `V`, `ep`, etc.).  \nKey constraints enforce that the time lies between 0 and a deadline (`t229uscore0dollarskuscore0`), that derived quantities such as `?v_0 = A*ts + vuscore4dollarskuscore90` stay within the interval [0, V], that velocities and parameters are non‑negative, and that the position after time `ts` exceeds the current position plus a quadratic term `(v*v)/(2*B)`.  \nAdditional conditions require `B > 0`, `V > 0`, `ep > 0`, and either a particular mode flag `I1` equals 2 or the expression `A*t229 + vuscore4dollarskuscore90` is non‑negative.  \nThe instance is characteristic of industrial hybrid‑system VCs: it mixes many bit‑vector arithmetic operators (addition, multiplication, signed division, comparison) with a nesting depth of 22, making it a challenging case for solvers that must handle non‑linear arithmetic over fixed‑size bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node294748.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it appears in the “intersection‑example‑simple” proof node 294748 and was translated to BV by Mathias Preiner for the 2017 Preiner‑keymaera family.  The single top‑level assertion is the negation of an existential formula ∃ts₀ that encodes a safety invariant for two moving objects (variables x₁,x₂, v₁,v₂) at a road intersection, with parameters A, B, V, ep describing acceleration limits, braking capability, a global speed bound and a time horizon.  Inside the let‑binding the constraints assert non‑negativity of all physical quantities, upper bounds by a common speed limit V, and a quadratic stopping‑distance term v₂·v₂ / (2·B) that must keep the second object ahead of the first ( x₂ + v₂²/(2B) ).  The formula also requires the time variable t₀ to lie between 0 and ep, and it checks that either the current mode identifier I₁ equals 2 or a similar condition on I₂ holds.  Satisfiability of the negated existential corresponds to a violation of the safety property, so the benchmark is essentially asking the solver to prove that no reachable state can breach the intersection safety condition.  With 18 declared bit‑vector constants, a max term depth of 19 and a mixture of linear, non‑linear (multiplication) and signed‑division operations, it serves as an industrial‑style test of BV solvers on non‑linear arithmetic encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node174885.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite – specifically the “intersection‑example‑simple” proof node 174885 – and was translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category, 2 728 bytes, 18 declared constants, 1 top‑level assertion).  \n\nThe single assertion negates an existential statement over a fresh time variable `ts814uscore0`; the body is a large let‑expression that first defines a linear combination `?v_0 = -B·ts814uscore0 + v1uscore2dollarskuscore332` and then checks a cascade of arithmetic constraints.  \n\nThe constraints encode the safety conditions of a traffic‑intersection hybrid model: all state variables (`v1`, `v2`, `A`, `B`, `V`, `ep`, etc.) are bounded between 0 and a global upper bound `V`, the velocities satisfy `v1 ≥ 0`, `v2 ≥ 0` and `v1 ≤ V`, `v2 ≤ V`, and the positions `xI1`, `xI2` must respect quadratic‑time reachability inequalities such as `xI1 > x1 + v1²/(2·B)` and `xI2 < x2`.  \n\nAdditional side conditions require the time‑step `t814uscore0` and the existential time `ts814uscore0` to lie within non‑negative intervals and to keep `?v_0` inside `[0,V]`.  \n\nThe whole formula is a satisfiability‑check that the modeled intersection scenario is **unsafe**; the intended result is unsat, proving that all those safety constraints can be simultaneously satisfied.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node171778.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) benchmark of size ≈ 2.9 KB (2859 characters) with 20 declared constants and a single, large quantified assertion; it belongs to the industrial “Preiner‑keymaera” family and originates from the KeYmaera hybrid‑system verifier (the “safe‑intersection” example). The SMT‑LIB logic is **BV**, and the problem checks a verification condition that was originally expressed in non‑linear real arithmetic but was translated to bit‑vectors by Mathias Preiner. Internally the formula asserts the **negation of an existential** statement over a fresh time variable `ts796uscore0`, whose body is a conjunction of signed comparisons (`bvsge`, `bvsle`, `bvsgt`, `bvslt`) together with linear and non‑linear BV operations such as addition, multiplication (`bvmul`) and signed division (`bvsdiv`). The constraints encode bounds on vehicle speeds (`v1`, `v2`) and acceleration (`A`), positivity of constants (`B`, `V`, `ep`), and safety conditions on positions (`xI1`, `xI2`, `x1`, `x2`) that must hold for all admissible time steps. Satisfiability of the negated existential corresponds to proving that the original safety property is valid; thus the solver is asked to show that the quantified condition is **unsatisfiable**, i.e., that no counterexample exists.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node346919.smt2",
    "description": "This benchmark is a 32‑bit‑vector encoding (logic BV) of a safety verification condition that originates from a KeYmaera proof about a simple road‑intersection scenario.  The model introduces bit‑vector constants for two vehicles’ velocities (v1, v2), positions before the intersection (x1, x2), safety‑distance variables (xI1, xI2), a braking deceleration bound (B), a speed limit (V), and several auxiliary parameters (A, ep, ts‑variables).  The heart of the formula states, for each vehicle, that the initial distance to the crossing must be larger than its braking distance \\(v^{2}/(2B)\\) (expressed with bvmul and bvsdiv), while all physical quantities are constrained to be non‑negative, bounded by V, and certain indices (I1, I2) are fixed to 2.  The outermost “not exists” quantifier asserts that no choice of the time variable ts can violate these braking‑distance and bound constraints, i.e., it checks the unsatisfiability of a potential safety breach.  Although the instance contains only one large conjunct (19 declared constants, depth 20), it mixes non‑linear arithmetic, division, and inequalities, making it a representative industrial benchmark from the Preiner‑keymaera family.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsl.proof-node2761.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance of the industrial “Preiner‑keymaera” family (size 2638 characters, 10 declared constants and a single quantified assertion).  It originates from a verification condition generated by the KeYmaera hybrid‑system prover (node 2761 of the *vsl.proof* example) and was translated to bit‑vectors by Mathias Preiner.  The formula asserts the negation of an existential statement over a time variable `ts3uscore1`; inside the quantified body a large conjunction encodes a collection of range constraints (e.g., non‑negativity of parameters `A`, `B`, `ep`, bounds on `ts3uscore1` between 0 and `t12uscore0dollarskuscore1`) together with linear relationships such as `bvadd (bvmul a1 ts3) v1 ≥ 0` and ordering constraints between `v1`, `vsl`, and `x1`.  The most distinctive clause is a disjunction that ties a linear expression `?v_0 ≤ vsl` to a quadratic inequality involving squares of `?v_0` and `vsl` and a term proportional to `B`, thereby introducing mixed non‑linear arithmetic into the BV setting.  The goal of the check is to determine whether the negated existential is satisfiable, i.e., whether the original verification condition (the existence of a suitable `ts3uscore1`) fails; the presence of multiplications, divisions, and a quadratic term makes this a challenging non‑linear BV problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node175109.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera hybrid‑system verification suite; it appears in the 2012 IJCAR paper on non‑linear arithmetic and models the “safe intersection” example from the ITSC 2011 traffic‑safety case study. The file declares 18 32‑bit variables that stand for physical quantities such as the two cars’ positions (x₁, x₂), velocities (v₁, v₂), a common speed limit V, acceleration A, braking capability B, and several auxiliary interval identifiers (I₁, I₂). The single top‑level assertion is the negation of an existential formula over a time step variable ts; it requires that there is **no** ts ≥ 0 such that the cars can satisfy a collection of linear and quadratic‑style safety constraints (e.g., xI₁ > x₁ + v₁²/(2·B), xI₂ < x₂, all variables staying within [0,V], and the updated velocities after a time‑step staying in the same bounds). In other words, the solver is asked to prove that the safety condition holds for all reachable states of the hybrid system. The instance is relatively small (2664 characters, depth 21) but embeds non‑linear arithmetic via bit‑vector multiplication and division, making it a representative industrial‑style verification challenge.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node387850.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) formula (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it originates from the “intersection‑example‑simple” proof node 387850 in the Keymaera family of industrial verification conditions (see Jovanović & de Moura 2012).  The file contains 18 declared constants, one large quantified assertion (an existential over a time variable ts1809₀) and a single conjunctive safety condition that encodes the non‑linear arithmetic of the VC by using BitVec multiplication (v₁·v₁, v₂·v₂) and signed division.  The core constraints enforce non‑negative bounds on all physical quantities (A, B, V, ep, v₁, v₂, I₁, I₂), relate the “intersection” positions xI₁, xI₂ to their initial positions x₁, x₂ via quadratic terms divided by a linear combination of B and the time variable, and require the time and auxiliary variables to lie within the interval \\([0,ep]\\).  The outermost `(not …)` turns the safety condition into an unsatisfiability query: the solver must show that no assignment to the bit‑vectors can violate the safety property, i.e., that the original hybrid‑system invariant holds.  Notably, the benchmark captures non‑linear reasoning (quadratic terms) in fixed‑size BV arithmetic, leading to a relatively deep term nesting (depth 19) and a mixture of signed comparisons, arithmetic, and logical connectives.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node531710.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (BV logic) originating from the KeYmaera hybrid‑system verifier; it appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and encodes the VC for the *intersection‑example‑simple* proof (node 531710).  The file contains 18 declared bit‑vector constants and a single, fairly large assertion (≈2.7 KB, max term depth 20) that asserts the **negation** of an existential property over a time variable `ts2515uscore0`.  \n\nThe core of the property models a simple traffic‑intersection scenario: it relates positions `x1`, `x2`, velocities `v1`, `v2`, and parameters `A`, `B`, `V`, `ep` by linear and non‑linear (multiplication) constraints such as  \n`v1uscore2dollarskuscore767 = v1·ts + ...` and `v2uscore2dollarskuscore767 = A·ts + …`, together with safety conditions like `bvsgt xI1 (x1 + v1²/(2·B))`, `bvslt xI2 x2`, and bounds `0 ≤ v1 ≤ V`, `0 ≤ v2 ≤ V`, `A,B,V,ep > 0`.  \n\nThe outer implication requires that, for any non‑negative `ts2515uscore0` satisfying these bounds and the invariant “`?v_0` and `?v_1` stay within `[0,V]`”, the elapsed time `ts2515uscore0` plus a zero offset stays below `ep`.  The formula is therefore a safety‑property check: it asks whether there exists a time instant violating the guarded inequality, and the solver must return **unsat** to prove the intersection model safe.  \n\nNotable features are the mixture of signed‑comparison (`bvsge`, `bvsle`), signed division, and the use of a single existential quantifier inside a `not`, which together make the problem a challenging non‑linear BV verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node197625.smt2",
    "description": "The file is a single‑assertion SMT‑LIB‑2.6 benchmark in the **BV** logic, using 32‑bit bit‑vectors; it contains 19 declared constants and one quantified formula (an existential over the variable `ts924uscore0`).  \nIt originates from the KeYmaera verification suite (the “intersection‑example‑simple” proof node 197625) and was translated to bit‑vectors by Mathias Preiner, so it encodes a verification condition for a hybrid‑system model of a safe road intersection.  \nThe core of the assertion is a negated existential: it asks whether there exists a time‑step `ts924uscore0` that satisfies a conjunction of safety and physical‑law constraints such as non‑negative velocities (`v1`, `v2`, `V`, `A`, `B`), upper bounds (`v1 ≤ V`, `v2 ≤ V`), position updates (`xI1 > x1 + v1²/(2·B)`), and a safety horizon (`bvadd ts924uscore0 0 ≤ ep`).  \nKey arithmetic constraints involve non‑linear multiplication (`bvmul v1 v1`), signed division (`bvsdiv`), and signed comparisons (`bvsgt`, `bvsge`, `bvsle`), together with a disjunction that links the current position `xI2` to a stored value `x2uscore2dollarskuscore300`.  \nThe benchmark is intended to be **unsatisfiable** (the outer `not` makes the solver prove that no such `ts924uscore0` exists), thereby establishing the safety property of the intersection model; its relatively deep term nesting (depth 20) and mixture of non‑linear arithmetic make it a challenging industrial case for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node480617.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition produced by the KeYmaera hybrid‑systems prover for the “safe intersection” example described in Platzer et al. (2009).  The file contains 19 declared bit‑vector constants and a single, negated existential formula that quantifies over a time‑step variable `ts2284uscore0`.  The core of the condition is a large conjunction of signed arithmetic constraints describing two vehicles (variables `x1`, `x2`, `v1`, `v2`) moving with bounded speeds (`v1 ≤ V`, `v2 ≤ V`), non‑negative parameters (`A`, `B`, `V`, `ep`), and a safety predicate that the projected position of vehicle 1 (using the quadratic term `bvsdiv (bvmul v1 v1) (bvmul 2 B)`) stays ahead of vehicle 2.  The formula also contains case distinctions on integer flags (`I1`, `I2` equal to 2) and ensures that the computed intermediate value `?v_0 = -B*ts + v2` stays within `[0,V]` and that the total elapsed time stays below `ep`.  Proving the instance unsatisfiable shows that, under these bit‑vector‑approximated dynamics, no counterexample to the intersection safety property exists.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node250172.smt2",
    "description": "This benchmark is a 32‑bit Bit‑Vector (BV) instance (logic BV) of modest size (≈2.8 KB, 19 declared constants, one top‑level assertion) taken from the KeYmaera hybrid‑system verification suite and submitted to SMT‑LIB by Dejan Jovanović (Preiner translation). The formula asserts the negation of an existential condition over the time variable `ts1163uscore0`; proving the benchmark means showing that no assignment to this variable can satisfy the inner safety condition. The inner condition is a large implication whose antecedent collects a conjunction of signed‑comparison constraints on “state” variables such as velocities `v1`, `v2`, bounds `A`, `B`, `V`, a safety margin `ep`, and positional variables (`x1`, `x2`, `xI1`, `xI2`), together with arithmetic relations using signed multiplication, addition, subtraction and a division (`bvsdiv`). The consequent is a disjunction that either equates two position terms or, assuming a non‑negative time bound `t1163uscore0`, enforces further bounds on a linear expression `?v_0 = -B*ts1163uscore0 + v1uscore3dollarskuscore229` together with the trivial equality `0 = 2` or the flag `I2uscore3dollarskuscore229 = 2`. Hence the benchmark checks whether the hybrid‑system verification condition for a simple safe‑intersection scenario is universally valid, exercising non‑linear arithmetic over bit‑vectors and mixed signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node11136.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) taken from the KeYmaera hybrid‑system verification suite, specifically the “intersection‑example‑onelane” proof node 11136, and was translated to bit‑vectors by Mathias Preiner (size ≈ 2.4 KB, 13 declared constants, a single top‑level assertion).  \nThe formula asserts the **negation of an existential** over the time variable `ts23uscore1`; in other words it checks that *no* concrete valuation of the variables can satisfy a conjunction of linear arithmetic constraints derived from the safety conditions of a one‑lane traffic‑intersection model.  \nThe constraints are expressed with signed 32‑bit comparisons (`bvsle`, `bvsge`, `bvslt`, `bvsgt`) and arithmetic (`bvadd`, `bvmul`, `bvneg`) and enforce: non‑negativity of all physical quantities (time, positions `xI`, `x`, velocities `v`, upper bounds `V`, parameters `A`, `B`, `ep`); ordering relations such as `xI < x` and `xI < xuscore2dollarskuscore27`; bounds on a derived term `(-B * ts23uscore1 + vuscore2dollarskuscore33)` to stay within `[0, V]`; and a final inequality `(-B * t38uscore0dollarskuscore1 + vuscore2dollarskuscore33) ≤ V`.  \nThe benchmark thus encodes a safety‑property check for the hybrid system: it is unsatisfiable iff the original continuous‑time verification condition holds, making it a representative industrial case with moderate term depth (23) and a rich mix of relational and arithmetic bit‑vector operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347928.smt2",
    "description": "The file is a 2.6‑SMT‑LIB benchmark in the **BV** logic (32‑bit signed bit‑vectors) with 19 declared constants, one large conjunctive assertion and a total size of about 2.9 KB.  It originates from the Keymaera hybrid‑systems verifier (intersection‑example‑simple.proof, node 347928) and was translated to bit‑vectors by Mathias Preiner for the Preiner‑keymaera industrial benchmark suite.  The core formula is the negation of an existential quantifier over the time variable `ts1621uscore0`, together with a `let` that defines two auxiliary expressions (`?v_0 = 2·B` and `?v_1 = –2·B·ts1621uscore0 + v1_231`).  Inside the quantified part a large conjunction encodes safety conditions for two moving objects (variables `v1`, `v2`, `V`, `A`, `B`, `x1`, `x2`, `xI1`, `xI2`, …), requiring non‑negative velocities, upper bounds (`v1, v2 ≤ V`), positive parameters (`V, ep > 0`), and that the future positions (`xI1`, `xI2`) exceed their current positions plus a term involving `v1²`/`?v_0` and `v2²`/`?v_0`.  A secondary implication enforces that, if `t1621uscore0 ≥ 0`, then `ts1621uscore0` lies between 0 and `t1621uscore0`, the auxiliary term `?v_1` stays within `[0,V]`, and the overall time budget (`ts1621uscore0 + 0 ≤ ep`) holds, finally branching on the Boolean `(= 0 2) ∨ (= I2_231 2)`.  Thus the benchmark checks that, under the given linear and non‑linear (multiplication/division) constraints, the existential time choice cannot violate the safety invariant of the intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node271565.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (SMT‑LIB 2.6, logic BV) taken from the **KeYmaera** hybrid‑system verification suite, specifically the “intersection‑example‑simple” proof node 271565 that models a safe traffic‑intersection scenario.  The file declares 19 32‑bit constants (e.g., A, B, V, ep) and contains a single top‑level assertion that **negates an existential query** over a time‑stamp variable `ts1266uscore0`; the solver must therefore show the query is unsatisfiable, i.e., that the safety condition holds for all admissible values.  The quantified condition is a conjunction of signed inequalities (`bvslt`, `bvsle`, `bvsge`, `bvsgt`) together with linear and non‑linear bit‑vector arithmetic (`bvadd`, `bvmul`, `bvsdiv`, `bvneg`), expressing bounds on positions (`x1`, `x2`), velocities (`v1`, `v2`), and parameters (`A`, `B`, `V`, `ep`).  A key sub‑expression `?v_0 = bvadd (bvmul (bvmul (bvneg 1) B) ts1266uscore0) v2uscore3dollarskuscore328` captures a reachable‑state constraint that must stay within `[0,V]`.  The benchmark is relatively small (≈2.8 KB, max term depth 19) but is notable for mixing quantified reasoning with signed bit‑vector multiplication and division, making it a challenging industrial case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node674535.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) from the Preiner‑Keymaera family, originally derived from the KeYmaera proof “intersection‑example‑simple” (node 674535) and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial verification problem and contains 18 declared constants, a single quantified assertion and roughly 2.8 KB of text.  \n\nThe formula asserts the *negation* of an existential statement over a time variable `ts3215uscore0`, i.e. it tries to prove that no valuation of this time can violate the safety condition encoded inside the let‑expression.  \n\nThe safety condition captures a hybrid‑system collision‑avoidance proof: under non‑negative parameters (`A`, `B`, `V`, `v1`, `v2`, `ep` > 0) and bounds (`v1`,`v2` ≤ `V`, `A` ≥ 0), the positions `xI1` and `xI2` must stay ahead of the brake‑distance estimates `x1 + v1²/(2·B)` and `x2 + v2²/(2·B)`.  \n\nAdditional constraints tie the auxiliary integer flags `I1`, `I2`, `I1uscore4dollarskuscore771`, `I2uscore4dollarskuscore771` to specific constant values (mostly 2 or 0) and require the time variable to lie between 0 and a given horizon `t3215uscore0`, while also respecting the overall deadline `ep`.  \n\nThus the instance checks, via bit‑vector arithmetic (including multiplication and signed division), whether the encoded safety invariant holds for all admissible times; a SAT result would indicate a counter‑example, whereas UNSAT confirms the verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node459232.smt2",
    "description": "The file is a single‑query SMT‑LIB 2.6 benchmark in the **BV** logic (32‑bit bit‑vectors), taken from the Preiner‑keymaera family of industrial‑style verification problems that originate from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node). It encodes a safety condition for a simple traffic‑intersection hybrid model: two cars i₁ and i₂ start at positions xI₁, xI₂ (both strictly before the intersection points x₁, x₂) with non‑negative velocities v₁, v₂ bounded by a global speed limit V, and the dynamics are linear v₁ = A·t + v₁₀, v₂ = ‑B·t + v₂₀ where A, B > 0. The core of the problem is the quantified formula  \n\n```\n¬∃ ts ≥ 0 . ( … ⇒ ( … ⇒ ( safety(ts) ∧ (0 = 2 ∨ I2 = 2) ) ) )\n```  \n\nwhere *safety(ts)* requires both computed velocities to stay within [0,V] and the elapsed time ts plus a zero‑offset to remain below a positive horizon ep. The benchmark therefore asks whether **any** non‑negative time step can violate these bounds; satisfiability would exhibit a counterexample to the safety proof. It is a relatively small instance (≈2.6 KB, 18 declared constants, depth 19) that features non‑linear bit‑vector multiplication, several relational constraints (bvslt, bvsle, bvsgt, bvsge), and a nested let‑binding, making it a typical challenge for SMT solvers handling quantified bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384691.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it was originally a safety proof for a simple traffic‑intersection model and was translated to bit‑vectors by Mathias Preiner (≈2.8 KB, 18 declared constants, a single large assertion).  \n\nIt encodes a verification condition that asserts the **negation of an existential safety violation**: there must be no time `t` (`ts1794uscore0`) for which the post‑state of the two cars (variables `xI1`, `xI2`) violates the separation constraints derived from their initial positions (`x1`, `x2`), velocities (`v1`, `v2`), and braking/acceleration parameters (`A`, `B`).  \n\nThe formula enforces a collection of physical‐like bounds: all parameters (`A`, `B`, `V`, `ep`) are non‑negative with `V>0` and `ep>0`; velocities lie in `[0,V]`; the stopping distance terms `bvsdiv(bvmul v v, 2*B)` appear in the expressions `bvadd x (bvsdiv (bvmul v v) ?v_0)`.  Additional equalities fix the mode identifiers (`I1`, `I2`) to specific values (0,2) and relate auxiliary constants (`I1uscore4dollarskuscore398`, `I2uscore4dollarskuscore398`).  \n\nThus the instance checks whether, under these linear and non‑linear (quadratic/division) constraints, the cars can ever get too close before the deadline `ep`; the solver must prove the negated existential is unsatisfiable, i.e., that the safety property holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node57081.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (BV logic) taken from the **Keymaera** hybrid‑systems verification suite; it originates from the “intersection‑example‑simple” proof (node 57081) used in the Jovanović & de Moura IJCAR‑2012 paper and was translated to bit‑vectors by Mathias Preiner.  It declares 19 32‑bit constants that model integer parameters of a traffic‑intersection hybrid system (e.g., velocities v₁, v₂, bounds V, time‑step ep, and coefficients A, B).  The single top‑level assertion is a negated existential formula over a time variable ts₍₂₅₉₎, asserting that **no** choice of ts₍₂₅₉₎ can satisfy a conjunction of safety conditions such as positivity of all parameters, ordering of positions (xI₁ < x₁, xI₂ < x₂), and that the linearly‑updated state variables  \n ?v₀ = A·ts₍₂₅₉₎ + v₁′ and ?v₁ = −B·ts₍₂₅₉₎ + v₂′  \nstay within the interval [0, V] while the elapsed time stays below ep.  \nThe formula also encodes a branch condition “I₁ = 2 ∨ 1 = 2” (effectively forcing I₁ = 2) and checks that the system respects the invariant bvsge t259uscore0 0 before the safety constraints are applied.  \nThus the instance asks the solver to prove that, under the given linear dynamics and initial bounds, the safety invariant is inductive—i.e., the negated existential is unsatisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node384936.smt2",
    "description": "This benchmark is a 32‑bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑systems prover, specifically the “intersection‑example‑simple” safety proof (node 384936) used in the IJCAR 2012 and ITSC 2011 papers.  The file contains 19 bit‑vector constants and a single quantified assertion (∃ ts1795₀) that captures the reachable‑state condition of two moving objects (variables xI1, xI2, v1, v2) crossing an intersection under bounds A, B, V and a time‑limit ep.  The antecedent encodes a collection of pre‑conditions: non‑negative parameters, upper bounds (v1,v2 ≤ V), positivity of A, B, V, ep, and nonlinear relationships such as  \n xI1 > x1 + (v1·v1)/(2·B) and xI2 > x2 + (v2·v2)/(2·B),  \nwhere the division is performed with signed‑bit‑vector division after the product bvmul.  \nThe consequent asserts that if the elapsed time t1795₀ is non‑negative, then the elapsed time plus a zero offset stays within the deadline ep, and that either I1 = 2 or the constant 0 equals 2 (the latter being unsatisfiable, so the whole implication reduces to the safety property).  \nThus the instance checks that, under the given initial bounds, the safety condition of the intersection cannot be violated; the problem is notable for translating non‑linear real arithmetic into fixed‑size bit‑vectors and for its relatively deep term nesting (depth 20) despite having only one top‑level assertion.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node25171.smt2",
    "description": "The benchmark is a **BV‑logic** (32‑bit bit‑vector) instance of size 2 472 characters, contributed by Dejan Jovanovic and translated to bit‑vectors by Mathias Preiner.  It originates from the **KeYmaera** hybrid‑systems verifier (intersection‑example‑onelane.proof, node 25171) and appears in the IJCAR 2012 paper on non‑linear arithmetic.  \n\nThe single assertion negates an **existential query** over a time variable `ts57uscore0`, encoding a safety verification condition that must hold for all reachable states of a one‑lane traffic‑intersection model.  The formula ties together linear and **non‑linear constraints** on positions (`xI`, `x`), velocities (`v`, `V`, `vuscore2dollarskuscore88`), and parameters (`A`, `B`, `ep`), using arithmetic such as `bvmul`, `bvsdiv`, and quadratic terms (`vuscore2dollarskuscore88*vuscore2dollarskuscore88`).  \n\nKey properties enforced include:  \n* all variables lie within non‑negative bounds and upper limits (`V`, `ep`),  \n* a relationship `xI > x + (vuscore2dollarskuscore88²) / (2·B)` expressing a safety distance,  \n* temporal bounds `0 ≤ ts57uscore0 ≤ t101uscore0dollarskuscore0`, and  \n* consistency of auxiliary counters (`I1 = 2`, `I1uscore2dollarskuscore80 = 0`).  \n\nThus the instance checks whether the hybrid‑system’s safety invariant is violated for any admissible time instant, and the use of bit‑vectors makes the originally real‑valued non‑linear arithmetic problem amenable to SAT‑based SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node347403.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a safety verification condition generated by the KeYmaera hybrid‑system prover; it originates from the “intersection‑example‑simple” proof node 347403 described in the IJCAR 2012 and ITSC 2011 papers and was translated to bit‑vectors by Mathias Preiner.  \nThe file contains a single, large assertion that negates an existential quantifier over a time‑stamp variable `ts1618_0`; inside the quantifier a `let` introduces four auxiliary terms that combine parameters `A`, `B`, `v1`, `v2` with the quantified time using multiplication, addition and signed division.  \nThe core of the condition is a chain of implications stating that, assuming non‑negative parameters (`A`, `B`, `V`, `ep`) and bounded velocities (`0 ≤ v1,v2 ≤ V`), the computed positions `xI1` and `xI2` must stay ahead of the current positions `x1`, `x2` by at least the quadratic terms `v1²/(2·B)` and `v2²/(2·B)`.  \nAdditional constraints enforce that the time variables are non‑negative and that the elapsed time (`ts1618_0`) does not exceed the deadline `ep`, while also fixing the indices `I1` and `I2` to the constant 2.  \nThus the instance checks that a bounded‑velocity vehicle model can never violate a safety distance before a given deadline, using a non‑linear arithmetic property encoded entirely with bit‑vector arithmetic; it is relatively large (≈2.8 kB, depth 19) and contains a single quantified assertion with many conjuncts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/dccs-example-simple-node6246.smt2",
    "description": "This benchmark is a bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑system prover for the “adaptive cruise control” example (node 6246 of the dccs‑example‑simple family).  It declares twelve 32‑bit unsigned variables that model the two cars’ positions ( x1, x2 ), velocities ( v1, v2 ), a braking parameter B, an acceleration bound A, a reaction‑time constant eps, and several auxiliary time terms ( t4, ts4 ).  The single top‑level assertion states the negation of an existential claim: there must exist a time ts4 within the interval [0, t4] such that a long chain of safety premises holds (non‑negativity of all variables, ordering x1 < x2, v1 ≤ v2, and bounds on the motion given by linear updates using A and eps).  Under these premises the benchmark checks a disjunction of two safety guarantees: either the leading car’s velocity is already zero or, after accelerating for eps, its velocity stays ≤ v2, **or** a quadratic inequality involving B, t4, v1, x1, v2, x2 holds, which corresponds to the usual distance‑after‑braking condition.  The file originates from the 2012 IJCAR “Solving Non‑Linear Arithmetic” paper, was translated to bit‑vectors by Mathias Preiner, and has a modest size (≈2.6 KB, 13 “and” nodes, max term depth 20).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node189374.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition extracted from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” safety proof (node 189374).  It originates from the industrial‑style non‑linear arithmetic suite of Jovanović & de Moura (IJCAR 2012) and was translated to bit‑vectors by Mathias Preiner, giving a single large quantified assertion of size ≈ 2.7 KB with 18 declared constants.  The formula asserts the negation of an existentially quantified time‑step variable ts880₀ under a conjunction of linear and non‑linear BV constraints that model vehicle dynamics (e.g., v₁² / (2·B) and A·ts) and safety bounds such as non‑negative accelerations, speed limits V, and positional ordering (xI₁ > x₁ + v₁²/(2·B), xI₂ < x₂).  Key properties checked are that, for all admissible parameters (A ≥ 0, B > 0, velocities within [0,V]), the reachable positions after a time step remain within the allowed interval and do not violate the intersection safety condition.  The instance showcases a heavily nested BV arithmetic VC with many signed‑comparison operators (bvsge, bvsle, bvsgt, bvslt) and a mixture of multiplication, addition, and signed division, making it a typical challenging case for BV solvers handling non‑linear reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node192767.smt2",
    "description": "The file is a 32‑bit‑vector (BV) benchmark (logic BV) taken from the KeYmaera hybrid‑system verification suite; it originates from the “intersection‑example‑simple” proof node 192767 used in the safety‑intersection case study.  It contains 19 declared bit‑vector constants (e.g., A, B, V, x1, x2, v1, v2, etc.) and a single, large, quantified assertion that negates an existential over the time‑step variable ts896uscore0.  The assertion encodes a safety condition: given non‑negative parameters A, B, V, ep and initial states (I1 = I2 = 2), the vehicle positions xI1, xI2 must stay within bounds defined by quadratic expressions (bvmul v1 v1) and linear updates (bvadd, bvsdiv), while all intermediate quantities remain within the interval [0,V].  The constraint set mixes signed comparisons (bvsge, bvsle, bvsgt, bvslt), arithmetic (addition, multiplication, negation, signed division), and a disjunction that either equates xI2 with a fresh variable x2uscore2dollarskuscore288 or forces a bounded evolution of ts896uscore0.  As an industrial‑style benchmark, it is relatively compact (≈2.8 KB, max term depth 20) but features non‑linear arithmetic encoded as bit‑vector operations, making it a challenging case for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node388939.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size ≈ 2.9 KB (19 declared constants, one large quantified assertion) taken from the KeYmaera hybrid‑system verification suite and translated to BV by Mathias Preiner. It encodes a safety verification condition for a simple traffic‑intersection scenario, where the constants `v1`, `v2` model vehicle speeds, `A`, `B`, `V` and `ep` are non‑negative parameters, and `I1`, `I2` are mode‑identifiers. The core of the formula is a negated existential (`not (exists ts …)`) stating that there is **no** time value `ts1815uscore0` (bounded between 0 and `t1815uscore0`) for which a set of nonlinear inequalities can be simultaneously satisfied; these inequalities involve quadratic terms (`v1*v1`, `v2*v2`) divided by the linear expression `A*ts + 2*B`, and they enforce that the resulting positions (`xI1`, `xI2`) stay beyond the current positions plus the computed travel distances while all variables remain within the bounds `[0,V]`. The assertion also requires strict positivity of `V` and `ep`, and includes a disjunction linking the mode identifiers (`I1 = 2` or `I2 = 2`). Altogether the instance tests the solver’s ability to handle non‑linear arithmetic, division, and quantified reasoning over 32‑bit bit‑vectors in an industrial‑style verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node620306.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑system verifier, namely the “intersection‑example‑simple” proof node 620306 that models a safe traffic‑intersection scenario.  The file contains 19 declared bit‑vector constants (variables such as v1, v2, A, B, V, ep, and several indexed copies) and a single, large quantified assertion: it negates an ∃ ts2965uscore0 . … formula that combines non‑linear arithmetic (quadratic terms v1·v1, v2·v2, a multiplication by 2·B) with linear bounds on positions x1, x2, xI1, xI2, velocities and safety parameters.  The core constraints enforce that the two vehicles’ positions after a time step stay ahead of their current positions (bvsgt xI1 …, xI2 …), that the velocities are non‑negative and bounded by a maximum V, that the road‑width B and safety margin ep are positive, and that a guard variable I1 (set to 2) selects the relevant branch of the proof.  The outermost “not (exists …)” turns the condition into a safety proof obligation: the solver must show the existential witness cannot exist, i.e., the conjunction of inequalities is unsatisfiable.  With a term depth of 20 and 2 876 characters, the instance is representative of industrial‑scale non‑linear arithmetic benchmarks that have been translated into bit‑vector arithmetic for SMT solving.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node391142.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (SMT‑LIB logic **BV**) of a verification condition generated by the hybrid‑system prover **KeYmaera** for the “safe intersection” example described in Loos & Platzer (ITSC 2011).  The file (2785 bytes, 1 assert, 18 declared constants) comes from the Preiner‑Keymaera suite (industrial category) and originates from the paper *Solving Non‑Linear Arithmetic* (Jovanović & de Moura, IJCAR 2012).  \n\nThe single assertion is the negation of an existential formula over a time‑step variable `ts1828_0`; the body of the existential quantifier is a large conjunction of arithmetic relations between the 32‑bit variables that model vehicle speeds (`v1`, `v2`), positions (`x1`, `x2`, `xI1`, `xI2`), maximal speed `V`, and constants `A`, `B`, `ep`.  The constraints enforce non‑negative speeds, upper bounds by `V`, positive acceleration parameters, and safety inequalities such as  \n`xI1 > x1 + (v1·v1) / (2·B – 2·B·ts)` and the analogous condition for `xI2`, which express that the vehicles can stop before the intersection.  \n\nThe outer implication additionally requires that for any admissible timestamps `0 ≤ ts ≤ t` the computed intermediate distance `?v_1` stays within `[0, V]` and that the overall time horizon `t` does not exceed the deadline `ep`.  Hence the problem checks whether the safety condition holds for all possible time steps; the solver must prove that the existential witness cannot exist.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node385140.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition extracted from the KeYmaera hybrid‑system prover, specifically the “intersection‑example‑simple” safety proof (node 385140).  It belongs to the Preiner‑keymaera family, is classified as industrial, and contains a single large assertion (≈ 3 KB, 20 declared constants, max term depth 21).  The formula asserts the negation of an existential condition over a time stamp `ts1796_0`, where the body is a conjunction of arithmetic‑like constraints that model non‑negative positions, velocities (`v1`, `v2`) bounded by a maximum speed `V`, and quadratic distance terms expressed with `bvmul` and `bvsdiv` (e.g., `bvsdiv (bvmul v1 v1) (…)`).  Safety is encoded by requiring the current positions (`xI1`, `xI2`) to stay ahead of the predicted positions (`x1 + v1²/…`, `x2 + v2²/…`) and by enforcing positivity of parameters such as `A`, `B`, `V`, and `ep`.  The overall structure is a classic “prove‑unsat” query: if the negated existential is unsatisfiable, the original safety property holds for the modeled intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-onelane.proof-node51016.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formulation (logic BV) of a safety proof obligation generated by the KeYmaera hybrid‑system verifier for the “intersection‑example‑onelane” case study (node 51016).  It contains 13 declared 32‑bit variables (e.g., positions x, xI, velocities v, vuscore4$, constants A, B, V, ep) and a single, large assertion that is the negation of an existential quantifier over the time‑step variable ts105$.  The quantified body is a conjunction of many linear and non‑linear inequalities (bvsle, bvsgt, bvsge) that enforce bounds such as non‑negativity, upper limits (≤ V), and relationships like B > 0, v ≥ 0, and the safety condition that the vehicle’s position xI stays ahead of a computed expression involving A, B, ep, v, and other parameters.  The core property being checked is that **no** time step exists that violates these safety constraints, i.e., the system never reaches an unsafe configuration at the intersection.  Because the original non‑linear arithmetic proof was translated to bit‑vectors, the instance stresses SMT solvers with nested lets, mixed multiplication/division, and deep term nesting (max depth 25), making it a notable industrial benchmark for non‑linear arithmetic handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node476004.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector instance (logic BV) taken from the KeYmaera hybrid‑systems verification suite; it appears in the Jovanović‑de Moura “Solving Non‑Linear Arithmetic” paper and was translated to bit‑vectors by Mathias Preiner (≈2.7 KB, 18 declared constants, one quantified assertion). The formula asserts the **negation of an existential property** over a time variable `ts2256uscore0`, thereby checking that a certain safety condition for a traffic‑intersection scenario is unsatisfiable. The core constraints encode physical relations such as non‑negativity of parameters (`A`, `B`, `V`, `v1`, `v2`), bounds on velocities (`0 ≤ v1,v2 ≤ V`), a kinematic inequality `xI1 > x1 + v1²/(2·B)`, a distance ordering `xI2 < x2`, and a linear update `?v_0 = A·ts + v2`. These are combined in a nested implication that also enforces `0 ≤ ts ≤ t` and that the updated value stays within `[0,V]`, with a final disjunction handling a degenerate case (`ts = 2` or `I2 = 2`). The benchmark is characteristic for its use of signed‑bit‑vector arithmetic to model real‑valued nonlinear constraints, a single quantified existential, and a deep term structure (max depth 21).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605258.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition from the KeYmaera hybrid‑systems prover, originating from the “safe‑intersection” example of Platzer et al. (ITSC 2011) and translated by Mathias Preiner for the 2017 Preiner‑keymaera family.  The single assertion asserts the negation of an existential query over a time variable `ts2880uscore0`; the query checks whether, under a large conjunction of linear arithmetic constraints on velocities (`v1`, `v2`), accelerations (`A`), braking distance (`B`), safety margin (`ep`) and position variables (`x1`, `x2`, `xI1`, `xI2`), a derived expression `A*ts + v2uscore3dollarskuscore789` can leave the admissible interval [0, V] or exceed the deadline `ep`.  The conjuncts enforce non‑negativity of all physical parameters, fixed integer indices (`I1 = I2 = 2`), a safety ordering `xI1 < x1` and a collision‑avoidance condition `xI2 > x2 + v2²/(2·B)`, as well as the usual bounds `v1, v2 ≤ V`.  Satisfiability of the negated exists thus proves that no time instant violates the safety invariant, i.e., the intersection controller is safe.  The instance is relatively small (≈2.8 KB, 19 declared constants, depth 20) but mixes signed bit‑vector arithmetic, division, and a quantifier, making it a representative industrial benchmark for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632840.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the KeYmaera safe‑intersection case study (see Loos & Platzer 2011) and submitted by Dejan Jovanović; it contains 19 declared constants, a single top‑level assertion and has a size of 2 851 nodes, placing it in the “industrial” category of the Preiner‑keymaera family.  \nThe sole assertion is a negated existential formula `(not (exists ((ts3026uscore0 (_ BitVec 32))) …))` in which a `let` introduces auxiliary terms (e.g. `?v_0 = 2·B`, `?v_1 = –B·ts + v1uscore…`, `?v_2 = A·ts + v2uscore…`).  \nWithin the quantified body a large conjunction ties together equalities (e.g. `xI2 = x2uscore…`, `I1 = 2`, `I2uscore… = 2`) and non‑linear arithmetic such as the squares `bvmul v1 v1` and `bvmul v2 v2` scaled by `?v_0`, together with linear terms `bvmul A ts`, `bvmul B ts`.  \nAll variables are constrained to be non‑negative (`bvsge … 0`) and bounded above by a common limit `V` (`bvsle … V`); the time variable `ts3026uscore0` is required to lie between 0 and `t3026uscore0` and to satisfy `ts + 0 ≤ ep`.  \nThus the instance encodes a hybrid‑system safety condition (the “intersection” verification condition) as a highly non‑linear bit‑vector formula that mixes multiplication, signed division, and many inequality bounds, making it a challenging industrial verification benchmark.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node287705.smt2",
    "description": "This benchmark is a bit‑vector encoding (BV, 32‑bit words) of a verification condition coming from the KeYmaera hybrid‑system proof “intersection‑example‑simple” (node 287705), originally used to show safety of vehicle intersections.  The file contains a single large quantified assertion: it asserts the negation of an existential search for a time stamp *ts* such that a number of linear and non‑linear constraints hold, which means the solver is asked to prove that no such *ts* exists.  The constraints model a simple kinematic scenario: non‑negative variables v₁, v₂, A, B, V, ep are bounded by a common upper limit V, the accelerations A and B are positive, and the positions satisfy xI₁ = x₁, xI₂ > x₂ + v₂²/(2·B); additionally a derived velocity ?v₀ = A·ts + v₁ must stay within [0,V] while *ts* ranges between 0 and a given horizon t₁₃₄₀.  The formula also fixes several index variables (I1, I2, I1₍₄₀₀₎, I2₍₄₀₀₎) to the constant 2, mimicking mode indices of the hybrid automaton.  It is an industrial‑style benchmark (≈2.9 kB, 20 declared bit‑vectors, max term depth 21) that exercises non‑linear arithmetic on bit‑vectors, mixed quantifiers, and arithmetic comparisons within an SMT solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node8746.smt2",
    "description": "This benchmark is a single‑assertion, 32‑bit bit‑vector (BV) problem in the industrial *Preiner‑keymaera* family, originally derived from a KeYmaera verification condition for the “binary_driver” example (node 8746) and translated to BV by Mathias Preiner. The assertion is the negation of an existential formula that quantifies a fresh time‑step variable `ts1_1` and then checks a long conjunction of arithmetic constraints on fifteen declared constants such as `amax`, `b`, `v`, `d`, `m`, `z`, `ep`, and several auxiliary terms (`vuscore…`, `duscore…`, etc.). These constraints encode non‑linear relationships (quadratic terms, products of variables, and divisions) together with simple bounds (e.g., all variables ≥ 0, `b>0`, `ep>0`, `amax>0`) and a safety‑invariant inequality that mixes the terms (essentially a bound on a combination of kinetic‑like and control‑like quantities). By asserting the negation, the solver is asked to prove that **no** value of `ts1_1` can satisfy the invariant, i.e., that the safety condition holds for all reachable states of the driver model. The instance is relatively large (≈ 2.7 KB, 15 constants, max term depth 22) and typifies the non‑linear arithmetic challenges that arise when real‑valued hybrid‑system proofs are encoded as fixed‑width bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node561079.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the **KeYmaera** hybrid‑systems verification suite; it appears in the “intersection‑example‑simple” proof node (node 561079) and was translated to bit‑vectors by Mathias Preiner.  It contains 19 constant declarations and a single, large quantified assertion (¬∃ ts2674₀ · …) whose body is a conjunction of linear and non‑linear (bvmul) arithmetic constraints that model safety conditions for two vehicles approaching an intersection (variables such as v1, v2, A, B, x1, x2, I1, I2, ep, V).  The constraints enforce non‑negativity and upper bounds (e.g., 0 ≤ v1 ≤ V, 0 ≤ v2 ≤ V, B > 0, V > 0, ep > 0), ordering of positions (xI1 < x1, xI2 > x2 + v2²/(2·B)), and a derived linear expression ?v_0 = ‑B·ts + v2₅₈₅ that must stay within [0,V].  The outer implication also requires the time variable t2674₀ to be non‑negative and that a trivial arithmetic tautology (1 = 2 ∨ I2₅₈₅ = 2) holds, reflecting the original proof‑obligation’s case split.  With a size of 2 820 characters, a maximum term depth of 20 and a moderate number of Boolean connectives (≈20 and‑nodes), the benchmark is representative of industrial non‑linear arithmetic problems encoded for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node548891.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) encoding of a verification condition taken from the KeYmaera hybrid‑systems prover, specifically the “intersection‑example‑simple” proof node 548891 used in the safe‑intersection case study.  It belongs to the industrial Preiner‑keymaera family, contains 19 declared constants, one large quantified assertion, and about 2.8 kB of SMT‑LIB text (max term depth 20).  The formula asserts the negation of an existential claim over a time variable `ts2615uscore0`; the inner condition couples several signed comparisons on velocities (`v1`, `v2`), positions (`x1`, `x2`), and parameters (`A`, `B`, `V`, `ep`) with non‑linear arithmetic such as `bvmul`, `bvsdiv` and a quadratic term `bvmul v2 v2`.  The constraints encode safety requirements like “the vehicle speeds stay between 0 and a global bound V”, “the distance to the intersection remains positive”, and “the braking distance derived from v2²/(2·B) is respected”.  Because the original real‑valued arithmetic is translated to 32‑bit two’s‑complement bit‑vectors, the problem tests solvers’ ability to handle mixed signed comparisons, overflow‑prone multiplication, and division in a non‑linear, quantified setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli.proof-node2282.smt2",
    "description": "The benchmark is a 3 240‑byte BV‑logic instance (logic BV, 15 declared 32‑bit bit‑vectors) taken from the KeYmaera verification suite (vsli.proof, node 2282) and translated to bit‑vectors by Mathias Preiner; it is classified as an industrial problem in the Preiner‑keymaera family.  It consists of a single quantified formula that asserts the *non‑existence* of a time‑step variable ts0 satisfying a large conjunction of linear and non‑linear bit‑vector constraints.  The constraints bind the variables through many multiplications, additions, subtractions and divisions (e.g., v1², (vmin·vmin), (bvneg B·t₁), (bvsdiv A B)), and impose ordering relations such as 0 ≤ ts0 ≤ t₁, vsl₃ ≥ vmin, xsl₃ ≤ xᵢ, xsl₃ ≤ (bvadd …) and strict inequalities like (bvadd x₁ (bvmul …)) < (bvsub xᵢ D).  Additional global bounds require A, B, ep, D, vmin, vi to be non‑negative (in fact > 0 for B, ep, vmin) and tie together auxiliary expressions defined by two nested let‑bindings.  The overall goal is to check that under these arithmetic and ordering conditions the existential witness for ts0 cannot exist, i.e., the verification condition is unsatisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/binary_driver-2007-10-09-node11384.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector formula (logic BV) from the Preiner‑keymaera industrial suite, originally derived from a KeYmaera hybrid‑system verification condition (binary_driver‑2007‑10‑09, node 11384) and translated to bit‑vectors by Mathias Preiner (size ≈ 2.5 KB, 15 declared constants, one top‑level assertion).  \nIt asserts the negation of an existential property over a time variable `ts4uscore1`, i.e., it asks whether there exists a valuation that violates a large conjunction of safety constraints; the outer `not` turns the problem into a SAT query for a counterexample.  \nThe conjunctive core mixes linear bounds (e.g., `bvsle`, `bvsge`, `bvsgt`) with several non‑linear quadratic relations such as `bvmul vuscore2dollarskuscore6 vuscore2dollarskuscore6 – bvmul duscore2dollarskuscore6 duscore2dollarskuscore6 ≤ 2*b*(m‑z)` and `bvmul v v – bvmul d d ≤ 2*b*(m‑z)`.  \nAll variables are 32‑bit bit‑vectors, and the formula uses a single `let` to store the common sub‑expression `2*b` (`?v_0`) and the negated coefficient `‑b` (`?v_1`), keeping the term depth at 21.  \nThus the instance tests SMT solvers on combined linear and non‑linear arithmetic in the bit‑vector domain, with a relatively deep nesting of arithmetic and comparison operators typical of translated hybrid‑system verification conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node361987.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 19 declared 32‑bit bit‑vector constants, 1 quantified assertion, 1 828 term nodes, max depth 21) taken from the **Preiner‑keymaera** industrial family.  \nIt encodes a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (intersection‑example‑simple.proof, node 361987).  \nThe core of the formula is a negated existential over a time variable `ts1684uscore0`; the body contains a large conjunction of non‑linear arithmetic constraints expressed with bit‑vector multiplication, addition, and signed division, modelling relations such as  \n`xI1 > x1 + (v1·v1)/(2·B)`, `xI2 > x2 + (v2·v2)/(2·B)`, non‑negative speeds (`v1,v2≥0`), bounds (`v1,v2 ≤ V`), and positivity of parameters (`A,B,V,ep > 0`).  \nAdditional constraints enforce that the computed positions `?v_1` and `?v_3` stay within `[0,V]` and that the elapsed time does not exceed the deadline `ep`.  \nThus the benchmark checks whether the safety invariant “both cars remain inside the intersection bounds and respect the timing deadline” holds for all admissible time steps; the SAT result determines the validity of the original hybrid‑system proof obligation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node478879.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) taken from the KeYmaera hybrid‑system verification suite; it was extracted from the “intersection‑example‑simple” proof node 478879 and translated to bit‑vectors by Mathias Preiner (see the IJCAR 2012 and CADE 2009 references).  \nIts single assertion is the negation of an existential formula, i.e. it checks that no value of the time‑step variable `ts776uscore0` can satisfy a conjunction of safety‑related constraints, thereby encoding a safety‑property verification condition.  \nThe constraints model two cars (`v1`, `v2`) with non‑negative speeds bounded by a maximum speed `V`, a braking deceleration `B>0`, an acceleration bound `A≥0`, and an epsilon time `ep>0`; they also relate positions (`x1`, `x2`, `xI1`, `xI2`) through inequalities such as  \n`xI1 > x1 + (v1·v1)/(2·B)` and `xI2 < x2`, which capture that the first car must be able to stop before the intersection while the second is still behind.  \nAdditional side conditions ensure that the intermediate velocity `?v_0 = A·ts + v2uscore2dollarskuscore531` stays within `[0,V]` and that the time variable stays in `[0, t776uscore0]`.  \nThe benchmark is notable for mixing linear and non‑linear bit‑vector arithmetic (multiplication, signed division) and for its relatively deep term structure (depth 20) while remaining a single‑assertion industrial verification case.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/vsli-alert.proof-node2416.smt2",
    "description": "The file is a single‑assertion benchmark in the **BV** (fixed‑size bit‑vector) logic, originating from the Keymaera hybrid‑systems verification suite (see Jovanović & de Moura 2012) and translated to 32‑bit vectors by Mathias Preiner; it is classified as an industrial‑category instance and contains 14 declared constants, 1 quantified assertion and about 2.8 KB of text (max term depth 26).  \n\nThe core of the formula is a negated existential over a time variable `ts0uscore0`, inside which a large implication relates many signed‑comparison constraints on linear, quadratic and division expressions built from the constants `A`, `B`, `D`, `ep`, `vi`, `vmin` and the state variables `x…`, `v…`.  \n\nThe conjuncts enforce basic safety hypotheses – all parameters are non‑negative (e.g. `bvsgt B 0`, `bvsge vi 0`), velocities and a minimum speed `vmin` are bounded below, and the “alerted” flag must stay zero – together with arithmetic relationships that model the continuous dynamics (e.g. `bvadd (bvmul ?v_5 ts0uscore0) v1uscore2dollarskuscore0 ≥ vmin`).  \n\nKey non‑linearities appear through terms such as `v1uscore2dollarskuscore0 * v1uscore2dollarskuscore0` and divisions like `bvsdiv (bvsub ?v_0 (bvmul vmin vmin)) (bvmul 2 B)`, which are encoded in bit‑vector arithmetic, making the instance a representative challenge for solvers that must handle mixed linear/non‑linear arithmetic on fixed‑width words.  \n\nOverall, the benchmark checks whether the encoded safety condition holds for any possible start time, and its negated form forces the solver to refute the existence of a counter‑example, exposing the difficulty of reasoning about quantified, non‑linear bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/bouncing-ball-inv-node6249.smt2",
    "description": "The file is a 32‑bit BV benchmark (logic BV, 2 586 characters, 10 declared constants, one top‑level assertion) that originates from the KeYmaera “bouncing‑ball” example (node 6249) used in the IJCAR 2012 paper on non‑linear arithmetic and was translated to bit‑vectors by Mathias Preiner.  \nIt encodes a verification condition for the invariant of a bouncing ball, where the variables v, g, h, t₁, V, c, etc. represent the ball’s velocity, gravity, height, time and auxiliary parameters, and the physics is captured by quadratic expressions such as 2·h + (–g)·t₁² + 2·t₁·v ≥ 0.  \nThe core of the assertion is a negated existential formula ∃ ts₁ · Φ(ts₁) ; proving sat means the existential witness does **not** exist, i.e., the invariant holds for all admissible time steps 0 ≤ ts₁ ≤ t₁.  \nΦ combines several signed‑comparison constraints (≤, ≥, >) and non‑linear arithmetic relations using bit‑vector multiplication, signed division by 2, and negation, e.g., huscore = g·(tus)² + vus·tus ≥ 0 and tus ≤ V·2/g.  \nBecause the problem is expressed entirely with bit‑vector operations, it exercises the solver’s handling of non‑linear arithmetic, quantifiers, and mixed arithmetic/comparison reasoning on 32‑bit words, which is atypical for industrial‑style BV benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node605722.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems prover for the “safe intersection” example (node 605722 of *intersection‑example‑simple.proof*).  It originates from the Jovanović & de Moura “Solving Non‑Linear Arithmetic” paper and was translated to bit‑vectors by Mathias Preiner, giving a relatively large instance (≈2.8 kB, 19 declared constants, one top‑level assertion, max term depth 20).  \n\nThe single assertion is the negation of an existential formula over a time variable `ts1357uscore0`; the body is a massive conjunction of signed‑comparison constraints that model non‑negativity of speeds (`v1`, `v2`), bounds by a maximal speed `V`, positivity of parameters `A`, `B`, `ep`, and ordering of positions (`xI1 < x1`, `xI2 > x2 + v2²/(2·B)`).  It also encodes a quadratic term `bvmul v2 v2` divided by `2·B` using signed division, and relates a control variable `I1`/`I2` to the constant 2.  \n\nThe outer disjunction expresses either a specific equality (`xI2 = x2uscore3dollarskuscore555`) or a conditional block that enforces time‐bounds (`0 ≤ ts1357uscore0 ≤ t1357uscore0`, `ts1357uscore0 + 0 ≤ ep`) together with the previously listed range constraints.  By asserting the negation of this existential, the solver is asked to prove that no assignment satisfies all those hybrid‑system safety conditions, i.e., to establish the safety property of the intersection scenario.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node268667.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of size 2720 bytes, taken from the KeYmaera “intersection‑example‑simple” verification condition and translated to BV by Mathias Preiner (family Preiner‑keymaera, industrial category).  The single assertion is the negation of an existential query over a fresh time variable ts1249₀, with two let‑bindings that compute the position of two moving objects after time ts ( v₀ = A·ts + v₁ ,  v₁ = −B·ts + v₂ ).  The quantified formula encodes the usual safety pre‑conditions: non‑negative parameters A, B, V, ep; velocities v₁,v₂ in the interval [0,V]; initial positions satisfying xI₁ < x₁ and xI₂ > x₂ + v₂²/(2·B); and the requirement that the computed positions stay within [0,V] and that ts remains within the global time bound ep.  The outer implication also forces either I₁ = 2 (which contradicts the earlier I₁ = 0) or I₂ = 2, so the only way the existential could be satisfied is via I₂ = 2, which the surrounding negation disproves, thereby checking that the unsafe state is unreachable.  Notably the problem is expressed entirely with BV arithmetic (including signed comparisons and division), contains a deep nesting of conjuncts (max term depth 19), and features a built‑in contradiction (I₁ = 0 ∧ I₁ = 2) that makes it a typical “unsat‑core” verification condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node632728.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of about 2.8 KB containing a single, large assertion that encodes a verification condition from the KeYmaera hybrid‑system verifier (the “intersection‑example‑simple” proof node 632728).  The formula is a negated existential over a time variable ts3025₀ and contains a massive conjunction of arithmetic constraints that model a safe‑intersection scenario: non‑negative parameters A, B, V, ep, bounds on the state variables v₁, v₂ (each between 0 and V), quadratic terms v₁·v₁ and v₂·v₂ divided by 2·B, and signed‑greater‑than comparisons of updated positions xI₁, xI₂ against their initial values x₁, x₂.  Additional constraints enforce that the elapsed time t₃₀₂₅₀ is within [0, ep] and that the integer‑indexed counters I₁, I₂ take the value 2 (captured by the clause (or (= 1 2) I₂ = 2)).  The instance originates from the industrial‑oriented Preiner‑keymaera family, was submitted by Dejan Jovanović, and showcases non‑linear arithmetic (multiplication and division) encoded in bit‑vector form, with 18 declared constants, a maximum term depth of 20, and a mixture of signed‑comparison operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/intersection-example-simple.proof-node249484.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector encoding (logic BV) of a verification condition generated by the KeYmaera hybrid‑systems theorem prover for the “safe intersection” example from the paper *Safe intersections* (Loos & Platzer, ITSC 2011).  It originates from the Preiner‑keymaera family (file intersection‑example‑simple.proof, node 249484) and contains 19 declared constants, one large quantified assertion and about 20 kB of terms (max depth 20).  The formula asserts the **negation** of an existential statement over a time‑step variable `ts1160uscore0`; proving unsatisfiability therefore shows that the safety condition holds under the given assumptions.  The constraints encode simple linear and quadratic relationships among the modeled quantities: fixed integer parameters (`I1 = I2 = 2`), non‑negative bounds on velocities (`0 ≤ v1, v2 ≤ V`), a positivity condition for the braking distance term `x2 + v2²/(2·B)`, ordering of positions (`xI1 < x1` and `xI2 > …`), and a derived velocity `v2 – B·ts` that must stay within `[0,V]`.  Additionally, side conditions restrict the time interval (`0 ≤ ts ≤ t1160uscore0 ≤ ep`) and include a trivial disjunction that forces either `xI1 = x1_uscore...` or the time bounds to hold, making the VC a conjunctive safety check typical for hybrid‑system reachability proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-keymaera/ETCS-d-braking-node1346.smt2",
    "description": "The benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the Keymaera verification suite; it encodes the ETCS (European Train Control System) “d‑braking” safety condition for node 1346 and was translated to bit‑vectors by Mathias Preiner (family Preiner‑keymaera, industrial category, 1 assertion, 7 declared constants, 1 KB size).  \n\nThe single top‑level assertion is the negation of an existential formula: “there exists a time t₁ such that for all times tₛ the following quantified constraints hold”.  \n\nInside the quantified block the constraints express non‑negativity of the variables v, d, b and the ordering z ≤ m, together with a chain of implications that require (i) t₁ ≥ 0, (ii) 0 ≤ tₛ ≤ t₁, (iii) a quadratic inequality involving t₁ and the parameters (b·tₛ + v ≥ 0), and (iv) a linear inequality linking the product b·t₁ + v with the distance bound d.  \n\nThe final conjunct asserts the safety property  \n\\[\nv^{2}-d^{2}\\;\\le\\;2\\,b\\,(m-z),\n\\]  \nrewritten in bit‑vector arithmetic with the auxiliary term \\(?v_0 = -b\\) and a division by 2.  \n\nThus the instance tests a non‑linear arithmetic safety condition (quadratic and bilinear terms) encoded as a quantified bit‑vector formula with a relatively deep term structure (max depth 19).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_673.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) verification condition generated by Ultimate Automizer from the SV‑COMP 2015 benchmark *Primes_true‑unreach‑call.c* (file Primes_true‑unreach‑call.c_673.smt2).  It declares four constants – a return value, a Boolean flag, and two 32‑bit variables `n` and `f1` – and contains only two top‑level asserts, for a total of 2 445 characters and a maximum term depth of 8.  The first assert states that the function’s return equals the input `n` and that there exist two auxiliary 32‑bit values (`v_nnf_35`, `v_nnf_34`) satisfying a chain of linear bit‑vector inequalities: `f1 ≤ v_nnf_35 ≤ v_nnf_34`, `n ≤ 2`, and an upper bound `f1 + 2·v_nnf_35 + 2·v_nnf_34 + 1 ≤ ret`.  The second assert negates the same existential conjunction together with the bound `n ≤ 2`, thus checking that no such witness can exist – i.e., it encodes an unreachability (safety) query.  Notably, the formula mixes quantified bit‑vector arithmetic with simple arithmetic constraints, a characteristic pattern of the automata‑theoretic encoding used by Ultimate Automizer.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_2207.smt2",
    "description": "This instance is a 32‑bit bit‑vector verification condition generated by the Ultimate Automizer tool from the SV‑COMP 2015 benchmark *Primes_true‑unreach‑call.c* (file Primes_true‑unreach‑call.c_2207.smt2, size ≈ 2.2 kB, 2 asserts, 3 declared constants). It works in the **BV** logic of SMT‑LIB 2.6 and uses only signed‑less‑or‑equal (`bvsle`), multiplication by the constant 2 (`bvmul`), addition and logical connectives; the deepest term has depth 8. The formula asserts the existence of a 32‑bit value v such that the scaled sum `2·c_mult_~n + 2·v + 1` is bounded by the result constant `|c_mult_#res|` and that `c_mult_~n` lies between the input constant `|c_mult_#in~n|` and v. A second assertion negates the existence of any *smaller* witness `mult_~n` satisfying the same arithmetic constraints, i.e., it checks that the chosen `c_mult_~n` is minimal (or that a certain error state is unreachable). The overall query therefore encodes an unreachability/minimality property of the original C program, and `check‑sat` will return **unsat** exactly when the property holds. Notably, the script contains only the commands needed for a single satisfiability check, making it compatible with the main track of SMT‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1070.smt2",
    "description": "This SMT‑LIB file is a bit‑vector (BV) encoding generated by the Ultimate Automizer verification tool on an SV‑COMP 2015 benchmark (file *nested9_true‑unreach‑call.i*).  It works in the 32‑bit BV logic, declares three unsigned 32‑bit constants `c_main_~i~6`, `c_main_~j~6` and `c_main_~k~6`, and contains only two top‑level assertions (the whole benchmark is 2 165 characters and has a maximum term depth of 7).  \n\nThe first assertion describes a simple numeric precondition:  \n `k ≤ i`, `2·i ≤ j`, and `4 ≤ i`.  \nThe second assertion is the negation of the safety property that the program should satisfy; it requires simultaneously that `i` is at least 1, that there exists a 32‑bit value `v_nnf_74` with `4 ≤ v_nnf_74`, `k ≤ v_nnf_74+3`, and `2·v_nnf_74 ≤ j`, and also that `i ≥ 3` and `i ≥ 2`.  \n\nThus the solver is asked whether the precondition can coexist with a counterexample consisting of such a witness `v_nnf_74`; a SAT result would mean the original (unreachability) claim is false.  The script is deliberately minimal (only the commands needed for a single SAT check) to satisfy SMT‑COMP rules, and it showcases Ultimate Automizer’s translation of array‑free integer programs into pure bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_678.smt2",
    "description": "The file is a bit‑vector (BV) verification condition generated by **Ultimate Automizer** for the SV‑COMP 2015 benchmark *Primes_true‑unreach‑call.c*.  \nIt is a small industrial‑style instance (≈2.8 KB, 4 BV constants, a single top‑level assert, depth 9) that was post‑processed for SMT‑COMP by Mathias Preiner.  \nThe formula expresses a reachable‑call safety check: it introduces the program variables `f1`, `n` and the returned value `ret12`, adds an existential block over two auxiliary 32‑bit terms `v_nnf_35` and `v_nnf_34`, and requires that they satisfy a chain of signed‑less‑or‑equal constraints together with the arithmetic inequality  \n\n```\nf1 + 2·v_nnf_35 + 2·v_nnf_34 + 1 ≤ ret12 .\n```  \n\nA Boolean flag `short13` is defined to be true exactly when `ret12 = n`, and the assertion conjuncts this definition with the existential condition **and also the negation of the same existential condition**. Hence the overall query is expected to be unsatisfiable, i.e., it proves that the call under verification cannot occur.  \n\nNotably, the benchmark uses only bit‑vector arithmetic (no arrays), a pair of existential quantifiers, and several `let`‑bindings to keep the term size low—characteristics typical of Ultimate Automizer’s generated BV encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_670.smt2",
    "description": "The file is a 2 KB SMT‑LIB 2.6 benchmark in the **BV** (fixed‑width bit‑vector) logic, generated by the Ultimate Automizer verifier from an SV‑COMP 2015 industrial benchmark (family *Preiner‑UltimateAutomizer*). It declares three 32‑bit variables `c_main_~i~6`, `c_main_~j~6` and `c_main_~k~6`, which model integer program counters or loop indices, and asserts two conjunctive constraints. The first constraint bounds the variables with simple linear inequalities: `k ≤ i`, `2·i+1 ≤ j`, and `i ≥ 3`. The second constraint negates a larger property that would require `i` to be non‑negative (0 ≤ i ≤ 3), `2·i ≤ j`, and the existence of a witness `v_nnf_40` (≥ 3) such that `k ≤ v+2` and `2·v+1 ≤ j`. Hence the query asks whether the conjunction of the first bounds and the *negation* of this safety condition is satisfiable, i.e., whether a counterexample to the intended invariant exists; the presence of a single existential quantifier and nested arithmetic makes it a small yet non‑trivial bit‑vector verification instance.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_597.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer from the SV‑COMP 2015 “Primes” benchmark (file Primes_true‑unreach‑call.c_597.smt2).  It uses the BV logic (SMT‑LIB 2.6) and contains three declared 32‑bit constants and two top‑level assertions, the whole script being about 2.3 kB with a maximum term depth of 7.  \n\nThe core of the encoding models a single function call c_mult, with an input value |c_mult_#in~n|, a global bound c_mult_~n, and a returned result |c_mult_#t~ret1|.  Both assertions refer to an existentially quantified pair of 32‑bit variables (v_nnf_29, v_nnf_28) and require the linear bit‑vector constraints  \n\n```\n2·v_nnf_29 + 2·v_nnf_28 + 1 ≤ |c_mult_#t~ret1|\nc_mult_~n ≤ v_nnf_29 ≤ v_nnf_28\n|c_mult_#in~n| ≤ c_mult_~n .\n```  \n\nThe first assertion demands that such a pair exists, while the second asserts the negation of the same existential condition.  Consequently the formula is unsatisfiable, which corresponds to proving that the particular “unreachable‑call” property of the original C program holds.  Notably, the benchmark exercises quantified bit‑vector arithmetic and the interaction of `exists` with linear inequalities, making it a typical industrial case for SMT‑C​OMP’s BV track.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_1770.smt2",
    "description": "This file is a 2‑KB SMT‑LIB 2.6 benchmark in the **BV** logic, generated by the Ultimate Automizer verification tool (via Mathias Preiner’s BV translation) from an SV‑COMP 2015 industrial benchmark. It declares three 32‑bit bit‑vector constants `c_main_~i~6`, `c_main_~j~6` and `c_main_~k~6` that model program variables, and formulates two conjunctive assertions that capture a reachability condition together with two nested existentially‑quantified auxiliary variables (`v_nnf_98` and `v_nnf_96`). The first assertion imposes a collection of signed‑less‑or‑equal inequalities relating i, j, k and an existential variable, while the second assertion asserts the **negation** of a similar pattern, effectively asking whether the original condition can be falsified. Satisfiability of the whole formula therefore corresponds to the existence of a counterexample to the intended safety property (i.e., a reachable error state). Notably, the benchmark features mixed linear arithmetic over bit‑vectors, nested quantifiers, and duplicated inequality patterns, making it a typical challenge for solvers that must handle quantified BV constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/Primes_true-unreach-call.c_187.smt2",
    "description": "The file is a 2‑KB BV‑logic benchmark (SMT‑LIB 2.6) produced by Ultimate Automizer from the SV‑COMP 2015 “Primes_true‑unreach‑call.c” benchmark; it contains four 32‑bit bit‑vector constants and one Boolean flag, two top‑level assertions and two quantified sub‑formulas (total assert count = 2, declare‑const count = 4, max term depth = 7).  \n\nThe first assertion ties the Boolean `|c_main_#t~short13|` to the equality `|c_main_#t~ret12| = c_main_~n~22` and additionally requires the existence of two 32‑bit variables `v_nnf_16` and `v_nnf_17` that satisfy a small system of linear bit‑vector inequalities:\n`2·v_nnf_16 + 2·v_nnf_17 + 1 ≤ |c_main_#t~ret12|`,\n`c_main_~f1~22 ≤ v_nnf_16`,\n`c_main_~n~22 ≤ 2`,\nand `v_nnf_16 ≤ v_nnf_17`.  \n\nThe second assertion is the negation of the same existential clause, i.e. it asserts that **no** pair of values can satisfy those inequalities.  \n\nConsequently the benchmark checks the consistency of a contradictory pair of existential constraints (together with the simple equality), which makes the whole formula unsatisfiable and encodes the “unreachable” property of the original C program.  \n\nIts construction is notable for using only quantifier‑free bit‑vector arithmetic (addition, multiplication by the constant 2, and signed ≤) together with a single quantified block, a pattern that stresses solvers' handling of quantifiers in the BV theory.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2017-Preiner-UltimateAutomizer/nested9_true-unreach-call.i_473.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (32‑bit bit‑vectors) produced by the Ultimate Automizer verifier on an SV‑COMP 2015 “true‑unreach‑call” benchmark; it is 2 450 characters long, contains three declared integer‑like constants (`c_main_~i~6`, `c_main_~j~6`, `c_main_~k~6`) and two top‑level assertions.  \nThe first assertion encodes a set of lower‑bound constraints on `i` (0 ≤ i, 1 ≤ i, 2 ≤ i, 3 ≤ i) together with an existentially quantified auxiliary variable `v_nnf_26` that must be at least 3 and satisfy `k ≤ v_nnf_26+1` and `2·v_nnf_26 ≤ j`, plus the global relation `2·i ≤ j`.  \nThe second assertion is the negation of a very similar conjunctive pattern, but with the existential variable `v_nnf_28` shifted by 2 (`k ≤ v_nnf_28+2`) and the same bounds on `i`, `j`, and `k`.  \nThus the script asks the solver to decide whether the conjunction of the first conjunctive condition and the negation of the second (i.e., whether the two versions can simultaneously hold), which is exactly the satisfiability check used by the tool to prove that the target program location is unreachable.  \nThe benchmark is notable for its use of nested existential quantifiers and multiple redundant lower‑bound literals, which stress quantifier handling in bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_9.smt2",
    "description": "The script is a BV‑logic benchmark (bit‑vector arithmetic) generated by Ultimate Automizer from an SV‑COMP 2023 industrial benchmark; it is 2 KB long, contains two top‑level assertions, two declared 32‑bit constants and three quantified variables, and its maximum term depth is seven.  \nIts core models a simple arithmetic relation on a 32‑bit variable n that is bounded by the constant 1 000 000: the first assertion introduces two existential witnesses for n, demanding that the floor of n/2 (computed with `bvsdiv`) multiplied by two equals a constant j, that `bvsdiv n 2 + 1` is larger than 1, and that the same division result equals another constant l.  \nA third conjunct in the first assertion asserts that `l + 1` is greater than 1, which is trivially true given the previous constraints.  \nThe second assertion negates the existence of any n in the same range for which `bvsdiv n 2 + 1` exactly equals the constant l, i.e., it checks that no such n can satisfy the equality while respecting the bounds.  \nThus the whole benchmark asks the solver whether the combination of these existential requirements and their negation is satisfiable, effectively testing a simple correctness property (a “no‑counterexample” condition) that arises from a heap‑sort verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_0.smt2",
    "description": "The file is a small BV‑logic benchmark (3 declared 32‑bit bit‑vectors, 2 assertions, 2149 characters) generated by Ultimate Automizer from an SV‑COMP 2023 industrial benchmark. It declares three symbolic return values of a function (`|c_ULTIMATE.start_main_~ret~1#1|`, `|c_ULTIMATE.start_main_~ret2~0#1|`, `|c_ULTIMATE.start_main_~ret5~0#1|`) and immediately forces them to be equal. The second assertion negates an existential claim that there exist two 32‑bit numbers (`v_arrayElimCell_14`, `v_arrayElimCell_15`) whose signed‑extended 64‑bit sum (computed with `bvadd` after `sign_extend`) equals that common return value. Consequently the whole formula asks whether the common return value can be a signed sum of *any* two 32‑bit integers; the solver must answer “unsat” if such a sum always exists, otherwise “sat”. The script is stripped of model‑producing commands to satisfy SMT‑COMP restrictions and showcases a typical automata‑theoretic encoding of a simple arithmetic property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_2.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite; it contains 3 declared constants (the initial values of x, y, z) and two quantified assertions, fitting in a 3 kB script with a maximum term depth of 7.  \nThe first assertion is a universal property that, for every choice of three nondeterministic 32‑bit variables, the big arithmetic expression  \n\n```\nx + z + 8·v6 + 4·v4 + 4·v5 + y\n```  \n\nmust never evaluate to the bit‑vector constant 1.  \nThe second assertion is the negation of a similar universal statement (it is equivalent to an existential claim) that adds four more terms (two extra 8·v6 and two extra 4·v4/ 4·v5) to the same sum, again requiring the result not to be 1.  \nThe overall check‑sat query therefore asks whether there exists a valuation of the nondeterministic variables that falsifies the first safety property while satisfying the second, i.e., whether a counter‑example to the intended invariant exists.  \nBecause the model uses nested quantifiers and several bvmul/bvadd operations, it is a typical quantifier‑heavy BV instance that challenges solvers’ support for reasoning about arithmetic over fixed‑size bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_3.smt2",
    "description": "This benchmark is a 2‑byte‑vector (BV) SMT‑LIB 2.6 script (logic BV) generated by Ultimate Automizer for the SV‑COMP 2023 “heapsort” benchmark (file heapsort.i_3.smt2).  It declares two 32‑bit bit‑vector constants – a current loop counter `c_…` and its “primed” version `c_…_primed` – and contains three top‑level assertions (the file is 2 295 bytes, with a max term depth of 7).  The first assertion forces the counter to be larger than 1 and to relate the primed value by `c = c_primed + 1`.  The second asserts that there exists some iteration count `n` in the interval [1, 1 000 000] such that `c` equals `⌊n/2⌋ + 1`.  The final (negated) existential asserts that no such `n` can make the primed value satisfy the same relation, i.e., it checks that after one increment the invariant `c = ⌊n/2⌋ + 1` cannot hold for any admissible `n`.  Thus the problem encodes a simple quantified safety property about the monotonic growth of a loop bound in a bit‑vector setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_2.smt2",
    "description": "This instance is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 benchmark jain_6‑1.c (file BV/20230321‑UltimateAutomizerSvcomp2023/jain_6-1.c_2.smt2). It declares three 32‑bit constants x, y, z (the initial values of the program variables) and then formulates two quantified constraints over several nondeterministic 32‑bit variables that model the program’s possible executions. The first constraint universally states that a weighted sum of x, y, z and the nondet variables can never equal the constant 4, while the second is the negation of a similar universal claim, i.e. it asserts that there exists a choice of nondet values for which the same sum does equal 4. Together the two assertions are contradictory, so the check‑sat query is intended to prove unsatisfiability, which corresponds to showing that the error state (sum = 4) is unreachable. The benchmark is tagged “industrial”, contains only two assertions (3023 characters, max term depth 7), and uses quantified bit‑vector arithmetic with many bvmul and bvadd terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_8.smt2",
    "description": "The file is a 3 KB BV‑logic benchmark (32‑bit bit‑vectors) generated by Ultimate Automizer from the SV‑COMP 2023 C‑source *jain_6-1.c* (industrial category, family UltimateAutomizerSvcomp2023, 3171 characters, 4 declared constants and 2 top‑level asserts).  \nIt encodes the verification condition for a program assertion, where three input variables *x*, *y*, *z* (the constants |c_ULTIMATE.start_main_~x~0#1|, |c_ULTIMATE.start_main_~y~0#1|, |c_ULTIMATE.start_main_~z~0#1|) are combined with several nondeterministic 32‑bit values through a linear expression built with `bvadd` and many `bvmul` by small constants (2, 4, 8).  \nThe first assert states that, assuming the original `__VERIFIER_assert` condition is non‑zero, the quantified expression can never evaluate to the constant 4; it is a universally quantified “no‑bad‑state” clause.  \nThe second assert is the negation of a similar universal claim, i.e. it requires the existence of concrete nondeterministic values that make the same expression equal 4, thereby turning the overall set of constraints into a satisfiability check for a counterexample.  \nThus the solver is asked to decide whether the asserted property holds for all possible nondeterministic inputs, a typical “reachability‑vs‑safety” query that features quantifiers, heavy bit‑vector arithmetic, and a relatively shallow term depth (7).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_5.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector verification condition generated by Ultimate Automizer from the SV‑COMP 2023 benchmark *jain_6‑1.c* (family UltimateAutomizerSvcomp2023, industrial category, 3 KB, 3 assertions, 4 declared constants).  \nThe logic is BV; the script asserts that the variable representing the condition of a `VERIFIER_assert` call equals the bit‑vector constant 1, i.e., the original program’s safety property is expected to hold.  \nTwo quantified formulas describe the core arithmetic check: the first universally quantified clause states that, for all nondeterministic inputs `nondet4`, `nondet5`, `nondet6`, a linear combination of these inputs (each multiplied by 8) together with the initial values of `x`, `y`, `z` can never sum to the constant 4; the second clause negates a similar universal statement, effectively asserting the existence of a concrete assignment that makes the sum equal to 4.  \nThe final `check‑sat` therefore asks whether the program can violate the assertion—if the formula is satisfiable, a counterexample exists; otherwise the safety property is proved.  \nNotably, the condition uses only bit‑vector multiplication and addition with a maximum term depth of 7, making it a relatively shallow but quantifier‑heavy example typical of automated software model‑checking encodings.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_0.smt2",
    "description": "The file is a 32‑bit bit‑vector (BV) SMT‑LIB 2.6 benchmark generated by the Ultimate Automizer tool for an SV‑COMP 2023 industrial suite (size ≈ 2.5 kB, 3 assertions, 2 declared constants).  It models the “start” step of a software floating‑point addition routine: the two 32‑bit constants `c_…~ma~0#1` and `c_…~mb~0#1` represent the normalized mantissas of the two operands, each forced to have the hidden‑bit pattern `0x01000000` (the assert with `bvand 33554432` clears that bit for the first mantissa).  The second assertion existentially defines `c_…~ma~0#1` as the sum of a masked‑and‑or‑combined mantissa `a` and a right‑shifted, similarly built mantissa `b` (parameterised by a shift amount `delta`).  The third assertion negates the conjunction that both `c_…~mb~0#1` can be expressed as the shifted mantissa of `b` **and** `c_…~ma~0#1` can be expressed as the masked‑or‑combined mantissa of `a`, i.e. it checks that the two representations cannot simultaneously satisfy the described construction.  Consequently the solver is asked to decide whether this verification condition is unsatisfiable, which corresponds to proving a correctness property of the soft‑float addition implementation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_10.smt2",
    "description": "This SMT‑LIB file is a BV (32‑bit) benchmark generated by **Ultimate Automizer** from the SV‑COMP 2023 industrial suite (the “baker‑y” mutual‑exclusion benchmark, file *btor2c‑eagerMod.bakery.1.prop1‑func‑interl.c_10.smt2*). It contains 7 declared 8‑ and 32‑bit bit‑vectors and six top‑level assertions, the largest of which nests 129 operators and uses more than 500 `zero_extend`, 400 `extract` and 350 `bvand` applications. The core of the problem is a set of universal‑quantified constraints that relate many input and state variables via intricate bitwise masks (e.g., `mask_SORT_1`, `mask_SORT_4`) and require the result of a cascade of `bvand`, `bvor`, `bvnot` and `bvextract` operations to be the constant zero vector. A separate “difference” assertion forces the extended values of `state_18` and `var_165` to be unequal, while another asserts that the product of `var_46` with 2 is masked away (i.e., `bvand mask_SORT_4 (bvmul 2 var_46) = 0`). Together these constraints encode the safety property of the bakery algorithm (absence of simultaneous critical‑section entry) and the instance is deliberately heavy‑weight to stress bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/psyco_abp_1-2.c_2.smt2",
    "description": "The file is a BV‑logic benchmark (32‑bit bit‑vectors) generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark *psyco_abp_1‑2.c*. It contains only two declared constants and two top‑level assertions, occupying about 1.9 KB (1871 characters) with a maximum term depth of 5. The first assertion fixes the constant `ULTIMATE.start_main_~this_expect~0#1` to the concrete value 6, while the second asserts the negation of an existential statement that a 32‑bit variable `v` can satisfy `bvadd (bvneg v) 1 = ULTIMATE.start_main_~this_buffer_empty~0#1`. Since for any bit‑vector `x` one can choose `v = 1‑x` to satisfy that equality, the existential is always true, making its negation false and rendering the whole formula unsatisfiable. Consequently, the script checks that the encoded verification condition cannot hold, i.e., it expects a `unsat` result.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_11.smt2",
    "description": "The file is a 4 KB BV‑logic benchmark (logic = BV, 12 declared 32‑bit bit‑vectors, 3 top‑level asserts, 2 quantified formulas) generated by Ultimate Automizer from the SV‑COMP 2023 C‑program *jain_4‑1.c*.  It encodes a tiny transition system for three program variables x, y, z that are each updated in a single step by adding a nondeterministic multiple of 4 (for x and y) or 8 (for z) – the primed symbols represent the next‑state values.  An auxiliary Boolean‑encoded condition `c_ULTIMATE.start___VERIFIER_assert_~cond#1` is defined by an `ite` that stores 1 iff the sum of the primed variables equals 1, and the original C‑assert is modeled as the requirement that this condition be 0.  The first `forall` asserts that **for all** choices of the nondet increments the summed expression can never be 1, while the final `not (forall …)` forces the existence of a concrete choice of increments making the summed expression equal 1, thereby checking reachability of the assertion violation.  Thus the SAT query asks whether the transition relation together with the negated safety property is satisfiable – i.e., whether the encoded program can reach a state that violates the `__VERIFIER_assert`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_0.smt2",
    "description": "The script is a BV‑logic benchmark (32‑bit bit‑vectors) generated by Ultimate Automizer from an SV‑COMP 2023 industrial benchmark (the *heapsort* program). It is a tiny quantified problem (2070 bytes, 2 assertions, 1 declared constant) that tests the solver’s handling of existential quantifiers, bounded arithmetic and division. The first assertion states that there must exist a 32‑bit value n (the “loop counter”) with 0 ≤ n ≤ 1 000 000 such that its integer‑division‑by‑2 equals the constant l, and additionally that l+1 > 1 (i.e. l≠0). The second assertion negates the existence of any n in the same range that also satisfies 1 ≤ n ≤ 1 000 000 and makes l+1 equal to (n÷2)+1, i.e. it forces the two definitions of l to be inconsistent. Thus the whole query asks whether the two quantified constraints can simultaneously hold, a typical “existential‑universal” consistency check arising from the automated verification of the heapsort implementation. Notably, the benchmark exercises quantified bit‑vector division and simple linear inequalities, which are known to be challenging for many SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/sum.i_1.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (`BV`) instance (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial set; it is about 2 KB, declares three 32‑bit constants and contains two top‑level assertions. The three constants model the return value of the function `start_main` (different internal copies) and the first assertion simply forces them to be equal. The second assertion negates an existential quantifier over two fresh 32‑bit variables; inside the quantifier the signed‑extended addition of the two variables is extracted (`(_ extract 31 0) (bvadd …)`) and equated to the (now unified) return value. Hence the formula states that the program’s output **cannot** be expressed as the signed sum of any two 32‑bit numbers, a property that is false for all bit‑vectors, making the instance expected to be unsatisfiable. The encoding showcases the use of quantifiers, `sign_extend`, and bit‑vector arithmetic to capture a simple arithmetic‑correctness check for a benchmark program.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_9.smt2",
    "description": "The script is a bit‑vector (BV) verification condition generated by **Ultimate Automizer** from an SV‑COMP 2023 benchmark (file *soft_float_4‑2.c.cil.c_9.smt2*). It uses 3 declared 32‑bit bit‑vectors and contains three top‑level assertions in a total of 2 286 characters (max term depth 9).  \n\nThe first assertion encodes an assumed non‑zero condition (the “abort‑if‑not” guard). The second assertion introduces two existentially quantified fresh inputs `addflt_~a#1` and `addflt_~b#1` and forces the declared constants `c_addflt_~ma~0#1` and `c_addflt_~mb~0#1` to be the results of masking each input with the 24‑bit mantissa mask (`0x00FFFFFF`) and setting the hidden‑bit (`0x01000000`).  \n\nThe third assertion is the negation of an existential formula that would witness a concrete choice of the two inputs together with a delta value such that, after adding the masked operand b to the delta, right‑shifting, and then adding the masked operand a, the final value (right‑shifted once more) equals the previously stored masked mantissa of a (`c_addflt_~ma~0#1`). In other words, it checks that no combination of inputs can make this particular shifted‑addition equation hold, i.e., it verifies a property of the software’s soft‑float addition routine.  \n\nOverall, the instance captures a small, quantifier‑heavy slice of a floating‑point addition model, uses only bit‑wise and shift operations, and is intended as an industrial‑category benchmark for BV solvers in SMT‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_2.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) formula generated by the Ultimate Automizer verification tool from an SV‑COMP 2023 industrial C benchmark (file *soft_float_1‑1.c.cil.c_2.smt2*; 2 KB, 2 asserts, 2 declared constants).  It declares two 32‑bit constants that represent masked parts of a floating‑point value (`c_…ma` and `c_…mb`) and then asserts two quantified properties over three auxiliary 32‑bit variables `a`, `b` and `delta`.  \n\nThe first conjunct asserts that there exist `b` and `delta` whose shifted‑or‑masked combination equals `c_mb`, and an `a` whose masked‑or combination equals `c_ma`; these encode the standard IEEE‑754 decomposition into exponent (the high bit 0x01000000) and mantissa (the low 23 bits 0x007FFFFF).  \n\nThe second conjunct negates the existence of `a`, `b`, `delta` satisfying a derived equation that adds the two masked parts, right‑shifts the sum by one, and expects the result to equal `c_ma`.  In other words, the script checks whether the simple “add‑then‑shift” abstraction of floating‑point addition is always consistent with the individual masked components.  \n\nThe problem therefore tests a quantifier‑rich, bit‑wise property of a floating‑point addition encoding, using only BV operators (bvand, bvor, bvlshr, bvadd) and a shallow term depth (≤ 9).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_2.smt2",
    "description": "The file is a bit‑vector (“BV”) benchmark generated by Ultimate Automizer for the SV‑COMP 2023 “bakery” concurrency case (file BV/…/bakery.1.prop1‑func‑interl.c_2.smt2).  It contains seven 8‑bit and one 32‑bit uninterpreted constants that model program states, inputs, masks and a counter variable, and it issues six top‑level assertions, the last of which is a **negated** disjunction of two universally quantified invariants—one a mask‑multiplication property (`bvand mask (bvmul 2 var_46) = 0`) and the other a large bit‑wise mask‑equality property built from many `zero_extend`, `extract`, `bvand`, `bvor` and `bvnot` operations.  The core logical structure is therefore an “exists‑state” check: the solver must find an assignment to the state bits that violates at least one of the two universally quantified safety conditions, i.e. a counterexample to the intended safety property of the bakery algorithm.  The instance is sizeable (≈ 41 k characters, max term depth 129) and heavily uses term‑sharing (`let`) and common sub‑expressions, with 548 `zero_extend` and 398 `extract` calls, reflecting the low‑level bit‑precise encoding of the program’s control‑flow and masking logic.  Because the logic is pure BV and the only quantifiers are universal over small‑width variables, the problem tests the ability of BV solvers to handle deep, highly repetitive bit‑wise reasoning typical of industrial software‑verification benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_6.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by the Ultimate Automizer tool from an SV‑COMP 2023 industrial benchmark (file linear‑inequality‑inv‑a.c_6.smt2).  It declares a single 32‑bit constant `c_ULTIMATE.start_main_~s~0#1` and relates it to several 8‑bit variables that are zero‑extended to 32 bits before being added with `bvadd`.  The first assertion states that there exist two 8‑bit values whose extended sum equals the constant `c`; the second asserts the negation of a disjunction of three alternatives, each of which would represent the same constant as a sum of three or more zero‑extended bytes (different groupings of the existentially quantified variables).  Thus the query asks whether `c` can be obtained *exactly* as the sum of two bytes and cannot be expressed as any of the larger sums, i.e., it checks a uniqueness property of a linear‑inequality‑style invariant.  The instance is small (≈3.5 kB, 2 asserts, 1 declaration) but features quantified bit‑vector arithmetic, making it a non‑trivial test of solvers’ handling of exists‑quantifiers and arithmetic over bit‑vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_7.smt2",
    "description": "This SMT‑LIB file is a bit‑vector (BV) benchmark of size 2396 generated by Ultimate Automizer from the SV‑COMP 2023 “soft_float” C benchmark (industrial category, family UltimateAutomizerSvcomp2023). It declares five 32‑bit constants that model parts of a software‑implemented floating‑point addition: two “input” words ( c_addflt_~ea~0_Hier, c_addflt_~eb~0_Hier) and two “masked” forms ( c_addflt_~ma~0_Hier, c_addflt_~mb~0_Hier) built by setting the exponent‑bit 0x01000000 and keeping the low 24 bits. The first assertion ties a Boolean‑encoded assertion variable to the signed‑greater‑or‑equal comparison of the two input words, while the second assertion defines the masked words via existentially quantified auxiliary variables that perform a bit‑wise and with 0x00FFFFFF followed by an or with 0x01000000. The final (negated) existential assertion checks that there is **no** triple (delta, b, a) for which the masked mantissa of a, after being shifted right by 1 and added to the similarly processed mantissa of b plus delta, equals the masked mantissa of a – essentially a correctness condition for the shift‑and‑add step of the soft‑float routine. The problem therefore combines quantified bit‑vector arithmetic, conditional (ite) and comparison operators, making it a non‑linear, quantified BV verification task.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_9.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance generated by the Ultimate Automizer tool from the SV‑COMP 2023 industrial suite (file soft_float_1‑1.c.cil.c_9.smt2, 2 439 bytes, 3 assertions, 1 declared constant).  It models a fragment of a software‐floating‑point addition routine (“addflt”) by introducing three existential 32‑bit variables a, b and δ that are combined with bitwise AND/OR, addition and logical right‑shifts to form a candidate mantissa value c.  The first assertion forces the most‑significant bit of c (mask 0x02000000) to be zero, while the second asserts that such a c can indeed be produced by the described expression.  The third assertion negates the existence of any a, b, δ that would make the same expression, after an additional one‑bit logical right‑shift, equal to c.  Thus the formula checks whether the un‑shifted mantissa can be obtained while the shifted version cannot, a property relevant to the correctness of the soft‑float rounding step.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_7.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (file *jain_6‑1.c_7.smt2*; 4 613 characters, 12 declared constants, 3 top‑level asserts).  It models a tiny C program with three integer variables x, y, z and three nondeterministic inputs (the “nondet*” symbols), using primed copies to represent the next program state after a single transition.  The transition relation is expressed by a conjunct of equalities that update x, y and z with linear combinations of the nondet values (e.g. x′ = x + 2·nondet4) and by an ite that sets the assertion‑condition flag to 1 exactly when the arithmetic expression 4 ≠ 2·y′ + z′ + 4·x′ holds.  A universally quantified clause then demands that for **all** possible nondet assignments the expression cannot equal 4, while a separate clause forces the condition flag to be 1; the final assert negates this flag, turning the whole query into a safety check.  Thus the solver is asked to prove (or refute) that the program can never reach a state where the verifier’s assert would fail, i.e. whether the asserted property is invariant under the nondeterministic transition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_10.smt2",
    "description": "The file is a 3 kB BV‑logic benchmark (logic = BV, 4 declared 32‑bit constants, 2 top‑level assertions) generated by Ultimate Automizer from the SV‑COMP 2023 “jain_6‑1.c” benchmark.  It encodes a safety property of a C program: a global Boolean flag `__VERIFIER_assert_cond` must never be zero, and a linear combination of several program variables (the inputs x, y, z and three nondeterministic 32‑bit values) must never equal the constant 4.  Both conditions are expressed with universal quantifiers over the nondeterministic variables, using a mixture of `bvadd` and `bvmul` with small integer coefficients (2, 4, 8).  The final query asserts the negation of the universally quantified property, so the solver is asked to find a concrete assignment that violates the safety condition; satisfiability therefore indicates a counterexample to the original assertion.  The benchmark features a relatively deep term nesting (depth 7) and a high density of multiplication operations, typical of bit‑vector encodings produced by automata‑based software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_3.smt2",
    "description": "This benchmark is a 2 KB bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 “soft_float_4‑2.c” benchmark (industrial category). It declares two 32‑bit constants, |c_addflt_~ma~0#1| and |c_addflt_~mb~0#1|, which are defined as the result of masking a 32‑bit word with 0x00 FFFFFF and then forcing the exponent‑bit 0x01 000000 (the usual “set‑biased‑exponent” step for single‑precision floats). The first assertion introduces existential variables |addflt_~a#1| and |addflt_~b#1| to capture exactly these masking operations, binding the two constants to the transformed inputs. The second assertion negates the existence of three words a, b, δ such that, after adding δ to the masked b value, shifting right by one, and then adding the masked a value, the result (again shifted) equals the previously defined constant |c_addflt_~ma~0#1|. In other words, the script checks that a specific relationship required by a floating‑point addition step cannot be satisfied, using only bitwise logical, shift, and addition operations together with existential quantifiers. The problem therefore tests the solver’s ability to handle quantified bit‑vector arithmetic typical of software‑verification encodings of floating‑point semantics.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_9.smt2",
    "description": "The script is a BV‑logic verification condition generated by **Ultimate Automizer** from a SV‑COMP 2023 benchmark (the file *soft_float_4‑1.c.cil.c_9.smt2*).  It is a relatively small instance (≈2.3 KB, 4 declared 32‑bit bit‑vectors, 3 top‑level assertions, max term depth 9) that models a fragment of a software routine for floating‑point addition using pure bit‑vector operations.  The first two assertions fix the auxiliary variable `c_addflt_~mb~0` to 0 and relate the function’s return value (`c_addflt_~a`) to that variable; they also introduce existential witnesses (`addflt_~delta~0`, `addflt_~b`, `addflt_~a`) that build normalized mantissas by masking with 0x00 FFFFF and OR‑ing the hidden‑bit constant 0x01000000, followed by a logical right‑shift.  The final assertion negates the existence of a triple `(addflt_~delta~0, addflt_~b, addflt_~a)` that would make the normalized mantissa of the sum, after an extra right‑shift by 1, equal to the previously computed `c_addflt_~ma~0`, thereby encoding the safety property that the implemented addition cannot produce that particular result.  In short, the problem checks whether the bit‑vector encoding of a soft‑float addition satisfies a specific invariant, and the solver is asked to show the formula unsatisfiable.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_9.smt2",
    "description": "This SMT‑LIB file is a 3 KB BV‑logic benchmark (logic = BV, 4 bit‑vector constants, 3 assertions, 2 universal quantifiers) generated by the Ultimate Automizer tool from the SV‑COMP 2023 C benchmark *jain_6‑1.c*.  The script encodes the verification condition of a C function that contains a call to `__VERIFIER_assert`; the constant `|c_ULTIMATE.start___VERIFIER_assert_~cond#1|` is required to be non‑zero (first assertion).  The second assertion strengthens this by demanding that, for all nondeterministic 32‑bit values `v_…#1_10`, a large linear combination of the program’s inputs (`x`, `y`, `z`) and the nondet variables never equals the bit‑vector constant 4.  The third assertion negates the same universal statement, i.e. it asserts that there exists a choice of the nondet variables for which that combination *does* equal 4, thereby contradicting the previous universal claim.  Consequently the benchmark checks the consistency of these contradictory constraints and exercises Ultimate Automizer’s handling of quantified bit‑vector arithmetic with many `bvmul` and `bvadd` operations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_4.smt2",
    "description": "The file is a BV‑logic SMT‑LIB 2.6 benchmark ( logic BV ) generated by Ultimate Automizer for an SV‑COMP 2023 industrial case; it contains 7 declared 8‑ and 32‑bit bit‑vectors, 7 top‑level assertions and about 41 k AST nodes (max depth 129).  The encoded program is a small “bakery‑algorithm” style concurrent routine (see the file name) whose state is represented by several 8‑bit variables (e.g. `state_18`, `state_31`, `state_41`) and a 32‑bit counter `var_46`.  The core of the model consists of a series of quantified Horn‑like constraints that relate the current state, input bytes and a mask (`mask_SORT_1`) using nested bitwise operations (`bvand`, `bvor`, `bvnot`, `extract`, `zero_extend`).  One of the assertions explicitly states that a certain universally quantified equality **does not** hold, thereby turning the problem into a safety‑property violation check, while another assertion forces the mask to be orthogonal to `2·var_46` (`bvand mask (bvmul 2 var_46) = 0`).  Because of the heavy use of quantifiers, deep term nesting and numerous bit‑vector manipulations, the instance is a demanding test of bit‑vector reasoning and quantifier instantiation for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_9.smt2",
    "description": "This benchmark is a 2 KB BV‑logic instance (logic BV, 4 declarations, 3 assertions, max term depth 9) generated by Ultimate Automizer from an SV‑COMP 2023 industrial C program (“soft_float_4”).  The formula models a small fragment of a floating‑point addition routine using 32‑bit bit‑vectors: three uninterpreted constants c_addflt_~ma~0, c_addflt_~mb~0, c_addflt_~mb~0_primed and a shift amount c_addflt_~delta~0.  The first constraint ties the primed “mb” value to a logical right shift of the original “mb” by the delta value; the second asserts that both “ma” and “mb” can be obtained by masking 32‑bit inputs (addflt_~a, addflt_~b) with 0x00 ffffff and then setting the exponent‑bit pattern 0x01 000000.  The final (negated) existential query asks whether there exist concrete inputs addflt_~a, addflt_~b and a delta such that, after the same masking, adding the shifted “mb” to “ma”, right‑shifting the sum by one, yields exactly c_addflt_~ma~0; the script checks that this situation is impossible (unsat).  Notably, the problem contains quantified (exists) sub‑formulas combined with bitwise‑and,‑or, shift and addition, making it a typical small‑scale verification condition for floating‑point arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.fischer.1.prop1-back-serstep.c_2.smt2",
    "description": "**Summary**  \nThe file is a BV‑logic benchmark (size ≈ 20 k, 8 asserts, 6 declared bit‑vector constants of 8 bits and one of 32 bits) generated by Ultimate Automizer from a SV‑COMP 2023 industrial C program (the “lazyMod” benchmark).  It models a small control‑flow fragment in which a single 8‑bit state variable `|state_41|` is updated by a massive bit‑wise expression that combines three input bytes (`input_85`, `input_93`, `input_101`) with a mask (`mask_SORT_1`) and a collection of auxiliary temporaries (`var_48…var_66`).  The core constraints are universally quantified equalities that require the masked‑and‑extended computation to yield zero whenever the state is non‑zero, together with two arithmetic side‑conditions that enforce `bvand(mask_SORT_4, 3*var_132) = 0` and `bvand(bvadd(var_132, …), mask_SORT_4) = 0`.  The last two assertions negate these universal conditions for specific inputs (forcing `input_101 ≠ 0`) and for a second arithmetic mask, thereby asking the solver to find a concrete assignment that violates the intended invariant.  In other words, the script checks whether the generated bit‑vector model of the program can reach a state where the invariant (masked result = 0 and the arithmetic mask constraints) is broken, which corresponds to an error‑state or assertion failure in the original C code.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_4.smt2",
    "description": "The script is a 32‑bit bit‑vector verification condition generated by Ultimate Automizer for a benchmark from SV‑COMP 2023 (file *jain_4‑1.c_4.smt2*), using the BV logic and classified as an industrial benchmark. It declares four 32‑bit constants that correspond to the program’s global variables and then encodes the program’s single `assert` as quantified arithmetic over several nondeterministic inputs (`v_…nondet*`). The first universally‑quantified assertion states that, for **all** possible values of six nondet variables, the bit‑vector sum  \n\n```\nz + y + x + 8·nondet6 + 4·nondet4 + 4·nondet5 + … \n```  \n\nmust never be equal to the constant 1. A second assertion fixes the condition variable of the original `assert` to 1, and a third (negated) forall asserts the existence of some three nondet values that make the same sum **equal** to 1. Consequently the formula is contradictory (unsatisfiable), illustrating a typical automata‑theoretic encoding that heavily relies on quantifiers and linear BV arithmetic, which is a known challenging pattern for SMT solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_4.smt2",
    "description": "The script is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from an SV‑COMP 2023 C program that implements a tiny software floating‑point routine. It declares two 32‑bit constants `c_addflt_~ma~0#1` and `c_addflt_~mb~0#1` that represent, respectively, a masked‑and‑or‑encoded mantissa of the first operand and the same encoding after a logical right‑shift of the second operand by an unknown “delta”.  \n\nThe first assertion asserts the existence of concrete operand values (`addflt_~a#1`, `addflt_~b#1`, `addflt_~delta~0#1`) that can produce those two encodings by applying the mask 0x00FFFFFF, setting the hidden‑bit 0x01000000, and then shifting the second encoding right by `delta`.  \n\nThe second assertion negates the existence of a triple of operands such that, after performing the same encoding on the first operand, adding the shifted second encoding, shifting the sum right by one, and comparing it to the first encoding, the equality would hold. In other words, it checks that the assumed floating‑point addition (with rounding by a single‑bit right shift) can never yield the original mantissa encoding.  \n\nThe benchmark is small (≈2 KB, 2 assertions, 2 declared constants), uses only basic BV operations (and, or, shift, add) and was submitted to the industrial category of SMT‑COMP 2023.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_0.smt2",
    "description": "This benchmark is a bit‑vector (BV) instance generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (benchmark *jain_2‑2.c*), containing 2 quantified assertions over 6 BV constants of size 32 and a total of 2 480 characters.  The script declares two input parameters `x` and `y` (both 32‑bit) and a family of nondeterministic variables (the `v_…` symbols) that are quantified universally.  The first assertion states that, for all four nondeterministic values, the expression  \n\n```\nx + 2·v4_9 + 2·v5_10 + 2·v5_9 + 2·v4_10 + y\n```  \n\ncan never equal the constant 1, i.e. `¬( … = 1 )`.  The second assertion is the negation of a universal claim that the simpler sum  \n\n```\nx + 2·v5_10 + 2·v4_10 + y\n```  \n\nis never 1; equivalently, it requires the existence of some `v5_10, v4_10` making that sum equal 1.  Thus the overall problem checks whether the two contradictory quantified properties can be satisfied simultaneously, exercising only basic BV addition and multiplication with a very shallow term depth (max 7).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_3.smt2",
    "description": "The script is a 2 KB BV‑logic benchmark generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (file soft_float_1‑1.c.cil.c_3.smt2, 6 declared 32‑bit bit‑vectors, 2 top‑level assertions).  It encodes a small fragment of IEEE‑754 single‑precision addition: the first assertion relates the 24‑bit high part of the two operands |a| and |b| (obtained by a logical right‑shift by 24) to their mantissas (masked with 0x00FFFFFF and forced to have the hidden leading‑one 0x01000000) and to their exponents (the shifted high parts plus the bias 128).  The second assertion negates an existential formula that would make the derived mantissa |ma| equal to the right‑shifted sum of the two operand mantissas after aligning the second operand by an unknown delta; thus it asks the solver to show that no choice of |a|, |b| and |delta| can satisfy that equality.  Satisfiability of the whole file therefore amounts to proving that the described floating‑point addition invariant holds for all 32‑bit inputs, a typical safety‑property check used in software model checking.  The benchmark features shallow term depth (≤ 9) but a mix of bitwise, arithmetic and quantified reasoning that makes it a useful challenge for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_3.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark “jain_7‑1.c”.  It declares four program variables x, y, z and an auxiliary assertion flag, all as 32‑bit bit‑vectors, and contains three top‑level assertions.  The first two constraints are universal formulas that forbid any choice of the nondeterministic variables (encoded as quantified bit‑vectors) from making a large linear combination of x, y, z and the nondet terms equal to the constant 1 048 576 (2¹⁰).  The third assertion asserts the opposite: it negates a universal statement, thereby requiring the existence of a nondeterministic assignment that *does* make the same linear combination equal to 1 048 576, while the second assertion forces the program’s “assert” condition to be true (the flag equals 1).  Consequently the whole formula checks whether the program can reach a state violating the original assert; the presence of quantifiers, heavy use of bvmul with the large constant 4 194 304 and a moderate term depth (9) make the instance a typical, yet challenging, bit‑vector verification problem.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-lazyMod.protocols.1.prop1-func-interl.c_0.smt2",
    "description": "This instance is a pure‑BV (bit‑vector) formula generated by the Ultimate Automizer tool from an SV‑COMP 2023 industrial benchmark (the C source *func‑interl.c*).  It encodes the transition system of the original program: every declared symbol is either an untimed program variable (8‑ or 32‑bit), an input, or a “primed’’ copy representing the value after one step, and the large conjunct of equalities defines the next‑state relation using only bitwise operators, zero‑extensions, extracts, and simple arithmetic.  The property under verification is the standard `__VERIFIER_assert` condition, asserted to hold (`c_ULTIMATE.start___VERIFIER_assert_~cond#1 = 1`) together with a mask that forces the Boolean‑style encoding (`mask_SORT_1 = 1`).  Finally, the outermost check asserts the negation of “mask = 1 ∧ ∃‑inputs that lead to a state where `state_55` is reachable”, i.e. it asks whether the error state is reachable; the solver must return **unsat** to prove the assertion safe.  The benchmark is large (≈ 161 k AST nodes, 715 bit‑vector constants, depth 80) and consists almost entirely of bit‑vector operations (≈ 700 zero‑extends, extracts, and Boolean combines), reflecting the automatic translation of a real‑world C program into a massive symbolic transition system.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_5.smt2",
    "description": "The script is a **32‑bit bit‑vector** (BV) encoding generated by **Ultimate Automizer** for the SV‑COMP 2023 benchmark *jain_7‑1.c* (file BV/20230321‑UltimateAutomizerSvcomp2023/jain_7‑1.c_5.smt2).  It contains 12 declared 32‑bit constants, 3 top‑level assertions and about 5 600 characters, with term depth up to 10 and a moderate amount of arithmetic (24 bvmul, 10 bvadd).  \n\nThe model represents a single loop‑iteration of the program: three state variables x, y, z are updated in the “primed” version by adding scaled nondeterministic values (`nondet4`, `nondet5`, `nondet6`).  An auxiliary Boolean‑as‑BitVec condition (`cond`) is defined by an *ite* that tests whether a linear combination of the new variables equals the constant 1 048 576.  \n\nTwo universally quantified blocks assert that **no choice of the nondeterministic inputs can make that combination equal 1 048 576**, while simultaneously fixing the condition variable to true (value 1).  The final `(not (forall …))` clause negates the same universal property, turning the whole formula into a check for a violation of the original `__VERIFIER_assert`.  \n\nThus the instance asks whether there exists a reachable program state in which the asserted arithmetic condition can be falsified; satisfiability corresponds to a counter‑example to the source program’s safety property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-2.c_1.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark *jain_7‑2.c* (file BV/20230321‑UltimateAutomizerSvcomp2023/jain_7‑2.c_1.smt2, size ≈ 3 KB, 2 quantified assertions and 3 global constants).  The logic is **BV**, with three declared constants |c_x|, |c_y|, |c_z| representing input variables of the original C program, and a set of nondeterministic 32‑bit variables introduced by the tool (the |v_…| terms).  Both assertions are universal: they forbid any combination of the nondet variables such that a large linear expression—built from multiplications by powers of two (2, 4, 4194304) and additions/subtractions—evaluates to the constant 2²⁰ (=_bv1048576_32).  The second assertion negates a similar universal property, so the whole query asks whether there exists a concrete valuation that makes the prohibited equality true; the solver therefore checks **unsat** (i.e., the original program satisfies the invariant).  Notably, the formula features deep (depth 9) nested arithmetic on 32‑bit vectors, but only a few distinct operators (13 bvmul, 4 bvadd, 2 bvneg), reflecting a typical Small‑Scale Verification condition from an automata‑theoretic software model‑checking pipeline.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_2.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic **BV**) generated by **Ultimate Automizer** from the SV‑COMP 2023 industrial suite (file *jain_7‑1.c_2.smt2*, 4 276 characters, 12 declared constants, 3 top‑level asserts).  \nIt models a tiny C routine with three state variables *x*, *y*, *z* that are updated in a single step using three nondeterministic 32‑bit values; the primed symbols denote the post‑state and the updates are expressed with `bvadd` and `bvmul` by large powers of two (2²⁰, 2²¹, 2²²).  \nThe second assert fixes the initial state by requiring each variable to be an exact multiple of the corresponding power of two and forces the program‑assertion variable `cond` to be true (`(_ bv1 32)`).  \nThe first assert defines the transition relation and ties the post‑state of the assertion to an `ite` that yields 1 iff the expression  \n`z′ + 4·x′ – 2·y′ ≠ 1048576` holds, i.e., it encodes the safety condition checked by the original `VERIFIER_assert`.  \nFinally, the third assert negates the existence of a reachable post‑state that still satisfies the multiplicative shape of *x′, y′, z′*; together with the earlier constraints this asks the solver to show that no reachable state can violate the asserted inequality, i.e., to prove the program safe.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_11.smt2",
    "description": "This instance is a 4 KB BV‑logic benchmark generated by Ultimate Automizer from the SV‑COMP 2023 C‑file **jain_6‑1.c** (category *industrial*).  \nIt models a single program step with three 32‑bit state variables x, y, z and three nondeterministic “aux” inputs, relating their *primed* (post‑state) versions to the *unprimed* (pre‑state) ones through a series of `bvadd`/`bvmul` assignments.  \nAn auxiliary Boolean condition (the result of an `ite`) is equated to the value of `__VERIFIER_assert`, and the script asserts that this condition is non‑zero, i.e. that the original `assert` must hold.  \nTwo quantified constraints then reason about the same linear combination of the variables: one universally‑quantified clause forbids it from equalling 4 for *all* nondet choices, while the final negated universal (∃) asks whether a concrete choice can make the combination equal 4.  \nThus the SAT query checks whether the program’s `assert` can be violated; a UNSAT result would prove the assertion safe, whereas SAT would exhibit a counter‑example.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_7.smt2",
    "description": "The script is a 32‑bit bit‑vector benchmark (logic **BV**) generated by **Ultimate Automizer** from the SV‑COMP 2023 C benchmark *jain_4‑1.c*. It declares three program variables x, y, z together with three nondeterministic “aux” inputs and a Boolean condition that models the `__VERIFIER_assert` of the original source. The first conjunct defines the one‑step transition: each variable is updated by adding a multiple (4·nondet4, 8·nondet6, 4·nondet5) of its respective nondeterministic input, and the assertion condition is set to 1 iff the sum x′+y′+z′ is not equal to 1. Two universal quantifiers then express that **for every** choice of the nondeterministic inputs the summed expression can never equal 1, while a third clause forces the condition to be 1 in the current state. Finally the script asserts the negation of this condition in the primed state, creating a direct contradiction that a solver must detect (the benchmark is intended to be unsatisfiable). The instance is relatively small (≈4.5 k characters, 12 constants) but features nested quantifiers, arithmetic multiplications, and an `ite`, which are characteristic of Ultimate Automizer’s automata‑theoretic encodings of safety‑property verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_10.smt2",
    "description": "The script is a bit‑vector (BV) verification condition generated by the Ultimate Automizer tool for the SV‑COMP 2023 benchmark **jain_2‑2.c** (file *BV/20230321‑UltimateAutomizerSvcomp2023/jain_2‑2.c_10.smt2*).  It uses 32‑bit bit‑vectors to model integer variables **x** and **y**, their “primed’’ next‑state versions, and two nondeterministic 32‑bit constants that are multiplied by 2 before being added to the variables (the usual encoding of `x += 2*nondet4; y += 2*nondet5`).  The first assertion defines the transition relation and introduces a Boolean condition that evaluates to 1 iff the new sum `x' + y'` is *not* equal to 1; this condition is then copied into a separate variable representing the program’s `assert`.  The second assertion universally states that for all possible nondeterministic choices the sum `x + y` can never be 1 and simultaneously forces the `assert`‑condition to be true (i.e., different from 0).  The final assertion negates a universal statement, thereby asserting the existence of some nondeterministic choices that make the sum of the primed variables (plus the same multipliers) equal to 1, which is precisely the counterexample the verifier is looking for.  The instance contains 9 declared bit‑vector constants, 3 top‑level conjuncts, a maximum term depth of 7, and falls into the industrial category of the competition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_0.smt2",
    "description": "The script is a very small BV‑logic benchmark (2 552 characters, 2 asserts, 1 declared 32‑bit constant) generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark. It works over 8‑bit and 32‑bit bit‑vectors and uses only zero‑extensions, addition and equality. The first assertion states that the 32‑bit constant `c_ULTIMATE.start_main_~s~0#1` can be obtained as the sum of four zero‑extended 8‑bit variables, i.e. there exists a 4‑byte decomposition whose widened sum equals c. The second assertion negates the existence of a 5‑byte decomposition (with a different ordering of the variables) whose widened sum equals the same constant. Hence the whole query asks whether a value can be represented as a sum of four bytes but **cannot** be represented as a sum of five bytes, checking the satisfiability of this linear‑inequality invariant. The problem is pure bit‑vector linear arithmetic with a shallow term depth (≤ 6) and was produced automatically for the “industrial” category of the competition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_3.smt2",
    "description": "This file is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer from the SV‑COMP 2023 C program *jain_2‑2.c* (family UltimateAutomizerSvcomp2023, industrial category, 2 609 bytes, 3 assertions).  It declares three 32‑bit constants representing the initial values of the program variables x, y and the Boolean condition of a `VERIFIER_assert`.  The first assertion universally quantifies over two nondeterministic variables and asserts that the linear expression  \n\n\\[\ny + x + 2·v_{5} + 2·v_{4} \\neq 1,\n\\]\n\nholds for every choice of those variables.  The second assertion simply forces the asserted condition to be true (`cond = 1`).  The third assertion negates a universal quantifier over four nondeterministic variables, which is equivalent to stating that there exists a valuation for which  \n\n\\[\ny + x + 2·v_{4}^{(9)} + 2·v_{5}^{(10)} + 2·v_{5}^{(9)} + 2·v_{4}^{(10)} = 1,\n\\]\n\nholds; together with the first assertion this creates a contradictory verification condition.  Hence the SMT query checks the unsatisfiability of an assertion‑failure condition that involves quantifiers, bit‑vector addition and multiplication by the constant 2.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_9.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (file jain_7‑1.c_9.smt2, size ≈ 3 KB, 4 declared constants, 2 top‑level asserts).  The script encodes the verification condition for a C function that contains a `VERIFIER_assert`, where the variables `x`, `y`, `z` are program inputs and a number of nondeterministic 32‑bit values are quantified universally.  The first assert requires two things to hold simultaneously: (i) for every choice of the nondet variables a linear combination of `x`, `y`, `z` and the quantified terms never equals the constant 1 048 576 (2²⁰), and (ii) the assert condition `cond` is non‑zero, i.e. the original program assertion is supposed to fire.  The second assert is the negation of a similar universal property, effectively stating that there exists a valuation of the nondet variables making the same combination equal to 1 048 576, thus providing a potential counter‑example.  The formula features several large coefficients (4, 2, 4 194 304 = 2²²) multiplied with bit‑vectors, uses two quantifier blocks, and has a modest term depth of 9, making it a typical quantified bit‑vector verification query for automated software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_1.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (the source file *jain_6-1.c*), containing 3 declared constants, 2 quantified assertions and a total size of about 3 KB.  The three constants `c_…~x~0#1`, `c_…~y~0#1` and `c_…~z~0#1` model fixed program inputs, while a set of quantified variables (`nondet4`, `nondet5`, `nondet6`) represent nondeterministic values read during execution.  The first assertion states that *for every* choice of these nondeterministic values the weighted sum  \n\\[\n2·y + 8·nondet5_9 + 8·nondet4_{10} + z + 8·nondet6_{10} + 8·nondet5_{10} + 4·x + 8·nondet6_9 + 8·nondet4_9\n\\]  \nis **not** equal to the bit‑vector constant 4.  The second assertion is the negation of a universal “not‑equal’’ clause, i.e. it requires the **existence** of a valuation of `nondet4_10`, `nondet5_10`, `nondet6_10` that makes the same linear combination equal to 4.  Together the two constraints are contradictory, so the check‑sat query is unsatisfiable; the script thus encodes a reachability‑type safety property (an error state is unreachable) expressed with mixed quantifiers and simple linear bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.cambridge.1.prop2-func-interl.c_2.smt2",
    "description": "The script is a **BV‑logic** benchmark (SMT‑LIB 2.6) generated by **Ultimate Automizer** from a SV‑COMP 2023 industrial benchmark; it contains 5 bit‑vector constants of width 8, 26338 characters, a maximum term depth of 192 and uses more than three hundred zero‑extend, two hundred extract and one hundred bvand nodes.  \n\nThe verification condition models a small fragment of a C function (the “eagerMod.cambridge” program) in which several 8‑bit input variables, state variables and a mask are combined with nested bitwise **and**, **or**, **not**, **extract** and **zero‑extend** operations, mimicking the effect of a series of bit‑level calculations on the program’s state.  \n\nThe first top‑level assertion is an **or** of three sub‑formulas: a universally quantified equality that the complex bitwise expression evaluates to zero, an equality tying the 8‑bit state 23 to the 8‑bit auxiliary variable 166, and the trivially true disjunct that the quantified part holds.  \n\nTwo further assertions explicitly negate the universal equality and also negate the state 23 = var 166 equality, thereby demanding a contradiction between the functional model and the expected property.  \n\nThus the instance asks the solver to decide whether the encoded bit‑vector computation can simultaneously satisfy the functional specification and violate the safety property, a typical “reach‑error” check used in automated software model‑checking competitions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.bakery.1.prop1-func-interl.c_11.smt2",
    "description": "The file is a bit‑vector SMT‑LIB 2.6 benchmark (logic BV) generated by **Ultimate Automizer** from a SV‑COMP 2023 industrial C program (the “bakery” mutex example).  It contains seven 8‑ and 32‑bit constants and seven top‑level assertions, of which four are universally quantified over dozens of auxiliary 8‑bit variables; the remaining three assert simple arithmetic and inequality facts.  The core of the model encodes a set of bit‑mask invariants that must hold after each step of the automaton (expressed with nested `zero_extend`, `extract`, `bvand`, `bvor` and `bvnot` operations) together with a multiplication‑mask condition on a 32‑bit counter (`bvand mask_SORT_4 (bvmul 2 var_46) = 0`).  The final two assertions negate the equality of two state variables and negate the universal mask property, so the whole query asks whether a reachable state exists that violates the intended safety invariant.  With ≈ 41 k symbols, a maximal term depth of 129 and more than 500 `zero_extend` applications, the instance is syntactically large but semantically a single‑location safety check typical for automated software verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_10.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector formula (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2023 C‑code suite; it contains 4 declared constants, 3 quantified assertions and a total size of about 2.3 kB. The model encodes a small “software‑floating‑point” routine in which the mantissa of two operands ( |c_addflt_~ma| and |c_addflt_~mb| ) is built from raw 32‑bit values by masking with the constant 2²⁴ (16777216) and combining the low‑order 24 bits with a hidden‑bit 1. A transition step is described by the equation |c_addflt_~mb′| = |c_addflt_~mb| ≫ |c_addflt_~delta|, i.e. a logical right‑shift of the second operand by a variable amount. The final assertion states that there is **no** choice of input mantissas and shift amount for which the resulting mantissa |c_addflt_~ma| equals the expression that first adds the shifted second operand to the first operand, then right‑shifts the sum by one and finally adds 1; this is expressed with a negated existential quantifier. In other words, the file checks a safety property of a soft‑float addition implementation, using quantified bit‑vector arithmetic, bitwise OR/AND, logical shifts and a single addition, with a modest term depth of 9.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_5.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 C benchmark *jain_4‑1.c*; it contains 4 declared constants, 3 assertions and a total size of about 3 KB.  The formula encodes a simple arithmetic safety property of the program’s `main` function: three fixed variables x, y, z are summed together with several nondeterministic multiples (8·v₆, 4·v₄, 4·v₅) and the solver is asked to prove that this sum can never equal the constant 1.  The first assertion states that **for all** choices of three nondet variables the sum is different from 1, while the second forces the verification condition variable `__VERIFIER_assert_cond` to be 1, i.e. the program expects the assertion to hold.  The third clause negates a stronger universal statement (including six nondet variables) and therefore asks the solver to find a concrete assignment that makes the sum equal to 1, effectively checking the reachability of an assertion violation.  The instance is characteristic of automated software‑model‑checking encodings: quantifiers are used to model nondeterministic inputs, all arithmetic is performed with 32‑bit bit‑vectors, and the problem is relatively shallow (max term depth 7) but contains multiple quantified layers that make it challenging for BV solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.vis_arrays_vsa16a_p6.c_5.smt2",
    "description": "This benchmark is a BV‑logic instance (bit‑vectors of width 8) generated by Ultimate Automizer from an SV‑COMP 2023 C benchmark (file *btor2c‑eagerMod.vis_arrays_vsa16a_p6.c_5.smt2*). It declares four 8‑bit constants that model a program’s current state, two auxiliary variables, and a mask, and then encodes the program’s transition relation with three large assertions. The first two assertions are quantified formulas that combine many nested `zero_extend`, `extract`, and bit‑wise operators (`bvand`, `bvor`, `bvnot`, `bvashr`, `bvadd`) to capture the effect of bit‑level arithmetic and masking; the third assertion is the negation of a conjunction of such quantified constraints, effectively asking the solver to refute the property. A final equality `state_24 = var_14` ties the abstract state to a concrete variable, so the overall check‑sat query asks whether the encoded safety property can be violated. The file is relatively large (≈ 7.6 k characters, term depth 54) and typifies industrial verification encodings that heavily use quantifiers and bit‑vector manipulations.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_6.smt2",
    "description": "The script is a 2 KB BV‑logic benchmark (2525 characters, 2 asserts, 6 declared constants) generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark suite. It models a single software floating‑point addition (`soft_float_4-2.c`) by representing the 32‑bit IEEE‑like operands as bit‑vectors and using shifts, masks and bitwise‑or/and to extract mantissa and exponent fields. The first assertion fixes the relationships between the original operands |c_addflt_~a#1|, |c_addflt_~b#1| and their “primed” components (extracted mantissas ma, mb and adjusted exponents ea, eb) through concrete bit‑vector equations. The second assertion negates an existential claim that there exist alternative operand values (|addflt_~a#1|, |addflt_~b#1|, |addflt_~delta~0#1|) satisfying a derived equality for the combined mantissa‑exponent term, thereby checking whether the specified transformation is uniquely determined. The overall check‑sat query asks whether the encoded floating‑point addition constraints are contradictory, i.e., whether the assumed abstraction of the addition operation is sound for the given program fragment.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_4.smt2",
    "description": "This SMT‑LIB file is a BV‑logic benchmark (32‑bit bit‑vectors) generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (file *jain_6-1.c_4.smt2*, 3146 characters, 3 asserts, 4 declared constants).  The script encodes the verification condition of a C program where three nondeterministic 32‑bit inputs (the “~nondet” variables) are combined with the program’s global variables x, y, z in a large linear expression built from `bvmul` and `bvadd`.  The first universal assertion states that this expression can never be equal to the constant 4, i.e. `¬(4 = …)`, while the second universal assertion (wrapped in a negation) asserts the opposite for a smaller subset of the nondeterministic variables.  An additional assert forces the verifier’s Boolean condition `|ULTIMATE.start___VERIFIER_assert_~cond#1|` to be the concrete value 1, representing the intended truth of the original C‑level `assert`.  The final `check‑sat` therefore asks whether the combination of these contradictory quantified constraints is satisfiable, which corresponds to checking the original program’s assertion for a possible violation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_4-1.c_1.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance generated by **Ultimate Automizer** from the SV‑COMP 2023 C benchmark *jain_4-1.c*. It uses the BV logic, contains three global constants `x`, `y`, `z` and a handful of universally‑quantified nondeterministic variables, for a total of 2947 characters, 2 assertions and 3 declared constants. The first assertion universally states that for every choice of six 32‑bit nondet values the expression  \n\n```\nx + z + 8·nd6_10 + 4·nd4_10 + 4·nd5_10 + 4·nd5_9 + 4·nd4_9 + 8·nd6_9 + y\n```  \n\nis **never** equal to the bit‑vector constant 1. The second assertion negates a similar universal quantifier (over three nondet values), thereby requiring that there exists at least one assignment of those three variables for which the same summed expression **does** equal 1. Consequently the formula encodes a direct logical conflict between a global “always‑false” property and an existential counter‑example, a pattern that often leads to unsatisfiability and is used to test solvers’ handling of quantified bit‑vector arithmetic. The script is stripped of model‑extraction commands to meet SMT‑COMP benchmark rules.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_8.smt2",
    "description": "The file is a **BV‑logic** benchmark (logic BV, 6 bit‑vector constants, 3 top‑level asserts, 2453 characters) generated by **Ultimate Automizer** from the SV‑COMP 2023 industrial suite.  \nIt models a small software routine for adding two 32‑bit floating‑point numbers by treating the mantissas as bit‑vectors and performing the usual exponent difference, right‑shift, and addition steps.  \nThe first assert defines the exponent difference Δ (= ea – eb) and the shifted mantissa mb′ = mb ≫ Δ; the second assert existentially introduces the original mantissas a and b, masking them with 0x01000000 ∨ (... & 0x00FFFFFF) to enforce the normalised representation.  \nThe final (negated) existential claim states that there must **not** exist values Δ, a, b for which the computed mantissa ma equals the right‑shift‑by‑1 of the sum of the aligned mantissas, i.e. it checks a safety property of the addition algorithm.  \nThus the problem asks the solver to prove that the asserted condition is unsatisfiable, i.e. that the software implementation can never produce the forbidden mantissa pattern.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-2.c.cil.c_6.smt2",
    "description": "The file is a small BV‑logic benchmark (2527 bytes, 3 declarations and 3 asserts) generated by Ultimate Automizer from an SV‑COMP 2023 C‑program that manipulates single‑precision floating‑point numbers.  It declares three 32‑bit bit‑vector constants that represent the “masked” parts of two operands ( ma and mb ) and a condition that must be non‑zero.  The first asserted conjunct existentially introduces two 32‑bit variables a and b and forces the usual IEEE‑754 masks 0x007FFFFF and the hidden‑bit 0x00800000 to reconstruct the mantissas ma and mb from them.  The second assert negates the existence of a third variable delta such that, after adding the two masked mantissas, inserting delta as a right‑shift amount and then shifting the sum right by one, the result would equal ma.  Consequently the solver is asked to check whether the combination of the non‑zero condition and the mantissa construction can ever violate the stated arithmetic property, i.e., whether the negated existential formula is unsatisfiable.  The benchmark showcases the use of quantified bit‑vector formulas to encode low‑level floating‑point addition reasoning in an industrial verification setting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_2.smt2",
    "description": "The file is a 2 KB BV‑logic benchmark (logic BV, 3 declared 32‑bit bit‑vectors, 2 top‑level assertions) generated by the Ultimate Automizer tool for the SV‑COMP 2023 industrial suite. It encodes a tiny slice of a C program’s main routine, introducing three symbolic variables that model the loop counter n and the derived indices l and r. The first assertion fixes the “primed” values after one iteration: r′ is set equal to n, n is bounded by 0 ≤ n ≤ 1 000 000, and l′ is defined as ⌊n/2⌋ + 1 with the additional pre‑condition n ≥ 1. The second assertion negates a property that would simultaneously hold a strict inequality l′ + 1 > 1 and the existence of some n ≤ 1 000 000 such that l′ = ⌊n/2⌋; this check essentially verifies that the computed l′ cannot equal the exact half of n under the given bounds. The benchmark therefore tests the solver’s ability to handle bounded bit‑vector arithmetic together with an existential quantifier and a simple arithmetic contradiction. Notably, the script contains no model‑extraction commands, reflecting the restrictions imposed by SMT‑COMP.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2.c.cil.c_7.smt2",
    "description": "This SMT‑LIB script is a BV‑logic benchmark (size ≈ 2.5 KB, 5 declared bit‑vector constants, 3 top‑level asserts) generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark suite (soft_float_4‑2.c). The encoding models a small piece of floating‑point addition using 32‑bit bit‑vectors in which the exponent bits are forced to 1 << 24 (the constant 0x01000000) and the low 23 bits represent the mantissa, as reflected by the repeated patterns “bvand … 0x00 ffffff” and “bvor … 0x01000000”. The first assert ties the verification condition c___VERIFIER_assert_#in~cond to the signed‑greater‑or‑equal comparison of two hierarchical results (|c_addflt_~ea…| and |c_addflt_~eb…|) via an ite that yields 1 or 0. The second assert introduces two existentially quantified helper variables (|addflt_~a#1|, |addflt_~b#1|) that define the hierarchical mantissa/exponent representations |c_addflt_~ma…| and |c_addflt_~mb…| through bitwise‑and/‑or constructions. Finally, the third assert states the property to be proved: there must **not** exist any choice of the original operands and a delta such that the computed |c_addflt_~ma…| equals a right‑shifted sum of the transformed operands, i.e. it checks that the intended rounding/normalisation step cannot produce the asserted value.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_6-1.c_6.smt2",
    "description": "This instance is a 32‑bit bit‑vector (BV) benchmark generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite (file *jain_6‑1.c_6.smt2*). It declares twelve 32‑bit variables that model the pre‑state (`…#0#1`) and post‑state (`…#0#1_primed`) of the program’s three integer variables x, y, z together with three nondeterministic “aux” inputs. The first conjunct relates the post‑state to the pre‑state by a series of linear updates (e.g., x′ = x + 2·nondet4, z′ = z + 8·nondet6) and encodes the condition of a `__VERIFIER_assert` as an `ite` that must equal the assertion flag. The second conjunct introduces two universally‑quantified formulas over fresh nondeterministic variables that express the intended invariant: the summed expression involving 2·y, 4·x, 8·(various nondets) must never equal the constant 4, and the assertion flag is forced to 1. The final assertion negates one of these universal clauses, so the overall problem asks whether there exists a reachable state violating the invariant; the solver’s result (sat/unsat) determines if the original C program’s assert can fail. The file contains 3 asserts, 12 declarations, and a maximum term depth of 8, with a total size of about 5.4 KB.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/heapsort.i_6.smt2",
    "description": "This SMT‑LIB file is a Bit‑Vector (BV) benchmark generated by Ultimate Automizer for the SV‑COMP 2023 industrial test suite (file *heapsort.i_6.smt2*). It works in the quantifier‑rich fragment of BV: one 32‑bit constant `|ULTIMATE.start_main_~l~0#1|` is declared and two quantified assertions are given, giving the script a modest size (≈2 KB, 2 asserts, 1 const, max term depth 6). The first assertion states that there exists a 32‑bit variable `n` with `1 ≤ n ≤ 1 000 000` such that `l = (n div 2) + 1`. The second assertion negates the existence of a (maybe different) `n` with `n ≤ 1 000 000` and `l = (n div 2)`. Hence the problem checks whether a value of `l` can satisfy the “plus‑one after halving” condition for some bounded `n` while it is impossible to satisfy the “exact halving” condition for any bounded `n`.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-1.c.cil.c_1.smt2",
    "description": "This SMT‑LIB file uses the quantifier‑free‑with‑exists fragment of the bit‑vector logic **BV** (32‑bit vectors) and was generated by **Ultimate Automizer** from an SV‑COMP 2023 benchmark (the “soft_float_4‑1.c” program).  The script is relatively small (≈2.5 kB, 7 declared constants, 3 top‑level asserts) and encodes a safety check for a software routine that implements a floating‑point addition‑like operation using integer bit‑wise primitives.  The first assertion describes a one‑step transition: it increments a counter (`ea`) and relates a shifted version of `ma` to its primed successor, while also forbidding a specific value (127).  The second and third assertions are existentially quantified formulas that introduce auxiliary 32‑bit variables `addflt_a` and `addflt_b`; they require that, after adding a constant (128) and right‑shifting by 24 bits, these auxiliaries correspond to the current `ea` and `eb` values and must **not** satisfy the unsigned‑less‑than relation (`addflt_a < addflt_b`).  The final `assert (not …)` negates the same existential condition, turning the whole problem into a check whether the transition can ever violate the “no‑less‑than” property—i.e., whether the encoded program state is safe.  Notably, the benchmark mixes simple arithmetic (`bvadd`), logical shift right (`bvlshr`), and quantifiers, making it a typical case for quantifier handling in BV‑based software verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_10.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) generated by Ultimate Automizer from the SV‑COMP 2023 industrial benchmark *soft_float_1‑1.c*. It declares four 32‑bit constants that model the return value of a C function implementing a software floating‑point addition and the intermediate bit‑patterns for the mantissas of the two operands (|ma| and |mb|). The first two assertions state that there exist some raw operand bits (a, b) and a shift amount (δ) such that the mantissas are built by masking the lower 23 bits, inserting the hidden leading 1 (2²⁴ = 16777216), and optionally right‑shifting one of them – exactly the bit‑level construction used in IEEE‑754 addition. The third assertion negates the existence of a, b, δ that would make the computed result (after adding the two constructed mantissas and shifting right by one) equal the stored mantissa |ma|, i.e., it checks that the implementation’s rounding step cannot produce an unexpected value. Satisfiability of the whole formula therefore answers the verification question “does the soft‑float addition violate its specification?”, and the script is small (≈2.7 KB, 3 assertions) but contains quantified bit‑vector reasoning typical for automated software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_2-2.c_9.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance generated by Ultimate Automizer from the SV‑COMP 2023 C benchmark **jain_2‑2.c**, with 2 628 characters, 3 declared constants, 2 quantified assertions and a maximum term depth of 7.  The logic is purely BV, using only equality, addition, multiplication by the constant 2, and Boolean connectives, and it contains two universally‑quantified blocks over four nondeterministic 32‑bit variables.  The first assertion requires that for **all** choices of the nondeterministic variables the expression  \n\n\\[\nx + 2·v_{5} + 2·v_{4} + y\n\\]\n\nis never equal to 1, and additionally that the variable representing the user‑provided assertion condition (`cond`) is non‑zero.  The second assertion is the negation of a similar universal property, demanding that there exists some combination of the nondeterministic variables for which the sum  \n\n\\[\ny + x + 2·v_{4}^{(9)} + 2·v_{5}^{(10)} + 2·v_{5}^{(9)} + 2·v_{4}^{(10)}\n\\]\n\n*does* equal 1.  Consequently the solver is asked to decide whether the program’s `VERIFIER_assert` can be violated (i.e., whether the existential witness making the sum 1 exists while `cond ≠ 0`).  The formula is a small, quantifier‑heavy BV verification task typical of industrial software‑model‑checking benchmarks.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_10.smt2",
    "description": "This benchmark is a quantifier‑rich bit‑vector problem (logic BV) generated by the Ultimate Automizer tool from the SV‑COMP 2023 “soft_float_4‑2a.c” benchmark; it contains two declared 32‑bit constants and a total of 2,413 characters. The first assertion introduces three existentially quantified 32‑bit variables that model a simplified floating‑point addition: the 24‑bit mantissas of the operands are forced into the “normalised” form by OR‑ing with 2²⁴, then one mantissa is right‑shifted by a variable delta and added to the other, and the result is tied to the constant c_addflt_~ma~0; a second existential clause defines c_addflt_~mb~0 as the same right‑shifted mantissa of the second operand, and a third clause equates c_addflt_~ma~0 directly with the normalized mantissa of the first operand. The second assertion negates the existence of any triple (delta, b, a) for which the same summed value, after an additional logical right‑shift by one bit, would equal c_addflt_~ma~0. Thus the overall query asks whether the described floating‑point addition can ever produce a result that is *different* from the original unshifted sum when divided by two, i.e. it checks a specific overflow/rounding property of the soft‑float implementation. The instance is relatively small (2 declares, 2 asserts, maximal term depth 9) but uses nested quantifiers and bit‑vector arithmetic, making it a typical industrial verification condition for automated software model checking.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/linear-inequality-inv-a.c_5.smt2",
    "description": "The file is a BV‑logic benchmark (bit‑vector theory) generated by Ultimate Automizer from an SV‑COMP 2023 industrial C‑program (file *linear‑inequality‑inv‑a.c*).  It is a very small instance (≈2.5 kB, 2 quantified assertions, one declared 32‑bit constant) that was extracted to check a candidate invariant.  The first assertion states that there exist three 8‑bit variables whose zero‑extended sum equals the 32‑bit variable |ULTIMATE.start_main_~s~0#1|, i.e., a linear equality over bit‑vectors.  The second assertion negates the existence of six 8‑bit variables that could produce the same 32‑bit sum, thereby encoding the property “the three‑term sum is realizable but no six‑term decomposition exists.”  The benchmark therefore tests the solver’s handling of quantified bit‑vector arithmetic, zero‑extension and simple linear constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_4-2a.c.cil.c_8.smt2",
    "description": "This benchmark is a bit‑vector (BV) encoding generated by Ultimate Automizer from the SV‑COMP 2023 “soft_float_4‑2a.c” benchmark (file soft_float_4-2a.c.cil.c_8.smt2, 2204 bytes, 3 asserts, 3 declared 32‑bit constants).  \nThe three constants c_addflt_~ma~0, c_addflt_~mb~0 and c_addflt_~delta~0 model the mantissas of two floating‑point operands and a delta value; the mask 0x01000000 (16777216) together with 0x00FFFFFF (16777215) is used to enforce the hidden‑bit normalization (setting the implicit leading 1).  \nThe first two asserts state that there exist raw mantissa values addflt_~a and addflt_~b whose normalized forms equal the given constants, and that the delta fits in 32 bits (zero‑extended to 64 bits and bounded by 2³²).  \nThe final assert negates an existential claim that the normalized mantissa of the first operand can be obtained by adding the normalized second operand, adding the delta, and then right‑shifting the sum by one bit; in other words, it asks the solver to prove that this specific relationship cannot hold.  \nThus the instance checks a correctness property of a software floating‑point addition routine, using only bit‑vector operations to model mantissa manipulation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_0.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector verification condition generated by Ultimate Automizer from an SV‑COMP 2023 industrial C source (file *jain_7‑1.c*).  The script uses the BV logic, contains 2 quantified assertions over six nondeterministic 32‑bit variables and three declared constants |c_…x|, |c_…y|, |c_…z|, and is relatively small (≈3 kB, 2 asserts, max term depth 9).  The core property states that a large linear combination of the nondeterministic values (scaled by 2, 4, and 4 194 304) plus the constants never equals the concrete bit‑vector 1048576 (2²⁰).  This is expressed by a universal quantifier asserting `not (= 1048576 …)` and a second, negated universal quantifier that forces the existence of a witness making the same equality true, thereby turning the problem into a check for a counterexample.  Satisfiability of the whole script indicates that the original program can reach a state where the arithmetic expression hits the forbidden value, i.e., the safety property being verified is violated.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/jain_7-1.c_4.smt2",
    "description": "The file is a 3 KB BV‑logic benchmark (logic BV, 4 declared 32‑bit variables, 3 assertions, max term depth 9) that was automatically generated by Ultimate Automizer from the SV‑COMP 2023 C‑program *jain_7‑1.c*.  It belongs to the “industrial” category of the UltimateAutomizerSvcomp2023 family and was produced for the competition’s benchmark suite.  \n\nThe script encodes the verification condition of the program’s `main` function: three concrete inputs `x`, `y`, `z` are fixed, the Boolean flag `__VERIFIER_assert_cond` is forced to 1, and three fresh nondeterministic 32‑bit values (named `nondet4`, `nondet5`, `nondet6`) appear in a large linear combination built with `bvadd`, `bvmul` (mostly by the constant 4 194 304) and `bvneg`.  \n\nThe first quantified assertion states that for **all** choices of the three nondeterministic variables the expression never equals the constant 1 048 576.  The second quantified assertion is the negation of a similar universal property (now with six nondeterministic variables and a slightly different combination), and the script finally asserts its negation, turning the whole problem into a check‑sat query.  \n\nThus the solver is asked whether there exists a concrete assignment to `x`, `y`, `z` such that the first universal “no‑reach‑1048576” property holds while the second universal property is violated—essentially a counter‑example search for a specific arithmetic overflow/branch condition in the original C program.  \n\nThe benchmark is notable for its heavy use of large‐scale bit‑vector multiplication (13 `bvmul` occurrences) and nested quantifiers, which makes it a challenging instance for BV decision procedures.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/soft_float_1-1.c.cil.c_6.smt2",
    "description": "The script is a bit‑vector (BV) SMT‑LIB 2.6 benchmark generated by **Ultimate Automizer** from an SV‑COMP 2023 industrial benchmark (file *soft_float_1‑1.c.cil.c_6.smt2*, 2 757 characters, 3 top‑level assertions and 4 declared constants).  \nIt models a tiny fragment of a software floating‑point addition routine: the constants `|c_ULTIMATE.start_addflt_…|` represent the original input word, the mantissa/exponent parts extracted by masking with the constants 0xFF800000 and 0x007FFFFF, and a “delta” shift amount.  \nThe first two assertions relate these extracts to the declared constants via bit‑wise **and**, **or**, and logical **shift‑right** (`bvlshr`), each wrapped in an existential quantifier that says “there exist a mantissa b and a shift δ such that …”.  \nThe final assertion negates a third existential statement that would combine the two extracted parts, add them, and shift the result right by 1; thus the whole formula asks whether the described combination can ever be equal to the previously computed `ma` value.  \nA **sat** result would exhibit a concrete counterexample to the intended floating‑point addition invariant, while **unsat** proves that under the given bit‑wise encoding no such inputs exist.  The benchmark is notable for using quantified bit‑vector arithmetic with a modest term depth (9) to capture low‑level floating‑point manipulation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/Primes.c_3.smt2",
    "description": "The file is a very small (≈1.7 KB, 2 assertions, 2 declared bit‑vector constants) BV‑logic benchmark generated by Ultimate Automizer from the SV‑COMP 2023 industrial suite. It models a 32‑bit computation where the output `c_mult_#res` is defined as `4·c_mult_#in~n + 1`. The second assertion negates the existence of a 32‑bit value `mult_~n` such that the same output can also be written as `6·mult_~n + 1`. Thus the formula checks whether the linear expression `4·x+1` can ever coincide with an expression of the form `6·y+1`; if a coinciding pair exists the conjuncts become unsatisfiable. Because `x = 0` yields `c_mult_#res = 1 = 6·0+1`, the negated existential is false and the whole instance is unsatisfiable, exposing the violation of the intended property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/20230321-UltimateAutomizerSvcomp2023/btor2c-eagerMod.unsafe_arbitrated_fifos_n2d8w8.c_1.smt2",
    "description": "The file is a BV‑logic benchmark (4 Byte‑wide bit‑vectors) generated by Ultimate Automizer from the SV‑COMP 2023 unsafe‑arbitrated‑fifos benchmark; it contains 4 declared 8‑bit constants, 2 quantified assertions and a total of 5 994 terms (max depth 48). Both assertions quantify over four program variables (named *var_86*, *var_89*, *var_101*, *var_105*) and build a nested expression that first zero‑extends each 8‑bit term to 32 bits, then applies a cascade of extracts, bitwise‑and, bitwise‑or and bitwise‑not operations together with two fixed masks (*mask_SORT_1* and *state_83*). The first universal clause states that the resulting 8‑bit value must be equal to 0, i.e. it encodes a safety invariant that a certain masked state of the FIFO program is always cleared. The second clause asserts the negation of a similar invariant combined with an additional conjunct, thereby asking the solver to find a concrete assignment that violates the invariant – essentially a reachability‑or‑error check. The benchmark is thus a pure bit‑vector verification task that tests the solver’s ability to handle deep, heavily nested bit‑wise expressions generated by an automata‑theoretic software model‑checking pipeline.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_4.smt2",
    "description": "The file is a crafted BV‑logic benchmark (4‑bit vectors) generated for the FMCAD 2020 paper on bit‑precise reasoning; it contains 4 declared constants, 9 auxiliary definitions and only two top‑level assertions.  \nIts purpose is to check a “consistency condition” \\(CC\\) for the binary addition operator \\(t = x + s\\) under a mask‑range specification given by two 4‑bit bounds \\(x_{lo}\\) and \\(x_{hi}\\).  \nThe mask condition `mcb` requires that a candidate operand \\(x\\) satisfies \\(x_{hi}\\,\\&\\,x = x\\) and \\(x_{lo}\\,|\\,x = x\\), i.e. \\(x\\) lies within the interval described by the masks, while the literal condition `LIT` encodes the equation \\(x + s = t\\).  \nTwo constraints are asserted: (1) the bounds are well‑formed – \\((\\lnot x_{lo}) \\lor x_{hi}\\) must be all‑ones, guaranteeing a valid mask interval – and (2) the trivially true predicate \\(CC\\) must be *distinct* from the existential statement that there exist \\(x,s\\) satisfying both `mcb` and `LIT`.  \nThus the solver is asked to determine whether the defined consistency condition is equivalent to the existence of a masked addition witness; a satisfiable result shows a counter‑example to the intended equivalence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_32.smt2",
    "description": "This instance is a handcrafted 32‑bit‑vector benchmark (logic BV, 4 declared constants, 9 defined functions, 2 top‑level assertions; size ≈5 KB) taken from the FMCAD 2020 paper on ternary propagation‑based local search.  It formalises a consistency condition for the arithmetic right‑shift operator `bvashr`: the predicate **CC** relates a target word `t` and a mask pair `xlo,xhi` by demanding the existence of a shift amount `i` that respects the mask‑containment predicate **mcb** and either bounds `i` by the leading‑zero/leading‑one counts of `t` or forces `i` to have the same most‑significant bit as `t`.  A second predicate **LIT** simply states that `bvashr x s` must equal the same target `t`.  The benchmark asserts that the mask pair is valid (the high mask is the bitwise complement of the low mask) and then checks that the two ways of characterising a shift – via **CC** and via an explicit existential witnessing a value `x` and a shift amount `s` satisfying **mcb** and **LIT** – are *different* (i.e., the consistency condition fails).  Thus the problem asks the solver to decide whether there exists a counterexample to the intended equivalence between the abstract mask‑based specification and the concrete shift‑right operation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_32.smt2",
    "description": "The file is a handcrafted 32‑bit‑vector benchmark (logic BV, 4 constants and 9 auxiliary functions, 4 891 characters) generated for the FMCAD 2020 paper on bit‑precise reasoning. It defines low‑level bit‑vector utilities such as count‑trailing‑zeros (ctz), count‑leading‑zeros (clz) and their complements, together with trivial constants (zero, one, ones, mins, maxs) and a predicate odd. The core of the problem is the pair of assertions: the first forces the high‑bound xhi to be the bitwise complement of the low‑bound xlo (so that bvor(bvnot xlo, xhi) = ones), and the second asserts that the Boolean CC(t,xlo,xhi) (which merely requires xlo ≠ ones) must be *distinct* from the existence of a value x in the interval defined by xlo and xhi (encoded by mcb) that is strictly smaller than some arbitrary s (the LIT predicate). In other words, the solver is asked whether the simple “xlo ≠ ones” condition is logically equivalent to the existence of a concrete element between xlo and xhi that satisfies x < s. The benchmark therefore checks a consistency condition for a custom bit‑vector interval operator, featuring deep nested ite chains for the ctz/clz definitions that make the formula syntactically heavy despite its logical simplicity.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_32.smt2",
    "description": "This instance is a handcrafted BV‑logic benchmark (32‑bit vectors) from the Preiner/FMCAD‑2020 suite, ≈ 4.8 kB with 4 declared constants, 8 auxiliary functions and only two top‑level assertions.  It encodes the “consistency condition” for a ternary bit‑vector operator CC: the mask predicate mcb requires a value v to lie between a lower and upper bound xlo, xhi (`bvand`/`bvor` constraints), and a validity clause forces every (xlo,xhi) pair to satisfy (bvor (bvnot xlo) xhi) = all‑ones.  The first assertion fixes the mask pair, while the second asserts that the concrete concatenation concat ts tx cannot be reproduced by any other pair (x,s) that also satisfies the same mask (via LIT) – expressed with a `distinct` between CC and an existential formula.  The check therefore asks whether there exists a model in which the concatenation of the two 32‑bit words is *uniquely* determined by the mask, i.e., whether the stated consistency condition is violated.  The benchmark exercises deep term nesting (max depth 35) through many nested `ite`/`extract` constructions (e.g., the hand‑written definitions of ctz and clz) to stress bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_32.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 32‑bit vectors) of about 5 kB with four declared constants and nine auxiliary definitions.  It originates from the FMCAD 2020 paper [1] by Niemetz and Preiner, where the authors generated consistency checks for bit‑vector operators; the instance is listed under the “Preiner‑fmcad20” family.  \n\nThe core of the problem is to compare two characterisations of a 32‑bit value `t*: (i) the predicate **CC** that asserts the existence of a shift amount *i* (bounded by the trailing‑zero count of t) such that the masks xlo and xhi, when both left‑shifted by *i*, still cover t (the “mask‑contains‑bit” condition **mcb**); (ii) the existence of a literal *x* and a shift amount *s* with **LIT** stating that shifting x by s yields t while the masks satisfy **mcb**.  \n\nTwo constraints are posted: one forces xlo and xhi to be complementary masks ( (bvor (bvnot xlo) xhi) = `0xFFFFFFFF` ), and the second asserts that the two predicates above are *distinct* (i.e., there is a model where **CC** holds but no literal‑shift pair does, or vice‑versa).  The query therefore asks whether the “mask‑shift consistency” condition is violated for some 32‑bit configuration.  \n\nThe benchmark contains a deep nesting of `ite`‑expressions to implement exact‑bit `ctz`/`clz` functions, uses several quantified sub‑formulas, and exhibits a maximal term depth of 35, making it a non‑trivial test for solvers’ handling of quantified bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvxor_x_s_32.smt2",
    "description": "This SMT‑LIB file is a 32‑bit bit‑vector benchmark (logic BV) of moderate size (≈4.9 k characters, 4 declarations, 9 defined functions, 2 top‑level asserts) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on “Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”.  \nThe core problem encodes a consistency check for the equation \\(x \\oplus s = t\\) (the function LIT) under a mask‑coverage condition \\(mcb(x_{lo},x_{hi},x)\\) that forces \\(x\\) to lie between two 32‑bit bounds \\(x_{lo}\\) and \\(x_{hi}\\).  \nA validity constraint on the bounds asserts \\((\\text{bvor}(\\neg x_{lo},\\,x_{hi}) = \\text{ones})\\), i.e. each bit is either forced low or high but never both.  \nThe final assertion demands that the always‑true predicate CC be *distinct* from the existence of any pair \\(x,s\\) satisfying both the mask condition and the xor relation, effectively checking that no such pair exists.  \nNotable features are the hand‑crafted definitions of ctz, clz, cto, clo using deep nested ite chains and bit‑extractions, which produce a max term depth of 35 and heavily stress bit‑vector reasoning in solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_64.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (64‑bit bit‑vectors, 2 KB, 7968 characters) generated for the FMCAD 2020 paper on bit‑precise reasoning. It declares four 64‑bit constants `inv_s`, `t`, `xlo` and `xhi` and defines a collection of utility functions (most notably `mcb`, which tests that a candidate vector `v` lies between a lower bound `xlo` and an upper bound `xhi` via `bvand`/`bvor`). The core of the problem consists of two assertions: (1) the pair `xlo`/`xhi` must be a valid interval, i.e. `bvor (bvnot xlo) xhi = ones`, and (2) a `distinct` statement that forces the always‑true predicate `CC` to differ from the existence of a witness `x` and a bound `s` such that `mcb xlo xhi x` holds and `bvuge s x` (i.e., `s ≥ x`). Consequently the instance asks the solver to show that no such witness exists for the given interval, i.e. that the interval representation is inconsistent with the `bvuge` condition. It exercises deep nesting of chained `ite` expressions (depth 67) and a large number of bit‑extracts, making it a stress test for bit‑vector reasoning engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_4.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic = BV, 4‑bit vectors) of modest size (≈2 KB, 4 declared constants, 9 helper definitions) that originates from the FMCAD 2020 paper on bit‑precise reasoning.  It declares four 4‑bit variables `t`, `xlo`, `xhi` (the auxiliary `inv_s` is unused) and defines a collection of utility functions (mask‑check `mcb`, count‑leading/trailing‑zero functions, parity, constants like `zero`, `ones`, etc.).  The first asserted clause forces `xlo` and `xhi` to be complementary bounds (`(bvor (bvnot xlo) xhi) = ones`), i.e., every bit is either 0 in `xlo` or 1 in `xhi`.  The second clause asserts that the Boolean predicate `CC t xlo xhi`—which simply checks that `t` is a sub‑mask of `xhi`—must differ from the existence of a pair `(x,s)` satisfying both the mask‑consistency condition `mcb xlo xhi x` and the literal condition `LIT x s` (i.e., `x & s = t`).  Thus the solver is asked to decide whether a simple mask inclusion test is equivalent to the existence of a concrete masked value within the given interval, a consistency property that involves a quantified (`exists`) sub‑formula and a `distinct` comparison.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_64.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector problem (logic **BV**) generated for the FMCAD 2020 paper *“Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”* (Preiner & Niemetz). It is a handcrafted instance of modest size (≈8 KB, 2 top‑level asserts, 4 declared constants and 9 user‑defined functions). The core of the query is the pair of constraints  \n\n1. `(= (bvor (bvnot xlo) xhi) #xFFFFFFFFFFFFFFFF)`, which forces every bit that is 1 in `xlo` to also be 1 in `xhi` (i.e., `xhi` is a superset mask of `xlo`).  \n\n2. `(distinct true (exists ((x (_ BitVec 64)) (s (_ BitVec 64))) (and (mcb xlo xhi x) (bvsge s x))))`, where `mcb` requires `x` to lie between the two masks (`xlo ⊆ x ⊆ xhi`) and `bvsge` is signed‑greater‑or‑equal. Because `CC` is defined as `true`, this `distinct` forces the existential to be **unsatisfiable**; in other words, there must be no signed value `s` that is ≥ any mask‑conforming `x`.  \n\nThe file also defines a large collection of auxiliary functions (`ctz`, `clz`, `cto`, `clo`, etc.) using deep nested `ite`s to compute counts of trailing/leading zeros, but none of them participate in the final constraints. The instance therefore tests a solver’s ability to handle deep‑nested conditionals together with quantifier‑free reasoning about mask containment and signed comparisons.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_32.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈5 KB, 4 declared constants and 9 auxiliary functions) taken from the FMCAD 2020 “Preiner‑fmcad20” suite.  It defines a set of utility functions – `ctz`, `clz`, `cto`, `clo`, `odd`, and several constant‑generating helpers – all implemented with deeply nested `ite`‑expressions to count leading/trailing zeros.  The core of the problem is the assertion  \n\n```\n(distinct (CC t xlo xhi)\n          (exists ((x s)) (and (mcb xlo xhi x) (= x s))))\n```  \n\nwhere `CC` is defined as the always‑true predicate and `mcb` enforces that a candidate value `x` lies between a lower‑bound mask `xlo` and an upper‑bound mask `xhi` (i.e. `xhi & x = x` and `xlo | x = x`).  Together with the mask‑validity condition `bvor (bvnot xlo) xhi = ones`, the formula asks whether the trivial `true` predicate can be distinguished from the existence of a concrete literal satisfying the mask constraints – essentially a consistency check for the bit‑vector mask operators.  The benchmark is notable for its heavy use of bit‑extractions and nested conditionals, yielding a maximal term depth of 35, which stresses solvers’ handling of large, handcrafted Boolean‑rich BV terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_64.smt2",
    "description": "This instance is a 64‑bit bit‑vector benchmark (logic BV) generated for the FMCAD‑2020 paper on consistency conditions of bit‑vector operators; it contains 4 declared constants, 9 user‑defined functions and only two top‑level assertions (≈ 8 KB in size). The core problem asks whether the trivially true predicate `CC(t,xlo,xhi)` can be distinguished from an existential statement that looks for a value `x` satisfying the “mask‑cover‑bounds” condition `mcb(xlo,xhi,x)` (i.e. `x` must contain all bits set in `xlo` and be a subset of the bits set in `xhi`) together with the literal‑inequality constraint `LIT(x,s)` (requiring `x ≠ s`). A side‑constraint on the bounds themselves guarantees that `xlo` and `xhi` are complementary masks: `bvor(bvnot xlo, xhi) = 0xffff…ffff`. The query therefore checks the satisfiability of the formula  \n`(distinct true (exists x s . mcb(xlo,xhi,x) ∧ x ≠ s))`, which is equivalent to asking whether **any** `x` fitting the mask constraints exists. All the auxiliary definitions (ctz, clz, odd, etc.) are unused but inflate the term depth (≈ 67), making the benchmark a crafted stress test for solvers’ handling of deep nested ite‑chains.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_s_x_32.smt2",
    "description": "The file is a handcrafted 32‑bit‑vector benchmark (logic BV, 4 declared constants, 2 top‑level asserts, ≈5 KB, 35‑deep terms) extracted from the FMCAD 2020 paper *Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning* by Niemetz and Preiner.  \nIts purpose is to verify a consistency condition for the binary relation “s ≥ x” (encoded by the signed‑greater‑or‑equal `bvsge`) together with a mask‑constraint on x: the value x must lie between two bounds `xlo` and `xhi` such that every bit set in x is also set in xhi (`bvand xhi x = x`) and every bit cleared in x is also cleared in xlo (`bvor xlo x = x`).  \nThe benchmark first forces `xlo` and `xhi` to be complementary masks (`(bvor (bvnot xlo) xhi) = 0xFFFFFFFF`).  \nThe core check asserts that the trivially true predicate `CC(t,xlo,xhi)` is **distinct** from the existence of an ‑x‑ satisfying both the mask constraint (`mcb`) and the literal constraint `LIT(x,s) ≡ (s ≥ x)`. In other words, it asks whether there is any pair (x,s) witnessing that the mask‑based interval is non‑empty under the signed‑greater‑or‑equal order.  \nAll auxiliary functions (`ctz`, `clz`, `cto`, `clo`, `odd`, `mins`, `maxs`, etc.) are only defined but not used, making the benchmark a stress test for quantifier handling and deep nested ite‑expressions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvsge_x_s_32.smt2",
    "description": "The file is a 4 KB crafted benchmark in the **BV** (fixed‑size bit‑vector) logic, generated for the FMCAD 2020 paper on bit‑precise reasoning and labelled “Preiner‑fmcad20”. It declares four 32‑bit constants (an invariant `inv_s`, a term `t`, and the lower/upper masks `xlo` and `xhi`) and defines a handful of helper functions, most notably `mcb`, which characterises a value `v` as lying inside the interval specified by the masks (`bvand xhi v = v` and `bvor xlo v = v`). The core assertion forces the pair of masks to be complementary (`bvor (bvnot xlo) xhi = 0xffffffff`) and then checks that the trivially‑true predicate `CC(t,xlo,xhi)` is **distinct** from the existence of a concrete value `x` and a bound `s` such that `x` satisfies the interval condition (`mcb xlo xhi x`) and the signed‑greater‑or‑equal relation `bvsge x s`. In effect the solver is asked to decide whether there is a model in which the abstract consistency condition `CC` does **not** coincide with the concrete existential witness, i.e., whether the interval‑mask encoding is logically equivalent to the signed‑comparison predicate. The benchmark contains long, explicitly‑unrolled definitions of `ctz`, `clz`, `cto`, and `clo` (nested `ite`s over every bit) that are never used, making the term‑depth high (35) while keeping the logical core very small (two top‑level asserts).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_4.smt2",
    "description": "This instance works in the **BV** logic with 4‑bit bit‑vectors and contains four declared constants (`inv_s`, `t`, `xlo`, `xhi`).  It defines a handful of utility functions (mask‑containment `mcb`, counts of trailing/leading zeros – `ctz`, `clz`, their complements – `cto`, `clo`, parity `odd`, and several fixed bit‑vector constants such as `zero`, `ones`, `mins`, `maxs`).  The core of the problem is the predicate **CC** which is true either when `t` is zero or when there exists a mask value `i` no larger than the leading‑zero count of `t` that satisfies the mask‑containment relation with `xlo`/`xhi`.  The second predicate **LIT** states that a shift of some unknown `s` by a mask value `x` (restricted by the same `mcb` relation) must equal `t` (`bvlshr s x = t`).  The sole constraints assert that `xlo`/`xhi` form a valid complementary mask pair (`bvor (bvnot xlo) xhi = ones`) and then require that **CC** and the existence of such an `x`/`s` pair be *distinct*; the solver is asked whether a model violating this consistency condition exists.  Thus the benchmark encodes a crafted consistency‑check for a bit‑vector right‑shift operator, used in the FMCAD‑2020 study on ternary propagation‑based local search.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_s_x_32.smt2",
    "description": "This benchmark is a crafted 32‑bit bit‑vector problem (logic BV, 4 kB, 4896 tokens) generated for the FMCAD 2020 paper on bit‑precise reasoning.  It declares four 32‑bit constants (`inv_s`, `t`, `xlo`, `xhi`) and a collection of auxiliary definitions (mask‑consistency, count‑trailing/leading‑zero, parity, constants, etc.), most of which are not used in the final constraints.  The core of the instance asserts two things:  \n\n1. `xlo` and `xhi` must form a valid mask pair, i.e. `xlo` is a bitwise subset of `xhi` (`(bvor (bvnot xlo) xhi) = #xFFFFFFFF`).  \n\n2. It then forces a contradiction by requiring the Boolean value `true` (the always‑true `CC` predicate) to be *distinct* from the existential statement “∃ x,s · mcb(xlo,xhi,x) ∧ bvuge(s,x)”, i.e. it asks the solver to prove that no pair `x,s` exists with `x` lying between the masks and some `s` ≥ `x`.  \n\nThus the file checks the consistency of a simple mask‑interval property: for any admissible `xlo`/`xhi` there should be a witness `x` (and trivially a larger `s`), and the `distinct` assertion makes the instance unsatisfiable when that property holds.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_s_x_4.smt2",
    "description": "This instance is a handcrafted BV‑logic benchmark (4‑bit vectors) from the Preiner‑FMCAD 2020 suite that checks a consistency condition for the left‑shift operator. It declares four 4‑bit constants `t`, `xlo`, `xhi` (and an unused `inv_s`) and defines a number of auxiliary bit‑vector functions: a mask‑containment predicate `mcb`, trailing/leading zero counters (`ctz`, `clz`) and their complements, an odd‑test, and two compound predicates – `CC(t,xlo,xhi)`, which holds when `t` is zero or all values up to the count‑of‑trailing‑zeros of `t` satisfy the mask, and `LIT(x,s)`, which encodes the shift equation `s << x = t`. The first assertion forces `xlo` and `xhi` to be a complementary mask pair (every bit is either forced low by `xlo` or allowed high by `xhi`). The second assertion requires that the truth value of `CC(t,xlo,xhi)` be *different* from the existence of a pair `(x,s)` that both respects the mask (`mcb xlo xhi x`) and satisfies the shift equation (`LIT x s`). Hence the solver is asked whether there is a 4‑bit assignment making these two specifications disagree, i.e., whether the proposed consistency property for `bvshl` fails. The file is small (≈2 kB, 2 asserts, 4 constants, 9 definitions) and was generated for the verification of bit‑precise reasoning in the cited FMCAD 2020 paper.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_s_x_32.smt2",
    "description": "This benchmark is a handcrafted BV‑logic instance (32‑bit vectors) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning; it contains 4 declared constants, 9 user‑defined functions and only two top‑level assertions, with a total size of roughly 5 KB (4983 characters) and a maximal term depth of 35.  \n\nThe core of the problem encodes the “mask‑consistent‑bounds” ( mcb ) relation together with standard bit‑vector utilities for counting trailing/leading zeros ( ctz, clz ) and their complements ( cto, clo ).  Two higher‑level predicates are introduced:  \n\n* CC(t, xlo, xhi) holds when either t is zero or there exists an index i not larger than clz(t) that satisfies the mask bounds mcb with the given low/high masks;  \n\n* LIT(x, s) asserts that a logical right shift of s by x bits yields the shared term t.  \n\nThe instance first forces the low/high mask pair to be a complementary covering of all 32 bits (`(bvor (bvnot xlo) xhi) = ones`).  The final assertion then checks that the condition CC is **distinct** from the existence of any concrete mask x and shift source s that simultaneously satisfy the mask bounds and the shift equation, i.e., it asks whether the abstract consistency predicate can be separated from an explicit witness.  \n\nThus the solver is asked to decide the satisfiability of a subtle consistency condition for the 32‑bit logical right‑shift operator under mask constraints, a typical sub‑problem arising in bit‑vector operator verification.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_s_x_32.smt2",
    "description": "This SMT‑LIB file works in the **BV** logic with 32‑bit bit‑vectors and contains 5 declared constants, 10 auxiliary function definitions and two top‑level assertions (≈5 KB, 5466 characters). It encodes a **consistency‑condition check** for a bit‑vector operator introduced in the FMCAD 2020 paper by Niemetz and Preiner: the predicate `CC(t,xlo,xhi)` must be equivalent to the existence of a value `x` that matches the mask defined by `xlo/xhi` (`mcb`) and for which the unsigned division `s ÷ x` yields the fixed term `t`. The file supplies concrete bit‑vector utilities (`ctz`, `clz`, their complements, overflow detectors `addo` and `mulo`, parity test `odd`, constants 0, 1, all‑ones, width 32) and a **valid‑mask constraint** `bvor(bvnot xlo, xhi) = ones`. The core assertion states that `CC(t,xlo,xhi)` is **distinct** from the existential formula `(∃x s. mcb xlo xhi x ∧ bvudiv s x = t)`, i.e., it asks the solver to prove that the two specifications disagree. Thus the instance is a crafted verification benchmark that tests a solver’s ability to handle deep nested `ite` chains, bit‑extractions, quantifiers and overflow‑aware arithmetic on 32‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_32.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) generated for the FMCAD 2020 paper on “bit‑precise reasoning”.  It declares four 32‑bit constants `inv_s`, `t`, `xlo` and `xhi`, and defines a handful of utility functions (count‑trailing/‑leading zeros, odd‑ness, masks, etc.) that are not directly used in the core constraint.  The essential part consists of two assertions: (1) the pair `xlo`/`xhi` must be complementary masks, i.e. `(bvor (bvnot xlo) xhi) = 0xFFFFFFFF`; (2) a `distinct` check forces the always‑true predicate `CC(t,xlo,xhi)` to differ from the existential formula “∃ x s. mcb(xlo,xhi,x) ∧ (x ≥ₙ s)”, thereby requiring that no masked value `x` can satisfy the unsigned‑greater‑or‑equal relation.  In effect the instance tests the consistency of a “masked‑≥” condition under the mask‑pair invariant.  The file is relatively large (≈5 KB, 35‑level term depth) and contains many nested `ite`‑chains for the zero‑count functions, illustrating a crafted, high‑complexity encoding.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_32.smt2",
    "description": "**Description**\n\nThis SMT‑LIB script is a crafted 32‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on “Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”.  The file contains 5 declared 32‑bit constants, 10 user‑defined functions (including explicit bit‑wise implementations of count‑trailing‑zeros, count‑leading‑zeros, overflow‑detecting addition `addo` and multiplication `mulo`, and a mask‑contain‑between predicate `mcb`), and three top‑level assertions totaling 5 743 characters.\n\nThe core problem asks whether the predicate `CC(t,xlo,xhi)`—which encodes a sophisticated consistency condition on a candidate divisor `t` with respect to a bounded interval `[xlo,xhi]`—is *different* from the existence of a pair `(x,s)` such that `x` lies inside the same interval (`mcb xlo xhi x`) and `x / s` (unsigned division) equals `t`.  The interval is forced to be a proper mask (`bvor (bvnot xlo) xhi = #xffffffff`) and `xlo ≠ xhi`.\n\nThus the instance checks a non‑trivial equivalence between a handcrafted arithmetic‑overflow condition (`CC`) and the concrete semantics of unsigned division, using quantified formulas, nested `ite`s for the bit‑level definitions, and overflow predicates.  It serves as a consistency‑condition test for the bit‑vector division operator used in the cited verification study.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_4.smt2",
    "description": "The file is a handcrafted 4‑bit‑vector benchmark (logic BV, 2228 bytes, 2 assertions) coming from the FMCAD 2020 paper [1] that studies consistency conditions for bit‑vector operators.  \nFour 4‑bit constants are declared (inv_s, t, xlo, xhi) and a set of helper definitions is provided:  \n\n* **mcb** characterises a “mask‑cover‑by” relation, requiring that every bit set in a candidate value v is also set in the high‑bound xhi and that every bit cleared in v is also cleared in the low‑bound xlo;  \n* **CC** is a simple consistency predicate stating that if the lower and upper bounds coincide, they must not be the maximal mask maxs;  \n* **LIT** encodes the signed‑less‑than relation `bvslt x s`.  \n\nThe core of the benchmark asserts two things together: (1) the bounds must be complementary, i.e. `bvor (bvnot xlo) xhi = ones`; and (2) the boolean `CC t xlo xhi` is *distinct* from the existence of a value x satisfying both the mask condition (`mcb xlo xhi x`) and the signed‑less‑than test (`LIT x s`). In other words, the instance checks whether the manually crafted consistency condition `CC` is equivalent to the existence of an admissible literal under the mask, a typical consistency‑checking query for bit‑precise reasoning.  \n\nThe benchmark therefore exercises quantified reasoning, ite‑nested bit‑extractions (used to define `ctz`, `clz`, etc.), and the interaction of mask constraints with signed comparisons, making it a targeted stress test for solvers’ handling of quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_s_x_32.smt2",
    "description": "This file is a handcrafted 32‑bit bit‑vector benchmark (logic BV, 4 KB, 4928 characters) generated for the FMCAD 2020 paper *“Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”* by Niemetz and Preiner.  It declares four 32‑bit constants (`inv_s`, `t`, `xlo`, `xhi`) and defines a number of auxiliary functions (mask‑check `mcb`, counting‑trailing/leading‑zeros, parity, and several constant vectors).  The core of the instance is the assertion that a consistency condition `CC(t,xlo,xhi)`—which requires `xlo = xhi` to imply `xlo ≠ mins` (the smallest signed 32‑bit value)—must be *different* from the existence of a concrete value `x` satisfying the mask predicate `mcb xlo xhi x` and the signed‑less‑than literal `LIT(x,s)` (i.e., `s < x`).  A further “valid‑range” assertion forces `xlo` and `xhi` to be complementary masks (`bvor (bvnot xlo) xhi = ones`).  Thus the solver is asked to decide whether the logical condition `CC` is equivalent to the existence of a masked element that also satisfies a signed‑less‑than comparison, effectively checking a consistency property of bit‑vector interval operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvlshr_x_s_4.smt2",
    "description": "This instance is a 4‑bit‑vector benchmark (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning; it is a crafted check of a consistency condition (size ≈ 2.3 kB, 4 declarations, 9 defined functions, 2 top‑level asserts).  \nThe formula declares four 4‑bit constants (`inv_s`, `t`, `xlo`, `xhi`) and defines auxiliary functions modelling count‑trailing‑zeros (`ctz`), count‑leading‑zeros (`clz`), their complements (`cto`, `clo`), a “mask‑covers‑both” predicate `mcb`, and a literal‑shift relation `LIT` (asserting that a right‑logical shift of `x` by `s` equals the fixed vector `t`).  \nThe first assert enforces that `xlo` and `xhi` form a valid complement pair: `(bvor (bvnot xlo) xhi) = 0b1111`.  \nThe second assert checks that two ways of witnessing the condition “there exists a shift amount `i` not larger than the leading‑zero count of `t` such that the shifted bounds still cover `t`” (`CC t xlo xhi`) are **not** equivalent to the existence of a concrete pair `(x,s)` with `mcb xlo xhi x` and `LIT x s`.  \nThus the problem asks whether the quantified definition `CC` and the concrete shift‑literal formulation can differ for some 4‑bit `t`, `xlo`, `xhi`; it uses quantifiers, `ite`‑based bit‑count functions, and bit‑wise operations to capture subtle consistency properties of the `bvlshr` operator.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvult_x_s_64.smt2",
    "description": "This SMT‑LIB file is a handcrafted BV‑logic benchmark (logic = BV, 64‑bit vectors) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning (family = Preiner‑fmcad20, size ≈ 8 k characters, 4 declared constants, 9 function definitions, max term depth = 67).  \nThe model declares four 64‑bit constants `inv_s`, `t`, `xlo`, `xhi` and defines a suite of helper functions: `mcb` (membership in a mask‑controlled bit‑range), a fully unrolled `ctz`/`clz` (count‑trailing/leading zeros) together with their complements, and simple predicates such as `odd`, `LIT` (unsigned less‑than), and `CC`.  \nTwo core constraints are asserted: (1) `xlo` and `xhi` must be complementary bounds, i.e. `bvor (bvnot xlo) xhi = ones`; (2) the Boolean `CC t xlo xhi` (which merely asserts `xlo ≠ ones`) must be *distinct* from the existential statement “∃ x s · mcb xlo xhi x ∧ LIT x s”. In other words, the benchmark checks whether the simple “xlo ≠ all‑ones” condition is logically equivalent to the existence of a value `x` in the mask range that is strictly smaller than some `s`.  \nThe instance therefore encodes a consistency check for a custom bit‑vector condition, exercising deep ite‑chains (the exhaustive bit‑wise `ctz`/`clz` definitions) and quantifier reasoning, which makes it a stress test for solvers’ handling of quantified bit‑vector formulas.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_udiv_x_s_64.smt2",
    "description": "This SMT‑LIB file is a handcrafted BV‑logic benchmark (64‑bit vectors, 8.8 KB, 3 top‑level asserts) that originates from the FMCAD 2020 paper *“Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”* by Niemetz & Preiner.  \nThe model declares five 64‑bit constants (`inv_s`, `inv_s_ctz_s`, `t`, `xlo`, `xhi`) and defines a suite of auxiliary bit‑vector functions (bit‑wise “mask‑covers‑both” `mcb`, count‑trailing‑zeros/leading‑zeros `ctz`/`clz`, overflow detectors `addo` and `mulo`, etc.).  \nThe core of the problem is the predicate `CC(t,xlo,xhi)`, which encodes a fairly intricate consistency condition over the interval `[xlo,xhi]` using range checks, overflow‑free multiplication, and an existential sub‑query that searches for a multiplier‑offset pair (`y`, `o`).  \nA second predicate `LIT(x,s)` simply states that the unsigned division `x ÷ s` equals the constant `t`.  \nThe final assertion demands that the truth value of `CC(t,xlo,xhi)` be **different** from the existence of any pair `(x,s)` satisfying both the interval mask (`mcb xlo xhi x`) and the division relation (`LIT x s`). In other words, the benchmark asks whether the custom consistency condition `CC` is *not* equivalent to the existence of a division witness; the solver must decide the resulting SAT/UNSAT status.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvshl_x_s_64.smt2",
    "description": "This instance is a 64‑bit‑vector benchmark (logic BV) of size ≈8 KB, generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning.  It declares four 64‑bit constants ( inv_s, t, xlo, xhi ) and defines a collection of helper functions, notably **mcb** (a mask‑contain‑both test), **ctz**/ **clz** (count‑trailing/leading zeros) and **LIT** (the relation bvshl x s = t).  The core property is the predicate **CC(t,xlo,xhi)**, which existentially quantifies a shift amount i ≤ ctz(t) and requires that the shifted bounds xlo≪i and xhi≪i still mask‑contain t.  The sole assert checks that this “consistency condition” is **distinct** from an alternative formulation that existentially guesses a value x satisfying **mcb(xlo,xhi,x)** and a shift s with LIT(x,s); in other words, it asks whether the two ways of characterising a feasible shift are ever different.  The benchmark therefore encodes a consistency‑checking problem for bit‑vector shift operators, using deep nested extracts (≈130 ×) and a maximum term depth of 67 to stress solvers’ handling of quantifiers and bit‑vector arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvand_x_s_32.smt2",
    "description": "This is a handcrafted 32‑bit‑vector benchmark (logic BV, 4 declared constants, 2 top‑level assertions, ~5 KB) generated for the FMCAD 2020 paper on bit‑precise reasoning.  It defines the usual bit‑vector utilities (constants 0, 1, all‑ones, min/max signed values, “odd”, and explicit recursive definitions of count‑trailing‑zeros, count‑leading‑zeros, and their complements) together with two predicates:  \n\n* **mcb** asserts that a value v is “masked” by a lower/upper bound pair (xlo,xhi) (i.e. xhi & v = v and xlo | v = v);  \n* **CC** checks that the test vector t is a subset of xhi (t & xhi = t);  \n* **LIT** ties a literal t to a candidate value x and a selector s (x & s = t).  \n\nThe first assertion forces xlo and xhi to be complementary masks (¬xlo ∨ xhi = all‑ones).  The second assertion states that the predicate CC (t,xlo,xhi) must be *distinct* from the existence of a masked value x together with a selector s that reproduces t (∃x,s. mcb(xlo,xhi,x) ∧ LIT(x,s)).  In other words, the benchmark checks whether the simple “t ⊆ xhi” condition is equivalent to the more detailed masked‑literal formulation, thereby testing a consistency condition for the bit‑vector operators introduced in the cited work.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvuge_x_s_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (4‑bit vectors, 2196 characters, 2 assertions) generated for the FMCAD 2020 paper on bit‑precise reasoning.  It declares four 4‑bit constants (`inv_s`, `t`, `xlo`, `xhi`) and defines a number of auxiliary bit‑vector functions (count‑trailing‑zeros, count‑leading‑zeros, odd, etc.), although only the mask‑check `mcb` and the ordering predicate `LIT` are actually used.  The first assertion forces `xlo` and `xhi` to be complementary masks (`bvor (bvnot xlo) xhi = 1111₂`).  The second asserts that the always‑true predicate `CC` (here simply `true`) must be *distinct* from the existence of a pair `(x,s)` such that `x` satisfies the mask (`mcb xlo xhi x`) and is unsigned‑greater‑or‑equal to `s` (`bvuge x s`).  Consequently the problem asks whether, under the mask constraint, there is *no* 4‑bit value `x` that can be chosen at least as large as some `s`, i.e., it checks the consistency of the `bvuge` condition together with the mask relation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvashr_x_s_64.smt2",
    "description": "The file is a crafted BV‑logic benchmark (64‑bit bit‑vectors, 8 257 characters, 4 declared constants, 9 defined functions) generated for the FMCAD 2020 paper *“Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”* and used to test consistency conditions of bit‑vector operators.  It declares the 64‑bit variables `t`, `xlo`, `xhi` (and an unused `inv_s`) and defines a suite of helpers: `mcb` checks that a value lies between a lower and upper mask, `ctz`/`clz` compute trailing/leading‑zero counts, `cto`/`clo` apply them to the bitwise‑not, `odd`, `zero`, `one`, `ones`, `mins`, `maxs`, `w`, and `msb`.  The central predicate `CC` formalises a case‑analysis on `t`: for the extreme values 0 and all‑ones it requires the existence of a mask‑compatible value, otherwise it bounds a shift amount `i` by the leading‑zero count of `t` and again demands mask compatibility after shifting the masks.  The benchmark asserts two things: (1) that `xlo` and `xhi` form a valid complementary mask pair (`bvor (bvnot xlo) xhi = ones`), and (2) that `CC(t,xlo,xhi)` is **not** equivalent to the existence of a concrete literal `x` and shift amount `s` such that `x` respects the masks and `x` >>_a `s` equals `t`.  Thus the solver is asked to decide whether the abstract consistency condition `CC` and the concrete arithmetic‑right‑shift definition diverge for some 64‑bit configuration.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_x_s_32.smt2",
    "description": "This instance is a 32‑bit bit‑vector benchmark (logic BV) of modest size (≈4.8 KB, 35‑deep terms) generated for the FMCAD 2020 paper on ternary propagation‑based local search. It declares four 32‑bit constants tx, ts, xlo and xhi and defines a suite of helper functions, notably **mcb** (a mask‑cover condition), the classic **ctz/clz** and their complements, as well as a concatenation predicate **LIT** and a mask‑check predicate **CC**. The core of the problem consists of two assertions: (1) the pair xlo/xhi must be complementary masks covering every bit ((bvor (bvnot xlo) xhi) = ones), and (2) the mask condition on tx (CC tx ts xlo xhi) must be *distinct* from the existence of any 32‑bit x and s such that x also satisfies the mask (mcb xlo xhi x) and its concatenation with s equals the concatenation of tx and ts. In effect the solver is asked whether the concrete mask satisfaction of tx can be reproduced by some other split x‖s, i.e., a consistency check for concatenation under the mask constraints. The benchmark is crafted, uses many nested ite expressions for bit‑scanning, and exercises quantifier handling together with deep term nesting.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_distinct_x_s_32.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic = BV, 4 32‑bit constants, 9 user‑defined functions, 2 top‑level assertions, about 5 KB in size) generated for the FMCAD 2020 paper on bit‑precise reasoning.  It declares four 32‑bit bit‑vectors `inv_s`, `t`, `xlo` and `xhi` and defines a suite of auxiliary functions, most notably **`mcb`**, which enforces the “mask‑consistent bounds’’ condition `(bvand xhi v = v) ∧ (bvor xlo v = v)`, and a collection of explicit count‑leading‑zero/‑trailing‑zero definitions built with nested `ite`s.  The first assertion encodes the validity of the low/high pair by requiring that every bit is either 0 in `xlo` or 1 in `xhi` – formally `(bvor (bvnot xlo) xhi) = all‑ones`.  The second assertion checks a consistency condition: it demands that the always‑true predicate `CC` (which ignores its arguments) be *distinct* from the existence of a bit‑vector `x` satisfying `mcb(xlo,xhi,x)` together with a different bit‑vector `s` (`LIT(x,s)`), i.e. it asserts that no such pair `(x,s)` can exist.  Consequently the benchmark asks the solver to decide whether the interval defined by `xlo`/`xhi` can be non‑empty, a question that is expected to be UNSAT and therefore serves as a regression test for bit‑vector operator consistency.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_x_s_64.smt2",
    "description": "This SMT‑LIB file is a crafted BV‑logic benchmark (logic BV, 64‑bit vectors) of size ≈ 8 KB (7964 characters) generated for the FMCAD 2020 paper on bit‑precise reasoning.  Four 64‑bit constants are declared and several helper functions are defined (bit‑counting operations ctz, clz, their complements, and simple predicates like odd), but only the mask‑check function **mcb** and the trivial literal‑equality **LIT** are actually used in the constraints.  The main structure consists of two assertions: the first forces the pair (xlo, xhi) to be a valid interval by requiring `(bvor (bvnot xlo) xhi) = ones`; the second asserts that the Boolean term `CC t xlo xhi` (which is defined as true) is *distinct* from an existential statement that there exist x and s with `mcb xlo xhi x` and `LIT x s` (i.e., x = s).  Because `CC` is always true, the distinctness forces the existential to be unsatisfiable, turning the benchmark into a consistency check that no 64‑bit value can satisfy the mask condition given a valid (xlo, xhi) pair.  The instance is notable for its extremely deep term structure (nested ite chains for ctz and clz, term depth 67) and a high count of extract and ite operators, which make it a stress test for bit‑vector solvers.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_4.smt2",
    "description": "This benchmark is a handcrafted BV‑logic instance (4‑bit vectors) from the FMCAD 2020 paper “Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning” (Preiner & Niemetz).  It contains five 4‑bit constants, ten auxiliary definitions (including `mcb`, `ctz`, `clz`, overflow predicates, etc.), and only two top‑level assertions, making the file about 2.8 KB and depth 9.  \n\nThe first assertion enforces that the pair `(xlo,xhi)` forms a valid bit‑mask interval, i.e. `bvor (bvnot xlo) xhi = 1111₂`.  The second assertion states that the predicate `CC(t,xlo,xhi)`—a piecewise condition that relates the target value `t` to the interval via the helper `mcb`—must be *different* from the existence of a concrete `x` and divisor `s` such that `x` lies in the interval (`mcb xlo xhi x`) and the remainder constraint `x % s = t` holds (`LIT`).  \n\nThus the problem checks the consistency of the abstract “coverage condition” `CC` against the concrete semantics of the unsigned‑remainder (`bvurem`) for all 4‑bit values.  It is essentially a small SAT/SMT proof‑obligation that the two formulations disagree, exercising quantifiers, bit‑extractions, and conditional ite‑structures in a tight search space.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_concat_s_x_4.smt2",
    "description": "This SMT‑LIB file is a handcrafted benchmark in the **BV** logic (4‑bit bit‑vectors) generated for the FMCAD 2020 paper on bit‑precise reasoning. It declares four 4‑bit constants (tx, ts, xlo, xhi) and defines a set of auxiliary functions, notably **mcb**, which forces a value v to lie between xlo and xhi in the sense that xhi ∧ v = v and xlo ∨ v = v, as well as counting‑trailing/leading‑zero helpers and simple constants. The main formula asserts two things: (1) that xlo and xhi form a valid mask pair (`bvor(bvnot xlo, xhi) = 0b1111`), and (2) that the predicate **CC(tx,ts,xlo,xhi)** (i.e., mcb xlo xhi tx) is *distinct* from the existence of some x and s satisfying both **mcb xlo xhi x** and the concatenation equality `concat s x = concat ts tx`. In other words, the benchmark checks whether the specific assignment to tx and ts cannot be reproduced by any other pair (x,s) respecting the same mask constraints. The instance is small (≈2 KB, 4 declared constants, 8 defined functions) but features a quantified sub‑formula, bitwise operations, and concatenation, making it a useful stress test for solvers’ handling of bit‑vector consistency conditions.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvadd_x_s_64.smt2",
    "description": "This SMT‑LIB file is a handcrafted bit‑vector benchmark (logic BV) that uses 64‑bit vectors; it was generated in May 2020 by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary propagation‑based local search.  Four uninterpreted constants ( inv_s, t, xlo, xhi ) are declared, and a suite of auxiliary functions is defined, most notably exhaustive “count‑trailing‑zeros” (ctz) and “count‑leading‑zeros” (clz) functions built from deep nested ite‑expressions (term depth ≈ 67).  The core of the problem asserts two things: (1) xlo and xhi must be complementary masks – (bvor (bvnot xlo) xhi) = all‑ones – and (2) the Boolean CC (which is simply true) must be distinct from the existence of a concrete x and s such that x lies inside the mask defined by mcb (xlo,xhi,x) and x plus s equals the given constant t.  In other words, the solver is asked to decide whether there is any value x compatible with the mask that can produce t as a sum with some s, thereby checking a consistency condition for the BV addition operator.  The instance is relatively small (≈ 8 k characters, 2 assertions) but contains a large number of bit‑extractions and ite‑chains, making it a challenging test for bit‑precise reasoning engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_bvslt_x_s_32.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated for the FMCAD 2020 paper on ternary propagation, containing four 32‑bit constants (`inv_s`, `t`, `xlo`, `xhi`) and a handful of auxiliary functions (count‑leading/trailing zeros, oddness, masks, etc.). Its core consists of two assertions: (1) a “valid‑range” condition that forces `xlo` and `xhi` to be complementary masks (`(bvor (bvnot xlo) xhi) = 0xffffffff`), and (2) a disequality between the predicate `CC(t,xlo,xhi)`—which says that whenever `xlo = xhi` then `xlo` is not the maximal 32‑bit value—and the existence of a bit‑vector `x` that lies inside the interval defined by `xlo`/`xhi` (`mcb xlo xhi x`) and is strictly less than some `s` (`bvslt x s`). In other words, the benchmark checks whether the consistency condition `CC` is logically equivalent to the existence of a concrete witness `x` satisfying the interval mask and an ordering test. The problem is deliberately crafted (4928 bytes, 2 top‑level asserts, max term depth 35) to probe solvers’ handling of nested ite‑chains (the explicit `ctz`/`clz` definitions) and quantified Boolean‑valued bit‑vector constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/cons/check_cc_urem_x_s_32.smt2",
    "description": "This instance is a handcrafted 32‑bit BV benchmark (logic BV, 5 declared constants, 10 auxiliary functions, 2 top‑level assertions, ≈5.5 KB in size) taken from the FMCAD 2020 paper on ternary propagation‑based local search for bit‑precise reasoning.  It encodes a consistency check for the unsigned‑remainder operator `urem`: the formula asserts that a “combined‑carry” predicate `CC(t,xlo,xhi)` – which itself depends on a mask‑containment condition `mcb` and a special case for `t = ones` – must be *different* from the existence of a pair `(x,s)` such that `x` respects the same mask (`mcb xlo xhi x`) and the remainder of `x` by `s` equals the global variable `t`.  The mask pair `(xlo,xhi)` is constrained to be complementary (`bvor (bvnot xlo) xhi = ones`).  Supporting definitions for `ctz`, `clz`, their complements, and overflow tests (`addo`, `mulo`) are included but not directly used, illustrating a typical “library” of bit‑vector primitives for the study.  The benchmark therefore tests solvers’ ability to reason about nested conditionals, quantifiers, and bit‑vector arithmetic in a non‑trivial consistency property.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_64.smt2",
    "description": "This instance is a handcrafted BV‑logic benchmark (64‑bit bit‑vectors) that originates from the FMCAD 2020 paper on “invertibility conditions for bit‑vector operators” [1].  It declares five 64‑bit constants ( s, inv_s, t, xlo, xhi ) and defines a handful of utility functions (mask‑check mcb, count‑trailing/leading‑zeros, parity, and several constant helpers).  The core of the problem is the predicate **IC**, which tries to capture an invertibility condition for the signed‑greater‑or‑equal operator `s ≥ x` by distinguishing whether the most‑significant bit of xhi is zero or one and then comparing s with either xlo or `xlo ∨ mins`.  A second predicate asserts the existence of a concrete value x that both respects the mask (`mcb xlo xhi x`) and satisfies the literal `s ≥ x`.  The final assertion checks that **IC** and the existential formulation are *distinct* (i.e., they do not coincide), and the solver is asked to determine satisfiability.  The file is relatively small (≈8 KB, 2 assertions, 5 declarations) but contains very deep term nesting (depth ≈ 67) due to the exhaustive ite‑chains that implement ctz and clz.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_x_s_4.smt2",
    "description": "The instance is a handcrafted BV‑logic benchmark (4‑bit vectors) from the Preiner‑FMCAD 2020 suite, containing five declared constants and nine auxiliary definitions (including count‑trailing/leading‑zero functions and simple bit‑vector constants).  Its core models a *most‑constrained‑bits* mask `mcb(xlo,xhi,v)`, which forces every bit of a candidate value `v` to be either 0 where the lower bound `xlo` has a 0, or 1 where the upper bound `xhi` has a 1.  The first assertion enforces that `xlo` and `xhi` form a complementary pair (`bvor (bvnot xlo) xhi = ones`), i.e., each bit is fixed either low or high.  The second assertion states that the Boolean condition `IC(s,t,xlo,xhi)`—which simply checks that `s` satisfies the mask—must be *distinct* from the existence of a concrete 4‑bit value `x` that both satisfies the same mask and equals `s` (`LIT(x)`).  Thus the problem asks whether the mask‑based invertibility condition for `s` can ever differ from the trivial “there is a literal equal to `s` satisfying the mask”, a small quantified check used to validate the correctness of the derived invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_1_4.smt2",
    "description": "The file is a handcrafted bit‑vector benchmark (logic **BV**, 4‑bit vectors, 1‑bit flag) generated for the FMCAD 2020 paper on invertibility conditions; it contains 5 declared constants, 8 auxiliary definitions and only two top‑level assertions (size ≈ 2 KB).  \nIts main purpose is to encode the **invertibility condition (IC) for a sign‑extension of a 1‑bit term (`tn`) to a 4‑bit word (`tx`)**, i.e. the condition that the most‑significant bit of `tx` matches the sign bit `tn`.  This is expressed by the predicate `IC`, which also requires that `tx` lies inside a mask interval `[xlo, xhi]` defined by the helper `mcb`.  \nA second, existential side condition asserts that there exists a 4‑bit value `x` that both respects the same mask (`mcb xlo xhi x`) and satisfies the literal relation `LIT x` (the sign‑extended form of `x` equals the concatenation of `tn` and `tx`).  \nThe final check uses a `distinct` clause to demand that the IC predicate and the existential condition are **not equivalent**, i.e. it looks for a model where the computed invertibility condition differs from the actual existence of a satisfying `x`.  \nThus the benchmark tests whether the automatically derived IC for the `sign_extend` operator is sound and complete for the given 4‑bit domain, with additional auxiliary functions (ctz, clz, etc.) that are unused but illustrate typical bit‑vector utilities.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_4.smt2",
    "description": "The file is a crafted bit‑vector benchmark (logic BV, 2 227 characters, 5 declared constants, 8 defined functions) generated for the FMCAD 2020 paper on “invertibility conditions” and uses the Preiner‑fmcad20 family.  It models a small 4‑bit domain together with a 3‑bit “tn” and a 4‑bit “tx”, and defines a mask‑contain‑bounds predicate `mcb` that forces a candidate value v to lie between lower and upper 4‑bit masks xlo and xhi (i.e. `(bvand xhi v)=v` and `(bvor xlo v)=v`).  The main condition `IC` asserts a relationship between the top bit of tx and the sign of tn, and also requires that the candidate value respects the masks.  A second predicate `LIT` states that the sign‑extension of a 4‑bit value x (to 7 bits) must equal the concatenation of tn and tx.  The sole sat query checks that the `IC` condition is *distinct* from the existence of any 4‑bit x satisfying both the mask predicate and the sign‑extension equality, i.e. it verifies that the invertibility condition is not equivalent to the concrete solution existence.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 4‑bit vectors, 2 849 bytes, 5 declared constants, 9 user‑defined functions) that originates from the FMCAD 2020 paper *“Ternary Propagation‑Based Local Search for more Bit‑Precise Reasoning”* by Niemetz and Preiner.  \nIt encodes the verification of the **invertibility condition (IC)** for the left‑shift operator `bvshl` when the shift amount `s` is itself a 4‑bit variable: the predicate `IC(s,t,xlo,xhi)` requires that shifting `t` right by `s` and then left by `s` yields `t` again, and that `t` lies between the shifted lower and upper masks `xlo` and `xhi` (the `mcb` mask‑contain‑bit relation).  \nA second predicate, `LIT(x)`, states that shifting some candidate `x` left by `s` equals the target `t`.  The benchmark also asserts that the mask pair `(xlo,xhi)` is valid (`bvor (bvnot xlo) xhi = ones`).  \nThe sole assertion is a **`distinct`** between the IC predicate and the existential claim “there exists an `x` satisfying both `mcb xlo xhi x` and `LIT x`”.  Thus the solver is asked whether there is a concrete assignment of `s, t, xlo, xhi` for which the symbolic IC and the concrete witness‑existence differ, i.e., whether the IC is incomplete for `bvshl`.  \nAuxiliary definitions (count‑trailing/leading zeros, oddness, constants) are present but unused, making the instance a focused test of the invertibility condition’s correctness.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (4‑bit bit‑vectors) from the Preiner‑FMCAD 2020 suite, created to check invertibility conditions for the signed‑greater‑or‑equal operator `bvsge`.  It declares five 4‑bit constants (`s`, `inv_s`, `t`, `xlo`, `xhi`) and defines a small library of helper functions (mask‑containment `mcb`, count‑trailing/leading zeros, parity, and several constant vectors).  The core of the problem is the assertion that the *invertibility condition* `IC(s,t,xlo,xhi)` must be **different** from the existence of a concrete witness `x` satisfying both the mask condition `mcb(xlo,xhi,x)` and the literal condition `LIT(x) ≡ (x ≥ₛ s)`.  A second assertion forces `xlo` and `xhi` to be complementary masks (`bvor(bvnot xlo, xhi) = all‑ones`).  Thus the solver is asked to decide whether the proposed IC correctly characterises the set of signed‑greater‑or‑equal solutions for this 4‑bit instance; the benchmark features a single quantifier, a depth‑7 term structure, and only two top‑level constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 4‑bit vectors) generated for the FMCAD 2020 paper on “invertibility conditions” and contains 5 declared bit‑vector constants, 9 auxiliary function definitions and only two top‑level assertions (≈2.4 KB).  \nIt encodes the *invertibility condition* (IC) for the left‑shift operator `bvshl`: given a shift‑source `s`, a target `t` and an interval `[xlo,xhi]`, the predicate `IC(s,t,xlo,xhi)` asserts that the distance `y = ctz(t) – ctz(s)` is a feasible shift amount (i.e., `ctz(s) ≤ ctz(t)`, `s<<y = t` when `t ≠ 0`, or `s = 0` when `t = 0`) and that `y` lies inside the interval captured by `mcb`.  \nThe benchmark also defines `LIT(x)` as the concrete equation `s<<x = t` and requires that the interval bounds be complementary (`bvor (bvnot xlo) xhi = 0b1111`).  \nThe final assertion checks that the IC predicate is **not** equivalent to the existential statement “∃ x · mcb(xlo,xhi,x) ∧ LIT(x)”, i.e., it looks for a model where the computed invertibility condition differs from the actual existence of a suitable shift amount.  \nThus the problem tests whether the derived IC for `bvshl` correctly characterises the existence of a shift that maps `s` to `t` within a given bit‑precise interval.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_64.smt2",
    "description": "This SMT‑LIB file uses the **BV** logic with 64‑bit bit‑vectors (5 declared constants) and was generated for the FMCAD 2020 paper on invertibility conditions of bit‑vector operators.  The core of the problem is the predicate `IC`, which ties the variables together by fixing `s` to `ts` and enforcing the mask condition `mcb` on the pair `xlo`, `xhi` and the term `tx`.  A second predicate, `LIT`, states that the concatenation of an unknown `x` with the constant `s` must equal the concatenation of `tx` and `ts`.  The single non‑trivial assertion demands that the two formulas – `IC` and “there exists an `x` satisfying both `mcb` and `LIT`” – are **distinct**, i.e., that no such `x` can exist given the mask constraints (the `bvor (bvnot xlo) xhi = ones` clause guarantees a proper complementary mask).  Although auxiliary functions for `ctz`, `clz`, `cto`, and `clo` are defined with deep nested `ite`s (max term depth 67), they are unused and serve only to make the instance more challenging; the file contains 2 assertions, 8 function definitions, and a total size of about 7.9 KB.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_32.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (32‑bit vectors, 5 declared constants, 2 top‑level asserts, ≈5 KB) that comes from the FMCAD 2020 paper on “invertibility conditions” for bit‑vector operators.  It defines a mask‑cover‑bounds predicate **mcb** (requiring a candidate x to be sandwiched between lower and upper masks xlo/xhi) and a literal predicate **LIT** that simply checks the signed‑greater‑or‑equal relation bvsge s x.  The core invertibility condition **IC** encodes the intended sufficient condition for the existence of a solution to bvsge s x when the operand x is restricted by the masks, distinguishing the case where the high‑mask’s most‑significant bit is 0 or 1.  The benchmark first forces the masks to be complementary ( bvor(​bvnot xlo, xhi) = ones ) and then asserts that the **IC** formula is *distinct* from the actual existential statement “∃ x · mcb xlo xhi x ∧ LIT x”.  Thus the solver is asked to find a concrete 32‑bit assignment to s, t, xlo, xhi that demonstrates a counter‑example to the proposed invertibility condition.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_32.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector problem (logic BV) taken from the FMCAD 2020 paper on invertibility conditions for bit‑vector operators; it contains 5 declared constants, 9 auxiliary definitions and only two top‑level assertions, with a total term depth of 35 and a file size of about 5 KB.  \nThe constants `s`, `inv_s`, `t`, `xlo` and `xhi` are used to encode a masked interval `[xlo,xhi]` together with two signed comparison operands `s` and `t`.  \nThe first assertion forces `xlo` and `xhi` to be complementary masks (`bvor (bvnot xlo) xhi = 0xffffffff`).  \nThe second assertion checks the *invertibility condition* `IC(s,t,xlo,xhi)` – a Boolean formula that tries to capture exactly when there exists a 32‑bit value `x` satisfying both the mask‑condition `mcb(xlo,xhi,x)` and the signed‑greater‑or‑equal literal `bvsge x s`.  \nThe formula asserts that `IC` is **distinct** from the existential statement, i.e., it verifies whether the derived condition is equivalent to the concrete existence of such an `x`.  \nThus the instance encodes a crafted verification task: proving (or disproving) the correctness of a hand‑crafted invertibility condition for the `bvsge` operator under a masked‑interval abstraction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_32.smt2",
    "description": "This SMT‑LIB file is a crafted BV benchmark (32‑bit vectors, 5  KB, 2 assertions) originating from the FMCAD 2020 paper on bit‑precise reasoning [1].  It declares four 32‑bit constants `s`, `t`, `xlo` and `xhi` and defines a “mask‑in‑range” predicate `mcb` that forces a value `v` to satisfy `xlo ⊆ v ⊆ xhi` in the bitwise sense.  The core of the instance is the function `IC`, an invertibility condition for the unsigned remainder operator `bvurem` that combines a non‑trivial arithmetic inequality with a quantified existence of a witness `y` respecting `mcb`.  A second predicate `LIT` expresses the concrete remainder property `(s % x) = t`.  The final assertion states that `IC(s,t,xlo,xhi)` and the existence of an `x` satisfying both `mcb` and `LIT` must be *distinct*, i.e., it searches for a counter‑example where the invertibility condition does not match the actual solvability of the remainder equation.  Auxiliary definitions such as `ctz`, `clz`, `addo`, and `mulo` are present but unused, highlighting the benchmark’s focus on testing quantifier handling and bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_64.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic = BV, 64‑bit vectors) generated for the FMCAD 2020 paper on invertibility‑condition checking; it contains 5 declared constants, 8 user‑defined functions and only two top‑level assertions (≈7.9 KB, term depth 67).  The core of the problem is the predicate **IC** (s, tx, ts, xlo, xhi) that asserts the “mask‑cover‑by‑bounds’’ condition `s = ts` together with the mask‑cover‑by‑bounds property `mcb xlo xhi tx`.  A second formula existentially quantifies a 64‑bit value x that must satisfy the same mask condition on xlo/xhi and also a concatenation equality `concat s x = concat ts tx` (captured by **LIT**).  The only constraint on the bounds is that they form a complementary pair (`bvor (bvnot xlo) xhi = ones`).  Finally the benchmark asserts that the two formulas are **distinct**, i.e., it asks whether the invertibility condition IC is equivalent to the existence of an x satisfying the concatenation equality; the solver must determine satisfiability of this inequivalence.  The instance features massive nested `ite`‑chains for `ctz`/`clz` definitions, a high number of `extract` and `ite` operators, and an existential quantifier, making it a stress test for bit‑vector reasoning and quantifier handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvadd_x_s_32.smt2",
    "description": "This instance is a crafted bit‑vector benchmark (logic BV, 32‑bit vectors) generated for the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators”.  It declares the constants s, t, inv_s, xlo and xhi and defines a mask‑constraint function mcb that requires xlo to contain only bits cleared by x and xhi to contain only bits set by x.  The core property under test is the invertibility condition IC(s,t,xlo,xhi) ⇔ mcb xlo xhi (t − s), which is compared (via a single distinct assertion) against the existential statement that there actually exists an x satisfying both the mask constraint and the literal addition equation x + s = t.  An auxiliary axiom forces xlo and xhi to be complementary masks ( (bvor (bvnot xlo) xhi) = ones ), so the check asks whether the computed IC is logically equivalent to the concrete existence of a solution.  The file also contains exhaustive‑ite definitions of count‑trailing‑zeros/leading‑zeros functions, giving the benchmark a deep term‑depth (35) and a rich symbolic structure despite only two top‑level asserts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_4.smt2",
    "description": "This benchmark is a 4‑bit bit‑vector problem (logic BV) generated for the FMCAD 2020 paper on invertibility conditions of bit‑vector operators; it contains 5 declared constants, 8 auxiliary definitions and only 2 top‑level assertions, and its file size is about 2 KB.  \nThe core predicates are **IC**, which requires the high‑order bits `s` and `ts` to be equal and forces the low‑order word `tx` to lie inside a bitwise interval \\([x_{lo},x_{hi}]\\) (expressed by **mcb**), and **LIT**, which states that the 8‑bit concatenations `s‖x` and `ts‖tx` are identical.  \nA side condition asserts that `xlo` and `xhi` form a *complete* interval: every bit is either forced to 0 by `xlo` or to 1 by `xhi` (`(bvor (bvnot xlo) xhi) = ones`).  \nThe final check asks the solver to prove that the two specifications are **distinct** – i.e., there is a model where the interval‑based condition on `tx` does not guarantee the existence of an `x` satisfying the concatenation equality.  \nThus the instance encodes a small, handcrafted invertibility‑condition test for the `concat` operator, exercising quantifiers, bitwise masks, and a uniqueness‑vs‑existence distinction.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_4.smt2",
    "description": "The file is a handcrafted 4‑bit bit‑vector benchmark (logic BV, 2680 characters, 4 declared constants, 10 defined functions) taken from the FMCAD 2020 study on invertibility conditions for bit‑vector operators. It defines a “mask‑cover‑bits’’ predicate *mcb* that characterises values v lying between two bit‑masked bounds xlo and xhi, together with auxiliary bit‑counting functions (ctz, clz, cto, clo) and small arithmetic helpers (add‑carry *addo*, non‑zero‑high‑product *mulo*). The core of the instance is the predicate *IC(s,t,xlo,xhi)*, an analytically derived invertibility condition for the remainder expression bvurem s x = t, expressed using bit‑wise inequalities, a conditional existence of a divisor y satisfying the mask and divisibility constraints, and a special case when s = t. A second predicate *LIT(x)* merely states that x is a concrete divisor realizing the remainder, i.e., bvurem s x = t. The sole conjunctive assertion forces the mask pair to be complementary ( bvor(bvnot xlo, xhi) = ones ) and then asserts that *IC* and the existential “literal’’ condition are **distinct**, i.e., the benchmark checks whether the derived invertibility condition is not equivalent to the actual existence of a suitable divisor for the 4‑bit remainder operation.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_32.smt2",
    "description": "The file is a crafted BV‑logic benchmark (32‑bit vectors) of size ≈ 5 KB, generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on invertibility‑condition checking of bit‑vector operators.  \nIt declares five 32‑bit (and one 2‑bit) constants and defines several auxiliary functions, most prominently **mcb**, which enforces that a candidate value *v* lies between lower and upper masks *xlo* and *xhi*, and **IC**, which captures the intended invertibility condition: the sign‑bit of a 32‑bit term *tx* must match a 2‑bit tag *tn* (zero ↔ sign 0, non‑zero ↔ sign 1) while *tx* also satisfies the mask constraint.  \nThe core of the benchmark is a single `assert` that requires the predicate `IC s tx tn xlo xhi` to be **distinct** from the existence of any concrete 32‑bit value *x* that both satisfies the mask (`mcb xlo xhi x`) and is equal to the sign‑extended literal (`LIT x`, i.e., `sign_extend 2 x = concat tn tx`).  \nA second assert guarantees that the mask pair *(xlo, xhi)* is well‑formed: `bvor (bvnot xlo) xhi = ones`, i.e., every bit is either forced to 0 by *xlo* or forced to 1 by *xhi*.  \nThus the instance checks whether the derived invertibility condition for the 2‑bit sign‑extension into a 32‑bit word is sound, and it does so with deep nested `ite` chains (e.g., the explicit `ctz`/`clz` definitions) that push the solver’s term‑depth limit (max depth 35) despite those functions not being directly used in the final constraints.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (2.6 SMT‑LIB, 4‑bit vectors, 2 227 characters) that originates from the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators”.  It declares five 4‑bit constants and defines a collection of helper functions (mask‑check *mcb*, count‑trailing/leading‑zero/one, parity, and constant vectors) that are used to encode the semantics of a 4‑bit sign‑extension (`sext`) operation.  The core predicate **IC** captures the intended invertibility condition for a signed‑extend of a 4‑bit value `tx` with sign bit `tn`, while **LIT** states that a candidate `x` signed‑extended to 8 bits equals the concatenation of `tn` and `tx`.  Two top‑level assertions first require that `xlo` and `xhi` form a valid mask (`bvor (bvnot xlo) xhi = ones`) and then assert that **IC** is *distinct* from the existence of any 4‑bit `x` satisfying both the mask and the literal condition, i.e., it checks whether the invertibility condition is exact.  The benchmark therefore tests a quantified, distinct comparison over a tiny bit‑vector domain, featuring nested `ite`s, extracts, and a mix of Boolean and arithmetic operators.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvashr_x_s_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 4‑bit vectors, 5 declared constants and 9 auxiliary definitions) generated for the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators”.  Its goal is to test whether a proposed invertibility condition IC for the arithmetic right‑shift `bvashr x s` (with shift amount `s` and result `t`) is equivalent to the existence of a concrete operand `x` that satisfies both a mask‑cover‑bounds predicate `mcb` and the literal equation `bvashr x s = t`.  The two top‑level assertions encode (1) the validity of the interval pair `(xlo,xhi)` (they must be complementary masks covering all bits) and (2) a `distinct` between the predicate IC and the quantified formula asserting the existence of such an `x`.  Satisfiability of the resulting formula therefore answers whether the IC is *not* a sound and complete characterization of the shift‑invertibility problem for 4‑bit vectors.  The benchmark also contains unused helper functions (ctz, clz, cto, clo, odd, etc.) and features a single existential quantifier, making it a small but non‑trivial test of quantifier handling and bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_s_x_4.smt2",
    "description": "The file is a crafted BV‑logic benchmark (logic = BV, 4‑bit vectors) generated for the FMCAD 2020 paper on bit‑precise reasoning, containing 5 declared constants, 9 user‑defined functions and only two top‑level assertions (≈2.4 KB, max term depth 7).  It encodes the invertibility condition for the logical right‑shift operator **bvlshr** with a symbolic shift amount x: given 4‑bit operands s and t, the predicate IC(s,t,xlo,xhi) states that the shift amount y = clz(t)−clz(s) is within the interval \\([x_{lo},x_{hi}]\\) and that shifting s by y yields t (or handles the zero‑case specially).  The auxiliary function **mcb** enforces that a candidate value lies between the lower and upper bounds, while several helper functions (ctz, clz, cto, clo, odd, mins, maxs, etc.) provide classic bit‑vector utilities.  The single substantive check asserts that the IC predicate is *not* equivalent to the existential statement “∃ x. mcb(xlo,xhi,x) ∧ (bvlshr s x) = t”, i.e., it looks for a concrete counterexample to the proposed invertibility condition.  Thus the benchmark tests whether the derived condition correctly characterises all shift amounts that satisfy the equation, a typical verification task for bit‑vector operator invertibility.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_32.smt2",
    "description": "The file is a handcrafted bit‑vector benchmark (logic BV, 32‑bit vectors, one 4‑bit vector) generated for the FMCAD 2020 paper on “invertibility conditions” for bit‑vector operators.  It declares five constants ( s, tx, tn, xlo, xhi ) and defines a small library of helper functions: a mask‑coverage predicate mcb, explicit (and very deep) definitions of count‑trailing‑zeros/leading‑zeros and their complements, and predicates for oddness, constants zero/one/ones, and a 32‑bit word constant w.  \n\nThe core of the instance is the predicate IC, which encodes the candidate invertibility condition for the 4‑bit sign‑extension of a 32‑bit value: tn must equal the sign bit of tx and tx must lie inside the mask interval [xlo, xhi] (expressed by mcb).  A second predicate LIT states that a 32‑bit candidate x, when sign‑extended by 4 bits, must equal the concatenation of tn and tx.  \n\nTwo top‑level assertions are made: (1) a validity constraint on xlo and xhi (`(bvor (bvnot xlo) xhi) = ones`) ensuring they form a proper mask pair, and (2) a *distinct* check asserting that the IC formula is **not** equivalent to the existence of an x satisfying both mcb and LIT.  The solver is asked to determine satisfiability of this inconsistency, effectively testing whether the derived invertibility condition is sound for the sign‑extension operator.  \n\nThe benchmark is modest in size (≈ 4.9 KB, 2 asserts, 5 declared constants, 8 defined functions, max term depth 35) and comes from the Preiner‑FMCAD‑2020 family of verification‑oriented instances.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_4.smt2",
    "description": "The file is a handcrafted bit‑vector benchmark (logic BV) generated for the FMCAD 2020 paper on invertibility‑condition verification; it contains 5 4‑bit variables, 9 auxiliary definitions and only two top‑level assertions, totalling about 2 KB.  The core of the problem is to compare two Boolean terms: the “invertibility condition’’ IC, which is true whenever the lower and upper masks xlo, xhi are not both equal to the source constant s, and an existential clause that looks for a concrete 4‑bit value x satisfying the mask‑containment predicate mcb (and additionally being distinct from s).  The first assertion fixes the masks to be complementary (`(bvor (bvnot xlo) xhi) = ones`), i.e. every bit is covered either by xlo or xhi.  The second asserts that the truth value of IC must differ from the truth of the existential condition, effectively checking whether the invertibility condition is *not* equivalent to the existence of a suitable literal x.  Despite its tiny size, the benchmark contains a quantified bit‑vector subformula and a collection of small helper functions (ctz, clz, odd, etc.), making it a useful stress test for solvers’ handling of quantifiers and bit‑precise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_64.smt2",
    "description": "This instance is a crafted 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary propagation‑based local search.  It declares five 64‑bit constants (s, inv_s, t, xlo, xhi) and defines a suite of helper functions – most notably mcb (membership in the interval [xlo, xhi]), bit‑counting primitives ctz, clz, cto, clo, and simple constants such as zero, one, ones, mins, maxs.  The first assertion encodes that xlo and xhi form a valid interval, i.e. every bit set in xhi is also set in xlo (`(bvor (bvnot xlo) xhi) = ones`).  The second, and only, non‑trivial constraint states that the invertibility condition predicate IC(s,t,xlo,xhi) – which is true unless xhi equals xlo or s – must be distinct from the existence of a value x lying in the interval (satisfying mcb) that is different from s (`LIT x`).  Thus the solver is asked to decide whether the two Boolean expressions can ever coincide, effectively checking a specific invertibility condition for bit‑vector operators.  The benchmark is relatively small (≈8 KB, depth 67) but contains heavily nested ite chains for the counting functions, making it a stress test for BV reasoning engines.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_4_64.smt2",
    "description": "The benchmark is a handcrafted BV‑logic instance (64‑bit vectors, 4‑bit auxiliary value) coming from the FMCAD 2020 paper on invertibility conditions for bit‑vector operators (size ≈ 8 KB, 5 constants, 8 defined functions, 2 top‑level assertions).  \nIt encodes the verification task for the sign‑extension operator “sext 4 → 64”: `IC` captures the intended invertibility condition on the sign‑bit mask (`tn` is either all‑zero or all‑one and must match the most‑significant bit of `tx`), while `LIT` characterises the concrete existence of a 68‑bit value whose upper 4 bits are `tn` and lower 64 bits are `tx`.  \nThe mask‑consistency predicate `mcb` together with the assertion ` (= (bvor (bvnot xlo) xhi) ones)` forces `xlo`/`xhi` to form a valid interval of allowed values for the unknown 64‑bit vector.  \nThe final `distinct` assertion asks the solver to find a model where the abstract condition `IC` is **not** equivalent to the concrete existence of an `x` satisfying both the mask (`mcb`) and the sign‑extension relationship (`LIT`).  \nThus the file checks whether the proposed invertibility condition for `sext` is sound under arbitrary mask constraints; the many nested `ite` definitions of `ctz`, `clz`, etc., are auxiliary but unused in the core check.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_32.smt2",
    "description": "This is a 32‑bit bit‑vector benchmark (logic BV) generated for the FMCAD 2020 paper on invertibility conditions of bit‑vector operators; the file is 5 KB, declares five 32‑bit constants, defines nine auxiliary functions (including explicit `ctz`, `clz`, and their complements) and contains only two top‑level assertions.  \nThe core of the problem is the predicate **IC**, which encodes the expected invertibility condition for the left‑shift operation `bvshl`: it relates the number of trailing zeros of `s` and `t`, requires that shifting `s` by the difference yields `t` (when `t≠0), and constrains a candidate shift amount `y` to lie within a mask‑range described by `xlo`/`xhi`.  \nA second predicate **LIT** simply states that a concrete shift amount `x` satisfies `bvshl s x = t`.  \nThe sole assert checks that the abstract IC condition is **not** equivalent to the existence of a concrete shift `x` that both respects the mask (`mcb xlo xhi x`) and satisfies the literal equation, i.e., it asks whether a counter‑example to the invertibility condition exists.  \nThe benchmark is highly crafted: it uses deep nested `ite` chains to implement `ctz`/`clz`, includes a validity constraint on `xlo`/`xhi` (`bvor (bvnot xlo) xhi = ones`), and reaches a term‑depth of 35, making it a stress test for BV solvers’ handling of quantified and bit‑wise reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_s_x_64.smt2",
    "description": "This SMT‑LIB file is a 64‑bit bit‑vector benchmark (logic BV) of modest size (≈8 KB, 4 declared constants, 2 top‑level asserts) that was generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary‑propagation‑based local search.  The core of the instance is the predicate **IC**, which encodes a candidate invertibility condition for the unsigned remainder operation `s % x = t` in terms of two mask values `xlo` and `xhi`; the mask must satisfy the “valid pair’’ invariant `bvor(bvnot xlo, xhi) = all‑ones`.  Two auxiliary definitions are provided: `mcb` characterises values `y` that lie between the mask bounds (`xlo ≤ y ≤ xhi`), and `LIT` states the concrete remainder condition `bvurem s x = t`.  The final assertion demands that **IC** be *different* from the existence of a masked value `x` satisfying both `mcb xlo xhi x` and `LIT x`, thereby checking whether the proposed invertibility condition is sound (or looking for a counter‑example).  Noteworthy are the extremely deep nested `ite` definitions for `ctz`, `clz`, and their complements, and the use of quantified sub‑formulas (`exists`) together with bit‑vector arithmetic and overflow predicates (`addo`, `mulo`).",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_3_64.smt2",
    "description": "This SMT‑LIB file is a handcrafted benchmark in the BV (fixed‑size bit‑vector) logic, generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary propagation‑based local search; it contains 5 declared constants, 8 user‑defined functions and 2 top‑level assertions, with a total size of about 8 kB and a maximum term depth of 67.  \nThe model describes an *invertibility condition* (IC) for a 64‑bit sign‑extension of a 3‑bit value, using auxiliary mask‑checking (`mcb`) and literal‑matching (`LIT`) predicates together with a validity constraint on the low/high mask pair (`xlo`, `xhi`).  \nTwo Boolean formulas are then compared with a `distinct` assertion: (i) the IC itself, which ties the sign‑bit of the 64‑bit target (`tx`) to the 3‑bit sign‑extension tag (`tn`), and (ii) the existential statement that there exists a 64‑bit value `x` satisfying both the mask condition and the literal condition.  \nThe benchmark asks the solver to determine whether these two formulas are logically equivalent (i.e., whether the IC correctly characterises the existence of such an `x`).  \nIts notable features are the exhaustive bit‑by‑bit definitions of `ctz`, `clz`, and related helpers, and the heavy use of nested `ite` and `extract` constructs that stress bit‑vector reasoning and quantifier handling.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_x_s_32.smt2",
    "description": "This SMT‑LIB file is a crafted BV benchmark (32‑bit vectors) of about 5 KB generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on invertibility‑condition checking.  It declares five 32‑bit constants `s`, `inv_s`, `t`, `xlo`, `xhi` and defines a collection of helper functions (zero, one, ones, ctz/​clz and their complements, odd, mask‑containment `mcb`, and the invertibility condition `IC` for the left‑shift operator).  The core assertion first forces `xlo` and `xhi` to be complementary masks ((bvnot xlo) ∨ xhi = all‑ones), then requires that the predicate `IC s t xlo xhi` be **distinct** from the existence of a concrete bit‑vector `x` such that `x` satisfies the mask condition (`mcb xlo xhi x`) and the literal equality `bvshl x s = t`.  In other words, the formula checks whether the proposed invertibility condition for the bit‑vector shift‑left operator is equivalent to the actual existence of a pre‑image under that shift.  The benchmark thus exercises deep nesting of extracts, ite‑chains (for ctz/clz), quantification and bit‑wise arithmetic to stress‑test solvers’ handling of such invertibility proofs.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_s_x_64.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector query (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning; the file is 7.9 KB long, contains five declared constants, nine auxiliary definitions and two top‑level assertions.  It encodes a *local‑invertibility* check for the relation `s ≤ x` (the BV‑uge operator) under a “mask‑carry‑bit’’ interval `[xlo,xhi]`.  The interval is forced to be a complementary pair by the clause `bvor (bvnot xlo) xhi = ones`, and a helper predicate `mcb` ensures that a candidate value `x` lies inside that interval (`bvand xhi x = x` and `bvor xlo x = x`).  The main assertion states that the simple condition “`xlo ≤ s`” is **distinct** from the existence of any `x` that both respects the interval (`mcb xlo xhi x`) and satisfies the literal condition `s ≤ x`.  Thus the solver is asked whether the two formulations of the invertibility condition are inequivalent for some 64‑bit values.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvxor_x_s_32.smt2",
    "description": "The file is a crafted BV‑logic benchmark (32‑bit vectors) of about 5 KB, generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on invertibility‑condition verification.  Five 32‑bit constants `s, inv_s, t, xlo, xhi` are declared and a suite of helper definitions is given: `mcb` (a mask‑containment test), explicit `ctz`/`clz` (count‑trailing/leading zeros) built from nested extracts and `ite`s, their complements (`cto`, `clo`), and simple predicates such as `odd`.  \n\nThe core of the query is the predicate `IC(s,t,xlo,xhi)`, which states that the bitwise xor `s ⊕ t` satisfies the mask condition `mcb xlo xhi`.  A second, existential condition asserts the existence of a concrete value `x` that both satisfies the same mask (`mcb xlo xhi x`) and makes `x ⊕ s = t` true (the `LIT` predicate).  \n\nThe sole non‑trivial assertion demands that these two formulas are *distinct*: the derived invertibility condition `IC` must not be equivalent to the existence of an actual solution.  Together with a legality constraint on the mask pair (`bvor (bvnot xlo) xhi = ones`), the benchmark checks whether the purported invertibility condition for the 32‑bit `bvxor` operator is sound.  \n\nThus the instance encodes a small quantified consistency check, featuring heavy use of bit‑extracts, nested `ite`s, and a single `distinct` over a quantifier‑free term and an `exists`‑formula.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_x_s_64.smt2",
    "description": "This instance is a 64‑bit bit‑vector (BV) benchmark (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary‑propagation‑based local search; it is a handcrafted verification query of size ≈ 8 kB (8017 characters) with five declared constants, nine auxiliary definitions and two top‑level assertions.  \nThe core property under test is the **invertibility condition** `IC(s,t,xlo,xhi)` which requires `s ≠ 0` and `xlo < s`, and it is compared (via `distinct`) with an existential claim that there exists a value `x` satisfying two masks: `mcb(xlo,xhi,x)` (i.e. `x` is a subset of the high‑mask `xhi` and a superset of the low‑mask `xlo`) and `LIT(x)` (`x < s`).  \nA global consistency clause forces the masks to be complementary: `bvor (bvnot xlo) xhi = ones`, meaning every bit is either forced low or high.  \nThe file also defines exact‑bit count functions `ctz`, `clz`, `cto`, `clo` by exhaustive nested `ite` chains over all 64 bits, which are not used elsewhere but illustrate a bit‑precise encoding of trailing/leading zero counts.  \nThus the solver must decide whether the invertibility condition for the `bvult` comparison is equivalent to the existence of a masked literal within the range, a typical sub‑problem arising in bit‑vector operator invertibility analysis.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_s_x_32.smt2",
    "description": "The file is a 32‑bit bit‑vector benchmark (logic BV) generated for the FMCAD 2020 paper on ternary‑propagation and invertibility conditions; it is relatively small (≈4.8 kB, 5 declared constants, 2 top‑level assertions, a single existential quantifier).  \nIt defines a “mask‑cover‑both” predicate `mcb(xlo,xhi,v)` that forces a candidate value `v` to lie between a lower and an upper bound (all‑ones bits of `xlo` are forced to 0 and all‑ones bits of `xhi` are forced to 1).  \nThe core condition `IC(s,tx,ts,xlo,xhi)` asserts `s = ts` and that the unknown `tx` satisfies the mask predicate with the same bounds; a secondary predicate `LIT(x)` requires the 64‑bit concatenation `s‖x` to equal `ts‖tx`.  \nThe benchmark checks the *invertibility condition* for the concatenation operator by asserting that `IC` is **distinct** from the existence of an `x` that both fulfills the mask (`mcb xlo xhi x`) and satisfies the concatenation equality (`LIT x`).  \nA side constraint ensures that `xlo` and `xhi` form a valid complementary pair (`bvor (bvnot xlo) xhi = 0xFFFFFFFF`).  \nThus the problem encodes a crafted verification task: does the simple equality `s = ts` together with the mask on `tx` guarantee the existence of a suitable `x` for the concatenation, a question relevant to the paper’s analysis of bit‑precise invertibility.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_distinct_x_s_32.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic = BV, 5 32‑bit bit‑vector constants, 2 top‑level asserts, ~5 KB) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning.  It declares the 32‑bit vectors s, inv_s, t, xlo and xhi and defines a suite of helper functions (count‑trailing/leading zeros, oddness, constants 0, 1, all‑ones, etc.), although only the predicates **mcb**, **IC** and **LIT** actually appear in the constraints.  The first assert enforces that xlo and xhi form a valid interval by requiring (bvor (bvnot xlo) xhi) = 0xFFFFFFFF, i.e. every bit set in xhi must also be set in xlo’s complement.  The second assert states that the Boolean term **IC(s,t,xlo,xhi)** (which is true exactly when either xhi ≠ xlo or xhi ≠ s) must be *distinct* from the existential claim that there exists an x lying inside the interval ( mcb xlo xhi x ) and simultaneously different from s (LIT x)).  Thus the solver is asked whether a combination of s, t, xlo, xhi exists that makes the interval‑membership existential either true or false in opposite to the simple “interval‑or‑s‑different” predicate; the instance tests quantified reasoning and heavy use of nested ite and extract terms.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvuge_x_s_64.smt2",
    "description": "This SMT‑LIB file is a 64‑bit bit‑vector benchmark (logic BV) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary‑propagation‑based local search; the file is 7 KB long, contains 5 declared constants and 9 user‑defined functions, and uses a maximum term depth of 67.  \n\nThe core problem encodes a *invertibility condition* for the unsigned‑greater‑or‑equal operator (bvuge).  Two predicates are defined:  \n\n* `IC(s,t,xlo,xhi)` simply asserts that the upper bound `xhi` is at least the source value `s` (`bvuge xhi s`), and  \n\n* `LIT(x)` asserts that a candidate `x` is also at least `s`.  \n\nA valid interval `[xlo,xhi]` is forced by `bvor (bvnot xlo) xhi = ones`, i.e. the low and high bounds are bit‑wise complementary and together cover the whole 64‑bit space.\n\nThe single, decisive assertion states that the truth of `IC(s,t,xlo,xhi)` must be **distinct** from the existence of a concrete `x` satisfying both the interval membership predicate `mcb xlo xhi x` (which requires `x` to be sandwiched between `xlo` and `xhi`) and the lower‑bound predicate `LIT(x)`.  In other words, the benchmark checks whether the simple condition “upper bound ≥ s” is exactly equivalent to the existence of an `x` in the interval that also meets `x ≥ s`.  \n\nAlthough many helper functions such as `ctz`, `clz`, `cto`, `clo`, `odd`, `mins`, `maxs`, and `msb` are defined (using long nested `ite` chains of bit‑extractions), they are not directly referenced in the final constraint, making the instance a crafted test of quantifier handling, distinctness, and bit‑precise reasoning over 64‑bit vectors.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_32.smt2",
    "description": "This benchmark is a 32‑bit bit‑vector (BV) instance (logic BV) of moderate size (≈5 KB, 5 declared constants and 9 auxiliary function definitions) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on ternary propagation‑based local search. The core problem checks an *invertibility condition* IC for two bit‑vectors s and t together with lower/upper mask constants xlo and xhi: IC holds when s is not the all‑ones value and xhi is strictly greater than s (bvugt xhi s). A second, existential condition asks whether there exists a bit‑vector x that both satisfies the mask constraints (mcb xlo xhi x) and the literal constraint LIT x (i.e., s < x). The sole assertion asserts that the two conditions are **distinct**—that is, IC and the existence of such an x are not equivalent for the given masks, while an additional axiom forces the masks to be complementary ( bvor (bvnot xlo) xhi = ones ). Apart from the main check, the file contains verbose definitions of count‑trailing‑zeros/leading‑zeros (implemented with deeply nested ite chains), which are not used elsewhere but illustrate the benchmark’s crafted and symbolic‑heavy nature.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_sext_2_4.smt2",
    "description": "This SMT‑LIB file is a handcrafted bit‑vector benchmark (logic BV, 4‑bit vectors, 2‑bit auxiliary variable) generated for the FMCAD 2020 paper on “invertibility conditions” for bit‑vector operators.  It declares five constants (s, tn, tx, xlo, xhi) and defines eight auxiliary functions, most notably **mcb** (a mask‑based interval test), **IC** (the invertibility condition for a sign‑extension of a 4‑bit value to 6 bits), and **LIT** (the literal that the sign‑extended 4‑bit value equals the concatenation of tn and tx).  The main constraints first enforce that xlo and xhi form a complementary mask ( bvor(¬xlo, xhi)= ones ) and then assert that the IC predicate is *distinct* from the existential statement “∃x · mcb(xlo, xhi, x) ∧ LIT(x)”.  In other words, the benchmark asks whether the proposed invertibility condition is strictly weaker than the exact semantic condition for the sign‑extend operation.  The instance is modest in size (≈2.2 KB, 5 declared constants, 2 top‑level asserts, maximal term depth 7) and is used to test solvers’ ability to handle nested ite‑based bit‑vector arithmetic and quantified reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_concat_x_s_4.smt2",
    "description": "This benchmark is a 4‑bit bit‑vector problem (logic BV) generated for the FMCAD 2020 paper on “invertibility conditions” (family Preiner‑fmcad20; size ≈ 2 KB, 5 constants, 8 helper definitions).  It models a small “mask‑check‑and‑bound” situation: `mcb` asserts that a candidate vector `v` lies between lower and upper masks `xlo` and `xhi` (by requiring `xhi & v = v` and `xlo | v = v`).  The main predicate `IC` ties the source variable `s` to a target `ts` (forcing `s = ts`) and requires that the mask condition holds for a fixed `tx`.  A second predicate `LIT` relates the concatenation of an unknown 4‑bit value `x` with `s` to the concatenation of the fixed `tx` with `ts`.  The sole check asks whether the two formulas are distinct—that is, whether there exists any `x` obeying the mask and making the concatenations equal; the asserted mask‑complement condition on `xlo`/`xhi` ensures they form a proper interval, and the problem therefore verifies that the invertibility condition for the concat operation fails for this concrete 4‑bit configuration.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvlshr_x_s_32.smt2",
    "description": "The file is a **32‑bit bit‑vector** benchmark (`(set-logic BV)`) of moderate size (≈5 KB, 5 declared constants, 9 helper definitions and 2 top‑level assertions).  It originates from the FMCAD‑2020 paper [1] and is meant to **verify an invertibility condition for the logical right‑shift operator** `bvlshr`.  \n\nThe core predicate `IC(s,t,xlo,xhi)` encodes the candidate condition  \n`(bvlshr (bvshl t s) s) = t` together with a mask‑coverage property `mcb` that requires `xlo ≤ t ≤ xhi` bit‑wise.  A second predicate expresses the “existential” formulation: there exists a value `x` such that `mcb xlo xhi x` holds and `bvlshr x s = t`.  \n\nThe benchmark asserts two things: (1) that `xlo` and `xhi` form a valid complementary mask (`bvor (bvnot xlo) xhi = ones`), and (2) that the two formulations are **distinct** (`distinct IC … (exists x …)`).  Hence the solver is asked to find a concrete counter‑example showing the candidate condition is not equivalent to the existential definition.  \n\nThe instance also contains a large, fully unrolled definition of `ctz`/`clz` (count‑trailing/leading zeros) built with nested `ite`s, which, while unused in the final check, contributes to a deep term structure (max depth 35) and makes the benchmark a good stress test for quantifier handling and bit‑vector reasoning.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvslt_x_s_64.smt2",
    "description": "This SMT‑LIB file is a handcrafted BV‑logic benchmark (64‑bit bit‑vectors) generated for the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators”.  It declares five 64‑bit constants `s`, `inv_s`, `t`, `xlo` and `xhi` and defines several auxiliary functions, most notably `mcb` (a mask‑cover predicate), the exhaustive bit‑level definitions of `ctz`/`clz` (count‑trailing/leading zeros) and their complements, as well as simple helpers such as `odd`, `mins`, `maxs` and `msb`.  The core of the query is the assertion that the predicate `IC(s,t,xlo,xhi)`—which encodes a non‑trivial invertibility condition involving signed‑less‑than (`bvslt`) and the sign of `xhi`—must be *different* from the existence of a concrete value `x` that both satisfies the mask‑cover condition `mcb xlo xhi x` and the literal condition `LIT(x) ≡ x < s`.  A secondary assertion enforces that `xlo` and `xhi` form a valid complementary pair (`bvor (bvnot xlo) xhi = ones`).  The instance is relatively large (≈8 KB, 5 constants, 9 function definitions, quantifier depth 67) and is used to test solvers’ ability to reason about bit‑precise invertibility conditions with deep nested ite‑chains.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_x_s_64.smt2",
    "description": "This benchmark is a handcrafted BV‑logic instance (64‑bit vectors) of moderate size (≈8 k characters, 5 declared constants and 2 top‑level assertions) generated by Mathias Preiner and Aina Niemetz for the FMCAD 2020 paper on bit‑precise reasoning. It encodes a verification task for an *invertibility condition* (IC) of the signed‑greater‑or‑equal operator (`bvsge`) with a fixed 64‑bit constant `s`. The formula asserts two things: (i) that a pair of bounds `xlo`, `xhi` is well‑formed (`bvor (bvnot xlo) xhi = ones`), and (ii) that the manually derived predicate IC is **not** equivalent to the existential condition “there exists a value x in the interval `[xlo,xhi]` (captured by `mcb`) that satisfies the literal `bvsge x s`”. The IC itself branches on the most‑significant bit of `xlo` and uses signed comparisons with `s` and the constant `maxs`. Auxiliary definitions of `ctz`, `clz`, `cto`, `clo`, and other bit‑vector constants are present but unused in the final check, illustrating a typical “bit‑precise” encoding that stresses solvers with deep nested `ite`s and many extracts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvult_s_x_4.smt2",
    "description": "This instance is a 4‑bit bit‑vector benchmark (logic BV) of the “Preiner‑fmcad20” family, created for the FMCAD 2020 paper on ternary propagation‑based local search and containing 2245 characters, five declared constants and nine auxiliary definitions.  It encodes a verification of an **invertibility condition (IC)** for the unsigned‑less‑than operator `bvult`, namely the condition  \n\n\\[\n\\text{IC}(s,t,x_{lo},x_{hi}) \\;=\\; (s\\neq\\text{ones})\\;\\land\\;(x_{hi}>s),\n\\]\n\nwhere `ones` is the all‑1 4‑bit vector.  The benchmark asserts that this IC is **distinct** from the existence of a value `x` that simultaneously (i) satisfies the mask‑contain‑bounds predicate `mcb(xlo,xhi,x)` (i.e. `x` lies between `xlo` and `xhi` with bit‑mask semantics) and (ii) fulfills the literal condition `LIT(x)` meaning `s < x`.  \n\nA second assertion forces the lower and upper bounds to be complementary masks, `bvor(bvnot xlo, xhi) = ones`, guaranteeing a well‑formed interval.  Auxiliary functions such as `ctz`, `clz`, `cto`, `clo`, `odd`, and various constants (`zero`, `one`, `mins`, `maxs`, `w`) are defined but only the mask and ordering constraints are relevant to the SAT check.  \n\nThus the solver is asked whether the IC for `bvult` is equivalent to the existence of an `x` in the masked interval that satisfies `s < x`; the formula is satisfiable iff a counterexample to this equivalence exists.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvurem_x_s_64.smt2",
    "description": "This benchmark is a handcrafted BV‑logic (64‑bit) problem (≈8 kB, 4 declared constants, 2 top‑level assertions) generated for the FMCAD 2020 paper on invertibility‑condition checking.  It defines an “interval” predicate *mcb* that forces a bit‑vector x to lie between lower and upper masks xlo/xhi (the mask constraint is asserted separately as bvor(¬xlo,xhi)= all‑ones).  The core property IC(s,t,xlo,xhi) expresses the invertibility condition for the remainder operation bvurem with divisor s and remainder t: if s≠0 and t≠2⁶⁴−1, it asks whether there exists a y such that x = s·y + t lies in the interval, yet the multiplication s·y does not overflow ( mulo ) and the addition s·y + t does not overflow ( addo ).  The final assertion demands that the truth of IC be different from the existence of a concrete x satisfying both the interval mask and the literal remainder condition (bvurem x s = t).  Consequently the solver must decide whether the invertibility condition for bvurem holds for the given s, t, xlo, xhi, making the instance a focused test of quantifier reasoning, overflow detection, and bit‑precise arithmetic.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvsge_s_x_4.smt2",
    "description": "This instance is a handcrafted BV‑logic benchmark (4‑bit vectors, 2 307 characters, 5 declared constants, 9 defined functions) generated for the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators” [1].  The core of the formula encodes a check that the proposed invertibility condition **IC** for the signed‑greater‑or‑equal operator (`bvsge`) is **not** equivalent to the existence of a concrete value `x` that both satisfies a mask‑based interval (`mcb xlo xhi x`) and the literal constraint `s ≥ x` (`LIT x`).  The mask condition forces `x` to lie between lower and upper bounds represented by the bit‑vectors `xlo` and `xhi`, while an auxiliary assertion (`(= (bvor (bvnot xlo) xhi) ones)`) guarantees that `xlo` and `xhi` form a valid complementary pair.  The single top‑level `assert` therefore asserts the *distinctness* of the IC predicate from the existential witness, making the solver decide whether the invertibility condition is sound for this 4‑bit case.  Although several helper functions (e.g., `ctz`, `clz`, `cto`, `clo`, `odd`) are defined, they are unused in the final check, serving only to resemble typical bit‑precision reasoning contexts.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_64.smt2",
    "description": "This benchmark is a 64‑bit bit‑vector formula (`(set-logic BV)`) generated for the FMCAD 2020 paper on invertibility‑condition reasoning; it contains 4 declared constants, 8 auxiliary definitions, and only two top‑level assertions, but the term depth reaches 67 because the `ctz` and `clz` functions are expressed as a cascade of 64 nested `ite`/`extract` tests.  \nThe core of the instance is the predicate **IC(s,t,xlo,xhi)**, which asserts that the low/high masks `xlo`,`xhi` cover all bits (`(bvor (bvnot xlo) xhi) = ones`) and that either `s` is zero or, depending on the parity of `s`, a suitable modular inverse of `s` (or of `s` shifted right by its count‑trailing‑zeros) exists such that the product `t·inv_s` lies inside the masked interval `[xlo,xhi]`.  \nA second assertion states that the pair `(IC s t xlo xhi)` must be **distinct** from the existence of a concrete value `x` satisfying both the mask (`mcb xlo xhi x`) and the literal equation `x·s = t`.  \nThus the solver is asked to determine whether the generic invertibility condition encoded by **IC** is *exactly* characterising the existence of a solution to the multiplication equation under the same interval constraints.  \nThe file is a handcrafted, quantifier‑rich benchmark (three `exists` quantifiers) that stresses solvers’ handling of deep‑nested ite‑chains, bit‑vector arithmetic, and the interaction between masking and modular inverses.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvshl_s_x_64.smt2",
    "description": "This file is a handcrafted BV‑logic benchmark (64‑bit vectors, 8 177 characters) generated for the FMCAD 2020 paper on invertibility conditions of bit‑vector operators.  It declares five 64‑bit constants `s`, `inv_s`, `t`, `xlo` and `xhi` and defines a suite of helper functions, most notably `ctz`/`clz` (count‑trailing/leading zeros via a huge cascade of `ite`s), their complements (`cto`, `clo`), a mask‑containment predicate `mcb`, and the core invertibility predicate `IC`.  `IC` captures the condition under which a left‑shift of `s` by a variable amount can produce `t`: the shift amount must be `y = ctz(t) – ctz(s)`, it must respect ordering of trailing‑zero counts, and it must lie inside the bit‑mask range described by `xlo`/`xhi`.  The benchmark then asserts that the mask pair is valid (`bvor (bvnot xlo) xhi = ones`) and finally checks whether the logical formula `IC s t xlo xhi` is *distinct* from the concrete existence of a shift amount (`∃x. mcb xlo xhi x ∧ (s << x) = t`).  Thus the SAT query asks whether the derived invertibility condition is exactly equivalent to the actual existence of a suitable shift, serving as a verification of the condition’s correctness.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvudiv_s_x_4.smt2",
    "description": "The file is a handcrafted BV‑logic benchmark (logic BV, 4‑bit vectors) generated for the FMCAD 2020 paper on “Verification of invertibility conditions for bit‑vector operators” (Preiner & Niemetz).  It declares six 4‑bit constants (s, t, xlo, xhi, …) and defines a collection of auxiliary bit‑vector utilities (count‑trailing/leading zeros, odd‑test, overflow detectors, mask‑containment mcb, etc.).  The central formula is the predicate **IC**, which encodes the proposed invertibility condition for unsigned division:  \n\\[\n(bvudiv\\;s\\;(bvudiv\\;s\\;t)) = t\n\\]\ntogether with bounds on a mask [xlo, xhi] that should guarantee the existence of a witness y satisfying the division result.  A second predicate **LIT** simply states that a concrete value x satisfies \\((bvudiv\\;s\\;x)=t\\).  The benchmark asserts (i) that xlo/xhi form a valid mask ( bvor (bvnot xlo) xhi = ones ) and (ii) that the IC predicate is **distinct** from the existential statement “∃ x · mcb xlo xhi x ∧ LIT x”, i.e., it asks SAT whether there is a 4‑bit case where the invertibility condition is wrong.  With 2 asserts, 6 declared constants, 10 defined functions and a maximum term depth of 11, the instance is a small (≈3 KB) verification problem that tests the soundness of the division invertibility condition used in the authors’ ternary‑propagation solver.",
    "is_truncated": false
  },
  {
    "smtlib_path": "BV/2020-Preiner-fmcad20/inv/check_ic_bvmul_x_s_4.smt2",
    "description": "This benchmark is a 4‑bit bit‑vector (`BV`) verification query (logic BV, 2597 symbols, 4 constants, 2 asserts) taken from the FMCAD 2020 paper on ternary propagation‑based local search.  It declares four 4‑bit variables `s, t, xlo, xhi` and defines a number of helper functions: `mcb` (a mask‑containment test), `ctz`/`clz` (count‑trailing/leading zeros), their complements, an odd‑test, and the invertibility‑condition predicate `IC`.  `IC` encodes the theoretical condition under which the equation `s·x = t` has a solution using a modular inverse of `s` (or of a shifted version when `s` is even) together with the mask constraints on the candidate solution.  The benchmark asserts that the mask pair `(xlo,xhi)` is valid (`bvor (bvnot xlo) xhi = ones`) and then asks the solver to find a model where the `IC` predicate differs from the concrete existence of an `x` satisfying both the mask (`mcb xlo xhi x`) and the literal equation (`bvmul x s = t`).  Thus the problem checks the soundness of the derived invertibility condition for 4‑bit multiplication under the given mask bounds.",
    "is_truncated": false
  }
]